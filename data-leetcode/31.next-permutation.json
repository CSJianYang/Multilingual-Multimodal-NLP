[
    {
        "title": "Next Permutation",
        "question_content": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\tFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\tFor example, the next permutation of arr = [1,2,3] is [1,3,2].\n\tSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\n\tWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 13867,
                "title": "c-from-wikipedia",
                "content": "According to [Wikipedia](https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order), a man named Narayana Pandita presented the following simple algorithm to solve this problem in the 14th century.\\n\\n1. Find the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, just reverse `nums` and done.\\n2. Find the largest index `l > k` such that `nums[k] < nums[l]`.\\n3. Swap `nums[k]` and `nums[l]`.\\n4. Reverse the sub-array `nums[k + 1:]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n}; \\n```\\n\\nThe above algorithm can also handle duplicates and thus can be further used to solve [Permutations](https://leetcode.com/problems/permutations/) and [Permutations II](https://leetcode.com/problems/permutations-ii/).",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 13994,
                "title": "readable-code-without-confusing-i-j-and-with-explanation",
                "content": "Implementation based on description from [Project Nayuki](http://www.nayuki.io/page/next-lexicographical-permutation-algorithm). I cannot describe it better than them:\\n\\n![next permutation steps][1]\\n\\n\\tpublic class Solution {\\n\\t/*0*/ public void nextPermutation(int[] nums) {\\n\\t        // pivot is the element just before the non-increasing (weakly decreasing) suffix\\n\\t/*2*/   int pivot = indexOfLastPeak(nums) - 1;\\n\\t        // paritions nums into [prefix pivot suffix]\\n\\t        if (pivot != -1) {\\n\\t            int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it\\'s suffix[0]\\n\\t            // next prefix must exist because pivot < suffix[0], otherwise pivot would be part of suffix\\n\\t/*4*/       swap(nums, pivot, nextPrefix); // this minimizes the change in prefix\\n\\t        }\\n\\t/*5*/   reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot\\n\\t/*6*/ }\\n\\t    \\n\\t    /**\\n\\t     * Find the last element which is a peak.\\n\\t     * In case there are multiple equal peaks, return the first of those.\\n\\t     * @return first index of last peak\\n\\t     */\\n\\t/*1*/ int indexOfLastPeak(int[] nums) {\\n\\t        for (int i = nums.length - 1; 0 < i; --i) {\\n\\t            if (nums[i - 1] < nums[i]) return i;\\n\\t        }\\n\\t        return 0;\\n\\t    }\\n\\n\\t    /** @return last index where the {@code num > threshold} or -1 if not found */\\n\\t/*3*/ int lastIndexOfGreater(int[] nums, int threshold) {\\n\\t        for (int i = nums.length - 1; 0 <= i; --i) {\\n\\t            if (threshold < nums[i]) return i;\\n\\t        }\\n\\t        return -1;\\n\\t    }\\n\\n\\t    /** Reverse numbers starting from an index till the end. */\\n\\t    void reverseSuffix(int[] nums, int start) {\\n\\t        int end = nums.length - 1;\\n\\t        while (start < end) {\\n\\t            swap(nums, start++, end--);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    void swap(int[] nums, int i, int j) {\\n\\t        int temp = nums[i];\\n\\t        nums[i] = nums[j];\\n\\t        nums[j] = temp;\\n\\t    }\\n\\t}\\n\\n\\n  [1]: https://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm.svg",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t/*0*/ public void nextPermutation(int[] nums) {\\n\\t        // pivot is the element just before the non-increasing (weakly decreasing) suffix\\n\\t/*2*/   int pivot = indexOfLastPeak(nums) - 1;\\n\\t        // paritions nums into [prefix pivot suffix]\\n\\t        if (pivot != -1) {\\n\\t            int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it\\'s suffix[0]\\n\\t            // next prefix must exist because pivot < suffix[0], otherwise pivot would be part of suffix\\n\\t/*4*/       swap(nums, pivot, nextPrefix); // this minimizes the change in prefix\\n\\t        }",
                "codeTag": "Java"
            },
            {
                "id": 14054,
                "title": "python-solution-with-comments",
                "content": "        \\n    def nextPermutation(self, nums):\\n        i = j = len(nums)-1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:   # nums are in descending order\\n            nums.reverse()\\n            return \\n        k = i - 1    # find the last \"ascending\" position\\n        while nums[j] <= nums[k]:\\n            j -= 1\\n        nums[k], nums[j] = nums[j], nums[k]  \\n        l, r = k+1, len(nums)-1  # reverse the second part\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l +=1 ; r -= 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def nextPermutation(self, nums):\\n        i = j = len(nums)-1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:   # nums are in descending order\\n            nums.reverse()\\n            return \\n        k = i - 1    # find the last \"ascending\" position\\n        while nums[j] <= nums[k]:\\n            j -= 1\\n        nums[k], nums[j] = nums[j], nums[k]  \\n        l, r = k+1, len(nums)-1  # reverse the second part\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l +=1 ; r -= 1",
                "codeTag": "Python3"
            },
            {
                "id": 13866,
                "title": "share-my-o-n-time-solution",
                "content": "My idea is for an array:\\n\\n 1. Start from its last element, traverse backward to find the first one with index i that satisfy  num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted. \\n 2. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7. \\n 3. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]\\n\\nThe following is my code:\\n\\n        \\n    public void nextPermutation(int[] num) {\\n        int n=num.length;\\n        if(n<2)\\n            return;\\n        int index=n-1;        \\n        while(index>0){\\n            if(num[index-1]<num[index])\\n                break;\\n            index--;\\n        }\\n        if(index==0){\\n            reverseSort(num,0,n-1);\\n            return;\\n        }\\n        else{\\n            int val=num[index-1];\\n            int j=n-1;\\n            while(j>=index){\\n                if(num[j]>val)\\n                    break;\\n                j--;\\n            }\\n            swap(num,j,index-1);\\n            reverseSort(num,index,n-1);\\n            return;\\n        }\\n    }\\n    \\n    public void swap(int[] num, int i, int j){\\n        int temp=0;\\n        temp=num[i];\\n        num[i]=num[j];\\n        num[j]=temp;\\n    }\\n    \\n    public void reverseSort(int[] num, int start, int end){   \\n        if(start>end)\\n            return;\\n        for(int i=start;i<=(end+start)/2;i++)\\n            swap(num,i,start+end-i);\\n    }",
                "solutionTags": [],
                "code": "My idea is for an array:\\n\\n 1. Start from its last element, traverse backward to find the first one with index i that satisfy  num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted. \\n 2. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7. \\n 3. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]\\n\\nThe following is my code:\\n\\n        \\n    public void nextPermutation(int[] num) {\\n        int n=num.length;\\n        if(n<2)\\n            return;\\n        int index=n-1;        \\n        while(index>0){\\n            if(num[index-1]<num[index])\\n                break;\\n            index--;\\n        }\\n        if(index==0){\\n            reverseSort(num,0,n-1);\\n            return;\\n        }\\n        else{\\n            int val=num[index-1];\\n            int j=n-1;\\n            while(j>=index){\\n                if(num[j]>val)\\n                    break;\\n                j--;\\n            }\\n            swap(num,j,index-1);\\n            reverseSort(num,index,n-1);\\n            return;\\n        }\\n    }\\n    \\n    public void swap(int[] num, int i, int j){\\n        int temp=0;\\n        temp=num[i];\\n        num[i]=num[j];\\n        num[j]=temp;\\n    }\\n    \\n    public void reverseSort(int[] num, int start, int end){   \\n        if(start>end)\\n            return;\\n        for(int i=start;i<=(end+start)/2;i++)\\n            swap(num,i,start+end-i);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3473399,
                "title": "beats-100-full-explanation-in-steps",
                "content": "\\n\\n# Approach\\n The steps are the following:\\n\\n1. Find the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\n2. To find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\n3. If a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\n\\n![image.png](https://assets.leetcode.com/users/images/ec3b008b-3542-429e-aefe-07d870e88e5d_1682940260.9485922.png)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        // step 1 find breaking point \\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        // if there is no breaking  point \\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        \\n        else{\\n            // step 2 find next greater element and swap with ind2\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums,ind1,ind2);\\n            // step 3 reverse the rest right half\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/7c17f983-3b8b-4738-b722-c1c1466f9510_1682940288.2823734.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        // step 1 find breaking point \\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        // if there is no breaking  point \\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        \\n        else{\\n            // step 2 find next greater element and swap with ind2\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums,ind1,ind2);\\n            // step 3 reverse the rest right half\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13872,
                "title": "easiest-java-solution",
                "content": "Using a simple example, we can derive the following steps:\\n\\n    public void nextPermutation(int[] A) {\\n        if(A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while(i >= 0 && A[i] >= A[i + 1]) i--; // Find 1st id i that breaks descending order\\n        if(i >= 0) {                           // If not entirely descending\\n            int j = A.length - 1;              // Start from the end\\n            while(A[j] <= A[i]) j--;           // Find rightmost first larger id j\\n            swap(A, i, j);                     // Switch i and j\\n        }\\n        reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while(i < j) swap(A, i++, j--);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Using a simple example, we can derive the following steps:\\n\\n    public void nextPermutation(int[] A) {\\n        if(A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while(i >= 0 && A[i] >= A[i + 1]) i--; // Find 1st id i that breaks descending order\\n        if(i >= 0) {                           // If not entirely descending\\n            int j = A.length - 1;              // Start from the end\\n            while(A[j] <= A[i]) j--;           // Find rightmost first larger id j\\n            swap(A, i, j);                     // Switch i and j\\n        }\\n        reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while(i < j) swap(A, i++, j--);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13921,
                "title": "1-4-11-lines-c",
                "content": "**Solution 1**\\n\\nJust for info: There's a library function that does the job, even going from totally reverse sorted to sorted:\\n\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums), end(nums));\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nUsing library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of `+1`/`-1`, it all fits exactly.\\n\\n    void nextPermutation(vector<int>& nums) {\\n        auto i = is_sorted_until(nums.rbegin(), nums.rend());\\n        if (i != nums.rend())\\n            swap(*i, *upper_bound(nums.rbegin(), i, *i));\\n        reverse(nums.rbegin(), i);\\n    }\\n\\n---\\n\\n**Solution 3**\\n\\nDoing it all on my own (except `swap`, let's not be silly):\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            swap(nums[j], nums[k]);\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            swap(nums[i], nums[k]);\\n        }\\n    }\\n\\n---\\n\\n**Solution 4**\\n\\nOk, let's be silly after all and not even use `swap` :-)\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i, tmp;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            tmp = nums[j], nums[j] = nums[k], nums[k] = tmp;\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            tmp = nums[i], nums[i] = nums[k], nums[k] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Solution 1**\\n\\nJust for info: There's a library function that does the job, even going from totally reverse sorted to sorted:\\n\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums), end(nums));\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nUsing library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of `+1`/`-1`, it all fits exactly.\\n\\n    void nextPermutation(vector<int>& nums) {\\n        auto i = is_sorted_until(nums.rbegin(), nums.rend());\\n        if (i != nums.rend())\\n            swap(*i, *upper_bound(nums.rbegin(), i, *i));\\n        reverse(nums.rbegin(), i);\\n    }\\n\\n---\\n\\n**Solution 3**\\n\\nDoing it all on my own (except `swap`, let's not be silly):\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            swap(nums[j], nums[k]);\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            swap(nums[i], nums[k]);\\n        }\\n    }\\n\\n---\\n\\n**Solution 4**\\n\\nOk, let's be silly after all and not even use `swap` :-)\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i, tmp;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            tmp = nums[j], nums[j] = nums[k], nums[k] = tmp;\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            tmp = nums[i], nums[i] = nums[k], nums[k] = tmp;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169948,
                "title": "best-c-2-solution-two-pointers-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using 3 ways.\\n\\n1. Find all the permutation of Array(nums) then we can easily find next permutation.\\n2. Solved using Array + Two Pointers.\\n3. Solved using next_permutation (inbuilt) function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of the Array(nums).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant Space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\\n    the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\\n    the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909229,
                "title": "simple-easy-c-solution-explain-with-image",
                "content": "![image](https://assets.leetcode.com/users/images/d2dfaab0-542d-4cc8-a32a-d82dd29c4c95_1648961158.0012193.png)\\n\\n```\\nvoid nextPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--)                           // find decreasing sequence\\n        {\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(r=n-1;r>l;r--)                       // find rightmost successor to pivot\\n            {\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);                  // swap l,r\\n            \\n            reverse(nums.begin()+l+1,nums.end());   // reverse from l+1 to end\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--)                           // find decreasing sequence\\n        {\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(r=n-1;r>l;r--)                       // find rightmost successor to pivot\\n            {\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);                  // swap l,r\\n            \\n            reverse(nums.begin()+l+1,nums.end());   // reverse from l+1 to end\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1241286,
                "title": "c-simple-to-understand",
                "content": "# Find next permutation:\\n\\n### Algorithm:\\n\\n**step 1:** Linearly traverse given array from the end and find a number that is greater than its adjacent `nums[i] > nums[i-1]`. Store the index of smaller number in `breakPoint` variable. If there is no such element, reverse entire array and return.\\n\\n**step 2:** Linearly traverse from the end and this time find a number larger than `nums[breakPoint]`. Let\\'s call it `nums[i]`.\\n\\n**step 3:** Swap `nums[i] and nums[breakPoint]`.\\n\\n**step 4:** Reverse the array from index `breakPoint + 1` to `nums.size()`.\\n\\n### Example:\\n* Consider `nums[] = [1, 3, 5, 4, 2]`.\\n* Traverse from back and find a breakpoint. Here, index `breakPoint = 1` and `nums[breakPoint] = 3`\\n* Traverse from back and find a number larger than this. Here this number is: `nums[i] = 4`\\n* Swap `nums[breakPoint] and nums[i]`. Value after swapping: nums[] = [1, **4**, 5, **3**, 2].\\n* Reverse array from `breakPoint + 1` to `nums.size()` i.e. these elements: [1, 4, **5**, **3**, **2**]\\n* **`Final answer = [1, 4, 2, 3, 5]`.**\\n\\n**code:**\\n```\\n// find next permutation\\nvoid nextPermutation(vector<int> &nums)\\n{\\n    // initialize variable:\\n    int breakPoint = -1;\\n\\n    // find a breakpoint:\\n    for (int i = nums.size() - 1; i > 0; i--)\\n    {\\n        if (nums[i] > nums[i - 1])\\n        {\\n            breakPoint = i - 1;\\n            break;\\n        }\\n    }\\n\\n    // if no breakpoint\\n    if (breakPoint < 0)\\n    {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n\\n    // if found a breakpoint\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        if (nums[i] > nums[breakPoint])\\n        {\\n            swap(nums[breakPoint], nums[i]);\\n            reverse(nums.begin() + breakPoint + 1, nums.end());\\n            break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// find next permutation\\nvoid nextPermutation(vector<int> &nums)\\n{\\n    // initialize variable:\\n    int breakPoint = -1;\\n\\n    // find a breakpoint:\\n    for (int i = nums.size() - 1; i > 0; i--)\\n    {\\n        if (nums[i] > nums[i - 1])\\n        {\\n            breakPoint = i - 1;\\n            break;\\n        }\\n    }\\n\\n    // if no breakpoint\\n    if (breakPoint < 0)\\n    {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n\\n    // if found a breakpoint\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        if (nums[i] > nums[breakPoint])\\n        {\\n            swap(nums[breakPoint], nums[i]);\\n            reverse(nums.begin() + breakPoint + 1, nums.end());\\n            break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909728,
                "title": "simple-9-line-python-solution-with-detailed-explanation-easy-understand-for-beginners",
                "content": "```\\n    def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            # find the index of the last peak\\n            if nums[i - 1] < nums[i]:\\n                nums[i:] = sorted(nums[i:])\\n                \\n                # get the index before the last peak\\n                j = i - 1\\n                \\n                # swap the pre-last peak index with the value just large than it\\n                for k in range(i, len(nums)):\\n                    if nums[j] < nums[k]:\\n                        nums[k], nums[j] = nums[j], nums[k]\\n                        return nums\\n        return nums.reverse()\\n```\\n\\n**Please upvote me if you think this is useful! Much appreciated!**\\n\\nImagine this as a wave or signal, what we want to do is to move the last peak one-bit forward with equal or smaller peak\\n\\nConsider the following example [1, 2, 3, 5, 2, 3, 7, 5, 4, 3, 0]\\n![image](https://assets.leetcode.com/users/images/f3d1862c-f3a1-4a4b-9910-b784b7bdb818_1648968377.4465942.png)\\n\\nThe last peak is the red dot (index = 6), the index before the last peak (aka the pre-last peak index) is the green dot (index = 5)\\n![image](https://assets.leetcode.com/users/images/450b8952-98cc-4cc1-ac26-7cb1e1df72c0_1648968377.4618545.png)\\n\\nThen sort the region after the pre-peak index (green dot), the sorted region is shown in yellow dots\\n![image](https://assets.leetcode.com/users/images/6e92ec4f-6bb3-4e95-a44f-0d3f1488201a_1648968735.369267.png)\\n\\nThen find the point where its value is just above the pre-peak index (green dot)\\nIn this example, it is the pink dot with index = 8\\n![image](https://assets.leetcode.com/users/images/3db777e4-ff85-420b-99b7-4070ff207579_1648968871.7919884.png)\\n\\nSwap the green dot and the pink dot\\n![image](https://assets.leetcode.com/users/images/cb34be94-d97d-447a-be46-3f762876d33f_1648969056.4870846.png)\\n\\n**Done!** Output the final list\\nIn this case, it is [1,2,3,5,2,4,0,3,3,5,7]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            # find the index of the last peak\\n            if nums[i - 1] < nums[i]:\\n                nums[i:] = sorted(nums[i:])\\n                \\n                # get the index before the last peak\\n                j = i - 1\\n                \\n                # swap the pre-last peak index with the value just large than it\\n                for k in range(i, len(nums)):\\n                    if nums[j] < nums[k]:\\n                        nums[k], nums[j] = nums[j], nums[k]\\n                        return nums\\n        return nums.reverse()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13907,
                "title": "easy-python-solution-based-on-lexicographical-permutation-algorithm",
                "content": "For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nThe steps are shown in the picture below.\\n![alt text](https://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm.png)\\n\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # find longest non-increasing suffix\\n        right = len(nums)-1\\n        while nums[right] <= nums[right-1] and right-1 >=0:\\n            right -= 1\\n        if right == 0:\\n            return self.reverse(nums,0,len(nums)-1)\\n        # find pivot\\n        pivot = right-1\\n        successor = 0\\n        # find rightmost succesor\\n        for i in range(len(nums)-1,pivot,-1):\\n            if nums[i] > nums[pivot]:\\n                successor = i\\n                break\\n        # swap pivot and successor\\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \\n        # reverse suffix\\n        self.reverse(nums,pivot+1,len(nums)-1)\\n        \\n    def reverse(self,nums,l,r):\\n        while l < r:\\n            nums[l],nums[r] = nums[r],nums[l]\\n            l += 1\\n            r -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # find longest non-increasing suffix\\n        right = len(nums)-1\\n        while nums[right] <= nums[right-1] and right-1 >=0:\\n            right -= 1\\n        if right == 0:\\n            return self.reverse(nums,0,len(nums)-1)\\n        # find pivot\\n        pivot = right-1\\n        successor = 0\\n        # find rightmost succesor\\n        for i in range(len(nums)-1,pivot,-1):\\n            if nums[i] > nums[pivot]:\\n                successor = i\\n                break\\n        # swap pivot and successor\\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \\n        # reverse suffix\\n        self.reverse(nums,pivot+1,len(nums)-1)\\n        \\n    def reverse(self,nums,l,r):\\n        while l < r:\\n            nums[l],nums[r] = nums[r],nums[l]\\n            l += 1\\n            r -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179544,
                "title": "python-solution-with-easy-understanding-and-comments-bonus-related-links",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # To find next permutations, we\\'ll start from the end\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number grater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now out pointer is pointing at two different positions\\n        # i. first non-assending number from end\\n        # j. first number greater than nums[i-1]\\n        \\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place\\n        \\'\\'\\'\\n            Dhruval\\n        \\'\\'\\'\\n```\\n\\nTake an example from this site and try to re-run above code manually. This will better help to understand the code\\nhttps://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nRelated Link: \\nhttps://www.nayuki.io/res/next-lexicographical-permutation-algorithm/nextperm.py\\nhttps://en.wikipedia.org/wiki/Lexicographic_order",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # To find next permutations, we\\'ll start from the end\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number grater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now out pointer is pointing at two different positions\\n        # i. first non-assending number from end\\n        # j. first number greater than nums[i-1]\\n        \\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place\\n        \\'\\'\\'\\n            Dhruval\\n        \\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13885,
                "title": "9-lines-of-c-code-with-comments",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int> &num) \\n        {\\n            if (num.empty()) return;\\n            \\n            // in reverse order, find the first number which is in increasing trend (we call it violated number here)\\n            int i;\\n            for (i = num.size()-2; i >= 0; --i)\\n            {\\n                if (num[i] < num[i+1]) break;\\n            }\\n            \\n            // reverse all the numbers after violated number\\n            reverse(begin(num)+i+1, end(num));\\n            // if violated number not found, because we have reversed the whole array, then we are done!\\n            if (i == -1) return;\\n            // else binary search find the first number larger than the violated number\\n            auto itr = upper_bound(begin(num)+i+1, end(num), num[i]);\\n            // swap them, done!\\n            swap(num[i], *itr);\\n        }\\n    };\\n\\nYou might need to think for a while why this would work.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int> &num) \\n        {\\n            if (num.empty()) return;\\n            \\n            // in reverse order, find the first number which is in increasing trend (we call it violated number here)\\n            int i;\\n            for (i = num.size()-2; i >= 0; --i)\\n            {\\n                if (num[i] < num[i+1]) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 669387,
                "title": "javascript-clean-solution",
                "content": "Approach\\n*  Find the first decreasing index moving from end to start \\n\\t*  E.g. [7, 2, 3, 1, 5, 4, 3, 2, 0] num `1` is the first decreasing index going from the end backwards\\n*  Swap num `1` with the next large num to its right which is `2`\\n\\t*  [7, 2, 3, 2, 5, 4, 3, 1, 0]\\n*  Reverse/sort nums to the right\\n\\t*  [7, 2, 3, 2, 0, 1, 3, 4, 5]\\n*  If there is no next permutation reverse the array\\n\\n```javascript\\nvar nextPermutation = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--) {\\n        if(nums[i] < nums[i+1]) {\\n            const large = nextLarge(i);\\n            swap(i, large);\\n            reverse(i+1);\\n            return;\\n        }\\n    }\\n\\t\\n\\t// If there is no next permutation reverse the arr\\n    nums.reverse()\\n    \\n    function swap(i, j) {\\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    function reverse(idx) {\\n        let start = idx, end = nums.length-1;\\n        \\n        while(start < end) {\\n            swap(start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    function nextLarge(idx) {\\n        for(let i = nums.length-1; i > idx; i--) {\\n            if(nums[i] > nums[idx]) return i;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar nextPermutation = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--) {\\n        if(nums[i] < nums[i+1]) {\\n            const large = nextLarge(i);\\n            swap(i, large);\\n            reverse(i+1);\\n            return;\\n        }\\n    }\\n\\t\\n\\t// If there is no next permutation reverse the arr\\n    nums.reverse()\\n    \\n    function swap(i, j) {\\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    function reverse(idx) {\\n        let start = idx, end = nums.length-1;\\n        \\n        while(start < end) {\\n            swap(start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    function nextLarge(idx) {\\n        for(let i = nums.length-1; i > idx; i--) {\\n            if(nums[i] > nums[idx]) return i;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229211,
                "title": "python-solution",
                "content": "First observe that if a list of numbers is in descending order, then there is no lexicographically next greater permutation. Hence `for i in range(n-1,0,-1)`, we search for the first occurrence of i such that `nums[i] < nums[i+1]`. If no such i exists, the list is in descending order, and we use `nums.reverse()` to reverse the list in-place. Otherwise, if such i exists, then `nums[i-1]` will be updated to get the lexicographically next greater permutation. Next, we need to search for the smallest number in `nums[i:]` that\\'s larger than `nums[i-1]`, and swap it with `nums[i-1]`. Note that `nums[i:]` is sorted in descending order. Hence we start with `j = i`, and `while j < n and nums[j] > nums[i-1]`, we do `idx = j, j += 1`. When we are out of the while loop, `nums[idx]` will be the smallest number in `nums[i:]` that\\'s larger than `nums[i]`. We then swap `nums[idx]` and `nums[i-1]`. After the swap, we just need to sort `nums[i:]` in ascending order to get the lexicographically next greater permutation. This can be achieved fairly easily in-place, because `nums[i:]` is already in descending order, and we just need to invert `nums[i:]` in-place to sort `nums[i:]` in ascending order. \\n\\nTo illustrate the algorithm with an example, consider `nums = [2,3,1,5,4,2]`. It is easy to see that `i = 2` is the first i (from the right) such that `nums[i] < nums[i+1]`. Then we swap `nums[2] = 1` with the smallest number in `nums[3:]` that is larger than 1, which is `nums[5] = 2`, after which we get `nums = [2,3,2,5,4,1]`. To get the lexicographically next greater permutation of `nums`, we just need to sort `nums[3:] = [5,4,1]` in-place. Finally, we reach `nums = [2,3,2,1,4,5]`.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        for i in range(n-1, 0, -1):\\n            if nums[i] > nums[i-1]:\\n                j = i\\n                while j < n and nums[j] > nums[i-1]:\\n                    idx = j\\n                    j += 1\\n                nums[idx], nums[i-1] = nums[i-1], nums[idx]\\n                for k in range((n-i)//2):\\n                    nums[i+k], nums[n-1-k] = nums[n-1-k], nums[i+k]\\n                break\\n        else:\\n            nums.reverse()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        for i in range(n-1, 0, -1):\\n            if nums[i] > nums[i-1]:\\n                j = i\\n                while j < n and nums[j] > nums[i-1]:\\n                    idx = j\\n                    j += 1\\n                nums[idx], nums[i-1] = nums[i-1], nums[idx]\\n                for k in range((n-i)//2):\\n                    nums[i+k], nums[n-1-k] = nums[n-1-k], nums[i+k]\\n                break\\n        else:\\n            nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13890,
                "title": "sharing-my-really-simple-solution-with-explanation",
                "content": "    void nextPermutation(vector<int> &num) {\\n        for(int i = num.size() - 2; i >= 0; i--){\\n            if(num[i] < num[i + 1]){\\n                int pos;\\n                int diff = INT_MAX;\\n                for(int j = i + 1; j < num.size(); j++){\\n                    if(num[j] > num[i] && abs(num[i] - num[j]) < diff){\\n                        diff = abs(num[i] - num[j]);\\n                        pos = j;\\n                    }\\n                }\\n                swap(num[i], num[pos]);\\n                sort(num.begin() + i + 1, num.end());\\n                return;\\n            }\\n        }\\n        sort(num.begin(), num.end());\\n    }\\n\\nFor this problem, coding is not a big deal. Algorithm is!\\n\\nNow let's pick a number, for example, 24387651.\\n\\nwhat is the next permutation? 24513678.\\n\\nHow can I get the answer? \\n\\nFirst step: find the first ascending digit from the back of the number. 3 < 8 > 7 > 6 > 5 > 1. Then 3 is the digit.\\n\\nSecond step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\\n\\nThird step: sort 87631 into 13678. The final answer is 24513678.",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    void nextPermutation(vector<int> &num) {\\n        for(int i = num.size() - 2; i >= 0; i--){\\n            if(num[i] < num[i + 1]){\\n                int pos;\\n                int diff = INT_MAX;\\n                for(int j = i + 1; j < num.size(); j++){\\n                    if(num[j] > num[i] && abs(num[i] - num[j]) < diff){\\n                        diff = abs(num[i] - num[j]);\\n                        pos = j;\\n                    }\\n                }\\n                swap(num[i], num[pos]);\\n                sort(num.begin() + i + 1, num.end());\\n                return;\\n            }\\n        }\\n        sort(num.begin(), num.end());\\n    }\\n\\nFor this problem, coding is not a big deal. Algorithm is!\\n\\nNow let's pick a number, for example, 24387651.\\n\\nwhat is the next permutation? 24513678.\\n\\nHow can I get the answer? \\n\\nFirst step: find the first ascending digit from the back of the number. 3 < 8 > 7 > 6 > 5 > 1. Then 3 is the digit.\\n\\nSecond step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\\n\\nThird step: sort 87631 into 13678. The final answer is 24513678.",
                "codeTag": "Unknown"
            },
            {
                "id": 1043577,
                "title": "python-o-n-inplace-solution-explained",
                "content": "This problem is very similar to problem **556. Next Greater Element III**, with exactly the same reasoning:\\n\\nImagine, that we have `nums = [2, 3, 4, 1, 5, 7, 6, 4, 1]` Then next permutation is `[2, 3, 4, 1, 6, 1, 4, 5, 7]`. Idea here is to start to look from the end and find decreasing pattern, like `[7, 6, 4, 1]` here, then look at previous element and insert it in correct place. For more details see https://leetcode.com/problems/next-greater-element-iii/discuss/983076/Python-O(m)-solution-explained.\\n\\n**Complexity**: time complexity it is `O(n)`, where `n` is length of `nums`. Space complexity is `O(1)` here, because we do everything in-place.\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        def reverse(L, start, end):\\n            while start < end:\\n                L[start], L[end] = L[end], L[start]\\n                start, end = start + 1, end - 1\\n        \\n        i, n = len(nums) - 1, len(nums)\\n        while i >= 1 and nums[i] <= nums[i-1]:\\n            i -= 1\\n            \\n        if i != 0:\\n            j = i\\n            while j + 1 < n and nums[j+1] > nums[i - 1]:\\n                j += 1\\n            \\n            nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        reverse(nums, i, n - 1)\\n        \\n        return nums\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        def reverse(L, start, end):\\n            while start < end:\\n                L[start], L[end] = L[end], L[start]\\n                start, end = start + 1, end - 1\\n        \\n        i, n = len(nums) - 1, len(nums)\\n        while i >= 1 and nums[i] <= nums[i-1]:\\n            i -= 1\\n            \\n        if i != 0:\\n            j = i\\n            while j + 1 < n and nums[j+1] > nums[i - 1]:\\n                j += 1\\n            \\n            nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        reverse(nums, i, n - 1)\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152693,
                "title": "c-c-java-python-short-solution-with-comments-just-5-lines-of-clean-stl-c-code",
                "content": "1. Search from right to left for a point where the values stop ascending, that will be the point that must be updated.\\n2. Locate the point furthest right of this point that has a greater value than our destination point found in 1.\\n3. Swap the points found in 1. and 2 and reverse everything to the right of destination found in 1. as it is currently decending left to right and must be ascending.\\n\\n# **TL;DR**\\n**Python**\\n```python\\ndef nextPermutation(self, nums: List[int]) -> None:\\n  # Find the first place moving from right to left that is not assending\\n  dest = len(nums) - 2\\n  while (0 <= dest and nums[dest] >= nums[dest + 1]):\\n    dest = dest - 1\\n\\n  # Found a destination to change\\n  if (0 <= dest):\\n    # Find the first number moving right to left bigger than destination number\\n    target = len(nums) - 1\\n    while (nums[target] <= nums[dest]):\\n      target = target - 1\\n\\n    nums[dest], nums[target] = nums[target], nums[dest]\\n\\n  # Reverse everything right of our destination\\n  nums[dest + 1:] = reversed(nums[dest + 1:])\\n```\\n**Java**\\n```java\\npublic void nextPermutation(int[] num) {\\n  // Find the first place moving from right to left that is not assending\\n  int dest = num.length - 2;\\n  for (; 0 <= dest && num[dest] >= num[dest + 1]; --dest)\\n    ;\\n\\n  // If we found a location that is not sorted\\n  if (0 <= dest) {\\n    // Find the right most value greater than our destination (there must be one)\\n    int target = num.length - 1;\\n    for (; num[dest] >= num[target]; --target)\\n      ;\\n\\n    // Swap the destination with the target\\n    int tmp = num[dest];\\n    num[dest] = num[target];\\n    num[target] = tmp;\\n  }\\n\\n  // Reverse everything right of the destination\\n  for (int end = num.length - 1; dest + 1 < end; ) {\\n    int tmp = num[++dest];\\n    num[dest] = num[end];\\n    num[end--] = tmp;\\n  }\\n}\\n```\\n**C++ STL Solution**\\nDetails below;\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\n**C**\\n```c\\nvoid nextPermutation(int* nums, int numsSize) {\\n  /* Find the first place moving from right to left that is not assending */\\n  int dest = numsSize - 1;\\n  while (dest-- && nums[dest] >= nums[dest + 1])\\n    ;\\n\\n  if (0 <= dest) /* Found a destination to change */ {\\n    /* Find the right most value greater than our destination (there must be one) */\\n    int target = numsSize;\\n    while (nums[--target] <= nums[dest])\\n      ;\\n\\n    /* Swap the destination with the target */\\n    int tmp = nums[dest];\\n    nums[dest] = nums[target];\\n    nums[target] = tmp;\\n  }\\n  \\n  /* Reverse everything right of our destination */\\n  for (int back = numsSize - 1; dest + 1 < back; ) {\\n    int tmp = nums[++dest];\\n    nums[dest] = nums[back];\\n    nums[back--] = tmp;\\n  }\\n}\\n```\\n\\n# **C++ Details**\\nAn initial solution might be;\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      if (1 < nums.size()) {\\n        auto pos = nums.end() - 1;\\n        do {\\n          if (*pos > *(pos - 1)) {\\n            auto dest = pos - 1;\\n            // Find the first element that is greater then dest, this will be\\n            // the element between [pos, nums.end()] that is just above dest\\n            // Use the fact that [pos, nums.end()] is sorted in descending order to do a binary search\\n            auto target = --std::lower_bound(pos, nums.end(), *dest, std::greater<int>());\\n\\n            // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n            std::iter_swap(dest, target);\\n\\n            // At this point [pos, end) will be sorted descending, we need it to be\\n            // ascending\\n            // [3, 4, 2, 1] -> [3, 1, 2, 4] \\n            std::reverse(pos, nums.end());\\n            return;\\n          }\\n        } \\n        while (--pos != nums.begin());\\n\\n        // At the end of the permutation, reverse everything.\\n        std::reverse(nums.begin(), nums.end());\\n      }\\n    }\\n```\\t\\t\\nOf course, you could cheat and do\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      std::next_permutation(nums.begin(), nums.end());\\n    }\\n```\\nBut where\\'s the fun in that?\\n\\nCan we do better though? Well all we\\'re really trying to do is find the first point where the ordering is no longer ascending when moving right to left. There\\'s an ~~app~~ algorithm for that! `std::is_sorted_until` will return the iterator of the first unsorted element, so using the reverse iterators to search from right to left, we get a one-liner to find the destination element.\\n\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      // Find the first point where the ordering from right to left is not sorted\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        // We found a point, find a candidate to swap with. The range [rbegin, dest) is sorted ascendingly\\n        // so we can binary search for the first element greater than our destination\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        \\n        // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n        std::iter_swap(dest, target);\\n      }\\n      // Reverse everything to the right of our dest point. In the case of not being the whole vector this\\n      // reverses the ordering from being ascending (left to right) to being descending\\n      // [3, 4, 2, 1] -> [3, 1, 2, 4]\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\t\\t\\nThe actual code without comments is only a few, clean, lines.\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\t\\t",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\ndef nextPermutation(self, nums: List[int]) -> None:\\n  # Find the first place moving from right to left that is not assending\\n  dest = len(nums) - 2\\n  while (0 <= dest and nums[dest] >= nums[dest + 1]):\\n    dest = dest - 1\\n\\n  # Found a destination to change\\n  if (0 <= dest):\\n    # Find the first number moving right to left bigger than destination number\\n    target = len(nums) - 1\\n    while (nums[target] <= nums[dest]):\\n      target = target - 1\\n\\n    nums[dest], nums[target] = nums[target], nums[dest]\\n\\n  # Reverse everything right of our destination\\n  nums[dest + 1:] = reversed(nums[dest + 1:])\\n```\n```java\\npublic void nextPermutation(int[] num) {\\n  // Find the first place moving from right to left that is not assending\\n  int dest = num.length - 2;\\n  for (; 0 <= dest && num[dest] >= num[dest + 1]; --dest)\\n    ;\\n\\n  // If we found a location that is not sorted\\n  if (0 <= dest) {\\n    // Find the right most value greater than our destination (there must be one)\\n    int target = num.length - 1;\\n    for (; num[dest] >= num[target]; --target)\\n      ;\\n\\n    // Swap the destination with the target\\n    int tmp = num[dest];\\n    num[dest] = num[target];\\n    num[target] = tmp;\\n  }\\n\\n  // Reverse everything right of the destination\\n  for (int end = num.length - 1; dest + 1 < end; ) {\\n    int tmp = num[++dest];\\n    num[dest] = num[end];\\n    num[end--] = tmp;\\n  }\\n}\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\n```c\\nvoid nextPermutation(int* nums, int numsSize) {\\n  /* Find the first place moving from right to left that is not assending */\\n  int dest = numsSize - 1;\\n  while (dest-- && nums[dest] >= nums[dest + 1])\\n    ;\\n\\n  if (0 <= dest) /* Found a destination to change */ {\\n    /* Find the right most value greater than our destination (there must be one) */\\n    int target = numsSize;\\n    while (nums[--target] <= nums[dest])\\n      ;\\n\\n    /* Swap the destination with the target */\\n    int tmp = nums[dest];\\n    nums[dest] = nums[target];\\n    nums[target] = tmp;\\n  }\\n  \\n  /* Reverse everything right of our destination */\\n  for (int back = numsSize - 1; dest + 1 < back; ) {\\n    int tmp = nums[++dest];\\n    nums[dest] = nums[back];\\n    nums[back--] = tmp;\\n  }\\n}\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      if (1 < nums.size()) {\\n        auto pos = nums.end() - 1;\\n        do {\\n          if (*pos > *(pos - 1)) {\\n            auto dest = pos - 1;\\n            // Find the first element that is greater then dest, this will be\\n            // the element between [pos, nums.end()] that is just above dest\\n            // Use the fact that [pos, nums.end()] is sorted in descending order to do a binary search\\n            auto target = --std::lower_bound(pos, nums.end(), *dest, std::greater<int>());\\n\\n            // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n            std::iter_swap(dest, target);\\n\\n            // At this point [pos, end) will be sorted descending, we need it to be\\n            // ascending\\n            // [3, 4, 2, 1] -> [3, 1, 2, 4] \\n            std::reverse(pos, nums.end());\\n            return;\\n          }\\n        } \\n        while (--pos != nums.begin());\\n\\n        // At the end of the permutation, reverse everything.\\n        std::reverse(nums.begin(), nums.end());\\n      }\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      std::next_permutation(nums.begin(), nums.end());\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      // Find the first point where the ordering from right to left is not sorted\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        // We found a point, find a candidate to swap with. The range [rbegin, dest) is sorted ascendingly\\n        // so we can binary search for the first element greater than our destination\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        \\n        // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n        std::iter_swap(dest, target);\\n      }\\n      // Reverse everything to the right of our dest point. In the case of not being the whole vector this\\n      // reverses the ordering from being ascending (left to right) to being descending\\n      // [3, 4, 2, 1] -> [3, 1, 2, 4]\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043648,
                "title": "easy-solution-w-detailed-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nChanges made to the left part of an array have more impact on the lexicographical sorting than changes made to the right side, so logically, in order to find the next permutation that is lexicographically greater, we need to find the farthest right-most number that can be swapped for a larger number to its right.\\n\\nWe also then need to make sure that it\\'s not just any larger number, but the *next possible* larger number from the numbers to its right. Then, we\\'ll need to make sure that the remaining numbers to the right of our swapped target are in their lexicographically smallest configuration. (*Think of it like a counter rolling over from **0999** into **1000**.*)\\n\\n---\\n\\n***Implementation:***\\n\\nSo the first order of business is to find the target number we want to swap. As we check from the right to the left, if each number is larger than the one before, then we clearly can\\'t find a lexicographically larger number. Therefore, we have to move left until we find the first time a number is lower than the number to its right.\\n\\nOnce we find that target (**N[i]**), the very important thing to recognize is that the numbers to the target\\'s right are *already* in sorted order, just in the *reverse* order, so we can easily reverse them. (*Even if we don\\'t actually find the target, we still want to reverse the entire array, per the instructions.*)\\n\\nIt\\'s easy then to move from the smallest to largest of the reversed numbers and look for the first number (**N[j]**) that\\'s larger than our target so that we can swap the two. Since **N[j]** is lexicographically nearest to **N[i]**, the subarray to the right of **N[i]** will *still* be in the correct order even after the swap.\\n\\nA simple helper functions to swap array elements will be useful.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 39.3MB** (beats 100% / 100%).\\n```javascript\\nvar nextPermutation = function(N) {\\n    const swap = (a, b) => [N[a],N[b]] = [N[b],N[a]]\\n    let len = N.length - 1, i, j\\n    for (i = len - 1; N[i] >= N[i+1];) i--\\n    for (let k = i+1; len > k; k++, len--) swap(k,len)\\n    if (~i) {\\n        for (j = i + 1; N[i] >= N[j];) j++\\n        swap(i,j)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar nextPermutation = function(N) {\\n    const swap = (a, b) => [N[a],N[b]] = [N[b],N[a]]\\n    let len = N.length - 1, i, j\\n    for (i = len - 1; N[i] >= N[i+1];) i--\\n    for (let k = i+1; len > k; k++, len--) swap(k,len)\\n    if (~i) {\\n        for (j = i + 1; N[i] >= N[j];) j++\\n        swap(i,j)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777680,
                "title": "easy-simple-o-n-c-code",
                "content": "# Please do upvote if you like the code ..ty\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(),k,l;\\n         \\n        // finding first element from the last which is smaller than\\n        // element next to it\\n        for(k=n-2 ; k>=0 ; k--)\\n            if(nums[k] < nums[k+1]) break;\\n\\n        // if we dont find any such element that means the vector \\n        // is already sorted in descending order\\n\\n        // i.e. It is already the biggest number that can be formed\\n        // using all the integers\\n\\n        // In this case the next Premutation will be the smallest\\n        // permutation that can be formed using the numbers of\\n        // array i.e. all the array elements in ascending order\\n        // which is nothing but the reverse of the current order\\n \\n        if(k<0)\\n            reverse(nums.begin() ,nums.end());\\n\\n        // After finding the index \"k\" of the number which is \\n        // smaller than the number next to it ,\\n        // we will again traverse from the right to \\n        // left and will find the first element which is greater\\n        // the element at index k ....which is indeed the smallest \\n        // of all the numbers right to the index k\\n\\n        // we will then swap both the characters \\n        // after swapping we will just reverse the digits after the\\n        // index k as that is in descending order and reversing it\\n        // will make it in increasing order and will make the whole\\n        // number smallest possible number greater than \\n        // the original number \\n        else{\\n            for(l = n-1; l >k ;l--)\\n                if(nums[l] > nums[k]) break;\\n            swap(nums[k], nums[l]); \\n            reverse(nums.begin()+k+1 ,  nums.end());\\n        }\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(),k,l;\\n         \\n        // finding first element from the last which is smaller than\\n        // element next to it\\n        for(k=n-2 ; k>=0 ; k--)\\n            if(nums[k] < nums[k+1]) break;\\n\\n        // if we dont find any such element that means the vector \\n        // is already sorted in descending order\\n\\n        // i.e. It is already the biggest number that can be formed\\n        // using all the integers\\n\\n        // In this case the next Premutation will be the smallest\\n        // permutation that can be formed using the numbers of\\n        // array i.e. all the array elements in ascending order\\n        // which is nothing but the reverse of the current order\\n \\n        if(k<0)\\n            reverse(nums.begin() ,nums.end());\\n\\n        // After finding the index \"k\" of the number which is \\n        // smaller than the number next to it ,\\n        // we will again traverse from the right to \\n        // left and will find the first element which is greater\\n        // the element at index k ....which is indeed the smallest \\n        // of all the numbers right to the index k\\n\\n        // we will then swap both the characters \\n        // after swapping we will just reverse the digits after the\\n        // index k as that is in descending order and reversing it\\n        // will make it in increasing order and will make the whole\\n        // number smallest possible number greater than \\n        // the original number \\n        else{\\n            for(l = n-1; l >k ;l--)\\n                if(nums[l] > nums[k]) break;\\n            swap(nums[k], nums[l]); \\n            reverse(nums.begin()+k+1 ,  nums.end());\\n        }\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908568,
                "title": "python3-search-swap-sort-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThree steps:\\n1. Starting from the back, search for an element that has at least one element on the right side that is greater than it. [1, **2**, 4, 3, 1]\\n2. Swap the found element and the minimum element from the right side that is greater than the current. [1, **3**, 4, 2, 1]\\n3. Sort element on the right side. [1, 3, **1, 2, 4**]\\n\\nTime: **O(n^2)** - Can be linear if optimize searching for a candidate for swapping, and also instead of insertion sort just reverse the subarray :)\\nSpace: **O(1)**\\n\\nRuntime: 49 ms, faster than **72.04%** of Python3 online submissions for Next Permutation.\\nMemory Usage: 13.9 MB, less than **79.00%** of Python3 online submissions for Next Permutation\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        L = len(nums)\\n        for i in reversed(range(L - 1)):\\n            # Search\\n            cand = -1\\n            for j in range(i + 1, L):\\n                if nums[j] > nums[i]:\\n                    if cand < 0 or nums[j] < nums[cand]: cand = j\\n            if cand < 0: continue\\n\\n            # Swap\\n            nums[i], nums[cand] = nums[cand], nums[i]\\n                        \\n            # Insertion sort\\n            j = i + 2\\n            while j < L:\\n                k = j\\n                while k - 1 > i and nums[k - 1] > nums[k]:\\n                    nums[k - 1], nums[k] = nums[k], nums[k - 1]\\n                    k -= 1\\n                \\n                j += 1\\n\\n            break\\n        else:\\n            nums.reverse()\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        L = len(nums)\\n        for i in reversed(range(L - 1)):\\n            # Search\\n            cand = -1\\n            for j in range(i + 1, L):\\n                if nums[j] > nums[i]:\\n                    if cand < 0 or nums[j] < nums[cand]: cand = j\\n            if cand < 0: continue\\n\\n            # Swap\\n            nums[i], nums[cand] = nums[cand], nums[i]\\n                        \\n            # Insertion sort\\n            j = i + 2\\n            while j < L:\\n                k = j\\n                while k - 1 > i and nums[k - 1] > nums[k]:\\n                    nums[k - 1], nums[k] = nums[k], nums[k - 1]\\n                    k -= 1\\n                \\n                j += 1\\n\\n            break\\n        else:\\n            nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394208,
                "title": "c-brute-force-optimal-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution** \\n![image](https://assets.leetcode.com/users/images/312b7900-f2ea-4324-95b5-2a1c49055cb7_1628647022.5257127.gif)\\nPicture sourced from other coding sources\\n\\n**If n is the size of the array, then total number of permutations is n!. If nums[]={a,b,c} which means n=3, then the permutations are abc, acb, bac, bca, cba, cab. Time complexity of the brute force solution is O(NxN!) where N! is for the total number of permutations and N is for traversing each individual permutation**\\n```\\nclass Solution {\\n\\t    // Brute Force Solution Time O(N!*N) & Auxiliary Space O(N^2)\\n\\t\\t// Recursion & Backtracking\\n\\t    // TLE 64/265 test cases passed\\npublic:\\n\\t// permute function takes time of O(N*N!)\\n    void permute(int p,vector<int>& arr, vector<vector<int>>& res) {\\n        int n=arr.size();\\n        if(p==n) res.push_back(arr);\\n        for(int i=p;i<n;i++) {  // Time O(N) for traversal of each permutation\\n            swap(arr[i],arr[p]);\\n            permute(p+1,arr,res);  // Time O(N!) for total number of permutations\\n            swap(arr[i],arr[p]);\\n        }\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        vector<vector<int>> res; \\n        vector<int> arr=nums; \\n        permute(0,arr,res); \\n        set<vector<int>> s; // set stores unique elements in the sorted order\\n        for(int i=0;i<res.size();i++){\\n            s.insert(res[i]);\\n        }\\n        auto it=s.find(nums);\\n\\t\\t// If nums is last element of the permutation order, \\n\\t\\t// then nums is equal to the first element of the \\n\\t\\t// permutation sequence\\n        if(it==(--s.end())){\\n            it=s.begin();\\n            nums=*it;\\n        }\\n\\t\\t// else make nums equal to the immediate \\n\\t\\t// next element in the permutation sequence\\n        else{\\n            it++;\\n            nums=*it;\\n        }\\n    }\\n};\\n```\\n**Optimal Solution**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Narayana Panditha\\'s Algorithm\\n        int len=nums.size(), k=0, l=0;   // For example, if nums=[2,4,6,5,3]\\n        for(k=len-2;k>=0;k--){\\n            if(nums[k]<nums[k+1])\\n                break;  // k will point to 4 in nums=[2,4,6,5,3]\\n        }\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n            for(l=len-1;l>k;l--){\\n                if(nums[l]>nums[k])\\n                    break; //  l will point to 5 in nums=[2,4,6,5,3]\\n        }\\n            swap(nums[k],nums[l]); // nums=[2,5,6,4,3]\\n            reverse(nums.begin()+k+1,nums.end()); // nums=[2,5,3,4,6]\\n        }\\n    }\\n};\\n```\\n**Optimal Solution(Inbuilt Function)**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Inbuilt Function\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t    // Brute Force Solution Time O(N!*N) & Auxiliary Space O(N^2)\\n\\t\\t// Recursion & Backtracking\\n\\t    // TLE 64/265 test cases passed\\npublic:\\n\\t// permute function takes time of O(N*N!)\\n    void permute(int p,vector<int>& arr, vector<vector<int>>& res) {\\n        int n=arr.size();\\n        if(p==n) res.push_back(arr);\\n        for(int i=p;i<n;i++) {  // Time O(N) for traversal of each permutation\\n            swap(arr[i],arr[p]);\\n            permute(p+1,arr,res);  // Time O(N!) for total number of permutations\\n            swap(arr[i],arr[p]);\\n        }\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        vector<vector<int>> res; \\n        vector<int> arr=nums; \\n        permute(0,arr,res); \\n        set<vector<int>> s; // set stores unique elements in the sorted order\\n        for(int i=0;i<res.size();i++){\\n            s.insert(res[i]);\\n        }\\n        auto it=s.find(nums);\\n\\t\\t// If nums is last element of the permutation order, \\n\\t\\t// then nums is equal to the first element of the \\n\\t\\t// permutation sequence\\n        if(it==(--s.end())){\\n            it=s.begin();\\n            nums=*it;\\n        }\\n\\t\\t// else make nums equal to the immediate \\n\\t\\t// next element in the permutation sequence\\n        else{\\n            it++;\\n            nums=*it;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Narayana Panditha\\'s Algorithm\\n        int len=nums.size(), k=0, l=0;   // For example, if nums=[2,4,6,5,3]\\n        for(k=len-2;k>=0;k--){\\n            if(nums[k]<nums[k+1])\\n                break;  // k will point to 4 in nums=[2,4,6,5,3]\\n        }\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n            for(l=len-1;l>k;l--){\\n                if(nums[l]>nums[k])\\n                    break; //  l will point to 5 in nums=[2,4,6,5,3]\\n        }\\n            swap(nums[k],nums[l]); // nums=[2,5,6,4,3]\\n            reverse(nums.begin()+k+1,nums.end()); // nums=[2,5,3,4,6]\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Inbuilt Function\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349275,
                "title": "solution-swift-next-permutation-test-cases",
                "content": "```swift\\nclass Solution {\\n    func nextPermutation(_ nums: inout [Int]) {\\n        let len = nums.count\\n        var lhs = -1, rhs = -1, idx = len - 2\\n        while idx >= 0 {\\n            if nums[idx] < nums[idx + 1] { lhs = idx; break }\\n            idx -= 1\\n        }\\n        if lhs == -1 { nums = nums.reversed(); return }\\n        \\n        idx = len - 1\\n        while idx > lhs {\\n            rhs = idx\\n            if nums[idx] > nums[lhs] { break }\\n            idx -= 1\\n        }\\n        nums.swapAt(lhs, rhs)\\n        nums.replaceSubrange(lhs + 1..<len, with: nums[lhs + 1...len - 1].reversed())\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.016 (0.020) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var nums = [1,2,3]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,3,2])\\n    }\\n    \\n    func test1() {\\n        var nums = [3,2,1]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,2,3])\\n    }\\n    \\n    func test2() {\\n        var nums = [1,1,5]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,5,1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func nextPermutation(_ nums: inout [Int]) {\\n        let len = nums.count\\n        var lhs = -1, rhs = -1, idx = len - 2\\n        while idx >= 0 {\\n            if nums[idx] < nums[idx + 1] { lhs = idx; break }\\n            idx -= 1\\n        }\\n        if lhs == -1 { nums = nums.reversed(); return }\\n        \\n        idx = len - 1\\n        while idx > lhs {\\n            rhs = idx\\n            if nums[idx] > nums[lhs] { break }\\n            idx -= 1\\n        }\\n        nums.swapAt(lhs, rhs)\\n        nums.replaceSubrange(lhs + 1..<len, with: nums[lhs + 1...len - 1].reversed())\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var nums = [1,2,3]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,3,2])\\n    }\\n    \\n    func test1() {\\n        var nums = [3,2,1]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,2,3])\\n    }\\n    \\n    func test2() {\\n        var nums = [1,1,5]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,5,1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908463,
                "title": "two-pointers-solution-with-detailed-explanation-code-commented",
                "content": "[Leetcode](https://leetcode.com/) [31. Next Permutation](https://leetcode.com/problems/next-permutation/).\\n\\n# Intuition\\n\\n- How to make a number **larger**? \\n\\nPick a **larger** number from the **lower** digit and swap it with the **higher** digit smaller number.\\n\\n- How to find the permutation which is **just larger** than the given number?\\n\\nThe increase should be as small as possible.\\n\\n# Two Pointers\\n\\nTake a example, $[3,2,1]$ which is decreasing order, there is no next permutation, it is already stable and cannot get larger.\\n\\nLike $[1,5,2,4,3,2]$, how can it be just larger than the given number?\\n\\n1. Scanning from right to left, find the **first** number which is smaller than the right digit, and swap it to the lower digit;\\n\\t- For example, $1 5 (2) 4 3 2$, the $2$ in the middle is the found one.\\n\\n2. Scanning from right to left, searching for the first number which is larger than it, and **swap** them.\\n\\t- For example, $1 5 (2) 4 (3) 2$, after swap: $1 5 (3) 4 (2) 2$.\\n\\nHowever, it\\'s not over yet!\\n\\nThe magnitude of the increase can be made smaller, the $3rd$ digit from right has become slightly larger, and the last three can be made smaller.\\n\\nThe last three digits are definitely **decreasing**, and they are flipped to become $[1,5,3,2,2,4]$, which is what is required.\\n\\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static void nextPermutation_tp(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int len = nums.length;\\n        int left = len - 2;\\n        /**\\n         * from right to left, search for the first one which is smaller than the right digit.\\n         */\\n        while (left >= 0 && nums[left] >= nums[left + 1]) {\\n            left--;\\n        }\\n\\n        /**\\n         *  If the one exists, search a one which is larger than it from right to left.\\n         */\\n        if (left >= 0) {\\n            int right = nums.length - 1;\\n            while (right >= 0 && nums[left] >= nums[right]) {\\n                right--;\\n            }\\n            /**\\n             * swap them.\\n             */\\n            swap(nums, left, right);\\n        }\\n\\n        /**\\n         *  flip the right to make the number smaller.\\n         */\\n        reverse(nums, left + 1);\\n    }\\n\\n    public static void swap(int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n\\n    public static void reverse(int[] nums, int low) {\\n        int left = low;\\n        int right = nums.length - 1;\\n        while (left < right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static void nextPermutation_tp(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int len = nums.length;\\n        int left = len - 2;\\n        /**\\n         * from right to left, search for the first one which is smaller than the right digit.\\n         */\\n        while (left >= 0 && nums[left] >= nums[left + 1]) {\\n            left--;\\n        }\\n\\n        /**\\n         *  If the one exists, search a one which is larger than it from right to left.\\n         */\\n        if (left >= 0) {\\n            int right = nums.length - 1;\\n            while (right >= 0 && nums[left] >= nums[right]) {\\n                right--;\\n            }\\n            /**\\n             * swap them.\\n             */\\n            swap(nums, left, right);\\n        }\\n\\n        /**\\n         *  flip the right to make the number smaller.\\n         */\\n        reverse(nums, left + 1);\\n    }\\n\\n    public static void swap(int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n\\n    public static void reverse(int[] nums, int low) {\\n        int left = low;\\n        int right = nums.length - 1;\\n        while (left < right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13894,
                "title": "two-pointer-solution-in-python-with-detail-expalanation",
                "content": "Credit goes to http://blog.csdn.net/m6830098/article/details/17291259\\n\\n    class Solution(object):\\n        def nextPermutation(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            # Use two-pointers: two pointers start from back\\n            # first pointer j stop at descending point\\n            # second pointer i stop at value > nums[j]\\n            # swap and sort rest\\n            if not nums: return None\\n            i = len(nums)-1\\n            j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step\\n            while i > 0:\\n                if nums[i-1] < nums[i]: # first one violates the trend\\n                  j = i-1\\n                  break\\n                i-=1\\n            for i in xrange(len(nums)-1, -1, -1):\\n                if nums[i] > nums[j]: # \\n                    nums[i], nums[j] = nums[j], nums[i] # swap position\\n                    nums[j+1:] = sorted(nums[j+1:]) # sort rest\\n                    return",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "Credit goes to http://blog.csdn.net/m6830098/article/details/17291259\\n\\n    class Solution(object):\\n        def nextPermutation(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            # Use two-pointers: two pointers start from back\\n            # first pointer j stop at descending point\\n            # second pointer i stop at value > nums[j]\\n            # swap and sort rest\\n            if not nums: return None\\n            i = len(nums)-1\\n            j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step\\n            while i > 0:\\n                if nums[i-1] < nums[i]: # first one violates the trend\\n                  j = i-1\\n                  break\\n                i-=1\\n            for i in xrange(len(nums)-1, -1, -1):\\n                if nums[i] > nums[j]: # \\n                    nums[i], nums[j] = nums[j], nums[i] # swap position\\n                    nums[j+1:] = sorted(nums[j+1:]) # sort rest\\n                    return",
                "codeTag": "Java"
            },
            {
                "id": 2516442,
                "title": "c-two-simplest-solutions-with-without-stl",
                "content": "Hey Guys,\\nHope you all are doing well!\\nIn this post, I\\'ve provided two simple and easy-to-understand solutions.\\nApproach 1:\\nStep 1: Linearly traverse the array from backwards\\xA0so that the array\\'s ith index value is less than the array\\'s (i+1)th index value. Store \\xA0that index into a variable.\\nStep 2: If the index value obtained in step 1 is less than zero. This indicates that the given input array has already been sorted in descending order. Simply reverse the given array to obtain the next permutation. Otherwise, simply traverse the array backwards to find the index that has\\xA0a value greater than the previously found index. Store index in another variable.\\nStep 3: Swap values present in indices found in the above two steps.\\nStep 4: Reverse array from index+1 where the index is found at step 1 till the end of the array.\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        int n=arr.size(),i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]) break;\\n        }\\n        if(i<0) reverse(arr.begin(),arr.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(arr[j]>arr[i]) break;\\n            }\\n            swap(arr[i],arr[j]);\\n            reverse(arr.begin()+i+1,arr.end());\\n        }\\n    }\\n};\\n```\\nApproach 2: We can simply use the C++ STL library function ```next_permutation()``` to get the next lexicographically greater permutation.\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        next_permutation(arr.begin(),arr.end());\\n    }\\n};\\n```\\nWhile traversing from backwards we are searching for an element whose value is smaller than the value of its previous element and in each step, we are decrementing the counter i by 1. \\nIf the given array is already sorted in descending order then we will not get a single element.  Eventually, counter i become -1.\\nAs we know to find the next permutation of any integer array which is already sorted in descending order simply take the reverse of it. \\n\\n![sample](https://user-images.githubusercontent.com/106552945/188268610-bb25b8c6-65b6-48a8-a3b6-ad652e6ab0d9.jpg)\\n\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\nHappy Coding!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        int n=arr.size(),i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]) break;\\n        }\\n        if(i<0) reverse(arr.begin(),arr.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(arr[j]>arr[i]) break;\\n            }\\n            swap(arr[i],arr[j]);\\n            reverse(arr.begin()+i+1,arr.end());\\n        }\\n    }\\n};\\n```\n```next_permutation()```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        next_permutation(arr.begin(),arr.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13878,
                "title": "c-java-clean-code-with-really-simple-explanation",
                "content": "To understand this approach, we need to define 2 concept with a 5 digit example `12543`:\\n- `NCR - No Capacity Range` : the number in that `range` cannot be bigger, Like: \"543\"\\n- `DWC - Digit With Capacity` : A digit bring capacity to the range after it. Like: \"[2]543\"\\n\\nLet's get some hint from finding the Next Decimal:\\n```\\nNext Decimal\\n[5](9 9 9) <- NCR (No Capacity Range)\\n ^\\nDWC (Digit With Capacity)\\n=>\\n[6](0 0 0)\\n```\\nImagine how you increase this number `5999` to `6000`:\\nBecause the first 3 digits from right is a `No Capacity Range`, you have to flip the 4th digits (5, the first `Digit With Capacity`.), to what - The next smallest digits greater than `5`, which is `6`, then make the `rest 3 digits` the smallest combination, which is `\"000\"`, that's how you get this `\"6000\"`;\\n\\nIn an permutation though, the next smallest number for `DWC(Digit With Capacity)` would be whatever is available in that following `NCR(No Capacity Range)`\\n\\n```\\nNext Permutation\\n1[2](5 4 3) <- NCR (No Capacity Range)\\n  ^\\nDWC (Digit With Capacity)\\n=>\\n1[3](2 4 5)\\n```\\nSo we have found the pattern is always to find the first `DWC(Digit With Capacity)`, then minimize the `NCR` after it.\\n\\nTo summarize:\\n1. Find the first `DWC`, which is 2;\\n```\\n1[2](5 4 3)\\n  ^\\n```\\n2. Reverse the `NCR` after it to make the `NCR` in increasing order(because it is already sorted in descending order).\\n```\\n1[2](3 4 5)\\n  ^\\n```\\n3. Swap the `DWC` with the `1st` digit in the reversed range that is slightly bigger than it.\\n```\\n1[3](2 4 5)\\n  ^--^\\n```\\nDONE!\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        if (a.size() <= 1) return;\\n        int dwc = -1; // Digit With Capacity\\n        for (int i = a.size() - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        // if dwc is not found, means this is a max array, reverse whole array and return;\\n        reverse(a.begin() + dwc + 1, a.end());\\n        if (dwc != -1) return;\\n        for (int i = dwc + 1; i < a.size(); i++) {\\n            if (a[i] > a[dwc]) {\\n                swap(a[i], a[dwc]); break;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Java**\\n```\\n/**\\n * 0. For permutation of index, the smallest order is ever increasing, the largest order is ever decreasing.\\n * 1. no-capacity-range: NCR - Start from the end, as long as the next number is bigger, this whole range have no capacity.\\n * 2. First digit-with-capacity: DWC - find the first DWC index. reverse the rest. then switch the index with the first larger than index on the right.\\n */\\npublic class Solution {\\n    public void nextPermutation(int[] a) {\\n        if (a.length < 2) return;\\n        /* Find the first Digit With Capacity */\\n        int dwc = -1;\\n        for (int i = a.length - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        /* Reverse the No Capacity Range after 1st DWC. */\\n        reverse(a, dwc + 1, a.length - 1);\\n        if (dwc != -1) {\\n            for (int i = dwc + 1; i < a.length; i++) {\\n                if (a[i] > a[dwc]) {\\n                    swap(a, dwc, i); break;\\n                }\\n            }\\n        }\\n    }\\n    private void reverse(int[] a, int i, int j) {\\n        for (; i < j; i++, j--) { swap(a, i, j); }\\n    }\\n    private void swap(int[] a, int i, int j) {\\n        int tmp = a[i];\\n        a[i] = a[j];\\n        a[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nNext Decimal\\n[5](9 9 9) <- NCR (No Capacity Range)\\n ^\\nDWC (Digit With Capacity)\\n=>\\n[6](0 0 0)\\n```\n```\\nNext Permutation\\n1[2](5 4 3) <- NCR (No Capacity Range)\\n  ^\\nDWC (Digit With Capacity)\\n=>\\n1[3](2 4 5)\\n```\n```\\n1[2](5 4 3)\\n  ^\\n```\n```\\n1[2](3 4 5)\\n  ^\\n```\n```\\n1[3](2 4 5)\\n  ^--^\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        if (a.size() <= 1) return;\\n        int dwc = -1; // Digit With Capacity\\n        for (int i = a.size() - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        // if dwc is not found, means this is a max array, reverse whole array and return;\\n        reverse(a.begin() + dwc + 1, a.end());\\n        if (dwc != -1) return;\\n        for (int i = dwc + 1; i < a.size(); i++) {\\n            if (a[i] > a[dwc]) {\\n                swap(a[i], a[dwc]); break;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * 0. For permutation of index, the smallest order is ever increasing, the largest order is ever decreasing.\\n * 1. no-capacity-range: NCR - Start from the end, as long as the next number is bigger, this whole range have no capacity.\\n * 2. First digit-with-capacity: DWC - find the first DWC index. reverse the rest. then switch the index with the first larger than index on the right.\\n */\\npublic class Solution {\\n    public void nextPermutation(int[] a) {\\n        if (a.length < 2) return;\\n        /* Find the first Digit With Capacity */\\n        int dwc = -1;\\n        for (int i = a.length - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        /* Reverse the No Capacity Range after 1st DWC. */\\n        reverse(a, dwc + 1, a.length - 1);\\n        if (dwc != -1) {\\n            for (int i = dwc + 1; i < a.length; i++) {\\n                if (a[i] > a[dwc]) {\\n                    swap(a, dwc, i); break;\\n                }\\n            }\\n        }\\n    }\\n    private void reverse(int[] a, int i, int j) {\\n        for (; i < j; i++, j--) { swap(a, i, j); }\\n    }\\n    private void swap(int[] a, int i, int j) {\\n        int tmp = a[i];\\n        a[i] = a[j];\\n        a[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294256,
                "title": "simple-java-approach-with-100-beats",
                "content": "# Intuition\\nBasic Idealogy about the lexicographical order of permutations to the given input\\n\\n# Approach\\nStep 1:In first for loop, traverse the array from the end to find the first decreasing element from the right.(If any of the element had not been found means, just reverse the loop and exit the program.)\\n\\nStep 2:In second for loop, traverse the array from the end to find the first element which is greater than the element we had found before.\\n\\nStep 3:Swap the two elements we had found and stored previously.\\n\\nStep 4:Just reverse the array from the index next to the first swapped element to the end.\\n\\n\\n                        Do upvote for me!\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n            swap(nums,ind1,ind2);\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n            swap(nums,ind1,ind2);\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564964,
                "title": "c-solution-with-proper-explanation-along-with-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Find the point a[i]<a[i+1] by iterating from last. This is our index1.\\n- If there is no breakpoint that means the array is in descending order. So, simply reverse the full array.\\n- Else again iterate from last and find the element that is great than a[index1]. Store it as index2.\\n- Swap the 2elements at index1 and index2.\\n- Finally reverse the array from index1+1, so that we get the minimum number. Which means the next permutation.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i, j;\\n        int n= nums.size();\\n        int a=0;\\n        for(i=n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i<0)\\n            reverse(nums.begin(), nums.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(nums[i]<nums[j]){\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin()+i+1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i, j;\\n        int n= nums.size();\\n        int a=0;\\n        for(i=n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i<0)\\n            reverse(nums.begin(), nums.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(nums[i]<nums[j]){\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin()+i+1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910236,
                "title": "python-easy-o-n-solution-explained",
                "content": "**Explaination:**\\nLet\\'s take an example and try to understand.\\n```Example: curr = [1, 2, 4, 3]```\\n```next = [1, 3, 2, 4]``` , So How do we find next? \\n\\n**Step1:** Find the ```breakpoint``` from the end which breaks the non-increasing sequence. Why?\\n```\\n    |-breakpoint\\n    |\\n1,  2, [ 4,  3 ] - right (non increasing sequence)\\n```\\nNow Think, can we swap any element from ```right```? No we can\\'t because it will always result in lower permutation and not greater.\\nSo we find the break point\\n\\n**Step2:** Traverse from end in ```right``` part and find the first element greater than breakpoint. Why?\\nWe need to find the next lexicographically greater permutation, So we can\\'t just swap it with any number, In the above example, ```4``` and ```3``` both are greater than ```2```. Swapping with```4``` will be far greater, So we will swap it with ```3```\\n\\nAfter swapping ```1,  3, [ 4,  2 ] ```\\n\\n**Step3:** Reverse the right part. Why? \\nAfter getting the next greater ```breakpoint```, All the element at ```right``` part must be sorted as we need a next greater permutation\\nwe can\\'t just leave ```[4, 2]``` like this, because it will be far greater and not next greater.\\nSo we will sort the ```right```, but wait do we even need to sort it? No, bcoz right is already non-increasing, So we just need to reverse it in order to get it sorted.\\n```final = 1, 3, [2, 4]``` \\n\\n*Code*\\n```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        bPoint, n = -1, len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i] >= arr[i+1]: continue                   # Skip the non-increasing sequence\\n            bPoint = i                                        # Got our breakpoint\\n            for j in range(n-1,i,-1):                         # again traverse from end\\n                if arr[j] > arr[bPoint]:                      # Search an element greater the element present at the breakPoint.\\n                    arr[j], arr[bPoint] = arr[bPoint], arr[j] # Swap it\\n                    break                                     # We just need to swap once\\n            break                                             # Break this loop too\\n        arr[bPoint+1:] = reversed(arr[bPoint+1:])             # Reverse the element after the breakpoint\\n```\\n***\\n```Time Complexity:  O(n)```\\n```Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Example: curr = [1, 2, 4, 3]```\n```next = [1, 3, 2, 4]```\n```breakpoint```\n```\\n    |-breakpoint\\n    |\\n1,  2, [ 4,  3 ] - right (non increasing sequence)\\n```\n```right```\n```right```\n```4```\n```3```\n```2```\n```4```\n```3```\n```1,  3, [ 4,  2 ] ```\n```breakpoint```\n```right```\n```[4, 2]```\n```right```\n```final = 1, 3, [2, 4]```\n```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        bPoint, n = -1, len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i] >= arr[i+1]: continue                   # Skip the non-increasing sequence\\n            bPoint = i                                        # Got our breakpoint\\n            for j in range(n-1,i,-1):                         # again traverse from end\\n                if arr[j] > arr[bPoint]:                      # Search an element greater the element present at the breakPoint.\\n                    arr[j], arr[bPoint] = arr[bPoint], arr[j] # Swap it\\n                    break                                     # We just need to swap once\\n            break                                             # Break this loop too\\n        arr[bPoint+1:] = reversed(arr[bPoint+1:])             # Reverse the element after the breakpoint\\n```\n```Time Complexity:  O(n)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 2187200,
                "title": "c-solution-optimized-solution-tc-o-n",
                "content": "**Explanation:**\\n* Linearly traverse array from backward such that ith index value of the array is less than (i+1)th index value. Store that index in a variable.\\n\\n* If the index value received from step 1 is less than 0. This means the given input array is the largest lexicographical permutation. Hence, we will reverse the input array to get the minimum or starting permutation. Linearly traverse array from backward. Find an index that has a value greater than the previously found index. Store index is another variable.\\n* Swap values present in indices found in the above two steps.\\n* Reverse array from index+1 where the index is found at step 1 till the end of the array.\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\\nTC -> `O(n)`\\nSC ->` O(1)`\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044321,
                "title": "c-2-pointer-solution-explained-100-time-90-space",
                "content": "This problem is similar to a few others here on getting the next bigger number with the same digits or the next permutation of a string, etc.\\n\\nThis is just easier since we work directly with a vector, so let\\'s crack on!\\n\\nFirst of all, we will create 2 support variables, our indexes `i` and `j`, respectively set to be pointing to the penultimate element and past the end of the vector.\\n\\nWe will then keep reducing `i` as long as it is non-negative and as long as it points to an element `>=` than the previous one.\\n\\nIf we were to finally end up with `i == -1`, it would mean that the whole vector is set in decreasing order, so no next permutation is possible, and we need to transform the array to the very first one, before leaving the function.\\n\\nNow, you might just opt to sort the vector, but since we know it is already ordered, just reversing it might just save us precious computation: `O(nlogn)` vs. `O(n)` (or, rather `O(n/2)`) is a no brainer.\\n\\nFor any other value of `i`, we will then search with `j` for the very first element that is `<= nums[i]`, which is guaranteed to be there (since all the elements before `i` are in decreasing order).\\n\\nOnce found, we will swap `nums[i]` and `nums[j]`, since `nums[j]` is the next number to go there, and set the rest of the positions from `i + 1` to be in increasing order - I guess here reversing and then using insertion sort would perform better, but I did not feel like going for that overkill just in case.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        // support variables\\n        int i = nums.size() - 2, j = i + 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--;\\n        // edge case: already the highest permutation you can get\\n        if (i == -1) {\\n            reverse(begin(nums), end(nums));\\n            return;\\n        }\\n        // finding the first element > nums[i]\\n        while (nums[--j] <= nums[i]);\\n        // swapping i and j\\'s values\\n        swap(nums[i], nums[j]);\\n        // ordering the rest\\n        sort(begin(nums) + i + 1, end(nums));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        // support variables\\n        int i = nums.size() - 2, j = i + 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--;\\n        // edge case: already the highest permutation you can get\\n        if (i == -1) {\\n            reverse(begin(nums), end(nums));\\n            return;\\n        }\\n        // finding the first element > nums[i]\\n        while (nums[--j] <= nums[i]);\\n        // swapping i and j\\'s values\\n        swap(nums[i], nums[j]);\\n        // ordering the rest\\n        sort(begin(nums) + i + 1, end(nums));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903596,
                "title": "o-n-js-solution-with-explanation",
                "content": "```\\n/*\\nI will consider given array as a number.\\n\\nIf given array is in descending order, there is no greater number.\\nHence, we reverse the array and return.\\n\\n1. We iterate through given array from the back. We look for the first dip because that is where we can swap numbers and make our number greater.\\n2. However, simply swapping adjacent numbers when a dip is found isn\\'t sufficient.\\nex) Given 1 2 6 8 7, next greater number isn\\'t 1 2 8 6 7. It\\'s 1 2 7 6 8. \\n3. We consider the first dip as the pivot. Then, we iterate again from the back. The first number greater than\\npivot will be swapped with the pivot. This logic works because all numbers up to the pivot (the first dip) are in descending order.\\n4. Then, we reverse arr[pivot+1...end] because we want to change these numbers from descending order to ascending order.\\nThis allows us to get the next greater number. The swap doesn\\'t change the descending order of arr[pivot+1...end].\\n*/\\nvar nextPermutation = function(nums) {\\n    let pivot = -1;\\n    for (let i = nums.length-1; i > 0; i--) {\\n        if (nums[i] > nums[i-1]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) { // array is in descending order\\n        nums.reverse();\\n        return;\\n    }\\n    for (let i = nums.length-1; i > pivot; i--) {\\n        if (nums[i] > nums[pivot]) {\\n            swap(nums, i, pivot);\\n            break;\\n        }\\n    }\\n    for (let i = pivot+1, j = nums.length-1; i < j; i++, j--) {\\n        swap(nums, i, j);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction swap(nums, i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nI will consider given array as a number.\\n\\nIf given array is in descending order, there is no greater number.\\nHence, we reverse the array and return.\\n\\n1. We iterate through given array from the back. We look for the first dip because that is where we can swap numbers and make our number greater.\\n2. However, simply swapping adjacent numbers when a dip is found isn\\'t sufficient.\\nex) Given 1 2 6 8 7, next greater number isn\\'t 1 2 8 6 7. It\\'s 1 2 7 6 8. \\n3. We consider the first dip as the pivot. Then, we iterate again from the back. The first number greater than\\npivot will be swapped with the pivot. This logic works because all numbers up to the pivot (the first dip) are in descending order.\\n4. Then, we reverse arr[pivot+1...end] because we want to change these numbers from descending order to ascending order.\\nThis allows us to get the next greater number. The swap doesn\\'t change the descending order of arr[pivot+1...end].\\n*/\\nvar nextPermutation = function(nums) {\\n    let pivot = -1;\\n    for (let i = nums.length-1; i > 0; i--) {\\n        if (nums[i] > nums[i-1]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) { // array is in descending order\\n        nums.reverse();\\n        return;\\n    }\\n    for (let i = nums.length-1; i > pivot; i--) {\\n        if (nums[i] > nums[pivot]) {\\n            swap(nums, i, pivot);\\n            break;\\n        }\\n    }\\n    for (let i = pivot+1, j = nums.length-1; i < j; i++, j--) {\\n        swap(nums, i, j);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction swap(nums, i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13926,
                "title": "simple-o-n-java-solution-with-explanation-improved-using-binary-search",
                "content": "```\\n/*\\n    Idea:\\n    1. Reverse find first number which breaks descending order.\\n    2. Exchange this number with the least number that's greater than this number.\\n    3. Reverse sort the numbers after the exchanged number.\\n*/\\n\\npublic class Solution {\\n    public void nextPermutation(int[] nums) {\\n        /* 1. Reverse find first number which breaks descending order. */\\n        int i=nums.length-1;\\n        for(; i>=1; i--)\\n            if(nums[i-1]<nums[i]) break;\\n        \\n        /* if no break found in step 1 */\\n        if(i==0){\\n            /* for case \"1\" and \"1111\" */\\n            if(nums.length==1 || nums[0]==nums[1]) return; \\n            /* for case \"54321\" */\\n            int lo=i, hi=nums.length-1; \\n            while(lo<hi) swap(nums, lo++, hi--);\\n            return;\\n        }\\n        \\n        /* 2. Exchange this number with the least number that's greater than this number. */\\n        /* 2.1 Find the least number that's greater using binary search, O(log(nums.length-i)) */\\n        int j = binarySearchLeastGreater(nums, i, nums.length-1, nums[i-1]);\\n        \\n        /* 2.2 Exchange the numbers */\\n        if(j!=-1) swap(nums, i-1, j);\\n        \\n        /* 3. Reverse sort the numbers after the exchanged number. */\\n        int lo=i, hi=nums.length-1;\\n        while(lo<hi) swap(nums, lo++, hi--);\\n    }\\n    \\n    public int binarySearchLeastGreater(int[] nums, int lo, int hi, int key){\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid]>key){\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return hi;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Idea:\\n    1. Reverse find first number which breaks descending order.\\n    2. Exchange this number with the least number that's greater than this number.\\n    3. Reverse sort the numbers after the exchanged number.\\n*/\\n\\npublic class Solution {\\n    public void nextPermutation(int[] nums) {\\n        /* 1. Reverse find first number which breaks descending order. */\\n        int i=nums.length-1;\\n        for(; i>=1; i--)\\n            if(nums[i-1]<nums[i]) break;\\n        \\n        /* if no break found in step 1 */\\n        if(i==0){\\n            /* for case \"1\" and \"1111\" */\\n            if(nums.length==1 || nums[0]==nums[1]) return; \\n            /* for case \"54321\" */\\n            int lo=i, hi=nums.length-1; \\n            while(lo<hi) swap(nums, lo++, hi--);\\n            return;\\n        }\\n        \\n        /* 2. Exchange this number with the least number that's greater than this number. */\\n        /* 2.1 Find the least number that's greater using binary search, O(log(nums.length-i)) */\\n        int j = binarySearchLeastGreater(nums, i, nums.length-1, nums[i-1]);\\n        \\n        /* 2.2 Exchange the numbers */\\n        if(j!=-1) swap(nums, i-1, j);\\n        \\n        /* 3. Reverse sort the numbers after the exchanged number. */\\n        int lo=i, hi=nums.length-1;\\n        while(lo<hi) swap(nums, lo++, hi--);\\n    }\\n    \\n    public int binarySearchLeastGreater(int[] nums, int lo, int hi, int key){\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid]>key){\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return hi;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362645,
                "title": "amazon-sde-1-interview-o-n-approach",
                "content": "# **\\u2714 Approach-1 (Brute Force Approach ) O(N! N)**\\n*  **Find all the permutations of the given array/string/vector and then loop to find out the given permutation.**\\n* **Further, print its next permutation. If the given permutation is the last one, then print the first permutation.**\\n# **\\u2714 Approach-2  TC:O(N) SC:O(1)**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int k,j;\\n        for(k=nums.size()-2 ; k>=0 ; k--){               //O(n)          \\n            if(nums[k]<nums[k+1])                   \\n                break;\\n        }\\n//No Breakpoint i.e array is in desc. order already, so we print the\\n//1st permutation by reversing it which results in asc. order.\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());  \\n        }\\n        else{\\n            for(j=nums.size()-1 ; j>k ; j--){           //O(n)\\n                if(nums[j]>nums[k])\\n                    break;\\n            }\\n            swap(nums[k],nums[j]);                      //O(1)\\n            reverse(nums.begin()+k+1,nums.end());       //O(n)\\n        }\\n    }\\n};\\n// Total TC:O(3n)~O(n)  SC:O(1)\\n```\\n* Generally the permutations are in such a way that if we start from end, all the elements will be in sorted order till a specific break point. We need to find that break point element.\\n* Loop through the array starting from end till begin and find out such an element such that ele[i]<ele[i+1], where ele[i] is the break point element.\\n* Now, again loop through the end till i such that ele[j]>ele[i]. So basically we find first element from the end which is greater than ele[i].\\n* Now swap ele[i] and ele[j].\\n* Reverse all the elments after i to get the desired next permutation.\\n\\nThis video helped me. Thanks to @TUF and @Striver\\n[https://www.youtube.com/watch?v=LuLCLgMElus&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=9](http://)\\n\\n# **Please Upvote if it helps !  \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int k,j;\\n        for(k=nums.size()-2 ; k>=0 ; k--){               //O(n)          \\n            if(nums[k]<nums[k+1])                   \\n                break;\\n        }\\n//No Breakpoint i.e array is in desc. order already, so we print the\\n//1st permutation by reversing it which results in asc. order.\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());  \\n        }\\n        else{\\n            for(j=nums.size()-1 ; j>k ; j--){           //O(n)\\n                if(nums[j]>nums[k])\\n                    break;\\n            }\\n            swap(nums[k],nums[j]);                      //O(1)\\n            reverse(nums.begin()+k+1,nums.end());       //O(n)\\n        }\\n    }\\n};\\n// Total TC:O(3n)~O(n)  SC:O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376412,
                "title": "narayana-o-n",
                "content": "The algorithm is designed to generate the next permutation, but it can be made cyclic, thereby generating all permutations.\\n\\n# Algorithm\\n1. Find the maximum index $i$ for which $A_i < A_{i+1}$. *(It is optimal to search from the end of the permutation)*\\n2. Find the maximum index $j$ for which $A_j > A_i$. *(It is optimal to search from the end of the permutation)*\\n3. Swap $A_i$ and $A_j$.\\n4. Write the sequence $A_{i+1},...,A_n$ in reverse order.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int i = a.length - 2, j = a.length - 1;\\n\\n        while (i >= 0) {\\n            if (a[i] < a[i+1]) {\\n                break;\\n            } else {\\n                --i;\\n            }\\n        }\\n\\n        if (i == -1) {\\n            for(i = 0; i < a.length / 2; ++i) {\\n                int temp = a[i];\\n                a[i] = a[a.length - i - 1];\\n                a[a.length - i - 1] = temp;\\n            }\\n        } else {\\n            \\n            while (j >= 0) {\\n                if (a[j] > a[i]) {\\n                    break;\\n                } else {\\n                    --j;\\n                }\\n            }\\n\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n\\n            int shift = i + 1;\\n\\n            for(int k = 0; k < (a.length - shift) / 2; ++k) {\\n                temp = a[shift + k];\\n                a[shift + k] = a[a.length - k - 1];\\n                a[a.length - k - 1] = temp;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int i = a.length - 2, j = a.length - 1;\\n\\n        while (i >= 0) {\\n            if (a[i] < a[i+1]) {\\n                break;\\n            } else {\\n                --i;\\n            }\\n        }\\n\\n        if (i == -1) {\\n            for(i = 0; i < a.length / 2; ++i) {\\n                int temp = a[i];\\n                a[i] = a[a.length - i - 1];\\n                a[a.length - i - 1] = temp;\\n            }\\n        } else {\\n            \\n            while (j >= 0) {\\n                if (a[j] > a[i]) {\\n                    break;\\n                } else {\\n                    --j;\\n                }\\n            }\\n\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n\\n            int shift = i + 1;\\n\\n            for(int k = 0; k < (a.length - shift) / 2; ++k) {\\n                temp = a[shift + k];\\n                a[shift + k] = a[a.length - k - 1];\\n                a[a.length - k - 1] = temp;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902499,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        let n = nums.count\\n        var i = n - 2\\n        while i >= 0, nums[i + 1] <= nums[i] { i -= 1 }\\n        \\n        guard i >= 0 else {\\n            reverse(&nums, start: i + 1, end: n - 1)\\n            return\\n        }\\n        \\n        var j = n - 1\\n        while j >= 0, nums[j] <= nums[i] { j -= 1 }\\n        nums.swapAt(i, j)\\n        reverse(&nums, start: i + 1, end: n - 1)\\n    }\\n    \\n\\n    private func reverse(_ nums: inout [Int], start: Int, end: Int) {\\n        var i = start\\n        var j = end\\n        while i < j {\\n            nums.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        let n = nums.count\\n        var i = n - 2\\n        while i >= 0, nums[i + 1] <= nums[i] { i -= 1 }\\n        \\n        guard i >= 0 else {\\n            reverse(&nums, start: i + 1, end: n - 1)\\n            return\\n        }\\n        \\n        var j = n - 1\\n        while j >= 0, nums[j] <= nums[i] { j -= 1 }\\n        nums.swapAt(i, j)\\n        reverse(&nums, start: i + 1, end: n - 1)\\n    }\\n    \\n\\n    private func reverse(_ nums: inout [Int], start: Int, end: Int) {\\n        var i = start\\n        var j = end\\n        while i < j {\\n            nums.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448059,
                "title": "c-solution-with-explanation-easy-for-beginners",
                "content": "### Approach: (Without 1 liner XD)\\n\\nLet us start by taking an example of test case = [1 , 2 , 4 , 3]\\n\\nLexicographically next permutation would be [1 , 3 , 2 , 4]. \\n\\nHere, we have done 2 things:\\n- Swapped 2 with 3.\\n- Sorted the array after the swapped index.\\n\\nSo precisely, the generalised approach, which comes here in mind is:\\n\\n- Find the index from where we have to swap its value with its next greater value. For this, start from last, just find the index where number is greater than its next index. Say this index as small. \\n- Find the index of number, just greater than the number at the small.\\n- Swap the both values. And sort the array after the swapped index.\\n\\nEdge case: If array is in descending order, then we have to just sort it to ascending.\\n\\nMy submission:\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& number) {\\n        int i = 0;\\n        for(i = number.size() - 1 ; i > 0; i--){        //Finding the index needed to be swapped.\\n            if(number[i] > number[i - 1]){\\n                break;\\n            }\\n        }\\n        if(i == 0){     \\n            reverse(number.begin() , number.end());     // Permutation is in descending order. Sort it to ascending order.\\n        } else {\\n            int x = number[i - 1], small = i;           \\n            for(int j = i + 1; j < number.size(); j++){     //Finding the number just greater than at index needed to be swapped.\\n                if(number[j] > x && number[j] <= number[small]){\\n                    small = j;\\n                }\\n            }\\n            \\n            swap(number[i - 1] , number[small]);        //Swapping the numbers.\\n        \\n            sort(number.begin() + i, number.end());     // Sorting the array after the swapped index.\\n        }\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF YOU LIKED IT, IT REALLY MOTIVATES :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& number) {\\n        int i = 0;\\n        for(i = number.size() - 1 ; i > 0; i--){        //Finding the index needed to be swapped.\\n            if(number[i] > number[i - 1]){\\n                break;\\n            }\\n        }\\n        if(i == 0){     \\n            reverse(number.begin() , number.end());     // Permutation is in descending order. Sort it to ascending order.\\n        } else {\\n            int x = number[i - 1], small = i;           \\n            for(int j = i + 1; j < number.size(); j++){     //Finding the number just greater than at index needed to be swapped.\\n                if(number[j] > x && number[j] <= number[small]){\\n                    small = j;\\n                }\\n            }\\n            \\n            swap(number[i - 1] , number[small]);        //Swapping the numbers.\\n        \\n            sort(number.begin() + i, number.end());     // Sorting the array after the swapped index.\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510520,
                "title": "next-permutation-100-faster-java-solution",
                "content": "**Time  Complexity : `O(n) + O(n) + O(n) \\u2245 O(n)`\\nSpace Complexity : `O(1)`**\\n\\n**O(n)** is for First traversal to find break point, \\n**O(n**) is for Second traversal to swap,\\n**O(n**) is for to reverse\\n\\n*Next Permutation*\\n![image](https://assets.leetcode.com/users/images/e12165af-45ea-4ce4-ac8f-4516144d77e4_1633695069.3101196.gif)\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null || nums.length <= 1)\\n            return;\\n        \\n        int i = nums.length - 2;\\n        while(i>=0 && nums[i] >= nums[i+1])\\n            i--;\\n        \\n        if(i>=0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i])\\n                j--;\\n            \\n          swap(nums, i, j);  \\n        }\\n        \\n        reverse(nums, i+1, nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i, int j){\\n        while(i<j)\\n            swap(nums, i++, j--);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null || nums.length <= 1)\\n            return;\\n        \\n        int i = nums.length - 2;\\n        while(i>=0 && nums[i] >= nums[i+1])\\n            i--;\\n        \\n        if(i>=0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i])\\n                j--;\\n            \\n          swap(nums, i, j);  \\n        }\\n        \\n        reverse(nums, i+1, nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i, int j){\\n        while(i<j)\\n            swap(nums, i++, j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043674,
                "title": "c-simple-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n        \\n        int i = n-1, j = n-1;\\n        \\n        // Find the largest index i such that nums[i] < nums[i + 1]:\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        \\n        // If no such index exists - reverse the array and were done:\\n        if (i == 0) {\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // Find the largest index j > i such that nums[i] < nums[j]:\\n        i--;\\n        while (j > i && nums[j] <= nums[i]) j--;\\n        \\n        // Swap nums[i] and nums[j]:\\n        swap(nums[i], nums[j]);\\n        \\n        // Reverse the array from index i until the end:\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n        \\n        int i = n-1, j = n-1;\\n        \\n        // Find the largest index i such that nums[i] < nums[i + 1]:\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        \\n        // If no such index exists - reverse the array and were done:\\n        if (i == 0) {\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // Find the largest index j > i such that nums[i] < nums[j]:\\n        i--;\\n        while (j > i && nums[j] <= nums[i]) j--;\\n        \\n        // Swap nums[i] and nums[j]:\\n        swap(nums[i], nums[j]);\\n        \\n        // Reverse the array from index i until the end:\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910716,
                "title": "python-40-ms-and-beat-100-swap-method",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        i = len(nums)-1\\n        while i>0:\\n            if nums[i-1]<nums[i]:\\n                break\\n            i = i-1\\n        i = i-1\\n        j = len(nums)-1\\n        while j>i:\\n            if nums[j]>nums[i]:\\n                break\\n            j=j-1\\n        nums[i],nums[j]=nums[j],nums[i]  \\n        nums[i+1:]=sorted(nums[i+1:]) \\n# Thanks\\n```\\nSimilar method(Problem 1053):-https://leetcode.com/problems/previous-permutation-with-one-swap/discuss/959167/Swap-Method-Python",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        i = len(nums)-1\\n        while i>0:\\n            if nums[i-1]<nums[i]:\\n                break\\n            i = i-1\\n        i = i-1\\n        j = len(nums)-1\\n        while j>i:\\n            if nums[j]>nums[i]:\\n                break\\n            j=j-1\\n        nums[i],nums[j]=nums[j],nums[i]  \\n        nums[i+1:]=sorted(nums[i+1:]) \\n# Thanks\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466198,
                "title": "easy-to-understand-java-solution-1ms-please-upvote",
                "content": "# Intuition\\nIn dictionary consider the names `sam`, `sai` and `sui`. `sai` would be exactly next to sam because it has **`longest prefix match -sa`**. Similarly `sui` will be after `sam` but exactly not after `sam` because it has **`smaller prefix match - s`**. So the permutation with longest prefix match has higher chances of being the next one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Find the breaking index :** \\n      - Breaking index occurs when a dip point is observered in the\\n        pattern of the nums.\\n        \\n        ![next permutation1.jpg](https://assets.leetcode.com/users/images/2c0a6174-3062-4837-be9d-6e1454b59591_1682771631.79299.jpeg)\\n      - `Base codition` occurs when there is no breaking point, this indicates the given nums array is the last permutation. Hence, `reverse` the nums array which gives us our next permutation.\\n      \\n        ![next permutation2.jpg](https://assets.leetcode.com/users/images/15cdbcdd-5553-455c-8a9c-a1cd41272202_1682771975.8683147.jpeg)\\n\\n1. **Finding num just greater than breaking idx :**\\n    - Traverse the nums array `n-1 to idx`, if `nums[i] > nums[idx]->swap`and exit the loop.\\n      \\n    ![next permutation3.jpg](https://assets.leetcode.com/users/images/0be1c019-bd65-4bb9-9be2-cd98f6fda16b_1682772625.132264.jpeg)\\n\\n1. **Reverse the remaining nums array :**\\n    - Reversing is needed because we need the just next Permutation.\\n    \\n    ![next permutation4.jpg](https://assets.leetcode.com/users/images/f20a7a5d-5af7-44c2-9095-f303b961b718_1682772824.645866.jpeg)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length;\\n        // store the breaking point\\n        int idx = -1;\\n\\n        for(int i = n-2 ; i>=0 ; i--) {\\n            if(nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        // base case - no breakpoint found\\n        if(idx == -1) {\\n            Arrays.sort(nums, 0, n);\\n            return;\\n        }\\n\\n\\n        // finding the greater but closest num\\n        for(int i=n-1 ; i>idx ; i--) {\\n            if(nums[i] > nums[idx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[idx];\\n                nums[idx] = temp;\\n                break;\\n            }\\n        }\\n        // Reversing the remaining array.\\n        Arrays.sort(nums, idx+1, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length;\\n        // store the breaking point\\n        int idx = -1;\\n\\n        for(int i = n-2 ; i>=0 ; i--) {\\n            if(nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        // base case - no breakpoint found\\n        if(idx == -1) {\\n            Arrays.sort(nums, 0, n);\\n            return;\\n        }\\n\\n\\n        // finding the greater but closest num\\n        for(int i=n-1 ; i>idx ; i--) {\\n            if(nums[i] > nums[idx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[idx];\\n                nums[idx] = temp;\\n                break;\\n            }\\n        }\\n        // Reversing the remaining array.\\n        Arrays.sort(nums, idx+1, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416614,
                "title": "c-java-python-javascript-fully-explained-easy-to-understand",
                "content": "# Intuition:\\nThe problem requires finding the next permutation in lexicographic order of the given array. If the given permutation is the largest possible permutation, then the function should return the smallest possible permutation by rearranging the array in ascending order.\\n\\n# Approach:\\nThe algorithm finds the first pair of adjacent elements in the array that satisfy nums[k] < nums[k+1] from the right end of the array. If such a pair does not exist, then the entire array is sorted in descending order, and we need to reverse the entire array to obtain the smallest possible permutation.\\n\\nOtherwise, the algorithm finds the smallest element nums[l] to the right of nums[k] such that nums[l] > nums[k]. We swap nums[k] and nums[l], and then reverse the subarray starting at nums[k+1] to obtain the next lexicographic permutation of the array.\\n\\n# Complexity:\\n- Time complexity: The algorithm performs two passes over the array. The first pass has time complexity O(n), while the second pass also has time complexity O(n). Therefore, the overall time complexity of the algorithm is O(n).\\n\\n- Space complexity: The algorithm uses constant extra space, hence the space complexity of the algorithm is O(1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} \\n        else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n# JAVA\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length, k = n - 2, l = n - 1;\\n        while (k >= 0 && nums[k] >= nums[k + 1]) {\\n            k--;\\n        }\\n        if (k < 0) {\\n            reverse(nums, 0, n - 1);\\n        } else {\\n            while (l > k && nums[l] <= nums[k]) {\\n                l--;\\n            }\\n            swap(nums, k, l);\\n            reverse(nums, k + 1, n - 1);\\n        }\\n    }\\n    \\n    private void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i++, j--);\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        n = len(nums)\\n        k, l = n - 2, n - 1\\n        while k >= 0 and nums[k] >= nums[k + 1]:\\n            k -= 1\\n        if k < 0:\\n            nums.reverse()\\n        else:\\n            while l > k and nums[l] <= nums[k]:\\n                l -= 1\\n            nums[k], nums[l] = nums[l], nums[k]\\n            nums[k + 1:n] = reversed(nums[k + 1:n])\\n\\n```\\n---\\n\\n# JavaScript \\n```\\nvar nextPermutation = function(nums) {\\n    let n = nums.length;\\n    let k, l;\\n    for (k = n - 2; k >= 0; k--) {\\n        if (nums[k] < nums[k + 1]) {\\n            break;\\n        }\\n    }\\n    if (k < 0) {\\n        nums.reverse();\\n    } else {\\n        for (l = n - 1; l > k; l--) {\\n            if (nums[l] > nums[k]) {\\n                break;\\n            }\\n        }\\n        [nums[k], nums[l]] = [nums[l], nums[k]];\\n        nums.splice(k + 1, n - k - 1, ...nums.slice(k + 1).reverse());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} \\n        else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length, k = n - 2, l = n - 1;\\n        while (k >= 0 && nums[k] >= nums[k + 1]) {\\n            k--;\\n        }\\n        if (k < 0) {\\n            reverse(nums, 0, n - 1);\\n        } else {\\n            while (l > k && nums[l] <= nums[k]) {\\n                l--;\\n            }\\n            swap(nums, k, l);\\n            reverse(nums, k + 1, n - 1);\\n        }\\n    }\\n    \\n    private void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i++, j--);\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        n = len(nums)\\n        k, l = n - 2, n - 1\\n        while k >= 0 and nums[k] >= nums[k + 1]:\\n            k -= 1\\n        if k < 0:\\n            nums.reverse()\\n        else:\\n            while l > k and nums[l] <= nums[k]:\\n                l -= 1\\n            nums[k], nums[l] = nums[l], nums[k]\\n            nums[k + 1:n] = reversed(nums[k + 1:n])\\n\\n```\n```\\nvar nextPermutation = function(nums) {\\n    let n = nums.length;\\n    let k, l;\\n    for (k = n - 2; k >= 0; k--) {\\n        if (nums[k] < nums[k + 1]) {\\n            break;\\n        }\\n    }\\n    if (k < 0) {\\n        nums.reverse();\\n    } else {\\n        for (l = n - 1; l > k; l--) {\\n            if (nums[l] > nums[k]) {\\n                break;\\n            }\\n        }\\n        [nums[k], nums[l]] = [nums[l], nums[k]];\\n        nums.splice(k + 1, n - k - 1, ...nums.slice(k + 1).reverse());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163376,
                "title": "python-c-easy-to-understand-no-recursion",
                "content": "# Approach\\n- From the right end of our list, we first discover the first decreasing element here.\\nThe next part is only a little bit bigger than the one we discovered from the right end.\\n- Next, switch the elements.\\n- And the reverse end of it.\\n\\nPlease do check it out because it is easier to understand after seeing the code.\\nIf you find it understandable, please give Heartly an upvote.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code :\\n### Python\\n```\\nclass Solution:\\n    def nextPermutation(self, s: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # s = list(s)\\n        i = len(s) - 2\\n        while i >= 0 and s[i + 1] <= s[i]:\\n            i -= 1\\n\\n        if i >= 0:\\n            j = len(s) - 1\\n            while s[j] <= s[i]:\\n                j -= 1\\n            (s[i], s[j]) = (s[j], s[i])\\n\\n        s[::] = s[:i + 1] + s[i + 1:][::-1]\\n```\\n### C++\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i+1]<=nums[i]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int j=nums.size()-1;\\n            while(nums[j]<=nums[i]){\\n                j--;\\n            }\\n            swap(nums , i ,j);\\n        }\\n        reverse(nums.begin()+i+1,nums.end());\\n    }\\n    void swap(vector<int> &nums , int i,int j){\\n        nums[i]^=nums[j];\\n        nums[j]^=nums[i];\\n        nums[i]^=nums[j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, s: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # s = list(s)\\n        i = len(s) - 2\\n        while i >= 0 and s[i + 1] <= s[i]:\\n            i -= 1\\n\\n        if i >= 0:\\n            j = len(s) - 1\\n            while s[j] <= s[i]:\\n                j -= 1\\n            (s[i], s[j]) = (s[j], s[i])\\n\\n        s[::] = s[:i + 1] + s[i + 1:][::-1]\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i+1]<=nums[i]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int j=nums.size()-1;\\n            while(nums[j]<=nums[i]){\\n                j--;\\n            }\\n            swap(nums , i ,j);\\n        }\\n        reverse(nums.begin()+i+1,nums.end());\\n    }\\n    void swap(vector<int> &nums , int i,int j){\\n        nums[i]^=nums[j];\\n        nums[j]^=nums[i];\\n        nums[i]^=nums[j];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804608,
                "title": "python-simple-solution-explained-code-video",
                "content": "https://www.youtube.com/watch?v=4wlBBRo4tYY\\n[](https://www.youtube.com/watch?v=4wlBBRo4tYY)\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        if length <= 2:\\n            return nums.reverse()\\n        pointer = length - 2\\n        \\n        while pointer >= 0 and nums[pointer] >= nums[pointer + 1]:\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            return nums.reverse()\\n        \\n        for x in range(length - 1, pointer, -1):\\n            if nums[pointer] < nums[x]:\\n                nums[pointer], nums[x] = nums[x], nums[pointer]\\n                break\\n        \\n        nums[pointer + 1:] = reversed(nums[pointer + 1:])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        if length <= 2:\\n            return nums.reverse()\\n        pointer = length - 2\\n        \\n        while pointer >= 0 and nums[pointer] >= nums[pointer + 1]:\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            return nums.reverse()\\n        \\n        for x in range(length - 1, pointer, -1):\\n            if nums[pointer] < nums[x]:\\n                nums[pointer], nums[x] = nums[x], nums[pointer]\\n                break\\n        \\n        nums[pointer + 1:] = reversed(nums[pointer + 1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213704,
                "title": "rust",
                "content": "```\\nfn next_permutation(nums: &mut [i32]) {\\n    if let Some(i) = (1..nums.len()).rev().find(|&i| nums[i - 1] < nums[i]) {\\n        let j = (i..nums.len()).rev().find(|&j| nums[i - 1] < nums[j]).unwrap();\\n        nums.swap(i - 1, j);\\n        nums[i..].reverse();\\n    } else {\\n        nums.reverse();\\n    };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn next_permutation(nums: &mut [i32]) {\\n    if let Some(i) = (1..nums.len()).rev().find(|&i| nums[i - 1] < nums[i]) {\\n        let j = (i..nums.len()).rev().find(|&j| nums[i - 1] < nums[j]).unwrap();\\n        nums.swap(i - 1, j);\\n        nums[i..].reverse();\\n    } else {\\n        nums.reverse();\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228834,
                "title": "one-liner",
                "content": "// C++\\n\\t\\n\\t\\n\\tvoid nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "// C++\\n\\t\\n\\t\\n\\tvoid nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1908665,
                "title": "python-easy-nlogn-solution",
                "content": "Steps I followed:\\n\\t1. Find the **latest peak** in the array *(A peak is an element that is greater that the previous element in the array)*\\n\\t\\t\\t2. If a peak is not found: it means it is in reverse order we just need to revert the array\\n\\t3. If a peak is found: it means we can rearrange the array and build a next permutation\\n\\t\\t4. Iterate from the **latest peak** to the end of the array and find the min value in that subarray that is **greater** than the previous of the latest peak! This because we want to build the next greater permutation\\n\\t\\t5. Swap the min value after the peak and the element previous the peak\\n\\t\\t6. Sort the array from the latest_peak to the end of the array\\n\\nTime complexity = O(nlogn)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        latest_peak = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                latest_peak = i\\n                \\n        if latest_peak == 0:\\n            nums.reverse()\\n            return\\n        \\n        pre_peak = latest_peak - 1\\n        min_after_peak = latest_peak\\n        for i in range(latest_peak, len(nums)):\\n            if nums[i] > nums[pre_peak] and nums[i] < nums[min_after_peak]:\\n                min_after_peak = i\\n          \\n        temp = nums[pre_peak]\\n        nums[pre_peak] = nums[min_after_peak]\\n        nums[min_after_peak] = temp\\n        \\n        nums[latest_peak:] = sorted(nums[latest_peak:])\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Steps I followed:\\n\\t1. Find the **latest peak** in the array *(A peak is an element that is greater that the previous element in the array)*\\n\\t\\t\\t2. If a peak is not found: it means it is in reverse order we just need to revert the array\\n\\t3. If a peak is found: it means we can rearrange the array and build a next permutation\\n\\t\\t4. Iterate from the **latest peak** to the end of the array and find the min value in that subarray that is **greater** than the previous of the latest peak! This because we want to build the next greater permutation\\n\\t\\t5. Swap the min value after the peak and the element previous the peak\\n\\t\\t6. Sort the array from the latest_peak to the end of the array\\n\\nTime complexity = O(nlogn)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        latest_peak = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                latest_peak = i\\n                \\n        if latest_peak == 0:\\n            nums.reverse()\\n            return\\n        \\n        pre_peak = latest_peak - 1\\n        min_after_peak = latest_peak\\n        for i in range(latest_peak, len(nums)):\\n            if nums[i] > nums[pre_peak] and nums[i] < nums[min_after_peak]:\\n                min_after_peak = i\\n          \\n        temp = nums[pre_peak]\\n        nums[pre_peak] = nums[min_after_peak]\\n        nums[min_after_peak] = temp\\n        \\n        nums[latest_peak:] = sorted(nums[latest_peak:])\\n",
                "codeTag": "Java"
            },
            {
                "id": 1687454,
                "title": "easy-to-understand-with-comments-c-o-n",
                "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        /*Step and intituitions to be followed:\\n        \\n        Step 1: Find a break point from last where a single element is not in incresing order \\n            i.e, ar[i] < ar[i+1] and keep that index such as ind1\\n        \\n        Step 2: Find again from last that which element is just greater than ind1 \\n            as to follow the dictionary order to place bigger element than ind1 and name ind2\\n            \\n        Step 3: Swap ar[ind1] and ar[ind2]\\n            \\n        Step 4: Reverse from the next elemnt of ind1 i.e, ind1 + 1 to last of the array\\n            \\n        Edge Case: If the array is already increasing order from the last then just reverse it. */\\n        \\n        int n = nums.size();\\n        int k; //to find break point\\n        int l; // to traverse from last and find the greater element han break point\\n        \\n        for(k=n-2; k>=0; k--) //step 1\\n        {\\n            if(nums[k] < nums[k+1])\\n                break;\\n        }\\n        \\n        if(k < 0) //edge case\\n            reverse(nums.begin(), nums.end());\\n        else\\n        {\\n            for(l=n-1; l>k; l--) //step 2\\n            {\\n                if(nums[l] > nums[k])\\n                    break;\\n            }\\n            \\n            swap(nums[k], nums[l]); //step 3\\n        \\n            reverse(nums.begin() + k + 1, nums.end()); //step 4\\n        }              \\n\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        /*Step and intituitions to be followed:\\n        \\n        Step 1: Find a break point from last where a single element is not in incresing order \\n            i.e, ar[i] < ar[i+1] and keep that index such as ind1\\n        \\n        Step 2: Find again from last that which element is just greater than ind1 \\n            as to follow the dictionary order to place bigger element than ind1 and name ind2\\n            \\n        Step 3: Swap ar[ind1] and ar[ind2]\\n            \\n        Step 4: Reverse from the next elemnt of ind1 i.e, ind1 + 1 to last of the array\\n            \\n        Edge Case: If the array is already increasing order from the last then just reverse it. */\\n        \\n        int n = nums.size();\\n        int k; //to find break point\\n        int l; // to traverse from last and find the greater element han break point\\n        \\n        for(k=n-2; k>=0; k--) //step 1\\n        {\\n            if(nums[k] < nums[k+1])\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 557285,
                "title": "what-does-this-problem-mean",
                "content": "I\\'m having trouble understanding what this problem is asking. \\n\\nDoes\\n```\\n[1,2,3] -> [1,3,2]\\n```\\nbecause 3 comes after 2 lexographically?\\n\\nI put in my own example\\n```\\n[2,3,1] -> [3,1,2]\\n```\\n\\nWhy is [3,1,2] the output? a valid permutation is `[2,1,3]` but because this is not lexographically greater than `[2,3,1]` is that why `[3,1,2]` is the answer? Why isn\\'t `[3,2,1]` the lexographically next greater permutation?\\n\\n",
                "solutionTags": [],
                "code": "```\\n[1,2,3] -> [1,3,2]\\n```\n```\\n[2,3,1] -> [3,1,2]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162049,
                "title": "explanations-java-python",
                "content": "**Thought**\\n* How do we catch the next bigger given current sequence?\\nWe \\u201Cincrease\\u201D the current sequence as little as possible. \\n* Which element should we modify?\\n**The element to the left of the longest suffix that is non-increasing** (becase this suffix is already the biggest so we cannot make a bigger permutation just by modifying it). We call it the `fisrtInc`. \\n* Since `fisrtInc` can only be modified by swapping with another element, which element should it be swapped with? \\n**The smallest element in the suffix that is greater than the fisrtInc** (then the prefix is minimized).\\n* Since we increased the prefix, we want to make the new suffix as low as possible. How ?\\n**We sort the suffix in non-decreasing order**. In fact, we can avoid sorting and simply reverse the suffix, because the replaced element respects the decreasing order.\\n\\n**Java**\\n```\\n    public void nextPermutation(int[] nums) {\\n        \\n        int n = nums.length;\\n        int firstInc = n - 2; // The first index which is smaller than its next element.\\n        \\n        while (firstInc >= 0 && nums[firstInc] >= nums[firstInc + 1]) {\\n            firstInc--;\\n        }\\n        \\n        if (firstInc != -1) { // firstInc == -1 if nums is decreasing.\\n            for (int i = n - 1; i > firstInc; i--)\\n                if (nums[i] > nums[firstInc]) {\\n                    swap(nums, firstInc, i);  \\n                    break;\\n                }\\n        }\\n\\n        reverse(nums, firstInc + 1, n - 1);           \\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"      \\n        first_inc = len(nums) - 2\\n        \\n        while first_inc >= 0 and nums[first_inc] >= nums[first_inc + 1]:\\n            first_inc -= 1\\n    \\n        if first_inc != -1:  # nums is not non-increasing as a whole\\n            for i in range(len(nums) - 1, first_inc, -1):\\n                if nums[i] > nums[first_inc]:\\n                    nums[first_inc], nums[i] = nums[i], nums[first_inc]\\n                    break\\n    \\n        nums[first_inc + 1: len(nums)] = nums[first_inc + 1: len(nums)][::-1]\\n```\\n\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\n    public void nextPermutation(int[] nums) {\\n        \\n        int n = nums.length;\\n        int firstInc = n - 2; // The first index which is smaller than its next element.\\n        \\n        while (firstInc >= 0 && nums[firstInc] >= nums[firstInc + 1]) {\\n            firstInc--;\\n        }\\n        \\n        if (firstInc != -1) { // firstInc == -1 if nums is decreasing.\\n            for (int i = n - 1; i > firstInc; i--)\\n                if (nums[i] > nums[firstInc]) {\\n                    swap(nums, firstInc, i);  \\n                    break;\\n                }\\n        }\\n\\n        reverse(nums, firstInc + 1, n - 1);           \\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"      \\n        first_inc = len(nums) - 2\\n        \\n        while first_inc >= 0 and nums[first_inc] >= nums[first_inc + 1]:\\n            first_inc -= 1\\n    \\n        if first_inc != -1:  # nums is not non-increasing as a whole\\n            for i in range(len(nums) - 1, first_inc, -1):\\n                if nums[i] > nums[first_inc]:\\n                    nums[first_inc], nums[i] = nums[i], nums[first_inc]\\n                    break\\n    \\n        nums[first_inc + 1: len(nums)] = nums[first_inc + 1: len(nums)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14013,
                "title": "my-12ms-c-solution-only-15lines",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int index = 0,swapindex = 0;\\n            for (int i = 1; i < nums.size(); i++)\\n                if  (nums[i - 1] < nums[i])\\n                    index = i;\\n            if (index > 0){\\n                int i = nums.size() - 1;\\n                while (i > (index - 1) && nums[index-1] >= nums[i]) i--;\\n                swap(nums[index - 1],nums[i]);\\n            }\\n            sort(nums.begin() + index,nums.end());\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int index = 0,swapindex = 0;\\n            for (int i = 1; i < nums.size(); i++)\\n                if  (nums[i - 1] < nums[i])\\n                    index = i;\\n            if (index > 0){\\n                int i = nums.size() - 1;\\n                while (i > (index - 1) && nums[index-1] >= nums[i]) i--;\\n                swap(nums[index - 1],nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 14030,
                "title": "simple-java-solution-for-your-reference",
                "content": "    public void nextPermutation(int[] num) {\\n        for(int i = num.length-1; i > 0; i--) {\\n            if(num[i-1] < num[i]) {\\n                Arrays.sort(num, i, num.length);\\n                for(int j = i; j < num.length; j++) {\\n                    if(num[j] > num[i-1]) {\\n                       // swap num[i-1] and num[j]\\n                        num[i-1] = num[i-1] + num[j];\\n                        num[j] = num[i-1] - num[j];\\n                        num[i-1] = num[i-1] - num[j];\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        Arrays.sort(num);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void nextPermutation(int[] num) {\\n        for(int i = num.length-1; i > 0; i--) {\\n            if(num[i-1] < num[i]) {\\n                Arrays.sort(num, i, num.length);\\n                for(int j = i; j < num.length; j++) {\\n                    if(num[j] > num[i-1]) {\\n                       // swap num[i-1] and num[j]\\n                        num[i-1] = num[i-1] + num[j];\\n                        num[j] = num[i-1] - num[j];\\n                        num[i-1] = num[i-1] - num[j];\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        Arrays.sort(num);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14111,
                "title": "share-my-python-code-and-explain-how-to-get-the-solution",
                "content": "It's not easy to find a rule for this question. \\n\\nAnd I think the example is not good.\\n\\nExamples here:\\n\\n1243\\n=> 12 43 (2 is the first num who is less than the next), and the num split to two parts, left: [1,2], right: [4,3]\\n\\n=> 13 42 (swap 2 with 3, because 3 is the first num greater than 2).\\n\\n=> 13 24 sort right. 13, 42 sorted to 24.\\n\\n=> 1324 merge left, right.\\n\\nAnother more complex example:\\n1342\\n=>13 42 split to left: 13  right: 42 (3 is the first num less than next);\\n\\n=>14 32 swap 3 and 4, because in the right part, 4 is the first num greater than 3, from right ->left scan.\\n\\n=>14 23 sort right part,  (**That's why we need to sort the right part**).\\n\\n=>1423 merge them \\n\\n\\n    class Solution:\\n    # @param num, a list of integer\\n    # @return a list of integer\\n    def nextPermutation(self, num):\\n        if(len(num)<=1):return num;\\n        else:\\n            splitIdx=-1;\\n            for i in range(len(num)-2,-1,-1):\\n                if(num[i]<num[i+1]):\\n                    splitIdx=i;\\n                    break;\\n            replaceIdx=len(num)-1;\\n            while(replaceIdx > splitIdx):\\n                if(num[replaceIdx]>num[splitIdx]):\\n                    break;\\n                replaceIdx-=1;\\n\\n            num[replaceIdx],num[splitIdx]=num[splitIdx],num[replaceIdx];\\n            \\n            right=num[splitIdx+1:];\\n            right=sorted(right);            \\n            return num[0:splitIdx+1]+right;",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's not easy to find a rule for this question. \\n\\nAnd I think the example is not good.\\n\\nExamples here:\\n\\n1243\\n=> 12 43 (2 is the first num who is less than the next), and the num split to two parts, left: [1,2], right: [4,3]\\n\\n=> 13 42 (swap 2 with 3, because 3 is the first num greater than 2).\\n\\n=> 13 24 sort right. 13, 42 sorted to 24.\\n\\n=> 1324 merge left, right.\\n\\nAnother more complex example:\\n1342\\n=>13 42 split to left: 13  right: 42 (3 is the first num less than next);\\n\\n=>14 32 swap 3 and 4, because in the right part, 4 is the first num greater than 3, from right ->left scan.\\n\\n=>14 23 sort right part,  (**That's why we need to sort the right part**).\\n\\n=>1423 merge them \\n\\n\\n    class Solution:\\n    # @param num, a list of integer\\n    # @return a list of integer\\n    def nextPermutation(self, num):\\n        if(len(num)<=1):return num;\\n        else:\\n            splitIdx=-1;\\n            for i in range(len(num)-2,-1,-1):\\n                if(num[i]<num[i+1]):\\n                    splitIdx=i;\\n                    break;\\n            replaceIdx=len(num)-1;\\n            while(replaceIdx > splitIdx):\\n                if(num[replaceIdx]>num[splitIdx]):\\n                    break;\\n                replaceIdx-=1;\\n\\n            num[replaceIdx],num[splitIdx]=num[splitIdx],num[replaceIdx];\\n            \\n            right=num[splitIdx+1:];\\n            right=sorted(right);            \\n            return num[0:splitIdx+1]+right;",
                "codeTag": "Java"
            },
            {
                "id": 3797205,
                "title": "next-permutation-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/f0f088c6-8c8a-47ce-9461-10000fbb3af4_1689949086.1759074.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483577,
                "title": "o-n-time-and-o-1-space-easiest-beginner-friendly-solution",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem :\\n```\\narr : [2,5,8,4,7,6,3] -> nextPermutation : [2,5,8,6,3,4,7]\\n\\n1. In below image arr[i] and arr[i+1] = 4 and 7. so, i = 3.\\n2. In below image arr[i] and arr[j] = 4 and 6. So, j = 5.\\n3. swap arr[i] and arr[j]. So, our new array will be [2,5,8,6,7,4,3]\\n4. reverse i+1 to n-1. So, our final array will be [2,5,8,6,3,4,7] which is the next permutaion of given array \\n\\n**NOTE : THE ABOVE 4 STEPS IS SAME AS BELOW EXPLAINED APPROACH.**\\n                             8\\n                            / \\\\\\n                           /   \\\\       7\\n                          /     \\\\     / \\\\\\n                         /       \\\\   /   6\\n                        5         \\\\ /     \\\\\\n                       /           4       \\\\\\n                      /                     \\\\\\n                     /                       3\\n                    /\\n                   2\\n```\\n1. *Find the first element from the right that is smaller than its adjacent element. This is the first element that can be swapped with a larger element to its right to create a greater permutation.*\\n    - int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n2. *If such an element is found, find the smallest element to the right of it that is larger than it.*\\n    - int j = n - 1;\\n        while (j >= 0 && nums[i] >= nums[j]) {\\n            j--;\\n        }\\n3. *Swap these two elements.*\\n    - swap(nums[i], nums[j]); \\n4. *Reverse the subarray to the right of the swapped element. This is because the elements to the right of the swapped element are in descending order, and reversing them creates the smallest possible permutation that is greater than the original one.*\\n    - reverse(nums.begin() + i + 1, nums.end()); \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find the first element from the right that is smaller(nums[i]) than its adjacent(nums[i+1]) element\\n        int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n        \\n        // If such an element(nums[i]) is found, find the smallest element(nums[j]) to the right of it(nums[i]) that is just larger than it(nums[i]).\\n        if (i >= 0) {\\n            int j = n - 1;\\n            while (j >= 0 && nums[i] >= nums[j]) {\\n                j--;\\n            }\\n            // Swap the two elements\\n            swap(nums[i], nums[j]);\\n        }\\n        \\n        // Reverse the subarray to the right of the swapped element\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n)**, where n is the length of the input vector nums. This is because we traverse the vector from right to left at most once to find the first element that is smaller than its adjacent element and from right to left again to find the smallest element to the right of the element we found in the previous step. Then we reverse the subarray to the right of the swapped element in O(n/2) time. Therefore, the total time complexity is **O(n) + O(n) + O(n/2) = O(n)**.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(1)**. We use constant extra space throughout the algorithm.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\narr : [2,5,8,4,7,6,3] -> nextPermutation : [2,5,8,6,3,4,7]\\n\\n1. In below image arr[i] and arr[i+1] = 4 and 7. so, i = 3.\\n2. In below image arr[i] and arr[j] = 4 and 6. So, j = 5.\\n3. swap arr[i] and arr[j]. So, our new array will be [2,5,8,6,7,4,3]\\n4. reverse i+1 to n-1. So, our final array will be [2,5,8,6,3,4,7] which is the next permutaion of given array \\n\\n**NOTE : THE ABOVE 4 STEPS IS SAME AS BELOW EXPLAINED APPROACH.**\\n                             8\\n                            / \\\\\\n                           /   \\\\       7\\n                          /     \\\\     / \\\\\\n                         /       \\\\   /   6\\n                        5         \\\\ /     \\\\\\n                       /           4       \\\\\\n                      /                     \\\\\\n                     /                       3\\n                    /\\n                   2\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find the first element from the right that is smaller(nums[i]) than its adjacent(nums[i+1]) element\\n        int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n        \\n        // If such an element(nums[i]) is found, find the smallest element(nums[j]) to the right of it(nums[i]) that is just larger than it(nums[i]).\\n        if (i >= 0) {\\n            int j = n - 1;\\n            while (j >= 0 && nums[i] >= nums[j]) {\\n                j--;\\n            }\\n            // Swap the two elements\\n            swap(nums[i], nums[j]);\\n        }\\n        \\n        // Reverse the subarray to the right of the swapped element\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269908,
                "title": "shortest-2-pointer-5-lines-compact-solution-c-easy-explained",
                "content": "# Intuition\\nEvery lexicographic sequence has increasing order. We aim to get a peak from where the increasing sequence starts.\\n\\n# Approach\\n1. From the right, find an element (i) which is greater than its previous element (i-1).\\n2. If no such number is found, it means that array is in highest possible order. So return the reverse of the array (To rearrange it in lowest possible order).\\n3. Now from the right, find an element (j) which is greater than (i-1).\\n4. Swap (i-1) and (j).\\n5. Reverse the array after (i-1), i.e. From (i) till end. (Here we are resetting the number after finding the peak).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-1,j=nums.size()-1;\\n        while(i && nums[i-1]>=nums[i]) i--;\\n        if(!i) return reverse(nums.begin(),nums.end());\\n        while(nums[i-1]>=nums[j]) j--;\\n        swap(nums[i-1],nums[j]);\\n        return reverse(nums.begin()+i,nums.end());\\n    }\\n};\\n```\\n---\\n---\\n![3bjfi3.jpg](https://assets.leetcode.com/users/images/615d7731-d013-4da8-9502-8af799911cc5_1678215934.355254.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-1,j=nums.size()-1;\\n        while(i && nums[i-1]>=nums[i]) i--;\\n        if(!i) return reverse(nums.begin(),nums.end());\\n        while(nums[i-1]>=nums[j]) j--;\\n        swap(nums[i-1],nums[j]);\\n        return reverse(nums.begin()+i,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731188,
                "title": "next-permutation-very-easy-to-understand-much-better-in-terms-of-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) \\n    {\\n        \\n    int k=0;\\n    int l=0;\\n        \\n    int n=v.size();\\n        \\n    for(k=n-2;k>=0;k--)\\n    {\\n        if(v[k+1]>v[k])\\n        {\\n            break;\\n        }\\n    }\\n    \\n    if(k<=-1)\\n    {\\n        reverse(v.begin(),v.end());\\n    }\\n    else if(k>=0)\\n    {\\n        \\n        for(l=n-1;l>=0;l--)\\n        {\\n            if(v[l]>v[k])\\n            {\\n                break;\\n            }\\n        }\\n        \\n        swap(v[l],v[k]);\\n        \\n        reverse(v.begin()+k+1,v.end());\\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) \\n    {\\n        \\n    int k=0;\\n    int l=0;\\n        \\n    int n=v.size();\\n        \\n    for(k=n-2;k>=0;k--)\\n    {\\n        if(v[k+1]>v[k])\\n        {\\n            break;\\n        }\\n    }\\n    \\n    if(k<=-1)\\n    {\\n        reverse(v.begin(),v.end());\\n    }\\n    else if(k>=0)\\n    {\\n        \\n        for(l=n-1;l>=0;l--)\\n        {\\n            if(v[l]>v[k])\\n            {\\n                break;\\n            }\\n        }\\n        \\n        swap(v[l],v[k]);\\n        \\n        reverse(v.begin()+k+1,v.end());\\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908381,
                "title": "next-permutation-easy-solution-java",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n      if(nums == null || nums.length <= 1) return;\\n      int i = nums.length - 2;\\n      while(i >= 0 && nums[i] >= nums[i + 1]) i--; \\n      if(i >= 0) {                          \\n        int j = nums.length - 1;           \\n        while(nums[j] <= nums[i]) j--;           \\n        swap(nums, i, j);                     \\n    }\\n    reverse(nums, i + 1, nums.length - 1);       \\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\npublic void reverse(int[] nums, int i, int j) {\\n    while(i < j) \\n      swap(nums, i++, j--);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n      if(nums == null || nums.length <= 1) return;\\n      int i = nums.length - 2;\\n      while(i >= 0 && nums[i] >= nums[i + 1]) i--; \\n      if(i >= 0) {                          \\n        int j = nums.length - 1;           \\n        while(nums[j] <= nums[i]) j--;           \\n        swap(nums, i, j);                     \\n    }\\n    reverse(nums, i + 1, nums.length - 1);       \\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\npublic void reverse(int[] nums, int i, int j) {\\n    while(i < j) \\n      swap(nums, i++, j--);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887933,
                "title": "python-simple-intutive-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n            Since we have to find the next greater permutation of array, we can think greedly by modifying only that part of array which will contribute in detemining the next greater permutation.\\n            Now, to determine the contributing sub-array, consider the below examples:\\n                - [1,2,3,4,5] -(next greater permutation)> [1,2,3,5,4]\\n                - [1,2,5,3,4] -(next greater permutation)> [1,2,5,4,3]\\n                - [1,2,4,3,5] -(next greater permutation)> [1,2,4,5,3]\\n                - [1,2,4,5,3] -(next greater permutation)> [1,2,5,4,3]->[1,2,5,3,4]\\n                - [1,3,5,4,2] -(next greater permutation)> [1,4,5,3,2]->[1,4,2,3,5]\\n                - [5,4,3,2,1] -(next greater permutation)> [1,2,3,4,5]\\n            From the above examples, we can see that if we traverse from end and check for the index(from right) from where the elements are not in descending order-\\n                - If found, it means that this index needs to be updated with the firs greater element from right to get any greater permutation.\\n\\t\\t\\t\\t\\t-  To get the NEXT GREATER PERMUTATION we can reverse the array from next index to end as they were in descending order and by reversing, they will be in ascending order and that would be our next greater permutation.\\n                - Else, Complete array is in descending order so just make it into ascending by reversing it.\\n        \"\"\"\\n        # Check for the index from right from where the array doesn\\'t follows the descending order.\\n        i = len(nums)-2\\n        while i >= 0 and nums[i+1] <= nums[i]:\\n            i -= 1\\n        \\n        # If any such index is found then swap its value with the first greater element from right.\\n        if i >= 0:\\n            j = len(nums)-1\\n            while j >= 0 and nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        \\n        # Reverse the further array items\\n        i += 1\\n        j = len(nums)-1\\n        while i < j:\\n            nums[i], nums[j] = nums[j], nums[i]\\n            i += 1\\n            j -= 1\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n            Since we have to find the next greater permutation of array, we can think greedly by modifying only that part of array which will contribute in detemining the next greater permutation.\\n            Now, to determine the contributing sub-array, consider the below examples:\\n                - [1,2,3,4,5] -(next greater permutation)> [1,2,3,5,4]\\n                - [1,2,5,3,4] -(next greater permutation)> [1,2,5,4,3]\\n                - [1,2,4,3,5] -(next greater permutation)> [1,2,4,5,3]\\n                - [1,2,4,5,3] -(next greater permutation)> [1,2,5,4,3]->[1,2,5,3,4]\\n                - [1,3,5,4,2] -(next greater permutation)> [1,4,5,3,2]->[1,4,2,3,5]\\n                - [5,4,3,2,1] -(next greater permutation)> [1,2,3,4,5]\\n            From the above examples, we can see that if we traverse from end and check for the index(from right) from where the elements are not in descending order-\\n                - If found, it means that this index needs to be updated with the firs greater element from right to get any greater permutation.\\n\\t\\t\\t\\t\\t-  To get the NEXT GREATER PERMUTATION we can reverse the array from next index to end as they were in descending order and by reversing, they will be in ascending order and that would be our next greater permutation.\\n                - Else, Complete array is in descending order so just make it into ascending by reversing it.\\n        \"\"\"\\n        # Check for the index from right from where the array doesn\\'t follows the descending order.\\n        i = len(nums)-2\\n        while i >= 0 and nums[i+1] <= nums[i]:\\n            i -= 1\\n        \\n        # If any such index is found then swap its value with the first greater element from right.\\n        if i >= 0:\\n            j = len(nums)-1\\n            while j >= 0 and nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        \\n        # Reverse the further array items\\n        i += 1\\n        j = len(nums)-1\\n        while i < j:\\n            nums[i], nums[j] = nums[j], nums[i]\\n            i += 1\\n            j -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836471,
                "title": "2-solutions-with-stl-beats-100-non-stl-solution",
                "content": "# STL Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int idx = -1;\\n        int n = nums.size();\\n\\n        for(int i = n-2;i >= 0;i--){\\n            if(nums[i] < nums[i+1]){\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        if(idx == -1){\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        for(int i = n-1;i >= 0;i--){\\n            if(nums[i] > nums[idx]){\\n                swap(nums[i], nums[idx]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + idx + 1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int idx = -1;\\n        int n = nums.size();\\n\\n        for(int i = n-2;i >= 0;i--){\\n            if(nums[i] < nums[i+1]){\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        if(idx == -1){\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        for(int i = n-1;i >= 0;i--){\\n            if(nums[i] > nums[idx]){\\n                swap(nums[i], nums[idx]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + idx + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597823,
                "title": "o-n-solution-intuitive-and-easy-explaination",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTreating the array as real number for example [1,2,3] read as 123, the next permutation or the next greater  number that can be formed using these digits is 132 [1,3,2] is thus the next permutation.One thing to observe is that when we move from right to left as soon as we encounter a smaller number we think of swapping it with its just greater number because  we need a number just greater than the given number so using this observation we can loop in reverse order and find a number that is less than the current digit .On the contrary if we get a number greater than the current number then using the digits we cannot form a greater number so we are in search of a smaller number.As soon as it is found we break out from the loop. We then find a just greater number in the right half(already traversed part of the array just now) and swap the dip element with it. As we know if we swap a number greater than the dip element we need the other numbers to be in sorted order in th right half so that the number formed is just greater as the array was already sorted in descending order we just reverse it to get the increasing order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j,n=nums.size();\\n       for(i=n-2;i>=0;i--)\\n       {\\n           if(nums[i]<nums[i+1])\\n                break;\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n       }\\n       else\\n       {\\n            for(j=n-1;j>=i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                    break;\\n            }\\n           swap(nums[i],nums[j]);\\n           reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j,n=nums.size();\\n       for(i=n-2;i>=0;i--)\\n       {\\n           if(nums[i]<nums[i+1])\\n                break;\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n       }\\n       else\\n       {\\n            for(j=n-1;j>=i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                    break;\\n            }\\n           swap(nums[i],nums[j]);\\n           reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084401,
                "title": "priority-queue-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n**First Approach**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), element;\\n        if(n==1){\\n            return;\\n        }\\n        int index=-1;\\n        priority_queue<int> pq;\\n        for(int i=n-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.top()!= nums[i]){\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        int check, k = n-1;\\n        bool flag = true;\\n        element = nums[index];\\n        while (!pq.empty()) {\\n            if(pq.top() == element && flag){\\n                check = k+1;\\n                flag = false;\\n            }\\n            nums[k] = pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n\\n    }\\n};\\n```\\n**Second Approach**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1){\\n            return;\\n        }\\n\\n        int index=-1,element,check;\\n        for(int i=n-1; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                index = i-1;\\n                element = nums[i-1];\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        sort(nums.begin() + index, nums.end());\\n        \\n        for(int i=n-1; i>=index; i--){\\n            if(nums[i] == element){\\n                check = i+1;\\n                break;\\n            }\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), element;\\n        if(n==1){\\n            return;\\n        }\\n        int index=-1;\\n        priority_queue<int> pq;\\n        for(int i=n-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.top()!= nums[i]){\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        int check, k = n-1;\\n        bool flag = true;\\n        element = nums[index];\\n        while (!pq.empty()) {\\n            if(pq.top() == element && flag){\\n                check = k+1;\\n                flag = false;\\n            }\\n            nums[k] = pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1){\\n            return;\\n        }\\n\\n        int index=-1,element,check;\\n        for(int i=n-1; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                index = i-1;\\n                element = nums[i-1];\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        sort(nums.begin() + index, nums.end());\\n        \\n        for(int i=n-1; i>=index; i--){\\n            if(nums[i] == element){\\n                check = i+1;\\n                break;\\n            }\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075088,
                "title": "javascript-very-very-easy-to-understand-solution",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/Lhsz3BSJEKY\\n\\n# Code\\n```\\nvar nextPermutation = function(nums) {\\n    let swap = (l,r) =>{\\n        [nums[l],nums[r]] = [nums[r],nums[l]]\\n    }\\n    let reverse = (left) =>{\\n        let right = nums.length-1;\\n        while(left<right){\\n            swap(left,right)\\n            left++\\n            right--\\n        }\\n    }\\n\\n    for(let i = nums.length-2; i>=0; i--){\\n        for(let j = nums.length-1; j>i; j--){\\n            if(nums[j] >nums[i]){\\n                swap(i,j);\\n                reverse(i+1)\\n                return;\\n            }\\n        }\\n    }\\n    reverse(0)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextPermutation = function(nums) {\\n    let swap = (l,r) =>{\\n        [nums[l],nums[r]] = [nums[r],nums[l]]\\n    }\\n    let reverse = (left) =>{\\n        let right = nums.length-1;\\n        while(left<right){\\n            swap(left,right)\\n            left++\\n            right--\\n        }\\n    }\\n\\n    for(let i = nums.length-2; i>=0; i--){\\n        for(let j = nums.length-1; j>i; j--){\\n            if(nums[j] >nums[i]){\\n                swap(i,j);\\n                reverse(i+1)\\n                return;\\n            }\\n        }\\n    }\\n    reverse(0)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910550,
                "title": "concise-in-place-solution-with-no-backtracking",
                "content": "```csharp\\npublic void NextPermutation(int[] arr)\\n{\\n    int i = arr.Length - 2;\\n    while (i >= 0 && arr[i] >= arr[i + 1]) i--;\\n\\n    if (i >= 0)\\n    {\\n        int j = arr.Length - 1;\\n        while (arr[i] >= arr[j]) j--;\\n        (arr[i], arr[j]) = (arr[j], arr[i]);\\n    }\\n    \\n\\tarr.AsSpan(i + 1, arr.Length - i - 1).Reverse();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic void NextPermutation(int[] arr)\\n{\\n    int i = arr.Length - 2;\\n    while (i >= 0 && arr[i] >= arr[i + 1]) i--;\\n\\n    if (i >= 0)\\n    {\\n        int j = arr.Length - 1;\\n        while (arr[i] >= arr[j]) j--;\\n        (arr[i], arr[j]) = (arr[j], arr[i]);\\n    }\\n    \\n\\tarr.AsSpan(i + 1, arr.Length - i - 1).Reverse();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909231,
                "title": "c-1ms-algorithm-explaination",
                "content": "```\\n// Algorithm\\n//  1. find index i that arr[i] < arr[i+1] from end-1 to start of array.\\n//  2. Search for index j that arr[j] > arr[i] from back to start.\\n//  3. Swap (arr[i] > arr[j]).\\n//  4. Reverse Array from index i+1 to End of Array.\\n//  5. In Case we can not find i that means it is a Sorted Array(decreasing) , We have simply reverse Array.\\nclass Solution\\n{\\npublic:\\n    void nextPermutation(vector<int> &arr)\\n    {\\n        int firstIndex = INT_MAX;\\n        for (int i = arr.size() - 2; i >= 0; i--)\\n        {\\n            if (arr[i] < arr[i + 1])\\n            {\\n                firstIndex = i;\\n                break;\\n            }\\n        }\\n        if (firstIndex == INT_MAX)\\n        {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        else\\n        {\\n            int highIndex = INT_MAX;\\n            for (int i = arr.size() - 1; i >= 0; i--)\\n            {\\n                if (arr[i] > arr[firstIndex])\\n                {\\n                    highIndex = i;\\n                    break;\\n                }\\n            }\\n            swap(arr[highIndex], arr[firstIndex]);\\n            reverse(arr.begin() + firstIndex + 1, arr.end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Algorithm\\n//  1. find index i that arr[i] < arr[i+1] from end-1 to start of array.\\n//  2. Search for index j that arr[j] > arr[i] from back to start.\\n//  3. Swap (arr[i] > arr[j]).\\n//  4. Reverse Array from index i+1 to End of Array.\\n//  5. In Case we can not find i that means it is a Sorted Array(decreasing) , We have simply reverse Array.\\nclass Solution\\n{\\npublic:\\n    void nextPermutation(vector<int> &arr)\\n    {\\n        int firstIndex = INT_MAX;\\n        for (int i = arr.size() - 2; i >= 0; i--)\\n        {\\n            if (arr[i] < arr[i + 1])\\n            {\\n                firstIndex = i;\\n                break;\\n            }\\n        }\\n        if (firstIndex == INT_MAX)\\n        {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        else\\n        {\\n            int highIndex = INT_MAX;\\n            for (int i = arr.size() - 1; i >= 0; i--)\\n            {\\n                if (arr[i] > arr[firstIndex])\\n                {\\n                    highIndex = i;\\n                    break;\\n                }\\n            }\\n            swap(arr[highIndex], arr[firstIndex]);\\n            reverse(arr.begin() + firstIndex + 1, arr.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723652,
                "title": "easiest-explanatation-guarantee-with-intuition-c",
                "content": "***Easiest Explanatation Guarantee***\\n\\nSo I will give the algorithm first, then what the algorithm does, and then the intuition\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index1=-1,index2=-1;\\n        for(int i=nums.size()-1;i>0;i--) {\\n            if(nums[i]>nums[i-1]) {\\n                index1=i-1;\\n                break;\\n            }\\n            \\n        }\\n        if(index1!=-1) {\\n            for(int i=nums.size()-1;i>0;i--) {\\n                if(nums[i]>nums[index1]) {\\n                    index2=i;\\n                    break;\\n                }\\n            }\\n            //swap\\n            swap(nums[index1],nums[index2]);\\n            \\n            \\n        }\\n        reverse(nums.begin()+index1 + 1,nums.end());\\nreturn ;\\n    }\\n};\\n```\\n\\n\\nYou can find this algorithm in the all over the discussion section, but here you will find the intuition\\n\\nSee, We convert a permutation into greater lexicographical order by converting the last part into largest lexicographical order\\nFor eg 1 2 4 3 5\\nWe will not change 1 2 till we convert 4 3 5 into the largest order ie 5 4 3 , then only we can change 1 2\\n\\nSo the first step is to find the string from the back which is already in the largest lexicographical order \\nWe do this by finding index1 from the back as all elements after index1 will be in largest lexicographical order.\\neg 1 2 5 4 3 , we will find index1 to be 1 (nums[index1]=2),\\n\\nIn second step we will find element greater than nums[index] to replace it with.\\nIn example we now need to change 2, that is why we start from end because we know the string 5 4 3 will be in descending order\\nWe will find index2 to be 4(nums[index2]=3)\\n\\nAfter that we swap nums[index1] with nums[index2] \\nSo order becomes 1 3 5 4 2 , \\nThen we reverse the 5 4 2 string so as to convert it into smallest order\\n\\nSo order becomes 1 3 2 4 5 \\n\\nPlease do upvote if you find it helpful\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index1=-1,index2=-1;\\n        for(int i=nums.size()-1;i>0;i--) {\\n            if(nums[i]>nums[i-1]) {\\n                index1=i-1;\\n                break;\\n            }\\n            \\n        }\\n        if(index1!=-1) {\\n            for(int i=nums.size()-1;i>0;i--) {\\n                if(nums[i]>nums[index1]) {\\n                    index2=i;\\n                    break;\\n                }\\n            }\\n            //swap\\n            swap(nums[index1],nums[index2]);\\n            \\n            \\n        }\\n        reverse(nums.begin()+index1 + 1,nums.end());\\nreturn ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864025,
                "title": "simple-c-solution-with-explanation-beats-94",
                "content": "```\\n/* The simple intution to solve this problem is to find the index which will get swaped.\\nNow if we dont find any index, that means that the vector is in descending order and \\nhence we must sort it in ascending order and return. Now the simple logic to find the \\nswap index is that it is the number which breaks the ascending order sequence from the right (nums[i-1] < nums[i]) .\\nEx:- 2543, so here 543 is in ascending order from right and 2 breaks the sequence. So 0 will be the swap index. \\nNow to get the next permutation and not any permutation, we must swap the index found previously\\nwith the first element which is greater than the nums[index]. Now we swap the \\ntwo elements. So our swap index now contains an element which is greater than what\\nit had earlier. So now to have the next permutation, we must sort all the elements to its\\nright in ascending order as it will become the minimum possible value that could have\\nbeen formed by replacing the swap index with some value greater than it. \\n\\t\\t\\t\\n\\t\\t\\t\\tPlease upvote, if you find the solution helpful. \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        for(int i = nums.size()-1; i>=1; i--)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        \\n        if(index == -1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        for(int i = nums.size()-1; i>index; i--)\\n        {\\n            if(nums[i] > nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                sort(nums.begin()+index+1, nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* The simple intution to solve this problem is to find the index which will get swaped.\\nNow if we dont find any index, that means that the vector is in descending order and \\nhence we must sort it in ascending order and return. Now the simple logic to find the \\nswap index is that it is the number which breaks the ascending order sequence from the right (nums[i-1] < nums[i]) .\\nEx:- 2543, so here 543 is in ascending order from right and 2 breaks the sequence. So 0 will be the swap index. \\nNow to get the next permutation and not any permutation, we must swap the index found previously\\nwith the first element which is greater than the nums[index]. Now we swap the \\ntwo elements. So our swap index now contains an element which is greater than what\\nit had earlier. So now to have the next permutation, we must sort all the elements to its\\nright in ascending order as it will become the minimum possible value that could have\\nbeen formed by replacing the swap index with some value greater than it. \\n\\t\\t\\t\\n\\t\\t\\t\\tPlease upvote, if you find the solution helpful. \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        for(int i = nums.size()-1; i>=1; i--)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        \\n        if(index == -1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        for(int i = nums.size()-1; i>index; i--)\\n        {\\n            if(nums[i] > nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                sort(nums.begin()+index+1, nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615545,
                "title": "easy-python-solution-o-n-time-w-comments",
                "content": "**notes/assumptions:**\\n- modify in place, no outputs\\n- inputs: list of integers \\n- space: O(1)\\n- no negative integers\\n\\n**approach:**\\n- iterate through nums in reverse order until I find my first decreasing element\\n\\t- if the num @ current index > the num @ previous index \\n\\t\\t- break out of the loop\\n\\n- if index == 0 --> return the reverse of the loop \\n\\n- iterate through nums to find the index of the next element greater than my first decreasing element\\n\\t- swap the elements\\n\\t- reverse the rest of the nums from index of my decreasing element onwards\\n\\n\\n**complexity:**\\n- time: O(n) - we iterate through at most len of nums elements\\n- space: O(1) - modify in place and only use variables to store index\\n\\n\\n``` python\\nclass Solution(object):\\n\\tdef nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n\\t\\t# helper function to reverse the array from particular index\\n        def reverse_from_index(arr, start_idx, end_idx):\\n            while start_idx < end_idx:\\n                arr[start_idx], arr[end_idx] = arr[end_idx], arr[start_idx]\\n                start_idx += 1\\n                end_idx -= 1\\n            \\n        # find the first decreasing element\\n        first_decreasing_index = len(nums) - 1\\n        while first_decreasing_index > 0 and nums[first_decreasing_index] <= nums[first_decreasing_index - 1]:\\n            first_decreasing_index -= 1\\n\\n        # reverse nums because nums is in descending order and return \\n        if first_decreasing_index == 0:\\n            reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n            return\\n\\n        # find the next element greater than the first decreasing element\\n        next_num_index = len(nums) - 1\\n        while next_num_index > 0 and nums[next_num_index] <= nums[first_decreasing_index - 1]: \\n            next_num_index -= 1\\n\\n        # swap the two elements\\n        nums[first_decreasing_index - 1], nums[next_num_index] = nums[next_num_index], nums[first_decreasing_index - 1]\\n\\n        # reverse the rest of the list\\n        reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` python\\nclass Solution(object):\\n\\tdef nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n\\t\\t# helper function to reverse the array from particular index\\n        def reverse_from_index(arr, start_idx, end_idx):\\n            while start_idx < end_idx:\\n                arr[start_idx], arr[end_idx] = arr[end_idx], arr[start_idx]\\n                start_idx += 1\\n                end_idx -= 1\\n            \\n        # find the first decreasing element\\n        first_decreasing_index = len(nums) - 1\\n        while first_decreasing_index > 0 and nums[first_decreasing_index] <= nums[first_decreasing_index - 1]:\\n            first_decreasing_index -= 1\\n\\n        # reverse nums because nums is in descending order and return \\n        if first_decreasing_index == 0:\\n            reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n            return\\n\\n        # find the next element greater than the first decreasing element\\n        next_num_index = len(nums) - 1\\n        while next_num_index > 0 and nums[next_num_index] <= nums[first_decreasing_index - 1]: \\n            next_num_index -= 1\\n\\n        # swap the two elements\\n        nums[first_decreasing_index - 1], nums[next_num_index] = nums[next_num_index], nums[first_decreasing_index - 1]\\n\\n        # reverse the rest of the list\\n        reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561996,
                "title": "java-clean-code-time-o-n-space-o-1",
                "content": "```java\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        if (n == 0) return;\\n        int i = n - 2;\\n        while (i >= 0 && arr[i] >= arr[i+1]) i--; // Find first min point from the right\\n        if (i == -1) {\\n            reverse(arr, 0, n - 1);\\n        } else {\\n            int nextGreaterIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] > arr[i])\\n                    nextGreaterIndex = j;\\n            }\\n            swap(arr, i, nextGreaterIndex);\\n            reverse(arr, i + 1, n - 1);\\n        }\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    void reverse(int[] arr, int l, int r) {\\n        while (l < r) swap(arr, l++, r--);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        if (n == 0) return;\\n        int i = n - 2;\\n        while (i >= 0 && arr[i] >= arr[i+1]) i--; // Find first min point from the right\\n        if (i == -1) {\\n            reverse(arr, 0, n - 1);\\n        } else {\\n            int nextGreaterIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] > arr[i])\\n                    nextGreaterIndex = j;\\n            }\\n            swap(arr, i, nextGreaterIndex);\\n            reverse(arr, i + 1, n - 1);\\n        }\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    void reverse(int[] arr, int l, int r) {\\n        while (l < r) swap(arr, l++, r--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248070,
                "title": "java-solution",
                "content": "**Solution 1:**\\n\\n**Intuition:**\\n- A permutation is a rearrangement of the members of the sequence into a new sequence. For example, there are `24` permutations of `[a, b, c, d]`; some of these are \\n`[b, a, d, c]`, `[d, a, b, c]`, and `[a, d, b, c]`.\\n- There exists `n!` permutations of `n` elements. These can totally ordered using the dictionary ordering. We define permutation `p` to appear before `q` if in the first place where `p` and `q` differ in their array representations, the corresponding entry for `p` is less than that for `q`.\\nFor example, `[2, 0, 1] < [2, 1, 0]`. Note that permutation `[0, 1, 2]` is the smallest permutation under dictionary ordering, and `[2, 1, 0]` is the largest permutation under dictionary ordering.\\n- Here the algorithm takes a permutation as an input and returns the next permutation under dictionary ordering. \\nFor example, if the input is `[1, 0, 3 ,2]`, then we return `[1, 2, 0, 3]`.\\n- If the input permutation is the last permutation, then we return the first permutation. \\nFor example, if the input is `[4, 3, 2 ,1]`, then we return `[1, 2, 3, 4]`.\\n---------------------\\n- The key insight is that we want to increase the permutation by as little as possible. Here we can not change the values, only reorder them. We will use input permutation \\n`[6, 2, 1, 5, 4, 3, 0]`.\\n- Specifically, we start from the right, and look at the longest decreasing `suffix`, which is `[5, 4, 3, 0]` for our example. We can not get the next permutation just by modifying this `suffix`, since it is already the maximum it can be.\\n- Instead we look at the entry `e` that appears just before the longest decreasing `suffix`, which is `1` in this case. \\n- If there is no such element, i.e., the longest decreasing `suffix` is the entire input permutation, for which the next permutation is the first permutation. In this case we return reverse of input permutation.\\n- Observe that `e` must be less than some entries in `suffix`, since the entry immediately after `e` is greater than `e`. Intuitively, we should swap `e` with the smallest entry `s` in the `suffix` which is larger than `e` so as to minimize the change to the `prefix`, which is defined to the part of the sequence that appears before the `suffix`.\\nFor example, here `e = 1` and `s = 3` Swapping `s` and `e` results in `[6, 2, 3, 5, 4, 1, 0]`.\\n- We are not done yet, since the new `prefix` is the smallest possible for all permutations greater than the initial permutation, but the new `suffix` may not be the smallest. We can get the smallest `suffix` by sorting the entries in the `suffix` from the smallest to largest. For our working example, this yields the `suffix` `[0, 1, 4, 5]`.\\n- As an optimization, it is not necessary to call the full blown sorting algorithm on `suffix`. Since the `suffix` was initially decreasing, and after replacing `s` by `e` it still remains decreasing, reversing the `suffix` has the effect of sorting it from smallest to largest.\\n---------------------\\n\\n**Algorithm:**\\n1. Find the largest index `i` such that `A[i] < A[i + 1]`. If no such index exists, just reverse `A` and done.\\n2. Find the largest index `j` such that `j > i` and `A[i] < A[j]`.\\n3. Swap `A[i]` and `A[j]`.\\n4. Reverse the sequence after position `i`. i.e. the sub-array `A[i + 1, n]`.\\n\\n- For example, given the sequence `[1, 2, 3, 4]`, which is in increasing order, and given that the index is zero-based, the steps are as follows:\\n  1. Index `i = 2`, because `3` is placed at an index that satisfies condition of being the largest index that is still less than `A[i + 1]` which is `4`.\\n  2. Index `j = 3`, because `4` is the only value in the sequence that is greater than `3` in order to satisfy the condition `A[i] < A[j]`.\\n  3. The values of `A[2]` and `A[3]` are swapped to form the new sequence `[1, 2, 4, 3]`.\\n  4. The sequence after `i` index, i.e. `A[2]` to the final element is reversed. Because only one value lies after this index (the `3`), the sequence remains unchanged in this instance. Thus the lexicographic successor of the initial state is permuted as: `[1, 2, 4, 3]`.\\n\\n- Following this algorithm, the next lexicographic permutation will be `[1, 3, 2, 4]`, and the `24`<sup>th</sup> permutation will be `[4, 3, 2, 1]` at which point `A[i] < A[i + 1]` does not exist, indicating that this is the last permutation.\\n\\n**Time complexity:** `O(N)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        int N = A.length;\\n        int i;\\n        int j;\\n\\n        for (i = N - 2; i >= 0; i--) {\\n            if (A[i] < A[i + 1])\\n                break;\\n        }\\n\\n        if (i >= 0) {\\n            for (j = N - 1; j > i; j--) {\\n                if (A[i] < A[j])\\n                    break;\\n            }\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, N - 1);\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            swap(A, start++, end--);\\n        }\\n    }\\n\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        int N = A.length;\\n        int i;\\n        int j;\\n\\n        for (i = N - 2; i >= 0; i--) {\\n            if (A[i] < A[i + 1])\\n                break;\\n        }\\n\\n        if (i >= 0) {\\n            for (j = N - 1; j > i; j--) {\\n                if (A[i] < A[j])\\n                    break;\\n            }\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, N - 1);\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            swap(A, start++, end--);\\n        }\\n    }\\n\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795248,
                "title": "really-simple-solution-everyone-can-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlgorithm / Intuition\\nThe steps are the following:\\n\\nFind the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\nTo find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\nIf a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\nNote: For a better understanding of intuition, please watch the video at the bottom of the page.\\n\\n# Dry run\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a7afeec0-e1c6-4065-a964-f204b2c3cd31_1689915729.846143.png)\\n![image.png](https://assets.leetcode.com/users/images/6ec6a3e9-da9b-42f5-ab15-8e8fac596a35_1689915741.7086728.png)\\n![image.png](https://assets.leetcode.com/users/images/dbbca798-e59f-45c5-86d9-d683129646ac_1689915753.1975505.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity: O(3N), where N = size of the given array\\nFinding the break-point, finding the next greater element, and reversal at the end takes O(N) for each, where N is the number of elements in the input array. This sums up to 3*O(N) which is approximately O(3N).\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity: Since no extra storage is required. Thus, its space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        int ind = -1;\\n        // for finding the break point\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (arr[i] < arr[i + 1]) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        // if the break point does not exist\\n        if (ind == -1) {\\n            reverse(arr, 0, n - 1);\\n            return;\\n        }\\n        // if the break point exists\\n        int j = n - 1;\\n        for (int i = n - 1; i >= ind + 1; i--) {\\n            if (arr[i] > arr[ind]) {\\n                swap(arr, i, ind);\\n                break;\\n            }\\n        }\\n        // Reverse the entire right half array\\n        reverse(arr, ind + 1, n - 1);\\n    }\\n\\n    // Function for reverse the array\\n    public void reverse(int[] arr, int l, int r) {\\n        int start = l;\\n        int end = r;\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Function for swap the elements\\n    public void swap(int[] arr, int i, int j) {\\n        int tem = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tem;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        int ind = -1;\\n        // for finding the break point\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (arr[i] < arr[i + 1]) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        // if the break point does not exist\\n        if (ind == -1) {\\n            reverse(arr, 0, n - 1);\\n            return;\\n        }\\n        // if the break point exists\\n        int j = n - 1;\\n        for (int i = n - 1; i >= ind + 1; i--) {\\n            if (arr[i] > arr[ind]) {\\n                swap(arr, i, ind);\\n                break;\\n            }\\n        }\\n        // Reverse the entire right half array\\n        reverse(arr, ind + 1, n - 1);\\n    }\\n\\n    // Function for reverse the array\\n    public void reverse(int[] arr, int l, int r) {\\n        int start = l;\\n        int end = r;\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Function for swap the elements\\n    public void swap(int[] arr, int i, int j) {\\n        int tem = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tem;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716085,
                "title": "easy-c-solution-o-n-time-complexity-beats-100-in-both",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145361,
                "title": "c-easy-explanation-0ms",
                "content": "**Approach to the Problem**\\n\\nLet\\'s understand the problem with an example.\\n```\\n1 2 3 4 \\n```\\nFirstly, we traverse from the end element i.e, 4. \\nFind the pnt where the element is less than the next element. here it is-> 2 as 2<3\\nCode for above two lines:\\n```\\nfor(pnt=n-2;pnt>=0;pnt--){\\nif(nums[pnt]<nums[pnt+1]\\n  break;\\n}\\n```\\nNow if pnt<0 it means the number is in decreasing order and hence, the next permutation will be the reverse of it.\\ncode for it:\\n```\\nif(pnt<0)\\n reverse(nums.begin(),nums.end());\\n```\\nElse check by traversing from the last element the number greater than the number at (pnt) if found then swap them.\\nCode for it:\\n```\\nelse{\\n  for(l=n-1;l>k;l--){\\n\\t if(nums[l]>nums[k])\\n\\t  break;\\n\\t}\\n\\tswap(nums[l],nums[k]);\\n```\\nNow at the end, reverse the sequence starting after pnt and ending at nums end.\\n```\\nreverse(nums.begin()+pnt+1,nums.end());\\n```\\nfor eg. \\n```\\n**1 2 3 4** \\nnext permutation=> **1 2 4 3** => swapped(3,4)\\nnext permutation=> 1 2 4 3 => 1 3 4 2(swapped 2 with 3)=>**1 3 2 4**(reversed the number after 4)\\nnext permutation=>1 3 2 4=> 1 3 4 2(swapped 2 wih 4)\\nnext permutation=>1 3 4 2=>1 4 3 2(swapped 3 with 4)=>**1 4 2 3**(reversed the number after 4)\\n```\\nHere\\'s the whole code \\uD83D\\uDC47\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     int n=nums.size(),pnt,l;\\n     for(pnt=n-2;pnt>=0;pnt--){\\n         if(nums[pnt]<nums[pnt+1]){\\n             break;\\n         }\\n     }\\n     if(pnt<0){\\n         reverse(nums.begin(),nums.end());\\n     }else{\\n         for(l=n-1;l>pnt;l--){\\n             if(nums[l]>nums[pnt]){\\n                 break;\\n             }\\n         }\\n         swap(nums[l],nums[pnt]);\\n         reverse(nums.begin()+pnt+1,nums.end());\\n     }\\n    }\\n};\\n```\\n**IF You Liked the explanation please Upvote it:)**",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\n1 2 3 4 \\n```\n```\\nfor(pnt=n-2;pnt>=0;pnt--){\\nif(nums[pnt]<nums[pnt+1]\\n  break;\\n}\\n```\n```\\nif(pnt<0)\\n reverse(nums.begin(),nums.end());\\n```\n```\\nelse{\\n  for(l=n-1;l>k;l--){\\n\\t if(nums[l]>nums[k])\\n\\t  break;\\n\\t}\\n\\tswap(nums[l],nums[k]);\\n```\n```\\nreverse(nums.begin()+pnt+1,nums.end());\\n```\n```\\n**1 2 3 4** \\nnext permutation=> **1 2 4 3** => swapped(3,4)\\nnext permutation=> 1 2 4 3 => 1 3 4 2(swapped 2 with 3)=>**1 3 2 4**(reversed the number after 4)\\nnext permutation=>1 3 2 4=> 1 3 4 2(swapped 2 wih 4)\\nnext permutation=>1 3 4 2=>1 4 3 2(swapped 3 with 4)=>**1 4 2 3**(reversed the number after 4)\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     int n=nums.size(),pnt,l;\\n     for(pnt=n-2;pnt>=0;pnt--){\\n         if(nums[pnt]<nums[pnt+1]){\\n             break;\\n         }\\n     }\\n     if(pnt<0){\\n         reverse(nums.begin(),nums.end());\\n     }else{\\n         for(l=n-1;l>pnt;l--){\\n             if(nums[l]>nums[pnt]){\\n                 break;\\n             }\\n         }\\n         swap(nums[l],nums[pnt]);\\n         reverse(nums.begin()+pnt+1,nums.end());\\n     }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117786,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       next_permutation(nums.begin() ,nums.end());\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       next_permutation(nums.begin() ,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716217,
                "title": "python-easy-solution-comments",
                "content": "\\tclass Solution:\\n\\t\\tdef nextPermutation(self, nums: List[int]) -> None:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# 1st Step...\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and nums[i] >= nums[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\t# ...\\n\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t# It shows that all the elements are in descending order.\\n\\t\\t\\t\\tnums[:] = nums[::-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# 2nd Step...\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile nums[j] <= nums[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 3rd Step...\\n\\t\\t\\t\\tnums[i], nums[j] = nums[j], nums[i]\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 4th Step...\\n\\t\\t\\t\\tnums[i+1:] = sorted(nums[i+1:])\\n\\t\\t\\t\\t# ...\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef nextPermutation(self, nums: List[int]) -> None:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# 1st Step...\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and nums[i] >= nums[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\t# ...\\n\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t# It shows that all the elements are in descending order.\\n\\t\\t\\t\\tnums[:] = nums[::-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# 2nd Step...\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile nums[j] <= nums[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 3rd Step...\\n\\t\\t\\t\\tnums[i], nums[j] = nums[j], nums[i]\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 4th Step...\\n\\t\\t\\t\\tnums[i+1:] = sorted(nums[i+1:])\\n\\t\\t\\t\\t# ...\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1577491,
                "title": "java-detailed-explanation-with-diagram-o-n",
                "content": "The key observation in this algorithm is that when we want to compute the next permutation, we must \\u201Cincrease\\u201D the sequence as little as possible. Just like when we count up using numbers, we try to modify the rightmost elements and leave the left side unchanged.\\n\\nTo find next lexicographically greater permutation of numbers, follow following steps\\n1. Find the index (starting from right ending to left) which breaks the increasing order (nums[index - 1] < nums[index])\\n2. Find the FIRST number starting from right which is GREATER than the number we found at \\'index - 1\\' in step 1\\n3. After the swap, reverse the sequence which is RIGHT of \\'index - 1\\'\\n\\n![image](https://assets.leetcode.com/users/images/74a765af-58c3-4c4d-b284-39190c084e96_1636878412.2445583.png)\\n\\n\\nSource of diagram (good read) : https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nTC: O(N) -> all increasing order (worst case)\\nSC: O(1)\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int index = nums.length - 1;\\n        \\n        while(index > 0) {\\n            if(nums[index - 1] < nums[index]) { // find first index from right where the num breaks the increasing order (from right to left)\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        if(index == 0) { // if we have reached the index 0, this means the given array is in decreasing order so reverse it\\n            reverse(nums, index);\\n            return;\\n        } else {\\n            int val = nums[index - 1];\\n            int idxToSwap = nums.length - 1;\\n            while(idxToSwap > index - 1) {\\n                if(nums[idxToSwap] > val) { // find the first num which is grater than the num at \\'index - 1\\'\\n                    break;\\n                }\\n                idxToSwap--;\\n            }\\n            swap(nums, index - 1, idxToSwap); // swap the num, this will basically ATTEMPT to increase the original number \\'just a little\\'\\n            reverse(nums, index); // this step along with above step will basically increase the original number \\'just a little\\' (basically next lexicographically greater permutation of numbers)\\n            return;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int firstIdx, int secondIdx) {\\n        int temp = nums[firstIdx];\\n        nums[firstIdx] = nums[secondIdx];\\n        nums[secondIdx] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start) {\\n        int end = nums.length - 1;\\n        while(start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int index = nums.length - 1;\\n        \\n        while(index > 0) {\\n            if(nums[index - 1] < nums[index]) { // find first index from right where the num breaks the increasing order (from right to left)\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        if(index == 0) { // if we have reached the index 0, this means the given array is in decreasing order so reverse it\\n            reverse(nums, index);\\n            return;\\n        } else {\\n            int val = nums[index - 1];\\n            int idxToSwap = nums.length - 1;\\n            while(idxToSwap > index - 1) {\\n                if(nums[idxToSwap] > val) { // find the first num which is grater than the num at \\'index - 1\\'\\n                    break;\\n                }\\n                idxToSwap--;\\n            }\\n            swap(nums, index - 1, idxToSwap); // swap the num, this will basically ATTEMPT to increase the original number \\'just a little\\'\\n            reverse(nums, index); // this step along with above step will basically increase the original number \\'just a little\\' (basically next lexicographically greater permutation of numbers)\\n            return;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int firstIdx, int secondIdx) {\\n        int temp = nums[firstIdx];\\n        nums[firstIdx] = nums[secondIdx];\\n        nums[secondIdx] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start) {\\n        int end = nums.length - 1;\\n        while(start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400124,
                "title": "python-easy-sorting-binary-search-nlogn-time",
                "content": "***PLEASE DO UPVOTE***\\n```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    \\n    def find_ceil(self, a,i,j, key):\\n        ans = None\\n        while i<=j:\\n            mid = (i+j)//2\\n            if a[mid] > key: #strictly greater than key\\n                ans = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return ans\\n    \\n    def sort(self,a, i, j):\\n        heap = []\\n        heapify(heap)\\n        for k in range(i, j+1):\\n            heappush(heap, a[k])\\n        for k in range(i, j+1):\\n            a[k] = heappop(heap)\\n            \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx,n = None, len(nums)\\n        for i in range(n-2,-1,-1):\\n            if nums[i] < nums[i+1]:\\n                idx = i \\n                break\\n        if idx!=None:\\n            idx2 = self.find_ceil(nums, idx+1, n-1, nums[idx])\\n            nums[idx], nums[idx2] = nums[idx2], nums[idx]\\n            self.sort(nums, idx+1, n-1)\\n        else:\\n            nums.sort()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    \\n    def find_ceil(self, a,i,j, key):\\n        ans = None\\n        while i<=j:\\n            mid = (i+j)//2\\n            if a[mid] > key: #strictly greater than key\\n                ans = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return ans\\n    \\n    def sort(self,a, i, j):\\n        heap = []\\n        heapify(heap)\\n        for k in range(i, j+1):\\n            heappush(heap, a[k])\\n        for k in range(i, j+1):\\n            a[k] = heappop(heap)\\n            \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx,n = None, len(nums)\\n        for i in range(n-2,-1,-1):\\n            if nums[i] < nums[i+1]:\\n                idx = i \\n                break\\n        if idx!=None:\\n            idx2 = self.find_ceil(nums, idx+1, n-1, nums[idx])\\n            nums[idx], nums[idx2] = nums[idx2], nums[idx]\\n            self.sort(nums, idx+1, n-1)\\n        else:\\n            nums.sort()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358174,
                "title": "java-solution-0ms-faster-than-100-submissions",
                "content": "**Please Upvote the Solution if you find it useful!!**\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null||nums.length<=1) return;\\n        \\n        int i = nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        \\n        if(i>=0)\\n        {\\n            int j = nums.length-1;\\n            while(nums[j]<=nums[i]) j--;            \\n            swap(nums,i,j);                \\n        }\\n        reverse(nums,i+1,nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;        \\n    }\\n    \\n    public void reverse(int[] nums, int i,int j)\\n    {\\n        while(i<j)\\n        swap(nums,i++,j--);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null||nums.length<=1) return;\\n        \\n        int i = nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        \\n        if(i>=0)\\n        {\\n            int j = nums.length-1;\\n            while(nums[j]<=nums[i]) j--;            \\n            swap(nums,i,j);                \\n        }\\n        reverse(nums,i+1,nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;        \\n    }\\n    \\n    public void reverse(int[] nums, int i,int j)\\n    {\\n        while(i<j)\\n        swap(nums,i++,j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313889,
                "title": "c-100-faster-easy-2-approaches",
                "content": "**1. OPTIMAL APPROACH**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n        for(k=n-2; k>=0; k--){\\n            if(nums[k]<nums[k+1]){\\n                break;\\n            }\\n        }\\n        if(k<0){\\n            reverse(nums.begin(), nums.end());\\n        }\\n        else{\\n            for(l=n-1; l>k; l--){\\n                if(nums[l]>nums[k]){\\n                    break;\\n                }\\n            }\\n            swap(nums[l], nums[k]);\\n            reverse(nums.begin()+k+1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n**2. STL function**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n        for(k=n-2; k>=0; k--){\\n            if(nums[k]<nums[k+1]){\\n                break;\\n            }\\n        }\\n        if(k<0){\\n            reverse(nums.begin(), nums.end());\\n        }\\n        else{\\n            for(l=n-1; l>k; l--){\\n                if(nums[l]>nums[k]){\\n                    break;\\n                }\\n            }\\n            swap(nums[l], nums[k]);\\n            reverse(nums.begin()+k+1, nums.end());\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968963,
                "title": "faster-easy-understanding-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i,n=nums.size();\\n        for(i=n-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        int j=i-1;\\n        int index=j;\\n        for(int i=n-1;j!=-1 && i>j;i--){\\n            if(nums[i]>nums[j]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(j!=-1)\\n        swap(nums[j],nums[index]);\\n        reverse(nums.begin()+j+1,nums.end());\\n        \\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i,n=nums.size();\\n        for(i=n-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        int j=i-1;\\n        int index=j;\\n        for(int i=n-1;j!=-1 && i>j;i--){\\n            if(nums[i]>nums[j]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(j!=-1)\\n        swap(nums[j],nums[index]);\\n        reverse(nums.begin()+j+1,nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806532,
                "title": "rust-usual-solutoin",
                "content": "```\\nimpl Solution {\\n    pub fn next_permutation(nums: &mut Vec<i32>) {\\n        let l = nums.len();\\n        let (mut i, mut j) = (l-1, l-1);\\n\\t\\t\\n\\t\\t// get the index of last increasing subseq elem from right\\n        while i > 0 && nums[i-1] >= nums[i] { i -= 1; }\\n\\t\\t\\n\\t\\t// nums[i-1] is the smallest in range (i-1..len-1)\\n\\t\\t// elems from (i..len - 1) are in descending\\n        if i > 0 {\\n\\t\\t\\t// get index of the first element >= nums[i-1]\\n\\t\\t\\t// equivalent to sorting the element in ascending and get the index of element right after nums[i-1]\\n             while j >= i && nums[j] <= nums[i-1] { j -= 1; }\\n\\t\\t\\t // swap the smallest and next greater element\\n             nums.swap(i-1, j);\\n        }\\n\\n\\t\\t// reverse the elements from (i to len - 1) to convert to ascending\\n        nums[i..l].reverse();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn next_permutation(nums: &mut Vec<i32>) {\\n        let l = nums.len();\\n        let (mut i, mut j) = (l-1, l-1);\\n\\t\\t\\n\\t\\t// get the index of last increasing subseq elem from right\\n        while i > 0 && nums[i-1] >= nums[i] { i -= 1; }\\n\\t\\t\\n\\t\\t// nums[i-1] is the smallest in range (i-1..len-1)\\n\\t\\t// elems from (i..len - 1) are in descending\\n        if i > 0 {\\n\\t\\t\\t// get index of the first element >= nums[i-1]\\n\\t\\t\\t// equivalent to sorting the element in ascending and get the index of element right after nums[i-1]\\n             while j >= i && nums[j] <= nums[i-1] { j -= 1; }\\n\\t\\t\\t // swap the smallest and next greater element\\n             nums.swap(i-1, j);\\n        }\\n\\n\\t\\t// reverse the elements from (i to len - 1) to convert to ascending\\n        nums[i..l].reverse();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545263,
                "title": "python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx = len(nums)-2\\n        while idx>=0:\\n            if nums[idx]<nums[idx+1]:\\n                break\\n            idx-=1\\n        if idx < 0:\\n            nums.sort()\\n            return\\n        \\n        nextIdx = idx+1\\n        while nextIdx<len(nums) and nums[nextIdx]>nums[idx]:\\n            nextIdx+=1\\n        \\n        #swap idx and nextIdx\\n        nums[idx], nums[nextIdx-1] = nums[nextIdx-1], nums[idx]\\n        nums[idx+1:] = nums[idx+1:][::-1]\\n\\t\\t\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 2 -> first element which is smaller that next element \\n\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 3 -> smallest emlement which is larget that 2\\n\\n# 1\\u3000\\u30003\\u3000\\u30007\\u3000\\u30004\\u3000\\u30002\\u3000\\u30001   swap 2 and 3\\n\\n# 1\\u3000\\u30003\\u3000\\u3000[1\\u3000\\u30002\\u3000\\u30004\\u3000\\u30007]   sort nums after 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx = len(nums)-2\\n        while idx>=0:\\n            if nums[idx]<nums[idx+1]:\\n                break\\n            idx-=1\\n        if idx < 0:\\n            nums.sort()\\n            return\\n        \\n        nextIdx = idx+1\\n        while nextIdx<len(nums) and nums[nextIdx]>nums[idx]:\\n            nextIdx+=1\\n        \\n        #swap idx and nextIdx\\n        nums[idx], nums[nextIdx-1] = nums[nextIdx-1], nums[idx]\\n        nums[idx+1:] = nums[idx+1:][::-1]\\n\\t\\t\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 2 -> first element which is smaller that next element \\n\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 3 -> smallest emlement which is larget that 2\\n\\n# 1\\u3000\\u30003\\u3000\\u30007\\u3000\\u30004\\u3000\\u30002\\u3000\\u30001   swap 2 and 3\\n\\n# 1\\u3000\\u30003\\u3000\\u3000[1\\u3000\\u30002\\u3000\\u30004\\u3000\\u30007]   sort nums after 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412808,
                "title": "c-beats-100-on-memory-with-explanation",
                "content": "```\\n    void nextPermutation(vector<int>& nums) { // Example <1,0,3,2>\\n\\t// We need the next permutation to be <1,2,0,3>\\n\\t// Start from the right side and find the first element that is less than the one immediately after it. \\n\\t// That is 0.\\n\\t\\n        auto inversionPoint = is_sorted_until(rbegin(nums),rend(nums));\\n        if (inversionPoint == rend(nums)) { // Note that if no element is found that smaller than the one\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// immediately after it we have reached the end of the vector, meaning we are at the last valid permutation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// In that case, we want to return the first permutation (simply sort the vector).\\n            reverse(rbegin(nums),rend(nums)); // Using reverse on a vector sorted in ascending order \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//(from right to left) will yield a vector that is sorted from left to right.\\n            return; \\n        }\\n        auto lowestUpper = upper_bound(rbegin(nums),inversionPoint, *inversionPoint); // Now we need to find the first number\\n\\t    // that is higher than our inversion point of 0. That is 2.\\n        \\n\\t\\titer_swap(lowestUpper, inversionPoint); // We swap 0 and 2. We now have <1, 2, 3, 0>\\n        reverse(rbegin(nums), inversionPoint); // We reverse from 0 to 2 non inclusive of 2 \\n        return; // We now arrive at  <1,2, 0, 3>\\n    }\\n\\t\\n\\t// If this was helpful please give me reputation. Thanks!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    void nextPermutation(vector<int>& nums) { // Example <1,0,3,2>\\n\\t// We need the next permutation to be <1,2,0,3>\\n\\t// Start from the right side and find the first element that is less than the one immediately after it. \\n\\t// That is 0.\\n\\t\\n        auto inversionPoint = is_sorted_until(rbegin(nums),rend(nums));\\n        if (inversionPoint == rend(nums)) { // Note that if no element is found that smaller than the one\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// immediately after it we have reached the end of the vector, meaning we are at the last valid permutation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// In that case, we want to return the first permutation (simply sort the vector).\\n            reverse(rbegin(nums),rend(nums)); // Using reverse on a vector sorted in ascending order \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//(from right to left) will yield a vector that is sorted from left to right.\\n            return; \\n        }\\n        auto lowestUpper = upper_bound(rbegin(nums),inversionPoint, *inversionPoint); // Now we need to find the first number\\n\\t    // that is higher than our inversion point of 0. That is 2.\\n        \\n\\t\\titer_swap(lowestUpper, inversionPoint); // We swap 0 and 2. We now have <1, 2, 3, 0>\\n        reverse(rbegin(nums), inversionPoint); // We reverse from 0 to 2 non inclusive of 2 \\n        return; // We now arrive at  <1,2, 0, 3>\\n    }\\n\\t\\n\\t// If this was helpful please give me reputation. Thanks!",
                "codeTag": "Unknown"
            },
            {
                "id": 13902,
                "title": "simple-javascript-o-n-same-as-556-next-greater-element-iii",
                "content": "```\\nvar nextPermutation = function(nums) {\\n    let j = nums.length - 1, i = j - 1;\\n    while (nums[i + 1] <= nums[i]) i--;\\n    if (~i) {\\n        while (nums[j] <= nums[i]) j--;\\n        swap(nums, i, j);\\n    }\\n    for (let k = i + 1, stop = (i + nums.length) / 2; k < stop; k++) {\\n        swap(nums, k, nums.length - k + i);\\n    }\\n};\\n\\nfunction swap(nums, i, j) {\\n    let temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n```\\nSee [#556](https://discuss.leetcode.com/topic/86405/javascript-o-log-n-time-and-o-1-space-using-buckets) for the strategy.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextPermutation = function(nums) {\\n    let j = nums.length - 1, i = j - 1;\\n    while (nums[i + 1] <= nums[i]) i--;\\n    if (~i) {\\n        while (nums[j] <= nums[i]) j--;\\n        swap(nums, i, j);\\n    }\\n    for (let k = i + 1, stop = (i + nums.length) / 2; k < stop; k++) {\\n        swap(nums, k, nums.length - k + i);\\n    }\\n};\\n\\nfunction swap(nums, i, j) {\\n    let temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13981,
                "title": "o-n-1ms-java-solution-with-comments",
                "content": "        public void nextPermutation(int[] nums) {\\n            // Degenerate case.\\n            if (nums.length < 2) {\\n                return;\\n            }\\n    \\n            // Step 0: Working from right to left, find the index i of the first decreased value.\\n            int indexOfFirstDecrease;\\n            indexOfFirstDecrease = nums.length - 2;\\n            while (indexOfFirstDecrease >= 0 && nums[indexOfFirstDecrease] >= nums[indexOfFirstDecrease + 1]) {\\n                indexOfFirstDecrease--;\\n            }\\n    \\n            // Step 1: If it's a strictly decreasing array, there is no greater permutation, so we need to find the least\\n            // according to the problem statement. We can do this by reversing the array so it is strictly increasing.\\n            // Then we're finished.\\n            if (indexOfFirstDecrease == -1) {\\n                for (int j = 0; j < nums.length / 2; j++) {\\n                    int temp = nums[j];\\n                    nums[j] = nums[nums.length - 1 - j];\\n                    nums[nums.length - 1 - j] = temp;\\n                }\\n                return;\\n            }\\n    \\n            // Step 2: Find next-greatest number in the subpermutation after nums[indexOfFirstDecrease];\\n            // This works because we know that nums[i + 1], ..., nums[nums.length - 1] are in strictly non-increasing order\\n            int indexOfNextGreatestNumber = indexOfFirstDecrease + 1;\\n            while (indexOfNextGreatestNumber < nums.length - 1 && nums[indexOfNextGreatestNumber + 1] > nums[indexOfFirstDecrease]) {\\n                indexOfNextGreatestNumber++;\\n            }\\n    \\n            // Step 3: Interchange the values at indexOfFirstDecrease and indexOfNextGreatestNumber.\\n            int interchangeTemp = nums[indexOfFirstDecrease];\\n            nums[indexOfFirstDecrease] = nums[indexOfNextGreatestNumber];\\n            nums[indexOfNextGreatestNumber] = interchangeTemp;\\n    \\n            // Step 4: Reverse the values between indices (indexOfFirstDecrease + 1) and (nums.length - 1)\\n            int init = indexOfFirstDecrease + 1;\\n            for (int k = 0; k < (nums.length - init) / 2; k++) {\\n                int temp = nums[init + k];\\n                nums[init + k] = nums[nums.length - 1 - k];\\n                nums[nums.length - 1 - k] = temp;\\n            }\\n        }",
                "solutionTags": [],
                "code": "        public void nextPermutation(int[] nums) {\\n            // Degenerate case.\\n            if (nums.length < 2) {\\n                return;\\n            }\\n    \\n            // Step 0: Working from right to left, find the index i of the first decreased value.\\n            int indexOfFirstDecrease;\\n            indexOfFirstDecrease = nums.length - 2;\\n            while (indexOfFirstDecrease >= 0 && nums[indexOfFirstDecrease] >= nums[indexOfFirstDecrease + 1]) {\\n                indexOfFirstDecrease--;\\n            }\\n    \\n            // Step 1: If it's a strictly decreasing array, there is no greater permutation, so we need to find the least\\n            // according to the problem statement. We can do this by reversing the array so it is strictly increasing.\\n            // Then we're finished.\\n            if (indexOfFirstDecrease == -1) {\\n                for (int j = 0; j < nums.length / 2; j++) {\\n                    int temp = nums[j];\\n                    nums[j] = nums[nums.length - 1 - j];\\n                    nums[nums.length - 1 - j] = temp;\\n                }\\n                return;\\n            }\\n    \\n            // Step 2: Find next-greatest number in the subpermutation after nums[indexOfFirstDecrease];\\n            // This works because we know that nums[i + 1], ..., nums[nums.length - 1] are in strictly non-increasing order\\n            int indexOfNextGreatestNumber = indexOfFirstDecrease + 1;\\n            while (indexOfNextGreatestNumber < nums.length - 1 && nums[indexOfNextGreatestNumber + 1] > nums[indexOfFirstDecrease]) {\\n                indexOfNextGreatestNumber++;\\n            }\\n    \\n            // Step 3: Interchange the values at indexOfFirstDecrease and indexOfNextGreatestNumber.\\n            int interchangeTemp = nums[indexOfFirstDecrease];\\n            nums[indexOfFirstDecrease] = nums[indexOfNextGreatestNumber];\\n            nums[indexOfNextGreatestNumber] = interchangeTemp;\\n    \\n            // Step 4: Reverse the values between indices (indexOfFirstDecrease + 1) and (nums.length - 1)\\n            int init = indexOfFirstDecrease + 1;\\n            for (int k = 0; k < (nums.length - init) / 2; k++) {\\n                int temp = nums[init + k];\\n                nums[init + k] = nums[nums.length - 1 - k];\\n                nums[nums.length - 1 - k] = temp;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14106,
                "title": "share-my-short-solution",
                "content": "    public void nextPermutation(int[] num) {\\n           int start = num.length - 1;\\n           while (start > 0 && num[start-1] >= num[start]) start--;\\n           if (start > 0) {\\n               int end = num.length - 1;\\n               while (num[end] <= num[start-1]) end--;\\n               swap(num, start-1, end);\\n           }\\n           //we don't need to sort, we can just reverse it\\n           for (int i=start; i<(start+num.length)/2; i++) {\\n               swap(num, i, num.length-1+start-i);\\n           }\\n        }\\n        \\n        void swap(int[] A, int i, int j) {\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }",
                "solutionTags": [],
                "code": "    public void nextPermutation(int[] num) {\\n           int start = num.length - 1;\\n           while (start > 0 && num[start-1] >= num[start]) start--;\\n           if (start > 0) {\\n               int end = num.length - 1;\\n               while (num[end] <= num[start-1]) end--;\\n               swap(num, start-1, end);\\n           }\\n           //we don't need to sort, we can just reverse it\\n           for (int i=start; i<(start+num.length)/2; i++) {\\n               swap(num, i, num.length-1+start-i);\\n           }\\n        }\\n        \\n        void swap(int[] A, int i, int j) {\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 4079304,
                "title": "3-approaches-well-explained-bruteforce-better-optimized",
                "content": "# Approach 1: Brute Force \\uD83E\\uDDD0\\n\\n### Intuition \\uD83E\\uDD14\\nWe want to find the next lexicographically greater permutation of an array of integers, `nums`.\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\nThe brute force solution has three steps:\\n1. Find all possible permutations of given array `nums`.\\n2. Linearly search for the given permutation.\\n3. Return the very next permutation of the given found permutation.\\n\\n### Time Complexity \\u23F3\\n- **Generating All Permutations:** Generating all permutations of an array with N elements has a time complexity of O(N!). This is because there are N! (N factorial) possible permutations of an array of size N.\\n\\n- **Finding a Particular Arrangement Linearly:** After generating all permutations, you would need to linearly search for a particular arrangement. This search would also take O(N!) time in the worst case because you might need to go through all permutations to find the desired one.\\n\\n- **Returning the Next Permutation of the Found Permutation:** Once you\\'ve found the desired permutation, finding the next permutation of it would also take O(N) time because you need to follow the steps for finding the next permutation on that specific permutation.\\n\\nThus, the time complexity of this approach would be O(N!) due to the generation of all permutations. It\\'s an inefficient approach, especially for large values of N, and is likely to give a **TLE**.\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe space complexity for generating all permutations of an array with N elements is O(N!) because you\\'re storing N! different permutations.\\n\\n# Approach 2: Better Solution (only for cpp users) - Using `next_permutation()` fun\\uD83E\\uDDD0\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\nWe can use the `next_permutation()` function. The next_permutation function is a part of the C++ Standard Library\\'s `<algorithm>` header. It\\'s used to generate the next lexicographically greater permutation of a vector.\\n\\n### Time Complexity \\u23F3\\nThe time complexity of the `next_permutation()` function is O(N), where N is the size of the input vector (nums in this case).\\nThe function traverses the vector from right to left to find the first pair of two consecutive elements such that the left element is less than the right element. This operation takes O(N) time in the worst case.\\nThe subsequent operations, such as finding the smallest greater element and reversing the subarray, also take O(N) time in total.\\nSo, the overall time complexity is O(N).\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe next_permutation function operates in-place and does not use any additional memory that scales with the input size. Therefore, the space complexity of the nextPermutation function is O(1), which means it uses constant extra memory.\\n\\n### Code \\uD83D\\uDCBB\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\\n\\n# Approach 3: Optimized Solution \\uD83E\\uDDD0\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\n- Like in a dictionary the very next word to a given word is almost the same except for a very few alphabets, e.g. in a dictionary Fire would come after fira. Notice how the first three alphabets are the same?\\n- Observing this lexicographical order in an English dictionary, we apply a similar approach in the array as well.\\n- Given array `nums` we find a **break point**. What is a breakpoint exactly and why are we finding it?\\n- Notice that the next permutation of [1,2,5,4,3,0] -> [1,3,5,4,2,0] -> [1,3,0,2,4,5]. Observe how two numbers have been swapped( 2 and 3) first, and then the rest of the array is reversed.\\n- This is because 2 is a breakpoint. A breakpoint here refers to a point that is lesser than the next element in the array.\\n- We traverse `nums` starting from i=n-2th index. We compare each `nums[i]` with `nums[i+1]`. If at any index `i`, `nums[i]`<`nums[i+1]`, we set `i` as out `breakindex` variable.\\n- Now after we\\'ve found the `breakindex`, we traverse the right half of the `nums` array after `breakindex`, so from `i=n-1` till `i=breakpint+1`, and look for the least greater after the `breakpoint`.\\n- In the array example taken above, index 1 was the `breakindex` and we traverse from element 5 to 0 and find that 3 is the least element greater than 1 in that portion of the array.\\n- Now, we swap the `breakindex` element with this `leastgreat` index element.\\n- Now we reverse the array from `breakindex+1` to `n-1`.\\n-**Edge case:** It may happen that the array in the input is the last possible maximum permutation possible for the elements like: [5,4,3,3,2,0], so the next permutation will be the reverse of it which is the first smallest possible permutation of the elements. So in case we do not find a `breakpoint` like in this case, we simply reverse the given `nums` array.\\n\\n### Time Complexity \\u23F3\\nThe time complexity of this approach is linear. We traverse the array twice: first to find the `breakpoint` and then to find the least greater element. Each traversal takes O(N) time.tore indices and values.\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe space complexity is constant O(1) because the algorithm operates in-place without using any additional data structures that scale with the input size. \\n\\n### Code \\uD83D\\uDCBB\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        //find the breakpoint\\n        int breakpoint=-1;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n          if(nums[i]<nums[i+1]){\\n            breakpoint=i;\\n            break;\\n          }  \\n        } \\n        if(breakpoint==-1){reverse(nums.begin(),nums.end());return;}\\n        \\n        //find least greater of element at the breakpoint\\n        int leastgreater=-1; \\n        int leastGvalue=101;\\n        for(int i=n-1;i>breakpoint;i--){\\n            if(nums[i]>nums[breakpoint]){\\n                if(nums[i]<leastGvalue){\\n                    leastgreater=i;\\n                    leastGvalue=nums[i];\\n                }\\n            }\\n        }\\n\\n        //now swap breakpoint with leastgreater\\n        swap(nums[breakpoint],nums[leastgreater]);\\n        \\n        //reverse everything after the breakpoint\\n        reverse(nums.begin()+breakpoint+1,nums.end());\\nreturn;\\n}\\n};\\n```\\n\\n![CAN YOU PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/fc2c0af7-4f47-44cf-b680-292fe4f08da0_1695449550.2816818.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        //find the breakpoint\\n        int breakpoint=-1;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n          if(nums[i]<nums[i+1]){\\n            breakpoint=i;\\n            break;\\n          }  \\n        } \\n        if(breakpoint==-1){reverse(nums.begin(),nums.end());return;}\\n        \\n        //find least greater of element at the breakpoint\\n        int leastgreater=-1; \\n        int leastGvalue=101;\\n        for(int i=n-1;i>breakpoint;i--){\\n            if(nums[i]>nums[breakpoint]){\\n                if(nums[i]<leastGvalue){\\n                    leastgreater=i;\\n                    leastGvalue=nums[i];\\n                }\\n            }\\n        }\\n\\n        //now swap breakpoint with leastgreater\\n        swap(nums[breakpoint],nums[leastgreater]);\\n        \\n        //reverse everything after the breakpoint\\n        reverse(nums.begin()+breakpoint+1,nums.end());\\nreturn;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009650,
                "title": "explained-every-step-0ms-100-beats-java",
                "content": "# Approach\\n- First we have to find where i < i+1 while we are traversing the array from second last element , second last beacause we are comapring it with i+1.If we start from last then it will give index out of bound.When we find that point where i < i+1 we store that i index in variable name ind which is firstly intialised as -1.\\nlet understand why we are doing this,\\n```\\n->In question asked of next permutation of given arr elements . \\nLet suppose the given arr = [1 2 3]\\nwe can rearrange it in 6 different ways or we say there is 3! permutations , which are\\n 1 2 3\\n 1 3 2<- This is our answer \\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we can see 1 3 2  > 1 2 3,\\n->so we have to check and take that prefix,if we make change on that then our modified array is greater then previous array . \\nunderstand this with different example \\n;-                  i    i+1\\n                    ^    ^\\ngiven arr = [1 , 2 , 0 , 5 , 1]\\n             this is where our condition stops \\nNow we store this i in ind variable and break the loop.\\n```\\n- We can\\'t directly swap i with i+1 or any other number which can make array greater then previous beacuse output is according to the sorted permutation so we have to update it in sorted order before that think of edge case \\n```\\nEDGE CASE \\ngiven arr = [3 2 1]\\nAll permutation : -\\n 1 2 3\\n 1 3 2\\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we there is no next permutaion of  3 2 1  then we return the first permutation means\\n1 2 3 is our output in this case and we can get it by just reversing the array .\\n```\\n- Now lets decide with which element we can swap our ind index in order to make **Greater then previous** and **Next Permutation**\\n```\\ngiven arr = [1 2 0 5 1]\\n            0 1 2 3 4<-Index\\nind  = 2 \\nnow we have 5 and 1 to swap with ind index in order to make it greater then previous array , \\ni can\\'t write all possible permutaion of  1 2 0 5 1 but i just write the next permutation of it which is \\n  1 2 1 0 5 is our next permutaion\\n->Now if we swap i with 5 then our array is greater but not our next permutation \\n-> If we swap ind index value with 1 then our array is \\n1 2 1 5 0\\n->So by this we understanded we have to pick smallest from all larger elements\\n->0(ind index value)<1<5,just greater then ind index value and smaller then all choices we have.\\n->We can find this by traversing the array from last to ind or 0.\\nif(a[i]>a[ind]){\\nswap(a[i],a[ind]);\\nbreak;\\n}\\nNow after this we have 1 2 1 5 0\\n```\\n- After this we have to sort the remainig array in order to make next permutation we can do it simply by reversing the array from ind+1 to a.legnth-1.\\n```\\n1 2 1 5 0<-a.length-1\\n      ^ \\n    ind+1\\nif we just reverse this portion then\\n 1  2 1 0 5 is array and this is also next permutation of our given array.\\n```\\n\\n---\\n\\n*If there is some doubt or any mistake i have done in explaining please let me know in comments \\uD83D\\uDE4F*\\n# Complexity\\nin place and use only constant extra memory.\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int ind = -1;\\n        for(int i = a.length-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1){\\n            arev(a,0,a.length-1);\\n            return;\\n        }\\n        for(int i = a.length-1;i>=0;i--){\\n            if(a[i]>a[ind]){\\n                int temp = a[i];\\n                a[i]=a[ind];\\n                a[ind]=temp;\\n                break;\\n            }\\n        }\\n        arev(a,ind+1,a.length-1);\\n\\n    }\\n        static void arev(int[] a,int low,int high){\\n        while(low<high){\\n            int temp = a[low];\\n            a[low]=a[high];\\n            a[high]=temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n->In question asked of next permutation of given arr elements . \\nLet suppose the given arr = [1 2 3]\\nwe can rearrange it in 6 different ways or we say there is 3! permutations , which are\\n 1 2 3\\n 1 3 2<- This is our answer \\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we can see 1 3 2  > 1 2 3,\\n->so we have to check and take that prefix,if we make change on that then our modified array is greater then previous array . \\nunderstand this with different example \\n;-                  i    i+1\\n                    ^    ^\\ngiven arr = [1 , 2 , 0 , 5 , 1]\\n             this is where our condition stops \\nNow we store this i in ind variable and break the loop.\\n```\n```\\nEDGE CASE \\ngiven arr = [3 2 1]\\nAll permutation : -\\n 1 2 3\\n 1 3 2\\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we there is no next permutaion of  3 2 1  then we return the first permutation means\\n1 2 3 is our output in this case and we can get it by just reversing the array .\\n```\n```\\ngiven arr = [1 2 0 5 1]\\n            0 1 2 3 4<-Index\\nind  = 2 \\nnow we have 5 and 1 to swap with ind index in order to make it greater then previous array , \\ni can\\'t write all possible permutaion of  1 2 0 5 1 but i just write the next permutation of it which is \\n  1 2 1 0 5 is our next permutaion\\n->Now if we swap i with 5 then our array is greater but not our next permutation \\n-> If we swap ind index value with 1 then our array is \\n1 2 1 5 0\\n->So by this we understanded we have to pick smallest from all larger elements\\n->0(ind index value)<1<5,just greater then ind index value and smaller then all choices we have.\\n->We can find this by traversing the array from last to ind or 0.\\nif(a[i]>a[ind]){\\nswap(a[i],a[ind]);\\nbreak;\\n}\\nNow after this we have 1 2 1 5 0\\n```\n```\\n1 2 1 5 0<-a.length-1\\n      ^ \\n    ind+1\\nif we just reverse this portion then\\n 1  2 1 0 5 is array and this is also next permutation of our given array.\\n```\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int ind = -1;\\n        for(int i = a.length-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1){\\n            arev(a,0,a.length-1);\\n            return;\\n        }\\n        for(int i = a.length-1;i>=0;i--){\\n            if(a[i]>a[ind]){\\n                int temp = a[i];\\n                a[i]=a[ind];\\n                a[ind]=temp;\\n                break;\\n            }\\n        }\\n        arev(a,ind+1,a.length-1);\\n\\n    }\\n        static void arev(int[] a,int low,int high){\\n        while(low<high){\\n            int temp = a[low];\\n            a[low]=a[high];\\n            a[high]=temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404423,
                "title": "c-beat-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for(int i = 0; i < n-1; i++) {\\n          if(nums[i]<nums[i+1]) idx = i;\\n        }\\n        if(idx == -1) {\\n          reverse(nums.begin(), nums.end());\\n          return;\\n        }\\n        int l = idx + 1;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > nums[idx]) l = i;\\n        }\\n        swap(nums[idx], nums[l]);\\n        reverse(nums.begin() + 1 + idx, nums.end());\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for(int i = 0; i < n-1; i++) {\\n          if(nums[i]<nums[i+1]) idx = i;\\n        }\\n        if(idx == -1) {\\n          reverse(nums.begin(), nums.end());\\n          return;\\n        }\\n        int l = idx + 1;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > nums[idx]) l = i;\\n        }\\n        swap(nums[idx], nums[l]);\\n        reverse(nums.begin() + 1 + idx, nums.end());\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332720,
                "title": "simple-solution-in-python",
                "content": "\\nimport itertools\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        \"\"\"\\n        1. From right to left find the one with misorer match that is the one that not in ascending            order\\n        2.Swap the element with next greatest element from its rigth sub array\\n        3.the reverse the right sub arrray (but here it is already reversed)\\n        \"\"\"\\n        right_subarr,n=[],len(nums)\\n        right_subarr.append(nums[-1]) \\n        for i in range(n-2,-1,-1):\\n            if nums[i]>=right_subarr[-1]:right_subarr.append(nums[i])\\n            else:\\n                temp=right_subarr[:]\\n                temp.sort()\\n                for next_greatest in temp:\\n                    if next_greatest>nums[i]:\\n                        m=next_greatest\\n                        break\\n                ind=right_subarr.index(m)\\n                \\n                nums[i],right_subarr[ind]=right_subarr[ind],nums[i]\\n                break\\n        if len(right_subarr)==n: nums[:]=right_subarr[:]\\n        else: nums[i+1:n]=right_subarr[:]\\n        print(right_subarr,nums)\\n        \\n        \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\nimport itertools\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        \"\"\"\\n        1. From right to left find the one with misorer match that is the one that not in ascending            order\\n        2.Swap the element with next greatest element from its rigth sub array\\n        3.the reverse the right sub arrray (but here it is already reversed)\\n        \"\"\"\\n        right_subarr,n=[],len(nums)\\n        right_subarr.append(nums[-1]) \\n        for i in range(n-2,-1,-1):\\n            if nums[i]>=right_subarr[-1]:right_subarr.append(nums[i])\\n            else:\\n                temp=right_subarr[:]\\n                temp.sort()\\n                for next_greatest in temp:\\n                    if next_greatest>nums[i]:\\n                        m=next_greatest\\n                        break\\n                ind=right_subarr.index(m)\\n                \\n                nums[i],right_subarr[ind]=right_subarr[ind],nums[i]\\n                break\\n        if len(right_subarr)==n: nums[:]=right_subarr[:]\\n        else: nums[i+1:n]=right_subarr[:]\\n        print(right_subarr,nums)\\n        \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224452,
                "title": "next-permutation-o-n-solution-in-python",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChange the array from the last and not from the start as it will change it drastically and we have to increase the sequence as little as possible\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- example: [2,3,8,5,4,1,0]\\n- First identify the longest non increasing subarray  from the last i.e [8,5,4,1,0]\\n- If whole array is in descending order, its already the largest permutation so just reverse it \\n- Now will swap the element to the left of the longest subarray(3) with the smallest element from the subarray i.e larger than that element. To find the element we will traverse from end untill you find element just greater than (3) i.e (4).\\n- Now swap them to get [2,4,8,5,3,1,0]\\n- Now just reverse the longest non increasing subarray(since its already in descending order) to get the smallest permutation i.e [2,4,0,1,3,5,8]\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        i=len(nums)-1\\n        while i>0 and nums[i-1]>=nums[i]:\\n            i=i-1\\n        if i<1:\\n            nums[:]=nums[::-1]\\n        else:\\n            j=len(nums)-1 #last element \\n            #we have to find element from last that is greater than nums[i-1]\\n            while nums[j]<=nums[i-1]:\\n                j=j-1\\n            nums[i-1], nums[j]= nums[j], nums[i-1]\\n            nums[i:]=reversed(nums[i:])\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        i=len(nums)-1\\n        while i>0 and nums[i-1]>=nums[i]:\\n            i=i-1\\n        if i<1:\\n            nums[:]=nums[::-1]\\n        else:\\n            j=len(nums)-1 #last element \\n            #we have to find element from last that is greater than nums[i-1]\\n            while nums[j]<=nums[i-1]:\\n                j=j-1\\n            nums[i-1], nums[j]= nums[j], nums[i-1]\\n            nums[i:]=reversed(nums[i:])\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113745,
                "title": "easiest-o-n-solution-in-c-with-approach",
                "content": "# Approach\\nstep 1: find the element with a[i]>a[i-1];\\nstep 2: if non found then return a sort array.\\nstep 3: find the just greater element than step 1 element.\\nstep 4: swap step 3 and step 1 elements and reverse/sort the element before the step 1 index.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        // 1 3 5 4 2\\n        //find a[i]>a[i+1]\\n        int toswap=INT_MIN,withswap=INT_MIN;\\n        for(int i=a.size()-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                toswap=i-1;\\n                break;\\n            }\\n        }\\n        //edge case\\n        if(toswap==INT_MIN) return reverse(a.begin(),a.end());\\n        //just greater element than toswap.\\n        else{\\n            for(int i=a.size()-1;i>toswap;i--){\\n                if(a[i]>a[toswap]){\\n                    withswap=i;\\n                    break;\\n                }\\n            }\\n            swap(a[toswap],a[withswap]);\\n            return reverse(a.begin()+toswap+1,a.end()); \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        // 1 3 5 4 2\\n        //find a[i]>a[i+1]\\n        int toswap=INT_MIN,withswap=INT_MIN;\\n        for(int i=a.size()-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                toswap=i-1;\\n                break;\\n            }\\n        }\\n        //edge case\\n        if(toswap==INT_MIN) return reverse(a.begin(),a.end());\\n        //just greater element than toswap.\\n        else{\\n            for(int i=a.size()-1;i>toswap;i--){\\n                if(a[i]>a[toswap]){\\n                    withswap=i;\\n                    break;\\n                }\\n            }\\n            swap(a[toswap],a[withswap]);\\n            return reverse(a.begin()+toswap+1,a.end()); \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936089,
                "title": "time-o-n-easy-to-understanding",
                "content": "# Code\\n```\\nclass Solution(object):\\n    # To Reverse the Part of a List/Array\\n    def reverseLst(self,lst,left,right):\\n        while left < right:\\n            lst[left],lst[right] = lst[right],lst[left]\\n            left += 1\\n            right -= 1\\n        return lst\\n\\n    def nextPermutation(self, nums):\\n        numsLen = len(nums)\\n\\n        # Reaching the element which is Greater than the next and near to the right, and the element\\'s idx is  eleIdx\\n        eleIdx = numsLen - 1\\n        while 0 < eleIdx and nums[eleIdx-1] >= nums[eleIdx]:\\n            eleIdx -= 1\\n\\n        # if the eleIdx is 0 that mean the Whole lst is reversely sorted in this case just return the sorted array but don\\'t sort Just reverse it to get the sorted lst\\n        if eleIdx == 0:\\n            return self.reverseLst(nums,0,numsLen -1)\\n\\n        # Reversing the right sub array from the eleIdx to end -> indirectly Sorting\\n        nums = self.reverseLst(nums,eleIdx,numsLen -1)\\n\\n        # mainEle is the element that is neaded to swap with the next minum element after the mainEle\\'s idx\\n        mainEleIdx = eleIdx -1\\n\\n        # finding the right position for the mainElement and swapping it to the right position\\n        while eleIdx < numsLen and nums[mainEleIdx] >= nums[eleIdx]:\\n            eleIdx += 1\\n\\n        nums[mainEleIdx],nums[eleIdx] = nums[eleIdx],nums[mainEleIdx]\\n        return nums\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    # To Reverse the Part of a List/Array\\n    def reverseLst(self,lst,left,right):\\n        while left < right:\\n            lst[left],lst[right] = lst[right],lst[left]\\n            left += 1\\n            right -= 1\\n        return lst\\n\\n    def nextPermutation(self, nums):\\n        numsLen = len(nums)\\n\\n        # Reaching the element which is Greater than the next and near to the right, and the element\\'s idx is  eleIdx\\n        eleIdx = numsLen - 1\\n        while 0 < eleIdx and nums[eleIdx-1] >= nums[eleIdx]:\\n            eleIdx -= 1\\n\\n        # if the eleIdx is 0 that mean the Whole lst is reversely sorted in this case just return the sorted array but don\\'t sort Just reverse it to get the sorted lst\\n        if eleIdx == 0:\\n            return self.reverseLst(nums,0,numsLen -1)\\n\\n        # Reversing the right sub array from the eleIdx to end -> indirectly Sorting\\n        nums = self.reverseLst(nums,eleIdx,numsLen -1)\\n\\n        # mainEle is the element that is neaded to swap with the next minum element after the mainEle\\'s idx\\n        mainEleIdx = eleIdx -1\\n\\n        # finding the right position for the mainElement and swapping it to the right position\\n        while eleIdx < numsLen and nums[mainEleIdx] >= nums[eleIdx]:\\n            eleIdx += 1\\n\\n        nums[mainEleIdx],nums[eleIdx] = nums[eleIdx],nums[mainEleIdx]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854196,
                "title": "pen-n-paper-solution-easy-with-comments-2-solved-examples",
                "content": "![tempImageMwxUvV.jpg](https://assets.leetcode.com/users/images/b7877058-c4d1-40f1-8361-5248a2ba97a6_1669566589.0427344.jpeg)\\n![tempImageFumuEH.jpg](https://assets.leetcode.com/users/images/c9fd7d51-3776-4056-b5ef-a612ff46817f_1669566608.6524541.jpeg)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        # To find next permutations, we\\'ll start from the end\\n        \"\"\"\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number greater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now our pointer is pointing at two different positions\\n        # i. first non-ascending number from end\\n        # j. first number greater than nums[i-1]\\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        # To find next permutations, we\\'ll start from the end\\n        \"\"\"\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number greater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now our pointer is pointing at two different positions\\n        # i. first non-ascending number from end\\n        # j. first number greater than nums[i-1]\\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734334,
                "title": "clean-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        int ind1,ind2,i;\\n        for(i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(i<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]>nums[ind1]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        int temp=nums[ind1];\\n                nums[ind1]=nums[ind2];\\n                nums[ind2]=temp;\\n        \\n        reverse(nums.begin()+ind1+1,nums.end());  \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        int ind1,ind2,i;\\n        for(i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(i<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]>nums[ind1]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        int temp=nums[ind1];\\n                nums[ind1]=nums[ind2];\\n                nums[ind2]=temp;\\n        \\n        reverse(nums.begin()+ind1+1,nums.end());  \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570943,
                "title": "clean-code-with-comments-1ms",
                "content": "```\\nclass Solution {\\n    private void reverse(int[] arr, int start){\\n        int end = arr.length-1;\\n        while(start < end){\\n            swap(arr, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length-2;\\n        // decreasing order find kro \\n        while(i>=0 && nums[i] >= nums[i+1]){\\n            i--;\\n        }\\n        // jese hi mila swap krdo\\n        if(i>=0){\\n            // required element dhundo swap krne ke liye \\n            int j = nums.length-1;\\n            while(j>=0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            // jese hi element miljaye swap krdo \\n            swap(nums, i, j);\\n        }\\n        // reverse krdo baki ka \\n        reverse(nums, i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private void reverse(int[] arr, int start){\\n        int end = arr.length-1;\\n        while(start < end){\\n            swap(arr, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length-2;\\n        // decreasing order find kro \\n        while(i>=0 && nums[i] >= nums[i+1]){\\n            i--;\\n        }\\n        // jese hi mila swap krdo\\n        if(i>=0){\\n            // required element dhundo swap krne ke liye \\n            int j = nums.length-1;\\n            while(j>=0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            // jese hi element miljaye swap krdo \\n            swap(nums, i, j);\\n        }\\n        // reverse krdo baki ka \\n        reverse(nums, i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316586,
                "title": "c-approach-and-intuition",
                "content": "**Basic Intution:**\\n* If we look carefully to the sample inputs we will always find an increasing order for a certain breakpoint.\\n* For e.g. in [1 2 3], the next permutation will be [1 3 2] ---> 1<3>2. Similarily in [2 1 3], the next permutation will be    [2 3 1]--->2<3>1.\\n* The only time this won\\'t apply is when the given input is in decreasing order.\\n\\n1. So, we can traverse from back and check for the index position whose value is lesser than its prior index position\\'s value. Let\\'s store it in a variable--idx1.\\n2. Next, we have to again traverse from back and check which value is greater than the idx1 position value. Swap the places to get the possible next greater element.\\n3. However, this swap will only ensure the correctness of breakpoint. We need to then, reverse the rest array elements to the right side of the breakpoint in order to find the next permutation.\\n\\n**Edge case**\\nWhen the given array is in decreasing order, the next permutation will be the same array in reverse order. So in that case we can simply just reverse the entire array. For e.g. [3 2 1] --> [1 2 3].\\n\\n**Happy Hunting**",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2126330,
                "title": "python-solution",
                "content": "i=len(nums)-2\\n        while i>=0:\\n            if(nums[i]>=nums[i+1]):\\n                i-=1\\n            else:\\n                break\\n        j=len(nums)-1\\n        if i>=0:\\n            while j>=0:\\n                if(nums[j]<=nums[i]):\\n                    j-=1\\n                else:\\n                    break\\n            nums[j],nums[i]=nums[i],nums[j]\\n        def reverse(nums,a,b):\\n            while(a<b):\\n                nums[a],nums[b]=nums[b],nums[a]\\n                a+=1\\n                b-=1\\n        reverse(nums,i+1,len(nums)-1)\\n![image](https://assets.leetcode.com/users/images/47a26b6b-9549-48f3-8f40-3fc38ecce0a1_1654963496.6587029.jpeg)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "i=len(nums)-2\\n        while i>=0:\\n            if(nums[i]>=nums[i+1]):\\n                i-=1\\n            else:\\n                break\\n        j=len(nums)-1\\n        if i>=0:\\n            while j>=0:\\n                if(nums[j]<=nums[i]):\\n                    j-=1\\n                else:\\n                    break\\n            nums[j],nums[i]=nums[i],nums[j]\\n        def reverse(nums,a,b):\\n            while(a<b):\\n                nums[a],nums[b]=nums[b],nums[a]\\n                a+=1\\n                b-=1\\n        reverse(nums,i+1,len(nums)-1)\\n![image](https://assets.leetcode.com/users/images/47a26b6b-9549-48f3-8f40-3fc38ecce0a1_1654963496.6587029.jpeg)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1927066,
                "title": "4-step-explanation-linear-time-two-pointers",
                "content": "Hello Leetcoders, Hope you are doing well.\\n\\nLet\\'s continue with **next permutation**\\n\\n**Problem statement**\\nWe have an array of Integers, we need to find next permutation of that number in lexographic (Dictionary) order.\\ne.g\\n1 3 2\\n\\nso all permutations for the give number in dictionary order will be,\\nIndex 0 -> 1 2 3\\nIndex 1 -> 1 3 2\\nIndex 2 -> 2 1 3\\nIndex 3 -> 2 3 1\\nIndex 4 -> 3 1 2\\nIndex 5 -> 3 2 1\\n\\nour answer for input 1 3 2 (at index 1) will be 2 1 3 (at index 2)\\n\\n**How can we solve this problem**\\nFirst approcah comes in our mind will be **Brute-force approach**\\n\\nwhat we can do in brute-force method is\\n\\n* Store given array into temp array\\n* Sort given input array into increasing order\\n* Create a 2D arraylist\\n* Call recusrive function and calculate all permutations and store those permutations into 2D arrayList\\n* now find index of temp array in 2D arrayList\\n* print index + 1 from 2D arrayList\\n\\nTime complexity : too bad\\nSpace complexity : not O(1) as problem says\\n\\nNow how can we optimize the solution\\n\\n**Optimal Approach**\\nAccording to problem they want next permutation of the given array which comes in **lexographic order**\\nwe use lexographic order in dictionary (normal oxford one, not python ;->)\\nIf we dive into the dictionary can think about how they organised we will find our apprach.\\n\\nwe will understand dictionary work using example i.e **1 3 5 4 2**\\n\\n**Step 1 :**\\nIf you see the array carefully you will find that first numbers is in increasing order than after certain point it is decreasing. We will call this certain point **Break-point.**\\n\\n\\nwe have to find this break-point, A simple way we can do this\\n```\\ntraverse from 2nd last index and compare nums[i] >= nums[i+1] \\nwhen this fails we will find our break-point\\n\\nin our example \\ni = 3 (2nd last index)\\n\\nfirst iteration : 4 >= 2\\ni = 2\\n\\nsecond iteration : 5 >= 4\\ni=1\\n\\nthird iteration 3 >= 5\\nbreak\\n\\nour break-point i = 1\\n```\\n\\n**Step 2**\\nwe have prefix which is arr[0, i] i.e 1 3 this need to be change in lexographic order, for that we have to replace 3 with some integer which is present in another subarray[i+1, last] i.e 5 4 2\\n\\nWhat options we have\\nReplace 3 by 5 -> 1 5\\nReplace 3 by 4 -> 1 4\\nReplace 3 by 2 -> 1 2\\n\\nbut we want our next permutaion so we have to find greater than 3 which means 2 is rejected\\nwe want in lexographic order means 1 4 comes before 1 5.\\nif you sum-up both above point it is basically saying that find smallest number which is greater than break-point integer\\n\\n```\\ntraverse from last \\nnums[j] <= nums[i]\\n\\n\\narray 1 3 5 4 2\\ni = 1\\n\\nj = 4 (last index)\\nnums[j] <= nums[i]\\n\\nfirst Iteration : 2 <= 3\\nj = 3\\n\\nsecond iteration : 4 <= 3\\nbreak\\n\\nj = 3\\n```\\n\\n**Step 3**\\nSwap both ith and jth index element to get smallest lexographic prefix\\n```\\nswap(arr, i, j)\\n\\n\\ninput = 1 3 5 4 2\\noutput = 1 4 5 3 2\\n```\\n\\n**Step 4**\\n\\nI will say again we want lexographically next permutation so we find our prifix i.e 1 4\\nnow try to find remaining combination\\n\\nso you will see after swaping, our array is 1 4 5 3 2\\ntake arr(i+1, last)\\n5 3 2\\n\\nwe want it in dictionary order so\\nreverse it 2 3 5\\n\\n**final output : 1 4 2 3 5**\\n\\n**Edge case**\\nWhat happen if we can\\'t find any break-point\\ne.g 3 2 1\\n\\nin this case step 1, 2, 3 will be skipped and we perform step 4 directly\\nreverse the arr\\n1 2 3 is our output\\n\\n**Code**\\n```\\nclass Solution {\\n   public void nextPermutation(int[] nums) {\\n       if(nums == null || nums.length <= 1) return; // base case\\n       \\n       int i = nums.length - 2; // second last index\\n       while(i >= 0 && nums[i] >= nums[i+1]) i--; // find break point\\n       \\n       if(i >= 0) { // iff we found break point\\n           int j = nums.length - 1;\\n           while(nums[j] <= nums[i]) j--; // find smallest integer greater than break-point integer\\n           \\n           swap(nums, i, j); // swap the integers\\n       }\\n       reverse(nums, i+1, nums.length - 1); // reverse array apart from prefix\\n       \\n   }\\n   \\n   private void swap(int[] arr, int i, int j) {\\n       int temp = arr[i];\\n       arr[i] = arr[j];\\n       arr[j] = temp;\\n   }\\n   \\n   private void reverse(int arr[], int left, int right) {\\n       while(left < right) {\\n           swap(arr, left++, right--);\\n       }\\n   }\\n}\\n```\\n\\n**For break-point : O(n)\\nFor Smallest integer : O(n)\\nFor Swap : O(1)\\nFor Reverse : O(n)**\\n\\nT(n) : O(n)\\nSpace complexity : O(1)\\n\\nIn case of any doubt, feel free to comment down below, Thank you",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\ntraverse from 2nd last index and compare nums[i] >= nums[i+1] \\nwhen this fails we will find our break-point\\n\\nin our example \\ni = 3 (2nd last index)\\n\\nfirst iteration : 4 >= 2\\ni = 2\\n\\nsecond iteration : 5 >= 4\\ni=1\\n\\nthird iteration 3 >= 5\\nbreak\\n\\nour break-point i = 1\\n```\n```\\ntraverse from last \\nnums[j] <= nums[i]\\n\\n\\narray 1 3 5 4 2\\ni = 1\\n\\nj = 4 (last index)\\nnums[j] <= nums[i]\\n\\nfirst Iteration : 2 <= 3\\nj = 3\\n\\nsecond iteration : 4 <= 3\\nbreak\\n\\nj = 3\\n```\n```\\nswap(arr, i, j)\\n\\n\\ninput = 1 3 5 4 2\\noutput = 1 4 5 3 2\\n```\n```\\nclass Solution {\\n   public void nextPermutation(int[] nums) {\\n       if(nums == null || nums.length <= 1) return; // base case\\n       \\n       int i = nums.length - 2; // second last index\\n       while(i >= 0 && nums[i] >= nums[i+1]) i--; // find break point\\n       \\n       if(i >= 0) { // iff we found break point\\n           int j = nums.length - 1;\\n           while(nums[j] <= nums[i]) j--; // find smallest integer greater than break-point integer\\n           \\n           swap(nums, i, j); // swap the integers\\n       }\\n       reverse(nums, i+1, nums.length - 1); // reverse array apart from prefix\\n       \\n   }\\n   \\n   private void swap(int[] arr, int i, int j) {\\n       int temp = arr[i];\\n       arr[i] = arr[j];\\n       arr[j] = temp;\\n   }\\n   \\n   private void reverse(int arr[], int left, int right) {\\n       while(left < right) {\\n           swap(arr, left++, right--);\\n       }\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910927,
                "title": "c-1-lines-std-library",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\nhttps://en.cppreference.com/w/cpp/algorithm/next_permutation",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910469,
                "title": "java-highly-commented-with-example-proof-o-n-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1st step --> Find the pivot\\n        \\n        /*iska matlab aisa number jisko tumhe actually swap karna hai basically \\n\\t\\tleft lesser value to right larger value. So yaha par pehle hum wo left lesser\\n\\t\\tvalue dhund rahe hai next step mein right larger value.Ex: 9 1 5 3 toh \\n\\t\\tisme check karo ki kab tumhe arr[idx+1]>arr[idx] mil jaaye is case mein 1st idx is pivot hoga.\\n\\t\\t*/\\n        \\n        int i = arr.length-2;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        \\n  /*why if because in case of the largest number i will be -ve itself like 3 2 1\\n  have to return the smallest arrangement i.e. 1 2 3 so simply reverse no need of \\n  2nd step */\\n\\n        \\n        /*2nd step: Find the just larger value than your arr[i] so we can swap \\n\\t\\tboth the numbers. Ex: 9 1 5 3 mein 1 and 3 will be swapped because 3 is \\n\\t\\tjust immediate larger than our arr[i] */\\n        \\n        if(i>=0){  \\n            int j = arr.length-1;\\n            while(arr[i]>=arr[j])\\n            j--;\\n            \\n            /*Step 3: Swap both the indexes i.e. i and j in our example the resultant\\n\\t\\t\\twould look like 9 3 5 1 */\\n            \\n            swap(arr,i,j);\\n        }\\n        \\n        //Step-4 : Reverse the array after the pivot point\\n        \\n         /*Why see if you look carefully our number after swap becomes 9 3 5 1 \\n\\t\\t but according to question we want the next permutation which is just \\n\\t\\t immediate greater than the given number right so our resultant final answer \\n\\t\\t should be 9 3 1 5, for that we have to reverse the array after the pivot \\n\\t\\t point i.e. reverse from (i+1,arr.length-1) also if you remember our if check \\n\\t\\t is due to what if we provided with the highest number itself so we have to \\n\\t\\t return the smallest permutation i.e. reverse the whole array so our that \\n\\t\\t purpose is also serving because what we are passing is in our \\n\\t\\t reverse array (i+1,arr.length-1) and for highest number i = -1 \\n\\t\\t so automatically due to the function it will become(0,arr.length-1) .\\n */\\n        \\n        reverse(arr,i+1,arr.length-1);\\n        \\n    }\\n    \\n    public void reverse(int[] arr,int i,int j){\\n        while(i<j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1st step --> Find the pivot\\n        \\n        /*iska matlab aisa number jisko tumhe actually swap karna hai basically \\n\\t\\tleft lesser value to right larger value. So yaha par pehle hum wo left lesser\\n\\t\\tvalue dhund rahe hai next step mein right larger value.Ex: 9 1 5 3 toh \\n\\t\\tisme check karo ki kab tumhe arr[idx+1]>arr[idx] mil jaaye is case mein 1st idx is pivot hoga.\\n\\t\\t*/\\n        \\n        int i = arr.length-2;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        \\n  /*why if because in case of the largest number i will be -ve itself like 3 2 1\\n  have to return the smallest arrangement i.e. 1 2 3 so simply reverse no need of \\n  2nd step */\\n\\n        \\n        /*2nd step: Find the just larger value than your arr[i] so we can swap \\n\\t\\tboth the numbers. Ex: 9 1 5 3 mein 1 and 3 will be swapped because 3 is \\n\\t\\tjust immediate larger than our arr[i] */\\n        \\n        if(i>=0){  \\n            int j = arr.length-1;\\n            while(arr[i]>=arr[j])\\n            j--;\\n            \\n            /*Step 3: Swap both the indexes i.e. i and j in our example the resultant\\n\\t\\t\\twould look like 9 3 5 1 */\\n            \\n            swap(arr,i,j);\\n        }\\n        \\n        //Step-4 : Reverse the array after the pivot point\\n        \\n         /*Why see if you look carefully our number after swap becomes 9 3 5 1 \\n\\t\\t but according to question we want the next permutation which is just \\n\\t\\t immediate greater than the given number right so our resultant final answer \\n\\t\\t should be 9 3 1 5, for that we have to reverse the array after the pivot \\n\\t\\t point i.e. reverse from (i+1,arr.length-1) also if you remember our if check \\n\\t\\t is due to what if we provided with the highest number itself so we have to \\n\\t\\t return the smallest permutation i.e. reverse the whole array so our that \\n\\t\\t purpose is also serving because what we are passing is in our \\n\\t\\t reverse array (i+1,arr.length-1) and for highest number i = -1 \\n\\t\\t so automatically due to the function it will become(0,arr.length-1) .\\n */\\n        \\n        reverse(arr,i+1,arr.length-1);\\n        \\n    }\\n    \\n    public void reverse(int[] arr,int i,int j){\\n        while(i<j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909160,
                "title": "o-n-solution-easy-solution-with-comments",
                "content": "**step1:** find the first decending number from the end. Store number in index.\\n**step2:** If we don\\'t find the index then there is no permutation possible for the current number. So we return the first permutation. To do that we need to return reversed array.\\n**Step 3:** If we got the index, Then we need to find the second index. Second index is basically the index which has value greater then the first index value from back. Store the second index value.\\n**Step 4:** Swap index and second index value.\\n**Step 5:** reverse all the array items after the index value. We are doing this bacause we need to find the minimum permutation value after the array index.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    const len=nums.length-1;\\n    //stores the first index and second index for swapping.\\n    let index;\\n    let secIndex;\\n    \\n    //get the first index\\n    for(index=len-1;index>=0;index--){\\n        if(nums[index]<nums[index+1]){\\n            break;\\n        }\\n    }\\n    //if we don\\'t find first index we don\\'t find second index. we just reverse nums arr.\\n    //that means if we get [3,2,1] as input then our next permutation is [1,2,3].\\n    if(index<0){\\n        nums.reverse();\\n    }else{\\n        //find the second index from last.\\n        //if we find a value from back which is greater than value of index optained.\\n        for(secIndex=len;secIndex>index;secIndex--){\\n            if(nums[secIndex]>nums[index]){\\n                break;\\n            }\\n        }\\n        //swap values of index and secondindex.\\n        [nums[index],nums[secIndex]]=[nums[secIndex],nums[index]];\\n        \\n        //reverse values after the index value till last.\\n        let low=index+1;\\n        let high=len;\\n        while(low<high){\\n           [ nums[low],nums[high]]=[ nums[high],nums[low]];\\n            low++;\\n            high--\\n        }\\n    }\\n    \\n    \\n    return nums;\\n};\\n```\\n**TC: O(n)\\nSC: O(1)**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    const len=nums.length-1;\\n    //stores the first index and second index for swapping.\\n    let index;\\n    let secIndex;\\n    \\n    //get the first index\\n    for(index=len-1;index>=0;index--){\\n        if(nums[index]<nums[index+1]){\\n            break;\\n        }\\n    }\\n    //if we don\\'t find first index we don\\'t find second index. we just reverse nums arr.\\n    //that means if we get [3,2,1] as input then our next permutation is [1,2,3].\\n    if(index<0){\\n        nums.reverse();\\n    }else{\\n        //find the second index from last.\\n        //if we find a value from back which is greater than value of index optained.\\n        for(secIndex=len;secIndex>index;secIndex--){\\n            if(nums[secIndex]>nums[index]){\\n                break;\\n            }\\n        }\\n        //swap values of index and secondindex.\\n        [nums[index],nums[secIndex]]=[nums[secIndex],nums[index]];\\n        \\n        //reverse values after the index value till last.\\n        let low=index+1;\\n        let high=len;\\n        while(low<high){\\n           [ nums[low],nums[high]]=[ nums[high],nums[low]];\\n            low++;\\n            high--\\n        }\\n    }\\n    \\n    \\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908457,
                "title": "only-for-beginner-100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        // if(next_permutation(nums.begin(), nums.end())){\\n        //     return;\\n        // }\\n        // sort(nums.begin(), nums.end());\\n        // return;\\n        \\n\\t\\t\\n\\t\\t// Dry run for better understanding , very easy logic\\n\\t\\t\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                sort(nums.begin()+i+1, nums.end());\\n                auto it = upper_bound(nums.begin()+i+1, nums.end(), nums[i]);\\n                swap(*it, nums[i]);\\n                sort(nums.begin()+i+1, nums.end());\\n                return ;\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        return;\\n    }\\n};\\n//  If you understand this then please upvote this.\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        // if(next_permutation(nums.begin(), nums.end())){\\n        //     return;\\n        // }\\n        // sort(nums.begin(), nums.end());\\n        // return;\\n        \\n\\t\\t\\n\\t\\t// Dry run for better understanding , very easy logic\\n\\t\\t\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                sort(nums.begin()+i+1, nums.end());\\n                auto it = upper_bound(nums.begin()+i+1, nums.end(), nums[i]);\\n                swap(*it, nums[i]);\\n                sort(nums.begin()+i+1, nums.end());\\n                return ;\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        return;\\n    }\\n};\\n//  If you understand this then please upvote this.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922289,
                "title": "easy-c-well-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // we move from the left of array and find the first\\n        // element which is lesser than the previous one.\\n        int n = nums.size(), i;\\n        for(i = n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])\\n                break;\\n        }\\n        \\n        // if sorted in non-increasing order, we can not find\\n        // next permutation\\n        if(i == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // sort the array in non-decreasing order after ith \\n        // position, because we want the very next permutation\\n        sort(nums.begin()+(i+1), nums.end());\\n\\n        // find the very next greater number from nums[i] &\\n        // swap it with that\\n        int j = i+1;\\n        while(j<n && nums[j]<=nums[i]){\\n            j++;\\n        }\\n            \\n        swap(nums[i], nums[j]);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // we move from the left of array and find the first\\n        // element which is lesser than the previous one.\\n        int n = nums.size(), i;\\n        for(i = n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])\\n                break;\\n        }\\n        \\n        // if sorted in non-increasing order, we can not find\\n        // next permutation\\n        if(i == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // sort the array in non-decreasing order after ith \\n        // position, because we want the very next permutation\\n        sort(nums.begin()+(i+1), nums.end());\\n\\n        // find the very next greater number from nums[i] &\\n        // swap it with that\\n        int j = i+1;\\n        while(j<n && nums[j]<=nums[i]){\\n            j++;\\n        }\\n            \\n        swap(nums[i], nums[j]);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559892,
                "title": "c-solution",
                "content": "## Intuition\\n1. Backward traverse the array until we find the two consecutive numbers such that ```nums[i] < nums[i + 1]```. Because the numbers to the right of ```nums[i]``` are in descending order, so we can\\'t make that part bigger.\\n2. Now we need to backward traverse the array again to find first number ```nums[j]``` such that ```nums[j] > nums[i]```, and then swap them to generate a bigger number.  \\n\\t* Why do we need to find the **first** ```nums[j]```? Because we need to generate the **smallest** permutation that is greater than the original number.\\n3.  After swapping ```nums[i]``` and ```nums[j]```, we need to reverse the numbers to the right of ```nums[i]``` to force this part to be the smallest. \\n\\t* Why do we use reverse rather than sort? Sorting will work as well. However, swapping ```nums[i]``` and ```nums[j]``` doesn\\'t change the fact that the numbers to the right of ```nums[i]``` are still in descending order. So reversing this part can make its value smallest and meanwhile achieve O(N) time complexity. If we use sorting, then the complexity of this part will be O(NlogN).\\n\\n\\n## Implementation\\n```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        \\n        int swap = -1;\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                swap = i;\\n                break;\\n            }\\n        }\\n\\n        if(swap == -1)\\n        {\\n            Reverse(nums, 0, nums.Length - 1);\\n            return;\\n        }  \\n        \\n        for(int j = nums.Length - 1; j >= 0; j--)\\n        {\\n            if(nums[j] > nums[swap])\\n            {\\n                Swap(nums, j, swap);\\n                break;\\n            }\\n        }\\n        \\n        Reverse(nums, swap + 1, nums.Length - 1);\\n    }\\n    \\n    public void Swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void Reverse(int[] nums, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n\\n## Complexity\\n* Time compleixty: O(N)\\n* Space complexity: O(1)",
                "solutionTags": [],
                "code": "```nums[i] < nums[i + 1]```\n```nums[i]```\n```nums[j]```\n```nums[j] > nums[i]```\n```nums[j]```\n```nums[i]```\n```nums[j]```\n```nums[i]```\n```nums[i]```\n```nums[j]```\n```nums[i]```\n```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        \\n        int swap = -1;\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                swap = i;\\n                break;\\n            }\\n        }\\n\\n        if(swap == -1)\\n        {\\n            Reverse(nums, 0, nums.Length - 1);\\n            return;\\n        }  \\n        \\n        for(int j = nums.Length - 1; j >= 0; j--)\\n        {\\n            if(nums[j] > nums[swap])\\n            {\\n                Swap(nums, j, swap);\\n                break;\\n            }\\n        }\\n        \\n        Reverse(nums, swap + 1, nums.Length - 1);\\n    }\\n    \\n    public void Swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void Reverse(int[] nums, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398787,
                "title": "python-solution-with-inline-explanation",
                "content": "```python\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Two key observations in the problem:\\n            1. A decreasing array is the last permutation of the array, and the \\n               next one is the reverse of it. For example, `3,2,1` is the last \\n               permutation of this array and `1,2,3` will be next.\\n            2. For a decreasing subarray, there is a number right before the \\n               subarray that \"leads\" the subarray, e.g., `2,4,3,1` in which `2` \\n               \"leads\" the subarray `4,3,1`. Similarly, the decreasing subarray \\n               is the last permutation of itself, and the next one should be \\n               mostly the reverse of the subarray, except that the \"leading\" \\n               number is going to change. Looking at the previous example, the \\n               next permutation is `3,1,2,4` wherein the \"leading\" number is \\n               `3`, which is the next greater number than `2` in the sequence. \\n               Herein, the rule for generating the next permutation for a \\n               subarray is - 1) swap the \"leading\" number and the next greater \\n               one in the decreasing subarray; 2) reverse the decreasing \\n               subarray.\\n        In summary, the whole process should be the following:\\n            1. Find the decreasing subarray if not the entire array\\n            2. If it is not the entire array, swap the \"leading\" number and its \\n               next greater number in the decreasing subarray\\n            3. Reverse the decreasing part\\n        \"\"\"\\n        # if there is only a single number in the array, the next permutation is\\n        # itself\\n        if len(nums) == 1:\\n            return \\n\\n        # find the decreasing subarray from right to left and the pointer stops \\n        # at the \"leading\" number, if not the head of the array\\n        start = len(nums) - 2\\n        while start >= 0:\\n            if nums[start] < nums[start + 1]:\\n                break\\n            start -= 1\\n\\n        # find the two ends of the subarray to be reversed\\n        if start < 0:\\n            # if the entire array is decreasing, the entire array needs to be \\n            # reversed end-to-end\\n            start = 0\\n        else:\\n            # otherwise, we have a decreasing subarray and a \"leading\" number, \\n            # so we find and swap the \"leading\" number and its next greater \\n            # first \\n            i = start\\n            while i < len(nums) - 1 and nums[cur] < nums[i + 1]:\\n                i += 1\\n            nums[start], nums[i] = nums[i], nums[start]\\n            \\n            # the decreasing subarray will be reversed\\n            start += 1\\n\\n        # reverse the decreasing subarray in-place\\n        end = len(nums) - 1\\n        while start < end:\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Two key observations in the problem:\\n            1. A decreasing array is the last permutation of the array, and the \\n               next one is the reverse of it. For example, `3,2,1` is the last \\n               permutation of this array and `1,2,3` will be next.\\n            2. For a decreasing subarray, there is a number right before the \\n               subarray that \"leads\" the subarray, e.g., `2,4,3,1` in which `2` \\n               \"leads\" the subarray `4,3,1`. Similarly, the decreasing subarray \\n               is the last permutation of itself, and the next one should be \\n               mostly the reverse of the subarray, except that the \"leading\" \\n               number is going to change. Looking at the previous example, the \\n               next permutation is `3,1,2,4` wherein the \"leading\" number is \\n               `3`, which is the next greater number than `2` in the sequence. \\n               Herein, the rule for generating the next permutation for a \\n               subarray is - 1) swap the \"leading\" number and the next greater \\n               one in the decreasing subarray; 2) reverse the decreasing \\n               subarray.\\n        In summary, the whole process should be the following:\\n            1. Find the decreasing subarray if not the entire array\\n            2. If it is not the entire array, swap the \"leading\" number and its \\n               next greater number in the decreasing subarray\\n            3. Reverse the decreasing part\\n        \"\"\"\\n        # if there is only a single number in the array, the next permutation is\\n        # itself\\n        if len(nums) == 1:\\n            return \\n\\n        # find the decreasing subarray from right to left and the pointer stops \\n        # at the \"leading\" number, if not the head of the array\\n        start = len(nums) - 2\\n        while start >= 0:\\n            if nums[start] < nums[start + 1]:\\n                break\\n            start -= 1\\n\\n        # find the two ends of the subarray to be reversed\\n        if start < 0:\\n            # if the entire array is decreasing, the entire array needs to be \\n            # reversed end-to-end\\n            start = 0\\n        else:\\n            # otherwise, we have a decreasing subarray and a \"leading\" number, \\n            # so we find and swap the \"leading\" number and its next greater \\n            # first \\n            i = start\\n            while i < len(nums) - 1 and nums[cur] < nums[i + 1]:\\n                i += 1\\n            nums[start], nums[i] = nums[i], nums[start]\\n            \\n            # the decreasing subarray will be reversed\\n            start += 1\\n\\n        # reverse the decreasing subarray in-place\\n        end = len(nums) - 1\\n        while start < end:\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279370,
                "title": "c-with-comments",
                "content": "```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        var n = nums.Length;\\n        // 1. find the last element of the increasing sequence from the back to the front\\n        var lastElementIndex = n - 1;\\n        while (lastElementIndex > 0 && nums[lastElementIndex - 1] >= nums[lastElementIndex]) {\\n            lastElementIndex--;\\n        }\\n\\n        var preLastElementIndex = lastElementIndex - 1;\\n\\n        if (preLastElementIndex < 0) {\\n            // Corner case: 4,3,2,1 => 1,2,3,4\\n            reverse(0, n - 1, nums);\\n        } else {\\n            // 2. find the fist element larger than the pre and replace from the back to the front\\n            var firstElementLargerIndex = n - 1;\\n            while (firstElementLargerIndex > 0 && nums[preLastElementIndex] >= nums[firstElementLargerIndex]) {\\n                firstElementLargerIndex--;\\n            }\\n\\n            // 3. swap\\n            var temp = nums[firstElementLargerIndex];\\n            nums[firstElementLargerIndex] = nums[preLastElementIndex];\\n            nums[preLastElementIndex] = temp;\\n\\n            // 4. reverse [lastElementIndex ... n - 1] in place\\n            reverse(lastElementIndex, n - 1, nums);\\n        }\\n    }\\n\\n    private void reverse(int left, int right, int[] nums) {\\n        while (left < right) {\\n            var temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        var n = nums.Length;\\n        // 1. find the last element of the increasing sequence from the back to the front\\n        var lastElementIndex = n - 1;\\n        while (lastElementIndex > 0 && nums[lastElementIndex - 1] >= nums[lastElementIndex]) {\\n            lastElementIndex--;\\n        }\\n\\n        var preLastElementIndex = lastElementIndex - 1;\\n\\n        if (preLastElementIndex < 0) {\\n            // Corner case: 4,3,2,1 => 1,2,3,4\\n            reverse(0, n - 1, nums);\\n        } else {\\n            // 2. find the fist element larger than the pre and replace from the back to the front\\n            var firstElementLargerIndex = n - 1;\\n            while (firstElementLargerIndex > 0 && nums[preLastElementIndex] >= nums[firstElementLargerIndex]) {\\n                firstElementLargerIndex--;\\n            }\\n\\n            // 3. swap\\n            var temp = nums[firstElementLargerIndex];\\n            nums[firstElementLargerIndex] = nums[preLastElementIndex];\\n            nums[preLastElementIndex] = temp;\\n\\n            // 4. reverse [lastElementIndex ... n - 1] in place\\n            reverse(lastElementIndex, n - 1, nums);\\n        }\\n    }\\n\\n    private void reverse(int left, int right, int[] nums) {\\n        while (left < right) {\\n            var temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061592,
                "title": "o-n-0ms-simple-java-solution-most-optimized-solution-easily-explained-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWrite down all the permuatation of that array in the copy and try to decode how the next permutation comes by fixing the prefixes by following lexicographical order \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\n\\nTo find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\n\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\n\\nIf a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\n\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n      public void swap(int[] nums, int i, int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void reverse(int[] nums, int i ,int j){\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n\\n    }\\n    public void nextPermutation(int[] nums) {\\n        int index=-1;\\n        int n = nums.length;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                index= i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            reverse(nums,0,n-1);\\n        }\\n        else{\\n            for(int i=n-1;i>index;i--){\\n                if(nums[i] > nums[index]){\\n                    swap(nums,i,index);\\n                    break;\\n                }\\n            }\\n            reverse(nums,index+1, n-1 );\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public void swap(int[] nums, int i, int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void reverse(int[] nums, int i ,int j){\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n\\n    }\\n    public void nextPermutation(int[] nums) {\\n        int index=-1;\\n        int n = nums.length;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                index= i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            reverse(nums,0,n-1);\\n        }\\n        else{\\n            for(int i=n-1;i>index;i--){\\n                if(nums[i] > nums[index]){\\n                    swap(nums,i,index);\\n                    break;\\n                }\\n            }\\n            reverse(nums,index+1, n-1 );\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714796,
                "title": "superb-logic-with-unlimited-concept",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        index=-1\\n        n=len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index=i\\n                break\\n        if index==-1:\\n            arr[:]=arr[::-1]\\n            return arr\\n        for i in range(n-1,index-1,-1):\\n            if arr[index]<arr[i]:\\n                arr[index],arr[i]=arr[i],arr[index]\\n                break\\n        arr[::]=arr[:index+1]+sorted(arr[index+1:])\\n        return arr \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        index=-1\\n        n=len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index=i\\n                break\\n        if index==-1:\\n            arr[:]=arr[::-1]\\n            return arr\\n        for i in range(n-1,index-1,-1):\\n            if arr[index]<arr[i]:\\n                arr[index],arr[i]=arr[i],arr[index]\\n                break\\n        arr[::]=arr[:index+1]+sorted(arr[index+1:])\\n        return arr \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565329,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n            for (int i = n-1; i > idx; i--) {\\n                if (nums[i] > nums[idx]) {\\n                    swap(nums[i], nums[idx]);\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(nums.begin()+idx+1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n            for (int i = n-1; i > idx; i--) {\\n                if (nums[i] > nums[idx]) {\\n                    swap(nums[i], nums[idx]);\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(nums.begin()+idx+1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537825,
                "title": "c-analytics-solution-runtime-beats-63-memory-beats-71",
                "content": "# Introduction\\nThis is a dumb solution where you ***understand how to create the next permutation manually***. Thus if you are looking for a solution that requires ***less algorithm skills but more thinking***, here is your place.\\n\\n# Code (!the explanation etc. is below this section!)\\n```\\nclass Solution {\\npublic:\\n    void swapAB(int &a, int &b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // if it\\'s the last permutation\\n        bool flag = true;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > nums[i-1]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        // if it\\'s not the last permutation\\n        int lastIndex = nums.size()-1;\\n        while(nums[lastIndex-1] >= nums[lastIndex])\\n            lastIndex --;\\n        lastIndex --;\\n\\n        int mid = 101, midIdx = lastIndex;\\n        for(int i=lastIndex+1; i<nums.size(); i++){\\n            if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n                mid = nums[i];\\n                midIdx = i;\\n            }\\n        }\\n        swap(nums[lastIndex], nums[midIdx]);\\n\\n        for(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n            if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n    }\\n};\\n```\\n\\n# Approach\\nLet us use a couple of examples to help us understand how to get the next permutation.\\nThis is how you find the next permutation:\\n\\n1. 5 4 3 2 1 -> [5 4 3 2 1] ---------------> 1 2 3 4 5 (special case)\\n2. 1 2 3 4 5 -> 1 2 3 4 [5] -> 1 2 **4** [5 3] -> 1 2 4 **3 5**\\n3. 1 3 5 4 2 -> 1 3 [5 4 2] -> 1 **4** [5 3 2] -> 1 4 **2 3 5**\\n4. 1 5 4 3 2 -> 1 [5 4 3 2] -> **2** [5 4 3 1] -> 2 **1 3 4 5**\\n\\nEx1 is **special**, so let us tryna solve case 2-4 first.\\n\\n- The first \"arrow\" represents **finding the longest decending array at the end of the nums**. We temporarily call this decending array as \"The ***queue***\".\\n- The second \"arrow\" represents **replace the num before the queue with the smallest number in the queue that is greater than this number**.\\n- The third \"arrow\" means **sorting the queue**. As the original queue is decending and the replaced number is still in place, we only need to **reverse the whole queue**.\\n\\nNow you know how my solution works. Why it works is just generally how to find the next permutation, you can notice how it works if you print out all the permutations and observe the pattern in it.\\n\\nThe code for this part is\\n```\\n// step one / first \"->\"\\nint lastIndex = nums.size()-1;\\nwhile(nums[lastIndex-1] >= nums[lastIndex])\\n    lastIndex --;\\nlastIndex --;\\n// step two / second \"->\"\\nint mid = 101, midIdx = lastIndex;\\nfor(int i=lastIndex+1; i<nums.size(); i++){\\n    if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n        mid = nums[i];\\n        midIdx = i;\\n    }\\n}\\nswap(nums[lastIndex], nums[midIdx]);\\n// step three / third \"->\"\\nfor(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n    if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n```\\n\\nNow for the special case. Our Ex1 is special is **Thoroughly Decending**, the next permutation is the sorted permutation. Hence, we need an \"if\" statement to watch out for this case, the code is below:\\n```\\nbool flag = true; // keep track of whether it\\'s decending overall\\nfor(int i=1; i<nums.size(); i++){\\n    if(nums[i] > nums[i-1]){\\n        flag = false;\\n        break;\\n    }\\n}\\nif(flag == true){\\n    sort(nums.begin(), nums.end());\\n    return; // remember to return here to keep the nums sorted!\\n}\\n```\\n\\nThere you have it. This is my answer to this problem!\\n\\n# Complexity\\n- Time complexity: O(N) when it\\'s detecting the special case\\n\\n- Space complexity: O(1) only some parameters to keep track of info\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swapAB(int &a, int &b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // if it\\'s the last permutation\\n        bool flag = true;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > nums[i-1]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        // if it\\'s not the last permutation\\n        int lastIndex = nums.size()-1;\\n        while(nums[lastIndex-1] >= nums[lastIndex])\\n            lastIndex --;\\n        lastIndex --;\\n\\n        int mid = 101, midIdx = lastIndex;\\n        for(int i=lastIndex+1; i<nums.size(); i++){\\n            if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n                mid = nums[i];\\n                midIdx = i;\\n            }\\n        }\\n        swap(nums[lastIndex], nums[midIdx]);\\n\\n        for(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n            if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n    }\\n};\\n```\n```\\n// step one / first \"->\"\\nint lastIndex = nums.size()-1;\\nwhile(nums[lastIndex-1] >= nums[lastIndex])\\n    lastIndex --;\\nlastIndex --;\\n// step two / second \"->\"\\nint mid = 101, midIdx = lastIndex;\\nfor(int i=lastIndex+1; i<nums.size(); i++){\\n    if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n        mid = nums[i];\\n        midIdx = i;\\n    }\\n}\\nswap(nums[lastIndex], nums[midIdx]);\\n// step three / third \"->\"\\nfor(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n    if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n```\n```\\nbool flag = true; // keep track of whether it\\'s decending overall\\nfor(int i=1; i<nums.size(); i++){\\n    if(nums[i] > nums[i-1]){\\n        flag = false;\\n        break;\\n    }\\n}\\nif(flag == true){\\n    sort(nums.begin(), nums.end());\\n    return; // remember to return here to keep the nums sorted!\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347668,
                "title": "java-solution-runtime-0-ms-beats-100-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        if (A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = A.length - 1;\\n            while (A[j] <= A[i]) j--;\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, A.length - 1);\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while (i < j) swap(A, i++, j--);\\n    }\\n}\\n```\\n# \\u2B06\\uFE0FUpvote if you like the solution",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        if (A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = A.length - 1;\\n            while (A[j] <= A[i]) j--;\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, A.length - 1);\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while (i < j) swap(A, i++, j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133449,
                "title": "simple-o-n-java-solution-with-explanation-and-example",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        //Example\\n        //   3\\n        //  / \\\\\\n        // 1   2\\n\\n        //find the index of the first number that is lesser than it\\'s next\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                ind1=i-1;       //nums[ind1]=1\\n                break;\\n            }\\n        }\\n        int ind2=-1;\\n        //if such a number exists, for a lexicographical order, find the number immediately bigger than it\\n        if(ind1!=-1){\\n            for(int i=nums.length-1;i>=ind1;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;     //nums[ind2]=2\\n                    break;\\n                }\\n            }\\n            //perform a swap of the two numbers\\n            int temp=nums[ind1];\\n            nums[ind1]=nums[ind2];\\n            nums[ind2]=temp;\\n\\n        //      3\\n        //     / \\\\\\n        //    2   1\\n        }\\n        //reverse the order after the break point(ind1) to ensure the lexicographical order\\n        for(int i=ind1+1,j=nums.length-1;i<j;i++,j--){\\n            int t=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=t;\\n        }\\n        // 2   3\\n        //  \\\\ /\\n        //   1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        //Example\\n        //   3\\n        //  / \\\\\\n        // 1   2\\n\\n        //find the index of the first number that is lesser than it\\'s next\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                ind1=i-1;       //nums[ind1]=1\\n                break;\\n            }\\n        }\\n        int ind2=-1;\\n        //if such a number exists, for a lexicographical order, find the number immediately bigger than it\\n        if(ind1!=-1){\\n            for(int i=nums.length-1;i>=ind1;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;     //nums[ind2]=2\\n                    break;\\n                }\\n            }\\n            //perform a swap of the two numbers\\n            int temp=nums[ind1];\\n            nums[ind1]=nums[ind2];\\n            nums[ind2]=temp;\\n\\n        //      3\\n        //     / \\\\\\n        //    2   1\\n        }\\n        //reverse the order after the break point(ind1) to ensure the lexicographical order\\n        for(int i=ind1+1,j=nums.length-1;i<j;i++,j--){\\n            int t=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=t;\\n        }\\n        // 2   3\\n        //  \\\\ /\\n        //   1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125459,
                "title": "python-easy-to-understand-beats-75-time-complexity",
                "content": "# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        def reverse(nums, start):\\n            end = len(nums) - 1\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start += 1\\n                end -= 1\\n        i = len(nums) - 2\\n        while i >= 0 and nums[i + 1] <= nums[i]:\\n            i -= 1\\n        if i >= 0:\\n            j = len(nums) - 1\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        reverse(nums, i + 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        def reverse(nums, start):\\n            end = len(nums) - 1\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start += 1\\n                end -= 1\\n        i = len(nums) - 2\\n        while i >= 0 and nums[i + 1] <= nums[i]:\\n            i -= 1\\n        if i >= 0:\\n            j = len(nums) - 1\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        reverse(nums, i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397776,
                "title": "next-permutation-simple-c-solution",
                "content": "void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }",
                "solutionTags": [],
                "code": "void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2256856,
                "title": "c-simple-fast-solution-next-permutation",
                "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size()-1;\\n        int inflectionPoint=0;\\n        for(int i=n; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                inflectionPoint=i;\\n                break;\\n            }\\n        }\\n        if(inflectionPoint==0){\\n            sort(nums.begin(),nums.end());\\n        }\\n        else{               //if we get an inflection point\\n            int toSwap= nums[inflectionPoint-1];\\n            int min= INT_MAX;\\n            for(int j=inflectionPoint; j<=n; j++){\\n                if(nums[j]-toSwap>0 && nums[j]-toSwap<min){\\n                    int temp=nums[j];\\n                    nums[j]=nums[inflectionPoint-1];\\n                    nums[inflectionPoint-1]=temp;\\n                }\\n            }\\n            sort(nums.begin()+inflectionPoint, nums.end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size()-1;\\n        int inflectionPoint=0;\\n        for(int i=n; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                inflectionPoint=i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2238691,
                "title": "functional-declarative-javascript-typescript-solution",
                "content": "```\\n// mutative!\\nfunction swapValuesByIndex(array, index1, index2){\\n    let value1 = array[index1];\\n    array[index1] = array[index2];\\n    array[index2] = value1;\\n}\\n\\n// mutative! \\nfunction reversePartOfArray(array, startIndex, endIndex){\\n    while(startIndex < endIndex){\\n        swapValuesByIndex(array, startIndex, endIndex);\\n        startIndex += 1;\\n        endIndex -= 1;\\n    }\\n}\\n\\nfunction findLastIndexWhere(array, callbackFn){\\n    for(let i = array.length - 1; i >= 0; i--){\\n        if(callbackFn(array[i], i)) return i;\\n    }\\n}\\n\\n// mutative!\\nfunction nextPermutation(nums: number[]): void {\\n    // step 1: find the last digit that decreases from the one after it\\n    const firstIndex = findLastIndexWhere(nums, (num, i) => nums[i+1] !== undefined && num < nums[i+1]);\\n\\n    // step 1a: if the whole array is monotonically increasing from end to beginning, reverse the entire array\\n    if(firstIndex === undefined){\\n        reversePartOfArray(nums, 0, nums.length - 1);\\n        return;\\n    }\\n\\n    // step 2: find the last digit that is larger than our \"pivot\" digit\\n    const secondIndex = findLastIndexWhere(nums, (num, i) => num > nums[firstIndex]);\\n    \\n    // step 3: swap those digits\\n    swapValuesByIndex(nums, firstIndex, secondIndex);\\n    \\n    // step 4: reverse the part of the number after the swapped one\\n    reversePartOfArray(nums, firstIndex + 1, nums.length - 1);\\n};\\n\\n// time complexity: O(n + n + n) = O(n)\\n// space complexity: O(1)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// mutative!\\nfunction swapValuesByIndex(array, index1, index2){\\n    let value1 = array[index1];\\n    array[index1] = array[index2];\\n    array[index2] = value1;\\n}\\n\\n// mutative! \\nfunction reversePartOfArray(array, startIndex, endIndex){\\n    while(startIndex < endIndex){\\n        swapValuesByIndex(array, startIndex, endIndex);\\n        startIndex += 1;\\n        endIndex -= 1;\\n    }\\n}\\n\\nfunction findLastIndexWhere(array, callbackFn){\\n    for(let i = array.length - 1; i >= 0; i--){\\n        if(callbackFn(array[i], i)) return i;\\n    }\\n}\\n\\n// mutative!\\nfunction nextPermutation(nums: number[]): void {\\n    // step 1: find the last digit that decreases from the one after it\\n    const firstIndex = findLastIndexWhere(nums, (num, i) => nums[i+1] !== undefined && num < nums[i+1]);\\n\\n    // step 1a: if the whole array is monotonically increasing from end to beginning, reverse the entire array\\n    if(firstIndex === undefined){\\n        reversePartOfArray(nums, 0, nums.length - 1);\\n        return;\\n    }\\n\\n    // step 2: find the last digit that is larger than our \"pivot\" digit\\n    const secondIndex = findLastIndexWhere(nums, (num, i) => num > nums[firstIndex]);\\n    \\n    // step 3: swap those digits\\n    swapValuesByIndex(nums, firstIndex, secondIndex);\\n    \\n    // step 4: reverse the part of the number after the swapped one\\n    reversePartOfArray(nums, firstIndex + 1, nums.length - 1);\\n};\\n\\n// time complexity: O(n + n + n) = O(n)\\n// space complexity: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230218,
                "title": "easy-c-sol-naive-efficient-approach-linear-time",
                "content": "```\\n// Naive Solution Use the Inbuilt C++ function i.e, next_permutation : Time : O(N*N!) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }\\n};\\n\\n// Efficient Solution : Time : O(N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        int ind1,ind2;\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                ind1 = i;\\n                break;\\n            }\\n        }\\n\\n        if(ind1 < 0){\\n            reverse(nums.begin(),nums.end());\\n        }else{\\n\\n            for(int i=n-1;i>ind1;i--){\\n                if(nums[i] > nums[ind1]){\\n                    ind2 = i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums[ind1],nums[ind2]);\\n\\n            reverse(nums.begin()+ind1+1,nums.end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2007932,
                "title": "very-clearly-explained-using-examples-easy-to-understand-python-solution",
                "content": "A very **famous question**!\\nLet me explain using this example.\\n\\n**For example:**\\n2 5 4 3 1 -> 3 5 4 2 1 -> 3 1 2 4 5\\n\\n1. First loop from the end, find the first index that is not increasing,\\nin the example, it is the index of number 2.\\n2. Then we will again loop from the end, find the first index that is bigger than 2,\\nin the example, it is the index of number 3.\\n3. Swap these two.\\n4. At last reverse from 5 to end.\\n\\nTake care of the **duplicates**!\\nFor example:\\n2 5 5 3 1 -> 3 5 5 2 1 -> 3 1 2 5 5 \\n\\n**Time:** O(n)\\n**Space:** O(1)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 0 or len(nums) == 1:\\n            return\\n        \\n        i = len(nums) - 1\\n        while i > 0 and nums[i] <= nums[i - 1]: # here must be <= to take care of the duplicates!\\n            i -= 1\\n        \\n        if i == 0:\\n            self.swap(nums, 0, len(nums) - 1)\\n            return\\n        left_index = i - 1\\n        \\n        i = len(nums) - 1\\n        while nums[i] <= nums[left_index]:\\n            i -= 1\\n        nums[i], nums[left_index] = nums[left_index], nums[i]\\n        self.swap(nums, left_index + 1, len(nums) - 1)\\n    \\n    def swap(self, nums, left, right):\\n        while left < right:\\n            nums[left], nums[right] = nums[right], nums[left]\\n            left += 1\\n            right -= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 0 or len(nums) == 1:\\n            return\\n        \\n        i = len(nums) - 1\\n        while i > 0 and nums[i] <= nums[i - 1]: # here must be <= to take care of the duplicates!\\n            i -= 1\\n        \\n        if i == 0:\\n            self.swap(nums, 0, len(nums) - 1)\\n            return\\n        left_index = i - 1\\n        \\n        i = len(nums) - 1\\n        while nums[i] <= nums[left_index]:\\n            i -= 1\\n        nums[i], nums[left_index] = nums[left_index], nums[i]\\n        self.swap(nums, left_index + 1, len(nums) - 1)\\n    \\n    def swap(self, nums, left, right):\\n        while left < right:\\n            nums[left], nums[right] = nums[right], nums[left]\\n            left += 1\\n            right -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910219,
                "title": "daily-leet",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int r=-1;\\n        int s=-1;\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                r=i-1;\\n                break;\\n            }\\n        }\\n        if(r==-1){\\n            reverse(nums,0,nums.length-1);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=r;i--){\\n                if(nums[i]>nums[r]){\\n                    s=i;\\n                    break;\\n                }\\n            }    \\n            swap(nums,r,s);\\n            reverse(nums,r+1,nums.length-1);\\n        }\\n        return;    \\n    }\\n    public void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void swap(int[] nums, int i, int index) {\\n        int temp = nums[index];\\n        nums[index] = nums[i];\\n        nums[i] = temp;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int r=-1;\\n        int s=-1;\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                r=i-1;\\n                break;\\n            }\\n        }\\n        if(r==-1){\\n            reverse(nums,0,nums.length-1);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=r;i--){\\n                if(nums[i]>nums[r]){\\n                    s=i;\\n                    break;\\n                }\\n            }    \\n            swap(nums,r,s);\\n            reverse(nums,r+1,nums.length-1);\\n        }\\n        return;    \\n    }\\n    public void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void swap(int[] nums, int i, int index) {\\n        int temp = nums[index];\\n        nums[index] = nums[i];\\n        nums[i] = temp;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908548,
                "title": "next-permutation-c-solution-commented-explained-easily",
                "content": "```\\n//Check from right to left for any position for while nums[i-1]<nums[i]\\n    void nextPermutation(vector<int>& nums) {\\n        // declaring i so as to store position where the condition is true;\\n        int i =0, n = nums.size()-1;\\n        for(i=n;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        // This case comes when the array is sorted in reverse order in that cause we directly sort it in \\n        // increasing order.\\n        if(i <=0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        // Do the opertion move from right to left and find any number greater that nums[i] and then \\n        // swap it and sort from that position.\\n        for(int j = n;j>=0;j--){\\n            if(nums[j]>nums[i-1]){\\n                swap(nums[j], nums[i-1]);\\n                sort(nums.begin()+i, nums.end());\\n                break;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Check from right to left for any position for while nums[i-1]<nums[i]\\n    void nextPermutation(vector<int>& nums) {\\n        // declaring i so as to store position where the condition is true;\\n        int i =0, n = nums.size()-1;\\n        for(i=n;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        // This case comes when the array is sorted in reverse order in that cause we directly sort it in \\n        // increasing order.\\n        if(i <=0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        // Do the opertion move from right to left and find any number greater that nums[i] and then \\n        // swap it and sort from that position.\\n        for(int j = n;j>=0;j--){\\n            if(nums[j]>nums[i-1]){\\n                swap(nums[j], nums[i-1]);\\n                sort(nums.begin()+i, nums.end());\\n                break;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871342,
                "title": "c-simple-code-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvoid nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                for (l = n - 1; l > k; l--) {\\n                    if (nums[l] > nums[k]) {\\n                        break;\\n                    }\\n                } \\n                swap(nums[k], nums[l]);\\n                reverse(nums.begin() + k + 1, nums.end());\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t}\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvoid nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                for (l = n - 1; l > k; l--) {\\n                    if (nums[l] > nums[k]) {\\n                        break;\\n                    }\\n                } \\n                swap(nums[k], nums[l]);\\n                reverse(nums.begin() + k + 1, nums.end());\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1846325,
                "title": "c-detailed-explanation-with-comments-with-example",
                "content": "Steps involved;\\nExample: find next permutation of {1,2,5,4,3}\\nfirstly select the no. which is lesser then its next element,while checking from backward  ans store its index j\\nfor this example .no is  2 of index 1,stored in j;\\nNow search for the least no which is greater then it starting last index;\\nHere its 3 of index  4;\\n\\nThen swap these,and reverse  from the index j+1;\\nswapping: {1,3,5,4,2};\\nreversing from j+1=1+1=2\\n{1,3,2,4,5} ans\\n\\nThe expection is that,if the no is in desending order,it means our loop will reach to i=-1 before breaking,so the next pemutation will be the no in ascending order or say reverse of current no.for ex:{4,3,2,1} its next permut: {1,2,3,4}\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int i,j=0;\\n        for(i=n-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n          if(i==-1){\\n\\t\\t  reverse(nums.begin(),nums.end());   //for cases like {3,2,1}\\n\\t\\t  return;\\n\\t\\t  }\\n        \\n        for(i=n-1;i>j;i--){\\n            if(nums[i]>nums[j]){\\n                swap(nums[i],nums[j]);\\n                \\n                break;\\n            }\\n        }\\n      \\n       reverse(nums.begin()+j+1,nums.end());\\n        \\n        \\n    }\\n};\\n```\\n**Please do upvote if u find useful,It motivates me to post more such**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int i,j=0;\\n        for(i=n-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n          if(i==-1){\\n\\t\\t  reverse(nums.begin(),nums.end());   //for cases like {3,2,1}\\n\\t\\t  return;\\n\\t\\t  }\\n        \\n        for(i=n-1;i>j;i--){\\n            if(nums[i]>nums[j]){\\n                swap(nums[i],nums[j]);\\n                \\n                break;\\n            }\\n        }\\n      \\n       reverse(nums.begin()+j+1,nums.end());\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775228,
                "title": "c-easy-and-original-solution-with-comments",
                "content": "```\\nvoid nextPermutation(vector<int>& nums) {\\n\\t// start from end\\n\\tfor (int i=nums.size()-1; i>=1; i--){ \\n\\t\\t\\t// if there is an number that is smaller than the next number, that means we can start swapping\\n\\t\\t\\tif (nums[i]>nums[i-1]){\\n\\t\\t\\t\\t// we search for the smallest number(but larger than current number) in the remaining vector and swap\\n\\t\\t\\t\\tfor (int j=nums.size()-1; j>=i; j--){\\n\\t\\t\\t\\t\\tif (nums[j]>nums[i-1]){\\n\\t\\t\\t\\t\\t\\tswap(nums[i-1],nums[j]);\\n\\t\\t\\t\\t\\t\\t// sort the remaining vector so its smallest possible with index i being the new number\\n\\t\\t\\t\\t\\t\\tsort(nums.begin()+i,nums.end());\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\tsort(nums.begin(),nums.end());\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) {\\n\\t// start from end\\n\\tfor (int i=nums.size()-1; i>=1; i--){ \\n\\t\\t\\t// if there is an number that is smaller than the next number, that means we can start swapping\\n\\t\\t\\tif (nums[i]>nums[i-1]){\\n\\t\\t\\t\\t// we search for the smallest number(but larger than current number) in the remaining vector and swap\\n\\t\\t\\t\\tfor (int j=nums.size()-1; j>=i; j--){\\n\\t\\t\\t\\t\\tif (nums[j]>nums[i-1]){\\n\\t\\t\\t\\t\\t\\tswap(nums[i-1],nums[j]);\\n\\t\\t\\t\\t\\t\\t// sort the remaining vector so its smallest possible with index i being the new number\\n\\t\\t\\t\\t\\t\\tsort(nums.begin()+i,nums.end());\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\tsort(nums.begin(),nums.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392551,
                "title": "c-easy-to-understand-fast-intuitive",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n      int n=nums.size();\\n        int i,k;\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                break;\\n            }    \\n        }    \\n        if(i<0)\\n        reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(k=n-1;k>=0;k--)\\n            {\\n                if(nums[k]>nums[i])\\n                break;\\n            }\\n            swap(nums[i],nums[k]);\\n            reverse(nums.begin()+i+1,nums.end());\\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n      int n=nums.size();\\n        int i,k;\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                break;\\n            }    \\n        }    \\n        if(i<0)\\n        reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(k=n-1;k>=0;k--)\\n            {\\n                if(nums[k]>nums[i])\\n                break;\\n            }\\n            swap(nums[i],nums[k]);\\n            reverse(nums.begin()+i+1,nums.end());\\n        }    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373821,
                "title": "optimized-solution-with-explanation-in-java-along-with-video",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums.length <=1){\\n            return;\\n        }\\n        \\n        int i=nums.length-2;\\n        for(;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                break;\\n            }\\n        }\\n        \\n        if(i==-1){\\n            reverse(nums, 0, nums.length-1);\\n            return;\\n        }\\n        \\n        int j=nums.length-1;\\n        for(;j>=0;j--){\\n            if(nums[j]>nums[i]){\\n                break;\\n            }\\n        }\\n        \\n        swap(nums, i, j);\\n        reverse(nums, i+1, nums.length-1);\\n        \\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while(start < end){\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```\\nBackward traverse the array until we find the two consecutive numbers such that nums[i] < nums[i + 1]. Because the numbers to the right of nums[i] are in descending order, so we can\\'t make that part bigger.\\n\\nNow we need to backward traverse the array again to find the first number nums[j] such that nums[j] > nums[i], and then swap them to generate a bigger number, as we need to generate the smallest permutation that is greater than the original number.\\n\\nAfter swapping nums[i] and nums[j], we need to reverse the numbers to the right of nums[i] to force this part to be the smallest. As swapping nums[i] and nums[j] doesn\\'t change the fact that the numbers to the right of nums[i] are still in descending order. So reversing this part can make its value smallest and meanwhile achieve O(N) time complexity. If we use sorting, then the complexity of this part will be O(NlogN).\\n\\n\\nTime compleixty: O(N)\\nSpace complexity: O(1)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f758bcfa-a02b-4887-9045-c00cc140499d_1627716482.0443752.png)\\n\\nDetailed Explanation with Video:\\nyoutu[dot]be/un9_wSaxn7w\\n(Replace [dot] with .)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums.length <=1){\\n            return;\\n        }\\n        \\n        int i=nums.length-2;\\n        for(;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                break;\\n            }\\n        }\\n        \\n        if(i==-1){\\n            reverse(nums, 0, nums.length-1);\\n            return;\\n        }\\n        \\n        int j=nums.length-1;\\n        for(;j>=0;j--){\\n            if(nums[j]>nums[i]){\\n                break;\\n            }\\n        }\\n        \\n        swap(nums, i, j);\\n        reverse(nums, i+1, nums.length-1);\\n        \\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while(start < end){\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179173,
                "title": "c-fully-detailed-solution",
                "content": "So what do we mean my next permutation of the array\\n\\n# lets learn by basic concept of the permutation - \\n\\nso one of the test case be nums = {1,2,3} and the next permutaion be {1,3,2}\\n\\nso we have\\n\\n![image](https://assets.leetcode.com/users/images/566ca29b-45c5-4eaf-b33a-72ca1af46338_1619532968.2147515.png)\\n\\nSo with the help of the given recursion tree \\n\\nfor the first branch\\n\\n[1, , ,]  ->  we have two choices and than next child have only one possibility and that\\'s our answer but now how do we know that\\'s our answer \\nIf we see clearly that by recursion tree first change will we can made is in level 2 (from level 0) \\nSo if we have 1 as root than we have two choices so criteria for selecting the 2 and 3 is base on the last element as we always going to have one choice\\n\\nSo by the basics of the permutation algorithm - \\nWe can have following intutuion for the question given to us\\n\\n# Step1 - Find the first position in the array which follow the nums[i] > nums[i-1] for the ith element \\n# Step2 - After selecting the ith position we search for the next greater element than the ith element\\n# Step3 - Swap the both the current element at index i and next greater element\\n# Step4 - Reverse the numbers next to the ith position\\nFollow following step we will able to solve the question in **O(n) - time complexity and O(1) - time complexity**\\n\\n# Code -   \\n![image](https://assets.leetcode.com/users/images/6663e1a1-368a-4c0f-9a6b-636a35ee72f6_1619533848.548016.png)\\n\\nTo strengthen the grip on this algorithm try to solve following question\\n**1830. Minimum Number of Operations to Make String Sorted**\\n\\nI hope my explanation is enough for you guys to proceed.",
                "solutionTags": [],
                "code": "So what do we mean my next permutation of the array\\n\\n# lets learn by basic concept of the permutation - \\n\\nso one of the test case be nums = {1,2,3} and the next permutaion be {1,3,2}\\n\\nso we have\\n\\n![image](https://assets.leetcode.com/users/images/566ca29b-45c5-4eaf-b33a-72ca1af46338_1619532968.2147515.png)\\n\\nSo with the help of the given recursion tree \\n\\nfor the first branch\\n\\n[1, , ,]  ->  we have two choices and than next child have only one possibility and that\\'s our answer but now how do we know that\\'s our answer \\nIf we see clearly that by recursion tree first change will we can made is in level 2 (from level 0) \\nSo if we have 1 as root than we have two choices so criteria for selecting the 2 and 3 is base on the last element as we always going to have one choice\\n\\nSo by the basics of the permutation algorithm - \\nWe can have following intutuion for the question given to us\\n\\n# Step1 - Find the first position in the array which follow the nums[i] > nums[i-1] for the ith element \\n# Step2 - After selecting the ith position we search for the next greater element than the ith element\\n# Step3 - Swap the both the current element at index i and next greater element\\n# Step4 - Reverse the numbers next to the ith position\\nFollow following step we will able to solve the question in **O(n) - time complexity and O(1) - time complexity**\\n\\n# Code -   \\n![image](https://assets.leetcode.com/users/images/6663e1a1-368a-4c0f-9a6b-636a35ee72f6_1619533848.548016.png)\\n\\nTo strengthen the grip on this algorithm try to solve following question\\n**1830. Minimum Number of Operations to Make String Sorted**\\n\\nI hope my explanation is enough for you guys to proceed.",
                "codeTag": "Unknown"
            },
            {
                "id": 1151884,
                "title": "100-faster-c-next-permutation",
                "content": "***Do upvote if you found it helpful as it motivates me to post more content***\\n***Make sure to make a dry run for better understanding***\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) {\\n        int idx=-1;\\n        int n=v.size();\\n        int i,prev;\\n        for(i=n-1;i>0;i--)\\n        {\\n            if(v[i]>v[i-1]) \\n            {\\n                idx=i;\\n                break;\\n            }\\n        }\\n        \\n        if(idx==-1) // if given in descending order then reverse it\\n            reverse(v.begin(),v.end());\\n        \\n        else\\n        {\\n              prev=idx;\\n            for(i=idx+1;i<n;i++)\\n            {\\n                if((v[i]>v[idx-1]) && (v[i]<=v[prev]))\\n                    prev=i;\\n            }\\n             swap(v[idx-1],v[prev]);\\n             reverse(v.begin()+idx,v.end());\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) {\\n        int idx=-1;\\n        int n=v.size();\\n        int i,prev;\\n        for(i=n-1;i>0;i--)\\n        {\\n            if(v[i]>v[i-1]) \\n            {\\n                idx=i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1029262,
                "title": "c-10-lines-0ms-beats-100",
                "content": "```\\nvoid nextPermutation(vector<int>& nums) {\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            for(int j = nums.size()-1; j >= i; j--){\\n                if(nums.at(j) > nums.at(i)){\\n                    swap(nums.at(j),nums.at(i));\\n                    reverse(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n        reverse(nums.begin(), nums.end());             \\n    }\\n```\\ni wrote this solution 2 weeks ago. \\nthe reason i came back to this solution is because I was doing [https://leetcode.com/problems/permutation-sequence/](http://) and thought i could resue codes in this problem. \\n",
                "solutionTags": [],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) {\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            for(int j = nums.size()-1; j >= i; j--){\\n                if(nums.at(j) > nums.at(i)){\\n                    swap(nums.at(j),nums.at(i));\\n                    reverse(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n        reverse(nums.begin(), nums.end());             \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724118,
                "title": "python3-solution",
                "content": "```\\nimport bisect\\nclass Solution:\\n    \\n    def reverse(self,nums,low,high):\\n        while low<=high:\\n            nums[low],nums[high] = nums[high],nums[low]\\n            low+=1\\n            high-=1\\n    \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        i = length-2\\n        index = None\\n        while i>=0:\\n            if nums[i]<nums[i+1]:\\n                index = i\\n                break\\n            i = i-1\\n        if index==None:\\n            self.reverse(nums,0,length-1)\\n        else:\\n            self.reverse(nums,index+1,length-1)\\n            swap_index = bisect.bisect_right(nums,nums[index],index+1,length-1)\\n            nums[index],nums[swap_index] = nums[swap_index],nums[index]\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass Solution:\\n    \\n    def reverse(self,nums,low,high):\\n        while low<=high:\\n            nums[low],nums[high] = nums[high],nums[low]\\n            low+=1\\n            high-=1\\n    \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        i = length-2\\n        index = None\\n        while i>=0:\\n            if nums[i]<nums[i+1]:\\n                index = i\\n                break\\n            i = i-1\\n        if index==None:\\n            self.reverse(nums,0,length-1)\\n        else:\\n            self.reverse(nums,index+1,length-1)\\n            swap_index = bisect.bisect_right(nums,nums[index],index+1,length-1)\\n            nums[index],nums[swap_index] = nums[swap_index],nums[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375358,
                "title": "c-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        if(nums.size()<=1) return;\\n        int n= nums.size(), pos, i;\\n        \\n        for(i=n-1; i>=1; i--){\\n            if(nums[i-1]<nums[i])\\n               break;\\n        }\\n        if(i==0) return reverse(nums.begin(), nums.end());\\n        pos=i-1;\\n        \\n        for(i=n-1; i>pos && i>=0; i--){\\n            if(nums[i]>nums[pos]){\\n                swap(nums[i], nums[pos]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + pos+1, nums.end());\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        if(nums.size()<=1) return;\\n        int n= nums.size(), pos, i;\\n        \\n        for(i=n-1; i>=1; i--){\\n            if(nums[i-1]<nums[i])\\n               break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 327076,
                "title": "python-24ms-beats-94-with-step-by-step-explanation",
                "content": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        card = len(nums)\\n        \\n        for k in range(card-1):             # check if a greater arrangement is not possible\\n            if nums[k] < nums[k+1]:\\n                break\\n        else:\\n            nums.reverse()                  # if it\\'s not possible - reverse sequence and stop\\n            return\\n\\n        for i in range(card - 1, 0, -1):    # card-1, card-2, card-3, ..., 2, 1\\n            if nums[i] > nums[i - 1]:       # from the end of sequence find the first decreasing element (\\'nums[i-1]\\')\\n                low = nums[i]\\n                \\n                # among afterward digits (nums[i]...nums[card-1]) we find the smallest digit (\\'low\\') that is bigger then \\'nums[i-1]\\'\\n                for n in range(i+1, card):  \\n                    if nums[i-1] < nums[n] < low:\\n                        low = nums[n]\\n\\n                low_index = nums.index(low, i) \\n                nums[i - 1], nums[low_index] = nums[low_index], nums[i - 1]  # swap \\'nums[i-1]\\' and \\'low\\' in a sequence\\n            \\n                for iter_num in range(card-1, i, -1):  # sort afterward digits (nums[i]...nums[card-1])\\n                    for idx in range(i, iter_num):     # PS: this is Bubble Sort algorithm, but you can choose smth faster\\n                        if nums[idx] > nums[idx + 1]:\\n                            nums[idx + 1], nums[idx] = nums[idx], nums[idx + 1]\\n                break                                  # STOP\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        card = len(nums)\\n        \\n        for k in range(card-1):             # check if a greater arrangement is not possible\\n            if nums[k] < nums[k+1]:\\n                break\\n        else:\\n            nums.reverse()                  # if it\\'s not possible - reverse sequence and stop\\n            return\\n\\n        for i in range(card - 1, 0, -1):    # card-1, card-2, card-3, ..., 2, 1\\n            if nums[i] > nums[i - 1]:       # from the end of sequence find the first decreasing element (\\'nums[i-1]\\')\\n                low = nums[i]\\n                \\n                # among afterward digits (nums[i]...nums[card-1]) we find the smallest digit (\\'low\\') that is bigger then \\'nums[i-1]\\'\\n                for n in range(i+1, card):  \\n                    if nums[i-1] < nums[n] < low:\\n                        low = nums[n]\\n\\n                low_index = nums.index(low, i) \\n                nums[i - 1], nums[low_index] = nums[low_index], nums[i - 1]  # swap \\'nums[i-1]\\' and \\'low\\' in a sequence\\n            \\n                for iter_num in range(card-1, i, -1):  # sort afterward digits (nums[i]...nums[card-1])\\n                    for idx in range(i, iter_num):     # PS: this is Bubble Sort algorithm, but you can choose smth faster\\n                        if nums[idx] > nums[idx + 1]:\\n                            nums[idx + 1], nums[idx] = nums[idx], nums[idx + 1]\\n                break                                  # STOP\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301074,
                "title": "swift-16ms-100-beat-using-internet-logix",
                "content": "Check it out on the web. It\\'s good.\\n\\n```\\nclass Solution {\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        \\n        if nums.count <= 0 { return }\\n        \\n        var switchIndex: Int?\\n        var prev = nums.last!\\n        var i: Int = nums.count - 2\\n        \\n        while i >= 0 {    \\n            if nums[i] < prev {\\n                switchIndex = i\\n                break\\n            }\\n            prev = nums[i]\\n            i -= 1\\n        }\\n        \\n        guard let index = switchIndex else {\\n            nums.reverse()\\n            return\\n        }\\n        \\n        var successorValue: Int?\\n        var successorIndex: Int = index + 1\\n        \\n        for i in index+1..<nums.count {\\n            if nums[i] > nums[index] {\\n                if let value = successorValue {\\n                    if nums[i] <= value {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                } else {\\n                    successorValue = nums[i]\\n                    successorIndex = i\\n                }\\n            }\\n        }\\n        \\n        nums.swapAt(successorIndex, index)\\n        nums[(index+1)...].reverse()\\n    }\\n}\\n```\\n\\nDig?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        \\n        if nums.count <= 0 { return }\\n        \\n        var switchIndex: Int?\\n        var prev = nums.last!\\n        var i: Int = nums.count - 2\\n        \\n        while i >= 0 {    \\n            if nums[i] < prev {\\n                switchIndex = i\\n                break\\n            }\\n            prev = nums[i]\\n            i -= 1\\n        }\\n        \\n        guard let index = switchIndex else {\\n            nums.reverse()\\n            return\\n        }\\n        \\n        var successorValue: Int?\\n        var successorIndex: Int = index + 1\\n        \\n        for i in index+1..<nums.count {\\n            if nums[i] > nums[index] {\\n                if let value = successorValue {\\n                    if nums[i] <= value {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                } else {\\n                    successorValue = nums[i]\\n                    successorIndex = i\\n                }\\n            }\\n        }\\n        \\n        nums.swapAt(successorIndex, index)\\n        nums[(index+1)...].reverse()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291800,
                "title": "simple-c-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i = 0;\\n        for(i = nums.size() - 2 ; i >= 0 ; i--){\\n            if(nums[i] < nums[i+1])break;\\n        }\\n        sort(nums.begin() + i + 1,nums.end());\\n        for(int j = i; j < nums.size();j++ ){\\n            if(nums[j] > nums[i]){\\n                swap(nums[i] , nums[j]);\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i = 0;\\n        for(i = nums.size() - 2 ; i >= 0 ; i--){\\n            if(nums[i] < nums[i+1])break;\\n        }\\n        sort(nums.begin() + i + 1,nums.end());\\n        for(int j = i; j < nums.size();j++ ){\\n            if(nums[j] > nums[i]){\\n                swap(nums[i] , nums[j]);\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213308,
                "title": "simple-javascript-solution-beats-100",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    function swap(a, b) {\\n        const temp = nums[a]\\n        nums[a] = nums[b]\\n        nums[b] = temp\\n    }\\n    \\n    function reverse(start) {\\n        let end = nums.length - 1\\n        while (start < end) {\\n            swap(start, end)\\n            start++\\n            end--\\n        }\\n    }\\n    \\n    \\n    let i = nums.length - 2;\\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\\n        i--;\\n    }\\n    if (i < 0) {\\n        reverse(0);\\n        return;\\n    }\\n    let j = nums.length - 1;\\n    while (j >= 0 && nums[j] <= nums[i]) {\\n        j--;\\n    }\\n    swap(i, j);\\n    reverse(i + 1);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    function swap(a, b) {\\n        const temp = nums[a]\\n        nums[a] = nums[b]\\n        nums[b] = temp\\n    }\\n    \\n    function reverse(start) {\\n        let end = nums.length - 1\\n        while (start < end) {\\n            swap(start, end)\\n            start++\\n            end--\\n        }\\n    }\\n    \\n    \\n    let i = nums.length - 2;\\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\\n        i--;\\n    }\\n    if (i < 0) {\\n        reverse(0);\\n        return;\\n    }\\n    let j = nums.length - 1;\\n    while (j >= 0 && nums[j] <= nums[i]) {\\n        j--;\\n    }\\n    swap(i, j);\\n    reverse(i + 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 119205,
                "title": "simple-python-code",
                "content": "```python\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # 1. get the start index of non-increasing sequence from tail\\n        # 2. swap\\n        # 3. sort the non-increasing\\n        if not nums: return nums\\n        l = len(nums)\\n        i, j = l - 2, l - 1\\n        while i >= 0 and nums[i] >= nums[i+1]:\\n            i -= 1\\n        while j > i and nums[j] <= nums[i]:\\n            j -= 1\\n        nums[i], nums[j] = nums[j], nums[i]\\n        nums[i+1:] = sorted(nums[i+1:])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # 1. get the start index of non-increasing sequence from tail\\n        # 2. swap\\n        # 3. sort the non-increasing\\n        if not nums: return nums\\n        l = len(nums)\\n        i, j = l - 2, l - 1\\n        while i >= 0 and nums[i] >= nums[i+1]:\\n            i -= 1\\n        while j > i and nums[j] <= nums[i]:\\n            j -= 1\\n        nums[i], nums[j] = nums[j], nums[i]\\n        nums[i+1:] = sorted(nums[i+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14000,
                "title": "a-mathematical-solution-accepted-as-best-in-c-well-explained",
                "content": "The following algorithm from [wiki][1] generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.\\n\\n - Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n - Find the largest index l greater than k such that a[k] < a[l].\\n - Swap the value of a[k] with that of a[l].\\n - Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nAs for the demonstration, it will be presented in the comments of the solution as follows for your better understanding.\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void reverse(int* nums, int begin, int end)\\n    {\\n        for(int i = begin; i < (begin+end+1)/2; i++)\\n            swap(nums+i, nums+end+begin-i);\\n    }\\n    void nextPermutation(int* nums, int size)\\n    {\\n        int i=size-1, j=size-1;\\n        while(i>0 && nums[i]<=nums[i-1]) i--; //make sure the [i..size-1] is in descending order;\\n        if(i==0) //the whole array is descending now, reverse it to the smallest as problem requires;\\n        {\\n            reverse(nums, 0, size-1);\\n            return ;\\n        }\\n        while(nums[j] <= nums[i-1]) j--; //find the first bigger one backwards;\\n        swap(nums+j, nums+i-1); //ensure the next is bigger;\\n        reverse(nums, i, size-1); //since [i..size-1] is descending, after reverse it will be ascending and as a result - [i..size-1] will be the smallest - the smallest in the bigger results - the next permutation;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "The following algorithm from [wiki][1] generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.\\n\\n - Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n - Find the largest index l greater than k such that a[k] < a[l].\\n - Swap the value of a[k] with that of a[l].\\n - Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nAs for the demonstration, it will be presented in the comments of the solution as follows for your better understanding.\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void reverse(int* nums, int begin, int end)\\n    {\\n        for(int i = begin; i < (begin+end+1)/2; i++)\\n            swap(nums+i, nums+end+begin-i);\\n    }\\n    void nextPermutation(int* nums, int size)\\n    {\\n        int i=size-1, j=size-1;\\n        while(i>0 && nums[i]<=nums[i-1]) i--; //make sure the [i..size-1] is in descending order;\\n        if(i==0) //the whole array is descending now, reverse it to the smallest as problem requires;\\n        {\\n            reverse(nums, 0, size-1);\\n            return ;\\n        }\\n        while(nums[j] <= nums[i-1]) j--; //find the first bigger one backwards;\\n        swap(nums+j, nums+i-1); //ensure the next is bigger;\\n        reverse(nums, i, size-1); //since [i..size-1] is descending, after reverse it will be ascending and as a result - [i..size-1] will be the smallest - the smallest in the bigger results - the next permutation;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order",
                "codeTag": "Unknown"
            },
            {
                "id": 14008,
                "title": "20-line-1ms-in-place-java-code-with-expalantion",
                "content": "> 1. scan from right to left, find first pair where a[i] > a[i-1]. note that a[i:] is non-ascending.\\n> 2. scan from right to left again, find first element a[j] where a[j] > a[i-1]. since a[i:] is non-ascending, a[j] is the smallest number that > a[i-1].\\n> 3. swap a[i-1] with a[j]. note that after swap, a[i:] remains non-ascending.\\n> 4. reverse a[i:] so that a[i:] becomes non-descending.\\n\\n    public class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int p = nums.length-1;\\n            while (p>0 && nums[p]<=nums[p-1]) { --p; }\\n            if (p == 0) {  // case like [3,2,1]\\n                reverse(nums, 0, nums.length-1);\\n                return;\\n            }\\n            int q = nums.length-1;\\n            while (nums[q]<=nums[p-1]) { --q; }\\n            int temp = nums[p-1]; nums[p-1] = nums[q]; nums[q] = temp;\\n            reverse(nums, p, nums.length-1);\\n        }\\n        \\n        private void reverse(int[] a, int from, int to) {\\n            for (; from < to; ++from, --to) {\\n                int temp = a[from];\\n                a[from] = a[to];\\n                a[to] = temp;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int p = nums.length-1;\\n            while (p>0 && nums[p]<=nums[p-1]) { --p; }",
                "codeTag": "Java"
            },
            {
                "id": 14055,
                "title": "one-loop-simple-java-solution-with-comments",
                "content": "    public class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int len = nums.length;\\n            int index = -1;\\n            //find out the index that is not ascending from right most\\n            for(int i=len-2; i>=0; i--) {\\n                if(nums[i] < nums[i+1]) {\\n                    index = i; break;\\n                }\\n            }\\n            if(index == -1) Arrays.sort(nums);\\n            else {\\n                //sort the right part of index and swap the index with the min of nums bigger than nums[index] in the right part\\n                Arrays.sort(nums, index+1, len);\\n                for(int i=index+1; i<len; i++) {\\n                    if(nums[i] > nums[index]) {\\n                        swap(nums, i, index);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        public void swap(int[]nums, int i, int j) {\\n            int tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int len = nums.length;\\n            int index = -1;\\n            //find out the index that is not ascending from right most\\n            for(int i=len-2; i>=0; i--) {\\n                if(nums[i] < nums[i+1]) {\\n                    index = i; break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14073,
                "title": "4-line-12ms-c-code",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i;\\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            std::reverse(nums.begin() + i, nums.end());\\n            if (i>0) swap(nums[i-1],*upper_bound(nums.begin() + i, nums.end(),nums[i-1]));\\n        }\\n    };\\n\\nThanks for the upper_bound idea from:\\nhttps://leetcode.com/discuss/41925/solution-lines-imitate-next_permutation-bring-binary-search\\n\\notherwise I search it myself:\\n\\n    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i,j;\\n            \\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            if (i)\\n            {\\n                for(j = nums.size() - 1; nums[j] <= nums[i-1];j--);\\n                swap(nums[i-1],nums[j]);\\n            }\\n            std::reverse(nums.begin() + i, nums.end());\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i;\\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            std::reverse(nums.begin() + i, nums.end());\\n            if (i>0) swap(nums[i-1],*upper_bound(nums.begin() + i, nums.end(),nums[i-1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 14079,
                "title": "my-12ms-c-solution-use-reverse-iterator-very-easy-to-understand",
                "content": "the next permutaion could be like this.\\n\\n 1. find the first element which is great than the previous one from the\\n    last.\\n 2. then judge whether it is the first element of the vector or not .if\\n    it is the first element ,it means the vector is descent ,like this\\n    [5,4,3,2,1]\\n 3. then just sort it ascend.if it is not ,then swap the iter+1 to the\\n    minimum element which is great than iter+1.then sort the remaining\\n    vector.\\n\\n    class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return ;\\n        \\n        //use reverse iterator,because we want to iterate from the last to the first element\\n        auto iter=nums.rbegin();\\n        \\n        //find first element that is greater than the previous one.this time *(iter+1) is greater than *iter\\n        while(iter!=(nums.rend()-1)&&*iter<=*(iter+1))\\n            iter++;\\n            \\n        //if iter point to the first element .which means the origin vecotr is descand,just sort the vector\\n        if(iter==nums.rend()-1)\\n            sort(nums.begin(),nums.end());\\n        else\\n        {\\n            //or swap iter+1 to the element which is the mixest one but great than itself\\n            auto upper=iter;\\n            auto tmp=nums.rbegin();\\n            for(;tmp!=iter;tmp++)\\n            {\\n                if(*tmp>*(iter+1))\\n                {\\n                    if(*tmp<*upper)\\n                    {\\n                        upper=tmp;\\n                    }\\n                }\\n            }\\n            swap(*(iter+1),*upper);\\n            \\n            //sort the element\\n            sort(nums.rbegin(),iter+1,greater<int>());\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return ;\\n        \\n        //use reverse iterator,because we want to iterate from the last to the first element\\n        auto iter=nums.rbegin();\\n        \\n        //find first element that is greater than the previous one.this time *(iter+1) is greater than *iter\\n        while(iter!=(nums.rend()-1)&&*iter<=*(iter+1))\\n            iter++;\\n            \\n        //if iter point to the first element .which means the origin vecotr is descand,just sort the vector\\n        if(iter==nums.rend()-1)\\n            sort(nums.begin(),nums.end());\\n        else\\n        {\\n            //or swap iter+1 to the element which is the mixest one but great than itself\\n            auto upper=iter;\\n            auto tmp=nums.rbegin();\\n            for(;tmp!=iter;tmp++)\\n            {\\n                if(*tmp>*(iter+1))\\n                {\\n                    if(*tmp<*upper)\\n                    {\\n                        upper=tmp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4056343,
                "title": "c-one-line-code-2-approaches",
                "content": "# *PLEASE UPVOTE GUYS \\uD83E\\uDD79*\\n\\n\\n# Approach**\\n1. **With inbuilt STL function** \\n\\n2. **pointers**\\n- The nextPermutation function takes a vector nums as input and is used to find the next lexicographically greater permutation of the elements in nums.\\n\\n- It first calculates the size of the nums vector and initializes the index variable to -1.\\n\\n- It searches for the first element index from the right (starting from the second-to-last element) such that nums[i] is less than nums[i+1]. This step helps identify the rightmost element that can be modified to create a greater permutation.\\n\\n- If an index is found (i.e., there\\'s a possible next permutation), it proceeds to find the smallest element greater than nums[index] from the right. This element is found by iterating from the right end of the vector. Once found, it swaps this element with nums[index].\\n\\n- Finally, it reverses the elements to the right of index. This step ensures that the remaining elements to the right are in ascending order, making the permutation as small as possible while still being greater than the original.\\n\\n# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\n                  ----------Approach 1----------\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n\\n                  ----------Approach 2----------\\n\\nclass Solution {\\npublic:\\n    // Function to find the next lexicographically greater permutation of \\'nums\\'\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(); // Get the size of the \\'nums\\' vector\\n        int index = -1; // Initialize \\'index\\' to -1\\n\\n        // 1. Find the first element \\'index\\' from the right such that nums[i] < nums[i+1]\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        // 2. If \\'index\\' is found, find the smallest element greater than nums[index] from the right\\n        if (index != -1) {\\n            for (int i = n - 1; i >= index; i--) {\\n                if (nums[i] > nums[index]) {\\n                    swap(nums[i], nums[index]); // Swap nums[i] and nums[index]\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 3. Reverse the elements to the right of \\'index\\'\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n                  ----------Approach 1----------\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n\\n                  ----------Approach 2----------\\n\\nclass Solution {\\npublic:\\n    // Function to find the next lexicographically greater permutation of \\'nums\\'\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(); // Get the size of the \\'nums\\' vector\\n        int index = -1; // Initialize \\'index\\' to -1\\n\\n        // 1. Find the first element \\'index\\' from the right such that nums[i] < nums[i+1]\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        // 2. If \\'index\\' is found, find the smallest element greater than nums[index] from the right\\n        if (index != -1) {\\n            for (int i = n - 1; i >= index; i--) {\\n                if (nums[i] > nums[index]) {\\n                    swap(nums[i], nums[index]); // Swap nums[i] and nums[index]\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 3. Reverse the elements to the right of \\'index\\'\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002581,
                "title": "leetcode-31-next-permutation-c-solution-explanation-and-complexity-analysis",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start by traversing the list of numbers from right to left until you find the first element (let\\'s call it nums[i]) that is smaller than its right neighbor (nums[i+1]). This element is the first candidate for swapping.\\n\\n- It simply means that if we have a number that is greater that number nums[i] on the right we can get an array that is greater (lexicographically ordering of elements) than the current number and as the permutation are in lexicographical order we can get our next permutation just by manipulating the elements on the right side.\\n\\n- If no such element is found (i.e., if i becomes -1), it means that the list is in descending order, and there is no greater permutation possible. In this case, reverse the entire list to obtain the smallest permutation and return it.\\n\\n- If you found an element to swap (i.e., i is not -1), proceed to find the smallest element to the right of nums[i] that is just greater than nums[i]. This is done by traversing the list again from right to left and stopping when you find an element greater than nums[i]. Let\\'s call this element nums[j].\\n\\n- Swap nums[i] and nums[j] to get the array that will have greater value.Like in [1,2,3,2,1] doing above steps will get us to [1,3,2,2,1].Since we got our array greater by just with index (i), the value of array on the right side of (i) must be lowest to get the next permutation.\\n\\n- Finally, sort the elements to the right of nums[i] in ascending order to ensure you have the next greater permutation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void nextPermutation(vector<int>& nums) {\\n    int n = nums.size(), i = n - 2;\\n    while(i >= 0 && nums[i] >= nums[i + 1])i--;\\n    if(i < 0){\\n      reverse(nums.begin() + i + 1, nums.end());\\n      return;\\n    }\\n    int j = n - 1;\\n    while(j > i && nums[j] <= nums[i])j--;\\n    swap(nums[i], nums[j]);\\n    sort(nums.begin() + i + 1, nums.end());\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void nextPermutation(vector<int>& nums) {\\n    int n = nums.size(), i = n - 2;\\n    while(i >= 0 && nums[i] >= nums[i + 1])i--;\\n    if(i < 0){\\n      reverse(nums.begin() + i + 1, nums.end());\\n      return;\\n    }\\n    int j = n - 1;\\n    while(j > i && nums[j] <= nums[i])j--;\\n    swap(nums[i], nums[j]);\\n    sort(nums.begin() + i + 1, nums.end());\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910626,
                "title": "better-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int imp=n-1;\\n        while(imp>=0)\\n        {\\n               if(imp==0)\\n            break;\\n            if(nums[imp]<=nums[imp-1])\\n            {\\n                imp--;\\n            }\\n            else\\n            break;\\n         \\n        }\\n        if(imp!=0)\\n        {\\n            int greater=-1;\\n            for(int i=imp;i<n;i++)\\n            {\\n                if(greater==-1 || nums[greater]>nums[i])\\n                {\\n                   if(nums[imp-1]<nums[i])\\n                   {\\n                       greater=i;\\n                   }\\n                }\\n            }\\n            swap(nums[greater], nums[imp-1]);\\n        }\\n        sort(nums.begin()+imp, nums.end());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int imp=n-1;\\n        while(imp>=0)\\n        {\\n               if(imp==0)\\n            break;\\n            if(nums[imp]<=nums[imp-1])\\n            {\\n                imp--;\\n            }\\n            else\\n            break;\\n         \\n        }\\n        if(imp!=0)\\n        {\\n            int greater=-1;\\n            for(int i=imp;i<n;i++)\\n            {\\n                if(greater==-1 || nums[greater]>nums[i])\\n                {\\n                   if(nums[imp-1]<nums[i])\\n                   {\\n                       greater=i;\\n                   }\\n                }\\n            }\\n            swap(nums[greater], nums[imp-1]);\\n        }\\n        sort(nums.begin()+imp, nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781549,
                "title": "c-optimized-approach-with-step-by-step-solution",
                "content": "# Intuition\\nI referred to a youtube video for Lexicographical ordering | Order of permutation | Discrete Mathematics\\n# Approach\\nThis can be divided into four Steps:\\n\\n**Step 1:** Find the largest value of i such that nums[i-1] < nums[i]\\n\\nA short note (If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation as in lexicographic orderring leading zeros are significant)\\n\\n**Step 2:** Find the largest value of j such that nums[i-1] < nums[j]\\n**Step 3:** Interchange nums[i-1] and nums[j]\\n**Step 4:** Reverse the numbers from index i to the end\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void nextPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n    \\n    // Step 1: Find the largest value of i such that nums[i-1] < nums[i]\\n    int i = n - 1;\\n    while (i > 0 && nums[i-1] >= nums[i])\\n        i--;\\n    \\n    // If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation\\n    if (i == 0) {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n    \\n    // Step 2: Find the largest value of j such that nums[i-1] < nums[j]\\n    int j = n - 1;\\n    while (nums[j] <= nums[i-1])\\n        j--;\\n    \\n    // Step 3: Interchange nums[i-1] and nums[j]\\n    swap(nums[i-1], nums[j]);\\n    \\n    // Step 4: Reverse the numbers from index i to the end\\n    reverse(nums.begin() + i, nums.end());\\n}\\n\\n};\\n```\\nA pro tip I just discovered that you can directly use next_permutation(nums.begin(),nums.end());",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void nextPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n    \\n    // Step 1: Find the largest value of i such that nums[i-1] < nums[i]\\n    int i = n - 1;\\n    while (i > 0 && nums[i-1] >= nums[i])\\n        i--;\\n    \\n    // If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation\\n    if (i == 0) {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n    \\n    // Step 2: Find the largest value of j such that nums[i-1] < nums[j]\\n    int j = n - 1;\\n    while (nums[j] <= nums[i-1])\\n        j--;\\n    \\n    // Step 3: Interchange nums[i-1] and nums[j]\\n    swap(nums[i-1], nums[j]);\\n    \\n    // Step 4: Reverse the numbers from index i to the end\\n    reverse(nums.begin() + i, nums.end());\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765713,
                "title": "c-fully-optimised-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index=-1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                index=i-1;\\n                break;\\n            }\\n        }\\n        //finding the break point \\n        // now stored in index\\n\\n        if(index==-1){\\n            sort(nums.begin(),nums.end());\\n            return ;\\n        }\\n        // if no break point we sort the array and return\\n        // else\\n        for(int i=nums.size()-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                swap(nums[i],nums[index]);\\n                break;\\n            }\\n        }\\n        //swaping the min element which is greater than break point \\n        // and now sorting the remaining elements to get the next permutation\\n        sort(nums.begin()+index+1,nums.end());\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index=-1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                index=i-1;\\n                break;\\n            }\\n        }\\n        //finding the break point \\n        // now stored in index\\n\\n        if(index==-1){\\n            sort(nums.begin(),nums.end());\\n            return ;\\n        }\\n        // if no break point we sort the array and return\\n        // else\\n        for(int i=nums.size()-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                swap(nums[i],nums[index]);\\n                break;\\n            }\\n        }\\n        //swaping the min element which is greater than break point \\n        // and now sorting the remaining elements to get the next permutation\\n        sort(nums.begin()+index+1,nums.end());\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758581,
                "title": "easiest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        \\n        int i = nums.length-2;\\n        \\n        while(i>=0 && nums[i+1] <= nums[i]){\\n            i--;\\n        }\\n        if(i >= 0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums,i,j);\\n        }\\n        reverse(nums, i+1);\\n        \\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i){\\n        int j= nums.length-1;\\n        \\n        while(i<j){\\n            swap(nums, j, i);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        \\n        int i = nums.length-2;\\n        \\n        while(i>=0 && nums[i+1] <= nums[i]){\\n            i--;\\n        }\\n        if(i >= 0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums,i,j);\\n        }\\n        reverse(nums, i+1);\\n        \\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i){\\n        int j= nums.length-1;\\n        \\n        while(i<j){\\n            swap(nums, j, i);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691414,
                "title": "java-clean-code-beats-100-with-explanation",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1286931-->1289631-->1289136(ans)\\n        // find 1st decreasing element from the right\\n        int temp=0,i,min=Integer.MAX_VALUE,pivot=0,pos=0;\\n        for ( i=arr.length-1;i>=1;i--)\\n            if (arr[i]>arr[i-1])\\n            {\\n                pivot=i;break;\\n            }\\n        // find no. just larger than arr[pivot-1]\\n        if (pivot>0)//to check if there is a decreasing element to the left of pivot(i.e.pivot!=0)\\n        {\\n            for (i=pivot;i<arr.length;i++)\\n            {\\n                if (arr[i]>arr[pivot-1])\\n                    min=Math.min(min,arr[i]);\\n                if (min==arr[i])\\n                    pos=i;\\n            }\\n            //swap min and arr[pivot-1]\\n            swap(arr,pos,pivot-1);\\n        }\\n\\n        //reverse from pivot to end\\n        int high=arr.length-1;\\n        while(pivot<=high){\\n            swap(arr,pivot,high);\\n            high--;pivot++;\\n        }\\n    }\\n    private void swap(int[] arr,int low,int high){\\n            int temp=arr[low];\\n            arr[low]=arr[high];\\n            arr[high]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1286931-->1289631-->1289136(ans)\\n        // find 1st decreasing element from the right\\n        int temp=0,i,min=Integer.MAX_VALUE,pivot=0,pos=0;\\n        for ( i=arr.length-1;i>=1;i--)\\n            if (arr[i]>arr[i-1])\\n            {\\n                pivot=i;break;\\n            }\\n        // find no. just larger than arr[pivot-1]\\n        if (pivot>0)//to check if there is a decreasing element to the left of pivot(i.e.pivot!=0)\\n        {\\n            for (i=pivot;i<arr.length;i++)\\n            {\\n                if (arr[i]>arr[pivot-1])\\n                    min=Math.min(min,arr[i]);\\n                if (min==arr[i])\\n                    pos=i;\\n            }\\n            //swap min and arr[pivot-1]\\n            swap(arr,pos,pivot-1);\\n        }\\n\\n        //reverse from pivot to end\\n        int high=arr.length-1;\\n        while(pivot<=high){\\n            swap(arr,pivot,high);\\n            high--;pivot++;\\n        }\\n    }\\n    private void swap(int[] arr,int low,int high){\\n            int temp=arr[low];\\n            arr[low]=arr[high];\\n            arr[high]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565400,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565269,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565562,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570786,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565167,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567466,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568712,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569214,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570729,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566711,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565400,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565269,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565562,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570786,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565167,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567466,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568712,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569214,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570729,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566711,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575010,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1568651,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1568433,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1567030,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1566322,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1804406,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1685039,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1575896,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1570227,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1572944,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1569407,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1967407,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1928220,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1673006,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1670882,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1636952,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1576827,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1576497,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1574308,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1574113,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1573290,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1573223,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1573078,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1571870,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1570596,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1575467,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2074673,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2074405,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2073000,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2068405,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2061766,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2057195,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2053460,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2048586,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2044833,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2036705,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2035692,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2029696,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2029289,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2025716,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2022674,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2022489,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2009841,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2009524,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2005917,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2004595,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1999023,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1997557,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1997551,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1987560,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1987074,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1982735,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1967012,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1966109,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1964653,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1940853,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1925601,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1920437,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1916945,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1901514,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1892281,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1891452,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889718,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889684,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889680,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1880139,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1858142,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1844600,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1831749,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1829892,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1808656,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1807808,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1794691,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1789383,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1777049,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1761635,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759819,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754439,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752918,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752597,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1737199,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1729224,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1728678,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1728478,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1725436,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1710694,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1710323,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1709660,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1708744,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1693918,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            }
        ]
    }
]