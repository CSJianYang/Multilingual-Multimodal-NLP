[
    {
        "title": "Delete Node in a Linked List",
        "question_content": "There is a singly-linked list head and we want to delete a node node in it.\nYou are given the node to be deleted node. You will not be given access to the first node of head.\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\n\tThe value of the given node should not exist in the linked list.\n\tThe number of nodes in the linked list should decrease by one.\n\tAll the values before node should be in the same order.\n\tAll the values after node should be in the same order.\n\nCustom testing:\n\n\tFor the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\n\tWe will build the linked list and pass the node to your function.\n\tThe output will be the entire list after calling your function.\n\n&nbsp;\nExample 1:\n\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\nExample 2:\n\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n\n&nbsp;\nConstraints:\n\n\tThe number of the nodes in the given list is in the range [2, 1000].\n\t-1000 <= Node.val <= 1000\n\tThe value of each node in the list is unique.\n\tThe node to be deleted is in the list and is not a tail node.",
        "solutions": [
            {
                "id": 65455,
                "title": "1-3-lines-c-java-python-c-c-javascript-ruby",
                "content": "We can't really delete the node, but we can kinda achieve the same effect by instead removing the **next** node after copying its data into the node that we were asked to delete.\\n\\n**C++**\\n\\n    void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }\\n\\nBut better properly delete the next node:\\n\\n    void deleteNode(ListNode* node) {\\n        auto next = node->next;\\n        *node = *next;\\n        delete next;\\n    }\\n\\n**Java and C#**\\n\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n\\n**Python**\\n\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\n**C**\\n\\n    void deleteNode(struct ListNode* node) {\\n        *node = *node->next;\\n    }\\n\\nBut better properly free the next node's memory:\\n\\n    void deleteNode(struct ListNode* node) {\\n        struct ListNode* next = node->next;\\n        *node = *next;\\n        free(next);\\n    }\\n\\n**JavaScript**\\n\\n    var deleteNode = function(node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    };\\n\\n**Ruby**\\n\\n    def delete_node(node)\\n        node.val = node.next.val\\n        node.next = node.next.next\\n        nil\\n    end",
                "solutionTags": [],
                "code": "We can't really delete the node, but we can kinda achieve the same effect by instead removing the **next** node after copying its data into the node that we were asked to delete.\\n\\n**C++**\\n\\n    void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }\\n\\nBut better properly delete the next node:\\n\\n    void deleteNode(ListNode* node) {\\n        auto next = node->next;\\n        *node = *next;\\n        delete next;\\n    }\\n\\n**Java and C#**\\n\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n\\n**Python**\\n\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\n**C**\\n\\n    void deleteNode(struct ListNode* node) {\\n        *node = *node->next;\\n    }\\n\\nBut better properly free the next node's memory:\\n\\n    void deleteNode(struct ListNode* node) {\\n        struct ListNode* next = node->next;\\n        *node = *next;\\n        free(next);\\n    }\\n\\n**JavaScript**\\n\\n    var deleteNode = function(node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    };\\n\\n**Ruby**\\n\\n    def delete_node(node)\\n        node.val = node.next.val\\n        node.next = node.next.next\\n        nil\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 65464,
                "title": "easy-solution-in-java",
                "content": "    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n\\nSince we couldn't enter the preceding node, we can not delete the given node. We can just copy the next node to the given node and delete the next one.",
                "solutionTags": [],
                "code": "    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n\\nSince we couldn't enter the preceding node, we can not delete the given node. We can just copy the next node to the given node and delete the next one.",
                "codeTag": "Unknown"
            },
            {
                "id": 3364017,
                "title": "explained-2-lines-cpp-code",
                "content": "# **Please UPVOTE \\uD83D\\uDC4D**\\n\\n# Approach\\nCopy the next node to given node and then we can delete the next node easily.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val; //copying the next node value\\n        node->next = node->next->next; // deleting the next node\\n    }\\n};\\n\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/d7f0064b-27ef-46ec-b16b-22e23fee257b_1680317707.1202745.png)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val; //copying the next node value\\n        node->next = node->next->next; // deleting the next node\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65461,
                "title": "this-question-is-wrong-you-cannot-delete-the-node",
                "content": "    post the answer first:\\n    class Solution {\\n    public:\\n        void deleteNode(ListNode* node) {\\n            node->val = node->next->val;\\n            node->next = node->next->next;\\n        }\\n    };\\n\\nHowever, this question is INCORRECT for sure, since you don't really \"delete\" a node, you are replacing the value. In fact, this is a terrible design leading to memory leaks almost for sure.\\n\\nI wonder what company gives such misleading question. It's better called \"modify\" a node, instead of \"deleting\". Deleting means free the memory, and the incorrect description will mislead any person with slight experience on C++.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void deleteNode(ListNode* node) {\\n            node->val = node->next->val;\\n            node->next = node->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1354873,
                "title": "c-easy-explanation-o-1-solution",
                "content": "Basically we are just copying node\\'s next value to itself\\nInput: 1->2->3->4->5 ->6\\ngiven node = 4\\noutput: 1->2->3->5->6\\n\\n**1.** in first step:  node->val becomes node\\'s next ki value i.e 4 becomes 5\\n1->2->3->5->5->6\\n**2.** in 2nd step: node points to node\\'s next next i.e 5->6\\n1->2->3->5->6\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65547,
                "title": "my-c-solution-in-1-line",
                "content": "\\n\\n    class Solution {\\n    public:\\n        void deleteNode(ListNode* node) {\\n            *node = *(node->next);\\n        }\\n    };\\n\\nif the node should be freed, we need 3 lines: \\n\\n    class Solution {\\n    public:\\n        void deleteNode(ListNode* node) {\\n            ListNode* temp = node->next;\\n            *node = *temp;\\n            delete temp;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void deleteNode(ListNode* node) {\\n            *node = *(node->next);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65456,
                "title": "python-two-lines-solution-copy-value-and-then-delete-the-next-node",
                "content": "    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next",
                "codeTag": "Python3"
            },
            {
                "id": 65482,
                "title": "easy-question-easy-solution-java",
                "content": "```\\npublic class Solution {\\n        public void deleteNode(ListNode node) {\\n            if(node != null && node.next != null) {\\n                node.val = node.next.val;\\n                node.next = node.next.next;\\n            }\\n        }\\n    }\\n\\t\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n        public void deleteNode(ListNode node) {\\n            if(node != null && node.next != null) {\\n                node.val = node.next.val;\\n                node.next = node.next.next;\\n            }\\n        }\\n    }\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354949,
                "title": "python3-change-value-and-change-pointer",
                "content": "* We delete the node by \"replacing\" the node with node.next. \\n* node.val change to node.next.val\\n* node.next change to node.next.next\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n\\t   # goal : delete node 2.\\n\\t\\t\\n        1  ->  2 -> 3       -> 4\\n               ^    ^\\n               |    |\\n              node  node.next\\n         #step one:  change the node value to 3\\n         1  ->  3   3           4\\n               ^    ^           ^\\n               |    |           |\\n              node  node.next   node.next.next\\n              \\n          #step two: change the next pointer to point to node.next.next\\n         1  ->  3   ->          4\\n               ^    ^           ^\\n               |    |           |\\n              node  node.next   node.next.next\\n\\t\\t\\t  \\n\\t    1 ->3 ->4\\n        \"\"\"\\n        # Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\n**Complexity Analysis**\\n* Time complexity: O(1)\\n\\tThe algorithm only needs two assignment operations.\\n*  Space complexity: O(1)\\n\\tThe algorithm doesn\\'t need extra memory.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n\\t   # goal : delete node 2.\\n\\t\\t\\n        1  ->  2 -> 3       -> 4\\n               ^    ^\\n               |    |\\n              node  node.next\\n         #step one:  change the node value to 3\\n         1  ->  3   3           4\\n               ^    ^           ^\\n               |    |           |\\n              node  node.next   node.next.next\\n              \\n          #step two: change the next pointer to point to node.next.next\\n         1  ->  3   ->          4\\n               ^    ^           ^\\n               |    |           |\\n              node  node.next   node.next.next\\n\\t\\t\\t  \\n\\t    1 ->3 ->4\\n        \"\"\"\\n        # Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696260,
                "title": "c-don-t-be-that-person-that-leaks-memory-clean-code",
                "content": "### Approach 1: copy next node\\n\\nBefore looking at different implementation let me briefly touch on the intiution. Usually for a linked list if we want to remove a ListNode we would update the previous node to point the the node after the one we want to remove. For this problem we don\\'t know the previous node, we are only given the address of the node we want to remove. The approach is to overwrite the node we want to remove with the content of the next node and then remove the next node. The problem description states that we can expect that the node we should remove is never the last node, otherwise the problem can\\'t be solved.\\n\\n#### Variant 1: C style code\\n\\nInstead of assigning ```node->val``` and ```node->next``` we can just assign the entire node.\\n\\n```cpp\\n    static void deleteNode(ListNode* node) {\\n        ListNode* next = node->next;\\n        *node = *next;\\n        // Don\\'t be that person that leaks memory.\\n        delete next;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: left as an exercise to the reader.\\n  * Space Complexity: Is negative space complexity a thing, since we are freeing memory here? :D\\n\\n#### Variant 2: std::unique_ptr\\n\\nInstead of calling ```delete``` on the \"next\" node, we can also use ```std::unique_ptr``` which take owner ship of the node we want to delete. As soon as this ```std::unique_ptr``` goes out of scope it will delete the owned node. This approach has the benefit if we have a function with multiple ```returns``` the object will be destroyed, i.e. we can not forget to call ```delete``` on it.\\n\\n```cpp\\n    static void deleteNode(ListNode* node) {\\n        std::unique_ptr<ListNode> to_be_deleted(node->next);\\n        *node = *node->next;\\n    }\\n```\\n\\n#### Variant 3: std::exchange (just for fun, not recommended)\\n\\nWith ```std::exchange``` we can turn approach 1 into a oneliner. I don\\'t recommend actually doing this.\\n\\n```cpp\\n    static void deleteNode(ListNode* node) {\\n        delete std::exchange(*node, *node->next).next;\\n    }\\n```\\n\\n### Appendix: Looking at the generated assembly\\n\\nJust for fun I looked the generated assembly ([using clang x86-64 (trunk)](https://godbolt.org/z/WPz1cW98x))\\n\\nVariant 1:\\n\\n```asm\\ndeleteNode(ListNode*):               # @deleteNode(ListNode*)\\n        mov     rax, qword ptr [rdi + 8]\\n        vmovups xmm0, xmmword ptr [rax]\\n        vmovups xmmword ptr [rdi], xmm0\\n        mov     rdi, rax\\n        jmp     operator delete(void*)@PLT                      # TAILCALL\\n```\\n\\nVariant 2: Is exactly the same as Variant 1\\n\\n```asm\\ndeleteNode(ListNode*):               # @deleteNode(ListNode*)\\n        mov     rax, qword ptr [rdi + 8]\\n        vmovups xmm0, xmmword ptr [rax]\\n        vmovups xmmword ptr [rdi], xmm0\\n        mov     rdi, rax\\n        jmp     operator delete(void*)@PLT                      # TAILCALL\\n```\\n\\n... and it looks like clang can see through all of this, and Variant 3 generates the same code as well:\\n\\n```asm\\ndeleteNode(ListNode*):               # @deleteNode(ListNode*)\\n        mov     rax, qword ptr [rdi + 8]\\n        vmovups xmm0, xmmword ptr [rax]\\n        vmovups xmmword ptr [rdi], xmm0\\n        mov     rdi, rax\\n        jmp     operator delete(void*)@PLT                      # TAILCALL\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```node->val```\n```node->next```\n```cpp\\n    static void deleteNode(ListNode* node) {\\n        ListNode* next = node->next;\\n        *node = *next;\\n        // Don\\'t be that person that leaks memory.\\n        delete next;\\n    }\\n```\n```delete```\n```std::unique_ptr```\n```std::unique_ptr```\n```returns```\n```delete```\n```cpp\\n    static void deleteNode(ListNode* node) {\\n        std::unique_ptr<ListNode> to_be_deleted(node->next);\\n        *node = *node->next;\\n    }\\n```\n```std::exchange```\n```cpp\\n    static void deleteNode(ListNode* node) {\\n        delete std::exchange(*node, *node->next).next;\\n    }\\n```\n```asm\\ndeleteNode(ListNode*):               # @deleteNode(ListNode*)\\n        mov     rax, qword ptr [rdi + 8]\\n        vmovups xmm0, xmmword ptr [rax]\\n        vmovups xmmword ptr [rdi], xmm0\\n        mov     rdi, rax\\n        jmp     operator delete(void*)@PLT                      # TAILCALL\\n```\n```asm\\ndeleteNode(ListNode*):               # @deleteNode(ListNode*)\\n        mov     rax, qword ptr [rdi + 8]\\n        vmovups xmm0, xmmword ptr [rax]\\n        vmovups xmmword ptr [rdi], xmm0\\n        mov     rdi, rax\\n        jmp     operator delete(void*)@PLT                      # TAILCALL\\n```\n```asm\\ndeleteNode(ListNode*):               # @deleteNode(ListNode*)\\n        mov     rax, qword ptr [rdi + 8]\\n        vmovups xmm0, xmmword ptr [rax]\\n        vmovups xmmword ptr [rdi], xmm0\\n        mov     rdi, rax\\n        jmp     operator delete(void*)@PLT                      # TAILCALL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2696743,
                "title": "java-easy-solution-with-explanation-100-faster-code-2-line-solution",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n     \\n        // Step 1: Set value of current node as value of next node\\n        node.val = node.next.val;\\n        \\n        // Step 2: Delete the next node from list\\n        node.next = node.next.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n     \\n        // Step 1: Set value of current node as value of next node\\n        node.val = node.next.val;\\n        \\n        // Step 2: Delete the next node from list\\n        node.next = node.next.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665803,
                "title": "python-2-lines-easy-modify-values-in-your-list",
                "content": "If you never saw this problem it can seems quite difficult, how you can delete node, if you are given only access to that node? You need to find previous node first? No, the trick is a modification of values in our list! If you have this type of quesitions on real interview, it is the first question you must ask your interviewer. If we can modify data, solution becomes very easy, only two lines: change value of node with value of next node and then change next element for next of next element.\\n\\n**Complexity.** Both time and space comlexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516040,
                "title": "javascript-easy",
                "content": "```\\nvar deleteNode = function(node) {\\n    // copy next node\\'s val into current node\\n    // delete next node\\n    \\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteNode = function(node) {\\n    // copy next node\\'s val into current node\\n    // delete next node\\n    \\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140910,
                "title": "python",
                "content": "\\u5176\\u5B9E\\u4E0D\\u80FD\\u771F\\u6B63\\u610F\\u4E49\\u4E0A\\u7684\\u5220\\u9664\\u6307\\u5B9A\\u7684Node\\uFF0C\\u56E0\\u4E3A\\u6CA1\\u6709\\u7ED9\\u4E0EPrevious Node\\u3002\\n\\u6240\\u4EE5\\u4ECE\\u6839\\u672C\\u610F\\u4E49\\u4E0A\\uFF0C\\u53EA\\u80FD\\u53D6\\u5DE7\\u7684\\u89E3\\u51B3\\u8FD9\\u4E2A\\u95EE\\u9898\\u3002\\u9898\\u76EE\\u523B\\u610F\\u7ED9\\u4E86\\u5F88\\u591A\\u9644\\u4EF6\\u7684\\u6761\\u4EF6\\uFF0C\\u6BD4\\u5982\\u94FE\\u8868value\\u6CA1\\u6709\\u91CD\\u590D\\uFF0C\\u5E76\\u4E14\\u6307\\u5B9ANode\\u4E0D\\u662FTail\\uFF0C\\u5176\\u5B9E\\u90FD\\u662F\\u5728\\u7ED9\\u6B63\\u89E3\\u505A\\u94FA\\u57AB\\uFF0C\\u4EE3\\u7801\\u5982\\u4E0B\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\n\\n\\u6211\\u4EEC\\u771F\\u6B63\\u5220\\u9664\\u7684\\u662F\\u6307\\u5B9ANode\\u7684\\u4E0B\\u4E00\\u4E2ANode\\uFF0C\\u7136\\u540E\\u628A\\u6307\\u5B9ANode\\u7684Value\\u66F4\\u6539\\u6210\\u4E0B\\u4E00\\u4E2ANode\\u7684\\u503C\\u7F62\\u4E86\\u3002\\n\\u4E3A\\u4EC0\\u4E48\\u8FD9\\u4E2Anode.next.next\\u5728\\u8FD9\\u91CC\\u662F\\u6CA1\\u95EE\\u9898\\u7684\\uFF0C\\u56E0\\u4E3A\\u9898\\u76EE\\u544A\\u8BC9\\u4E86\\u8BF4\\u6307\\u5B9A\\u7684Node\\u4E0D\\u4E3ATail\\uFF0C\\u6240\\u4EE5\\u6211\\u4EEC\\u4E0D\\u7528\\u62C5\\u5FC3\\u8FD9\\u4E2AEdge Case\\u3002",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433918,
                "title": "best-explanation-for-two-line-code-solution-java-100-faster",
                "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```\\nSo, this is our code.\\nWe don\\'t have the access to the previous node of the to be deleted node.\\nBut we have the access to the next node, which makes deletion of next node possible.\\nSo, we copy the value of the next node to this node and delete the next node (i.e connecting our current node to the next node\\'s next)\\n\\nHopefully you understood, Thank you \\uD83D\\uDE00",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696481,
                "title": "2-lines-easy-to-understand-o-1-time-complexity-and-space-complexity",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val=node.next.val\\n        node.next=node.next.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val=node.next.val\\n        node.next=node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65575,
                "title": "4ms-c-solution-with-explanation",
                "content": "/* Here's my simple 4ms solution\\nWe have been given a pointer to the node to be deleted. \\nWe know that while deleting a node from the linked list, we have to fix the links between the previous and the next node. The following are the steps to achieve this:\\n\\n 1. Find out the next node of the pointer to the node that we have.\\n 2. Copy the data from the next node to the node to be deleted.\\n 3. Fix the link and delete the next node\\n\\n*/\\n\\n    void deleteNode(struct ListNode* node) {\\n        struct ListNode* nextNode = node->next;\\n        node->val = nextNode->val;\\n        node->next = nextNode->next;\\n        free(nextNode);\\n    }",
                "solutionTags": [],
                "code": "/* Here's my simple 4ms solution\\nWe have been given a pointer to the node to be deleted. \\nWe know that while deleting a node from the linked list, we have to fix the links between the previous and the next node. The following are the steps to achieve this:\\n\\n 1. Find out the next node of the pointer to the node that we have.\\n 2. Copy the data from the next node to the node to be deleted.\\n 3. Fix the link and delete the next node\\n\\n*/\\n\\n    void deleteNode(struct ListNode* node) {\\n        struct ListNode* nextNode = node->next;\\n        node->val = nextNode->val;\\n        node->next = nextNode->next;\\n        free(nextNode);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2696943,
                "title": "c-o-1-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tvoid deleteNode(ListNode* curr) {\\n        \\n        ListNode *temp = curr->next;      //store address of curr node\\'s next\\n        curr->val = temp->val;            //update curr->val with temp->val\\n        curr->next = temp->next;          //update connections \\n        delete temp;                      //delete temp\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tvoid deleteNode(ListNode* curr) {\\n        \\n        ListNode *temp = curr->next;      //store address of curr node\\'s next\\n        curr->val = temp->val;            //update curr->val with temp->val\\n        curr->next = temp->next;          //update connections \\n        delete temp;                      //delete temp\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2696325,
                "title": "python-3-3-lines-w-diagram-t-m-99-48",
                "content": "![image](https://assets.leetcode.com/users/images/7562b928-f92f-4e7e-a362-2995c9d1d282_1665622039.5094635.jpeg)\\n```\\nclass Solution:\\n    def deleteNode(self, node:ListNode):\\n        node.val  = node.next.val\\n        node.next = node.next.next\\n        return\\n```\\n[https://leetcode.com/submissions/detail/586646496/](http://)\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node:ListNode):\\n        node.val  = node.next.val\\n        node.next = node.next.next\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802169,
                "title": "python-2-liner-solution",
                "content": "One of the most important things in any Linked List solution is to have a pointer to the head. In the absence of that we need to ask ourselves what is the information that we have, which can help us iterate the part of the list that the question is asking for. \\n\\nHere, we are interested in removing the current node. We do not have a head pointer with which we can access the node prev to the curr node and jump to the next node. However , we can alway morph the list to get to the solution that we are looking for. To do that , we copy the data from the next node to the current node, effectively deleting the data from the current node and update the link to point to the node after next (effectvely removing the next node, data of which we already have copied into the current node). \\n\\n```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65542,
                "title": "simple-java-solution-1ms",
                "content": "    public class Solution {\\n    public void deleteNode(ListNode node) {\\n       ListNode n1 = null;\\n\\t\\tn1 = node.next;\\n\\t\\tif (n1 != null) {\\n\\t\\t\\tnode.val = n1.val;\\n\\t\\t\\tnode.next = n1.next;\\n\\t\\t}\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void deleteNode(ListNode node) {\\n       ListNode n1 = null;\\n\\t\\tn1 = node.next;\\n\\t\\tif (n1 != null) {\\n\\t\\t\\tnode.val = n1.val;\\n\\t\\t\\tnode.next = n1.next;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1450145,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid deleteNode(ListNode* node) {\\n\\t\\t\\tListNode* temp = node -> next;\\n\\t\\t\\tnode -> val = temp -> val;\\n\\t\\t\\tnode -> next = temp -> next;\\n\\t\\t\\tdelete temp;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid deleteNode(ListNode* node) {\\n\\t\\t\\tListNode* temp = node -> next;\\n\\t\\t\\tnode -> val = temp -> val;\\n\\t\\t\\tnode -> next = temp -> next;\\n\\t\\t\\tdelete temp;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 469072,
                "title": "python-java-js-go-c-by-victim-node-operation-w-visualization",
                "content": "Solution based on victim node operation\\n\\n---\\n\\n**Visualization & Diagram**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588600048.png)\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588600135.png)\\n\\n---\\n\\n**Implementation** in Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        # locate victim node\\n        victim_node = node.next\\n        \\n        # overwrite node\\'s value by victim node\\'s value\\n        node.val = victim_node.val\\n        \\n        # break the linkage of victim node\\n        node.next = victim_node.next\\n        \\n        # release victim node\\n        del victim_node\\n        \\n        return\\n```\\n\\n---\\n\\n**Implementation** by Java:\\n\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        \\n        // Locate victim node\\n        ListNode victimNode = node.next;\\n        \\n        // Copy value of victim node\\n        node.val = victimNode.val;\\n        \\n        // Make node.next pointes to next node of victim node\\n        node.next = victimNode.next;\\n        \\n        // Let Java GC automaticlly release victimNode in the background\\n        victimNode = null;\\n        \\n        return;\\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** in Javascript:\\n\\n```\\nvar deleteNode = function(node) {\\n    \\n    // copy object from victim node\\n    node = Object.assign(node, node.next);\\n    \\n\\t// Let JS GC automaticlly release victimNode in the background\\n    node = null;\\n\\t\\n\\treturn;\\n};\\n```\\n\\nor\\n\\n```\\nvar deleteNode = function(node) {\\n    \\n    // copy data from victim node\\n    node.val = node.next.val;\\n    \\n    // update linkage\\n    node.next = node.next.next;\\n    \\n\\t// Let JS GC automaticlly release victimNode in the background\\n    node = null;\\n\\t\\n    return;\\n};\\n```\\n\\n---\\n\\n**Implementation** in Golang:\\n\\n```\\nfunc deleteNode(node *ListNode) {\\n    \\n    // locate victim node\\n    victimNode := node.Next\\n    \\n    // overwrite node\\'s value by victim node\\'s value\\n    node.Val = victimNode.Val\\n    \\n    // break the linkage of victim node\\n    node.Next = victimNode.Next\\n    \\n    // release victim node\\n    victimNode = nil\\n    \\n    \\n}\\n```\\n\\n---\\n\\n**Implementation** in C++\\n\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        // locate victim node\\n        ListNode *victimNode = node->next;\\n        \\n        // copy data from victim node\\n        *node = *(node->next);\\n        \\n        // release memory of victim node\\n        delete victimNode;\\n        \\n        return;\\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by concise victim node operation in Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        # concise version of victim node operation\\n        \\n        node.val, node.next = node.next.val, node.next.next\\n```\\n\\n---\\n\\n**Implementation** by concise victim node operation in Golang:\\n\\n```\\nfunc deleteNode(node *ListNode) {\\n    \\n    node.Val = node.Next.Val\\n    node.Next = node.Next.Next\\n    \\n}\\n```\\n\\nor\\n\\n\\n```\\n\\nfunc deleteNode(node *ListNode) {\\n    \\n    // direct update linkage to next node\\n    *node = *(node.Next)\\n    return\\n}\\n\\n```\\n---",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        # locate victim node\\n        victim_node = node.next\\n        \\n        # overwrite node\\'s value by victim node\\'s value\\n        node.val = victim_node.val\\n        \\n        # break the linkage of victim node\\n        node.next = victim_node.next\\n        \\n        # release victim node\\n        del victim_node\\n        \\n        return\\n```\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        \\n        // Locate victim node\\n        ListNode victimNode = node.next;\\n        \\n        // Copy value of victim node\\n        node.val = victimNode.val;\\n        \\n        // Make node.next pointes to next node of victim node\\n        node.next = victimNode.next;\\n        \\n        // Let Java GC automaticlly release victimNode in the background\\n        victimNode = null;\\n        \\n        return;\\n    }\\n}\\n```\n```\\nvar deleteNode = function(node) {\\n    \\n    // copy object from victim node\\n    node = Object.assign(node, node.next);\\n    \\n\\t// Let JS GC automaticlly release victimNode in the background\\n    node = null;\\n\\t\\n\\treturn;\\n};\\n```\n```\\nvar deleteNode = function(node) {\\n    \\n    // copy data from victim node\\n    node.val = node.next.val;\\n    \\n    // update linkage\\n    node.next = node.next.next;\\n    \\n\\t// Let JS GC automaticlly release victimNode in the background\\n    node = null;\\n\\t\\n    return;\\n};\\n```\n```\\nfunc deleteNode(node *ListNode) {\\n    \\n    // locate victim node\\n    victimNode := node.Next\\n    \\n    // overwrite node\\'s value by victim node\\'s value\\n    node.Val = victimNode.Val\\n    \\n    // break the linkage of victim node\\n    node.Next = victimNode.Next\\n    \\n    // release victim node\\n    victimNode = nil\\n    \\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        // locate victim node\\n        ListNode *victimNode = node->next;\\n        \\n        // copy data from victim node\\n        *node = *(node->next);\\n        \\n        // release memory of victim node\\n        delete victimNode;\\n        \\n        return;\\n    }\\n};\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        # concise version of victim node operation\\n        \\n        node.val, node.next = node.next.val, node.next.next\\n```\n```\\nfunc deleteNode(node *ListNode) {\\n    \\n    node.Val = node.Next.Val\\n    node.Next = node.Next.Next\\n    \\n}\\n```\n```\\n\\nfunc deleteNode(node *ListNode) {\\n    \\n    // direct update linkage to next node\\n    *node = *(node.Next)\\n    return\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285385,
                "title": "golang-1-line-solution",
                "content": "Easiest golang solution:\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc deleteNode(node *ListNode) {\\n    *node = *node.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc deleteNode(node *ListNode) {\\n    *node = *node.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2697538,
                "title": "20-lines",
                "content": "\\n##### Java\\n```java\\npublic void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n```\\n\\n##### C++\\n```\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n```\\n\\n\\n##### Python\\n```python\\ndef deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\n\\n##### JS\\n```js\\nvar deleteNode = function(node) {\\n    node.val = node.next.val\\n    node.next = node.next.next\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```java\\npublic void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n```\n```\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n```\n```python\\ndef deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\n```js\\nvar deleteNode = function(node) {\\n    node.val = node.next.val\\n    node.next = node.next.next\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1667568,
                "title": "c-easy-solutions-2-approaches-with-explanation-and-illustration",
                "content": "*Please upvote if you liked this solution or found it useful.\\nFor any clarifications, suggestions or doubts please comment down below.*\\n\\n__Clarification:__ \\nThe problem expects us to shift values in order to achieve deletion\\nGiven below are 2 solutions (_Brute force and optimal_)\\n\\n__Approach:__\\n\\n__1. Brute Force__:\\nConsider an example : 1->2->3->4->5\\n1. We are supposed to delete say __2__ i.e. __node points to 2__ initially\\n2. We will do the following steps until __current->next->next!=NULL__\\n\\t2a. __current->val = current->next->val__\\n\\t2b. __current = current->next__\\n3. By doing this we will get\\n\\t1->2->3->4->5\\n\\t...... *\\n\\t1->3->3->4->5\\n\\t...............*\\n\\t1->3->4->4->5 (__current->next->next is NULL so break__)\\n\\t.......................*\\t\\n4. Finally we will do the following 2 steps\\n\\t4a. __current->data = current->next->data__\\n\\t4b. __current->next = NULL__\\n\\t1->3->4->5->5\\n\\t......................*\\n\\t1->3->4->5->X\\n\\t .....................*\\n\\t \\n__2. Optimal__\\nInvolves 3 steps, \\n1. let current= node\\n2.  current->val = current->next->val\\n3.  current->next = current->next->next\\n\\n__Code:__\\n\\n__1. Brute force code__\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode* current = node;\\n        while(current->next->next!=nullptr){\\n            current->val = current->next->val;\\n            current = current->next;\\n        }\\n        current->val = current->next->val;\\n        current->next = nullptr;\\n    }\\n};\\n```\\n__2. Optimal solution code__\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode* current = node;\\n        current->val = current->next->val;\\n        current->next = current->next->next;\\n    }\\n};\\n```\\n\\n__Complexity__\\n1. Brute force\\n\\t1a. Time : O(size_of_list) = O(n)\\n\\t1b. Space : O(1)\\n2. Optimal\\n\\t2a. Time : O(2 steps) = O(1)\\n\\t2b. Space : O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode* current = node;\\n        while(current->next->next!=nullptr){\\n            current->val = current->next->val;\\n            current = current->next;\\n        }\\n        current->val = current->next->val;\\n        current->next = nullptr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode* current = node;\\n        current->val = current->next->val;\\n        current->next = current->next->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298366,
                "title": "c-three-soln-simple",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        //1st method\\n        //we don\\'t delete the node we move it forward\\n        *node=*node->next; \\n        \\n        \\n        //2nd method;\\n        //we copy the value of next varibale and move the pointer to next\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        \\n        //3rd method\\n        //we copy the value of next varibale and move the pointer to next\\n        //also remove the node so to escape memory leak\\n        struct ListNode *temp=node->next;\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        delete temp;\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        //1st method\\n        //we don\\'t delete the node we move it forward\\n        *node=*node->next; \\n        \\n        \\n        //2nd method;\\n        //we copy the value of next varibale and move the pointer to next\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        \\n        //3rd method\\n        //we copy the value of next varibale and move the pointer to next\\n        //also remove the node so to escape memory leak\\n        struct ListNode *temp=node->next;\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        delete temp;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800231,
                "title": "javascript-solution-237",
                "content": "```\\nlet deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```\\n\\n**Runtime: 84 ms, faster than 57.78% of JavaScript online submissions for Delete Node in a Linked List.**\\n\\n**Memory Usage: 38.6 MB, less than 25.18% of JavaScript online submissions for Delete Node in a Linked List.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65553,
                "title": "c-16ms-simple-solution",
                "content": "    class Solution {\\n    public:\\n    void deleteNode(ListNode* node) {\\n        if(node == NULL) return;\\n        ListNode *tmp = node->next;\\n        node->val = tmp->val;\\n        node->next = tmp->next;\\n        delete tmp;\\n    }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    void deleteNode(ListNode* node) {\\n        if(node == NULL) return;\\n        ListNode *tmp = node->next;\\n        node->val = tmp->val;\\n        node->next = tmp->next;\\n        delete tmp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 65565,
                "title": "solution-in-java-in-2-lines",
                "content": "The idea is to copy the data of next node to current node and then delete the next node.\\n\\n\\n    public class Solution {\\n        public void deleteNode(ListNode node) {\\n            \\n            node.val = node.next.val;\\n            node.next = node.next.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void deleteNode(ListNode node) {\\n            \\n            node.val = node.next.val;\\n            node.next = node.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 665790,
                "title": "java-c-python3-with-explanation-2-line-code",
                "content": "```\\nEXPLANATION:-\\n   The idea behind this solution is we have only access to node to be deleted.\\n   So, copy the contents of next node and delete the next node.\\n   \\n   time:- O(1)\\n   space:- O(1)\\n   \\n   IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK\\n   IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\\n```\\nJava :-\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n\\nPython3:-\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\nC++:-\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nEXPLANATION:-\\n   The idea behind this solution is we have only access to node to be deleted.\\n   So, copy the contents of next node and delete the next node.\\n   \\n   time:- O(1)\\n   space:- O(1)\\n   \\n   IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK\\n   IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\n```\\nJava :-\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n\\nPython3:-\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\nC++:-\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65621,
                "title": "simple-c-solution",
                "content": "    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        ListNode* t = node->next;\\n        node->next = t->next;\\n        delete t;\\n    }",
                "solutionTags": [],
                "code": "    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        ListNode* t = node->next;\\n        node->next = t->next;\\n        delete t;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3417332,
                "title": "c-java-python-javascript-2-lines-of-code-linked-list",
                "content": "# Intuition:\\nTo delete a node in a singly-linked list, we can simply modify the current node\\'s value with the value of its next node and then skip the next node.\\n\\n---\\n\\n\\n# Approach:\\nWe first update the value of the current node with the value of its next node, and then we skip the next node by pointing the current node\\'s next pointer to its next node\\'s next pointer.\\n\\n---\\n\\n\\n# Complexity:\\n- Time complexity: Since we are only modifying the value and next pointer of the given node, the time complexity of this algorithm is O(1).\\n\\n- Space complexity: As we are not using any extra space, the space complexity of this algorithm is O(1).\\n\\n---\\n\\n# Code : C++\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next= node->next->next;\\n    }\\n};\\n```\\n\\n---\\n# Code : JAVA\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```\\n---\\n# Code : Python\\n```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\n---\\n# Code : JavaScript\\n```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next= node->next->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\n```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697472,
                "title": "java-better-than-100-2-approaches-fully-explained",
                "content": "![image](https://assets.leetcode.com/users/images/88b3c563-d774-467a-85c1-33fe79ed0143_1665646090.4154038.png)\\n\\n\\n# Intuition\\nWe are given any node in a linked list and we must remove that node.\\n\\nThe first thing that comes to mind is mutating/changing the previous\\' node reference to point to the next node. We can immediately see that it\\'s not possible because we can\\'t access the reference of the previous node.\\n\\nThe only choice we have left is to shift the values of the sublist that we have to the left. For example our list is `1 -> 2 -> 3 -> 4` and we wan\\'t to delete node `2` then we will shift from that node, i.e.: `1 -> 3 -> 4 -> null`. And that\\'s how we remove the node.\\n\\n# Code\\n```\\nclass Solution {\\n    /**\\n    * We can\\'t change the reference of the previous node to pointer to the next node.\\n    * Hence, we must shift the values of the nodes that we have access to.\\n    */\\n    public void deleteNode(ListNode node) {\\n        ListNode currentPointer = node;\\n        ListNode nextPointer = node.next;\\n        \\n        while (nextPointer != null) {\\n            currentPointer.val = nextPointer.val;\\n            currentPointer = nextPointer;\\n            nextPointer = nextPointer.next;\\n        }\\n        \\n        \\n        // We must remove the last node after the shift.\\n        currentPointer = node;\\n        while (currentPointer.next.next != null) {\\n            currentPointer = currentPointer.next;\\n        }\\n        currentPointer.next = null;\\n    }\\n}\\n```\\n\\n# Reference change\\nWe know we can\\'t get access of the previous node. Instead of changing the reference of the previous node to point to the next node, we can \"skip\" a node by marking the current node with the value of the next node, and skpping the duplicate.\\n\\nExample: Delete node `2`\\nList: `1->2->3->4`\\nMark current with next value: `1->3->3->4`\\nDelete the duplicate (next) reference: `1->3->4`\\n\\n# Code\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        ListNode currentPointer = node;\\n        ListNode nextPointer = node.next;\\n        \\n        // Mark current with next\\'s value\\n        currentPointer.val = nextPointer.val;\\n        \\n        // Skip the duplicate (delete)\\n        currentPointer.next = nextPointer.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n    * We can\\'t change the reference of the previous node to pointer to the next node.\\n    * Hence, we must shift the values of the nodes that we have access to.\\n    */\\n    public void deleteNode(ListNode node) {\\n        ListNode currentPointer = node;\\n        ListNode nextPointer = node.next;\\n        \\n        while (nextPointer != null) {\\n            currentPointer.val = nextPointer.val;\\n            currentPointer = nextPointer;\\n            nextPointer = nextPointer.next;\\n        }\\n        \\n        \\n        // We must remove the last node after the shift.\\n        currentPointer = node;\\n        while (currentPointer.next.next != null) {\\n            currentPointer = currentPointer.next;\\n        }\\n        currentPointer.next = null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        ListNode currentPointer = node;\\n        ListNode nextPointer = node.next;\\n        \\n        // Mark current with next\\'s value\\n        currentPointer.val = nextPointer.val;\\n        \\n        // Skip the duplicate (delete)\\n        currentPointer.next = nextPointer.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514068,
                "title": "c-simple-solution",
                "content": "**C++ :**\\n\\n```\\nvoid deleteNode(ListNode* node) {\\n\\tnode -> val = node -> next -> val;\\n\\tnode -> next = node -> next -> next;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid deleteNode(ListNode* node) {\\n\\tnode -> val = node -> next -> val;\\n\\tnode -> next = node -> next -> next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65567,
                "title": "my-java-easy-answer",
                "content": "**Notice :**  In this problem, we can't delete the last node with java code , so the problem says \"except the tail\". If I'm wrong, please tell me :) \\n\\n    public void deleteNode(ListNode node) {\\n        \\n        if(node.next==null || node==null )\\n\\t\\t\\treturn ;\\n\\n        node.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\t\\t\\n    }",
                "solutionTags": [],
                "code": "**Notice :**  In this problem, we can't delete the last node with java code , so the problem says \"except the tail\". If I'm wrong, please tell me :) \\n\\n    public void deleteNode(ListNode node) {\\n        \\n        if(node.next==null || node==null )\\n\\t\\t\\treturn ;\\n\\n        node.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\t\\t\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2696757,
                "title": "java-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635131,
                "title": "0ms-faster-than-100-java",
                "content": "**Copy the value of the next node in the given node.\\nThen make the given node point to the node to the next of the next of the given node.**\\n\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        \\n        node.val = node.next.val;\\n        \\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        \\n        node.val = node.next.val;\\n        \\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65516,
                "title": "java-1ms-solution",
                "content": "    public class Solution {\\n        public void deleteNode(ListNode node) {\\n    \\t\\tif (node.next != null) {\\n    \\t\\t\\tnode.val = node.next.val;\\n    \\t\\t\\tnode.next = node.next.next;\\n    \\t\\t}\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void deleteNode(ListNode node) {\\n    \\t\\tif (node.next != null) {\\n    \\t\\t\\tnode.val = node.next.val;\\n    \\t\\t\\tnode.next = node.next.next;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3565877,
                "title": "c-one-line-solution-o-1-beats-100-without-declaring-any-variable",
                "content": "\\n# Approach\\nUpdate the memory container of ```node``` by replacing current ```node``` instance with the instance of next ```ListNode```\\n\\n**NOTE:** ```*node``` returns the value of memory address where that particular *node* is stored\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node=*node->next;\\n    }\\n};\\n```\\n\\n**Please upvote if you like the solution!\\uD83E\\uDD79**",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```node```\n```node```\n```ListNode```\n```*node```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node=*node->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957043,
                "title": "js-simple-explained-98-faster-recursively",
                "content": "# 237. Delete Node in a Linked List \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nThis Question is rated **Easy**. Which I think is ***extremely*** inaccurate. I think it is more of a **Medium** question. The question and its description is ***highly misleading ***.\\n\\n***This is a trick question***. We\\'re told that the node we\\'re given, is the node that we will be deleting. Which is ***wrong***. ***We can never delete the node*** we\\'re given. The reason for this is that we\\'re never given access to the head of the linked list, which maintains the `next` pointer to the node that we\\'re going to delete. \\nWhat this means is we\\'re going to fully break the list if we delete the node we\\'re given.\\n\\n***So what do we do?***\\nGiven our limitations to deleting the given node, we\\'re instead going to move the values of our nodes backwards. Meaning we\\'re going to shift all the values we have one node back. Then we\\'re going to ***delete the last node*** of the list.\\n\\n***What? That makes no sense!?***\\nI know it sounds confusing. But it\\'s really simple. See the example below\\n\\nNode to delete: `5`\\nLinked List: `1->2->3->4->5->6->7->8->9`\\nNote: We can only see `(5->6->7->8->9)` Because we\\'re not given access to the `head`\\n\\nNow ***let\\'s start shifting the values backwards***:\\nCycle 1:\\nNote: This is where we start, on node `5`. So what we do is Make node `5` become node `6`\\nWhat we see `(6->6->7->8->9)`\\nLinked List: `1->2->3->4->6->6->7->8->9`\\n\\nCycle 2:\\nNote: We\\'ve now changed node `5` to become `6` so let\\'s change `6` to become `7`\\nWhat we see `(6->7->7->8->9)`\\nLinked List: `1->2->3->4->6->7->7->8->9`\\n\\nCycle 3:\\nNote: We\\'ve now changed node `6` to become `7` so let\\'s change `7` to become `8`\\nWhat we see `(6->7->8->8->9)`\\nLinked List: `1->2->3->4->6->7->8->8->9`\\n\\nRepeat this until we reach the very last node. \\nOnce at the last node we should have a linked list like this:\\nLinked List: `1->2->3->4->6->7->8->9->9`\\n\\nNow all we have to do, is remove the last duplicate node and we would have effectively deleted the given node.\\n\\n##  Recommended Knowledge\\n1. Linked Lists\\n2. Linked List Traversal\\n3. Linked List Traversal (Recursively) * ***Not needed but recommened***\\n4. How to changed linked list values\\n\\n## What do we know?\\n1. We have been given a trick question. See above.\\n2. We need to shift all the given values in the linked list backwards\\n\\n## How we\\'re going to do it:\\n1. At each node, we\\'re going to set the current nodes value to whatever the next value is.\\n2. We will have a prev pointer, keeping track of the last node we visited, which we update at every node\\n3. Once we have changed all of these values and we have reached the end of the list, we will remove the last node of the list as that is a dupe.\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the list length | As we will traverse them all\\n* Space Complexity: *O(**1**)* | As we never allocate extra space\\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 63 ms, faster than ***97.49%*** of JavaScript online submissions for Delete Node in a Linked List\\n* Memory Usage: 44.7 MB, less than ***18.59%*** of JavaScript online submissions for Delete Node in a Linked List\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/682104375/)\\n\\n\\n***\\n\\n# The Solution\\nvar deleteNode = function (node, prev) {\\n    \\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                      237. Delete Node in a Linked List                     */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @author  Samuel Hinchliffe\\n     * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n     * @see    {@link github.com/Samuel-Hinchliffe}\\n     */\\n\\n\\t// NOTE: This is not a easy problem.\\n\\t// It would be easy, if this was JUST deleting a node.\\n\\t// But as we never have the head of the linked list, this is a trick question.\\n\\t// So instead, we shift all the values backwards and remove the last node.\\n\\n\\t// We\\'re going to do this recursively, meaning, that we\\'re going to apply the same\\n\\t// rules for every node we encounter. So this must mean, we\\'re going to have to prepare\\n\\t// ourselves for every outcome possible. Starting with:\\n\\n\\t// Does the next node exist?\\n\\t// IF NOT: We\\'re at the end of the list, so\\n\\t// we nullify the prev node\\'s next pointer. (As that pointer is on the last node)\\n\\t// IF the next node does exist:\\n\\tif (node.next) {\\n\\t\\t// We update our prev node pointer, to be this current node (We do this because we need to always know the previous node)\\n\\t\\t// Because we will nullify it\\'s next in the end.\\n\\t\\tprev = node;\\n\\n\\t\\t// We now set our current nodes value to the next node\\'s value. (Shifting the values)\\n\\t\\t// Because we\\'re going to shift all the values backwards. The reason for this is because we cannot just\\n\\t\\t// delete the node, as the unaccessible head will still point towards it. (This is what makes this a trick question)\\n\\t\\tnode.val = node.next.val;\\n\\n\\t\\t// Now recursively call this function, with the next node.\\n\\t\\t// Keep doing the above until we reach the very end of the list\\n\\t\\tdeleteNode(node.next, prev);\\n\\t} else {\\n\\t\\tprev.next = null;\\n\\t}\\n\\n\\t// Don\\'t worry if you\\'re just starting our on linked lists and don\\'t understand this.\\n\\t// Leetcode has marked this as easy, but it\\'s not. They make it look simple, but it\\'s a trick question.\\n\\t// If you don\\'t understand, you\\'re all good. It\\'s just a trick question.\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Recursion"
                ],
                "code": "# 237. Delete Node in a Linked List \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nThis Question is rated **Easy**. Which I think is ***extremely*** inaccurate. I think it is more of a **Medium** question. The question and its description is ***highly misleading ***.\\n\\n***This is a trick question***. We\\'re told that the node we\\'re given, is the node that we will be deleting. Which is ***wrong***. ***We can never delete the node*** we\\'re given. The reason for this is that we\\'re never given access to the head of the linked list, which maintains the `next` pointer to the node that we\\'re going to delete. \\nWhat this means is we\\'re going to fully break the list if we delete the node we\\'re given.\\n\\n***So what do we do?***\\nGiven our limitations to deleting the given node, we\\'re instead going to move the values of our nodes backwards. Meaning we\\'re going to shift all the values we have one node back. Then we\\'re going to ***delete the last node*** of the list.\\n\\n***What? That makes no sense!?***\\nI know it sounds confusing. But it\\'s really simple. See the example below\\n\\nNode to delete: `5`\\nLinked List: `1->2->3->4->5->6->7->8->9`\\nNote: We can only see `(5->6->7->8->9)` Because we\\'re not given access to the `head`\\n\\nNow ***let\\'s start shifting the values backwards***:\\nCycle 1:\\nNote: This is where we start, on node `5`. So what we do is Make node `5` become node `6`\\nWhat we see `(6->6->7->8->9)`\\nLinked List: `1->2->3->4->6->6->7->8->9`\\n\\nCycle 2:\\nNote: We\\'ve now changed node `5` to become `6` so let\\'s change `6` to become `7`\\nWhat we see `(6->7->7->8->9)`\\nLinked List: `1->2->3->4->6->7->7->8->9`\\n\\nCycle 3:\\nNote: We\\'ve now changed node `6` to become `7` so let\\'s change `7` to become `8`\\nWhat we see `(6->7->8->8->9)`\\nLinked List: `1->2->3->4->6->7->8->8->9`\\n\\nRepeat this until we reach the very last node. \\nOnce at the last node we should have a linked list like this:\\nLinked List: `1->2->3->4->6->7->8->9->9`\\n\\nNow all we have to do, is remove the last duplicate node and we would have effectively deleted the given node.\\n\\n##  Recommended Knowledge\\n1. Linked Lists\\n2. Linked List Traversal\\n3. Linked List Traversal (Recursively) * ***Not needed but recommened***\\n4. How to changed linked list values\\n\\n## What do we know?\\n1. We have been given a trick question. See above.\\n2. We need to shift all the given values in the linked list backwards\\n\\n## How we\\'re going to do it:\\n1. At each node, we\\'re going to set the current nodes value to whatever the next value is.\\n2. We will have a prev pointer, keeping track of the last node we visited, which we update at every node\\n3. Once we have changed all of these values and we have reached the end of the list, we will remove the last node of the list as that is a dupe.\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the list length | As we will traverse them all\\n* Space Complexity: *O(**1**)* | As we never allocate extra space\\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 63 ms, faster than ***97.49%*** of JavaScript online submissions for Delete Node in a Linked List\\n* Memory Usage: 44.7 MB, less than ***18.59%*** of JavaScript online submissions for Delete Node in a Linked List\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/682104375/)\\n\\n\\n***\\n\\n# The Solution\\nvar deleteNode = function (node, prev) {\\n    \\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                      237. Delete Node in a Linked List                     */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @author  Samuel Hinchliffe\\n     * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n     * @see    {@link github.com/Samuel-Hinchliffe}\\n     */\\n\\n\\t// NOTE: This is not a easy problem.\\n\\t// It would be easy, if this was JUST deleting a node.\\n\\t// But as we never have the head of the linked list, this is a trick question.\\n\\t// So instead, we shift all the values backwards and remove the last node.\\n\\n\\t// We\\'re going to do this recursively, meaning, that we\\'re going to apply the same\\n\\t// rules for every node we encounter. So this must mean, we\\'re going to have to prepare\\n\\t// ourselves for every outcome possible. Starting with:\\n\\n\\t// Does the next node exist?\\n\\t// IF NOT: We\\'re at the end of the list, so\\n\\t// we nullify the prev node\\'s next pointer. (As that pointer is on the last node)\\n\\t// IF the next node does exist:\\n\\tif (node.next) {\\n\\t\\t// We update our prev node pointer, to be this current node (We do this because we need to always know the previous node)\\n\\t\\t// Because we will nullify it\\'s next in the end.\\n\\t\\tprev = node;\\n\\n\\t\\t// We now set our current nodes value to the next node\\'s value. (Shifting the values)\\n\\t\\t// Because we\\'re going to shift all the values backwards. The reason for this is because we cannot just\\n\\t\\t// delete the node, as the unaccessible head will still point towards it. (This is what makes this a trick question)\\n\\t\\tnode.val = node.next.val;\\n\\n\\t\\t// Now recursively call this function, with the next node.\\n\\t\\t// Keep doing the above until we reach the very end of the list\\n\\t\\tdeleteNode(node.next, prev);\\n\\t} else {\\n\\t\\tprev.next = null;\\n\\t}\\n\\n\\t// Don\\'t worry if you\\'re just starting our on linked lists and don\\'t understand this.\\n\\t// Leetcode has marked this as easy, but it\\'s not. They make it look simple, but it\\'s a trick question.\\n\\t// If you don\\'t understand, you\\'re all good. It\\'s just a trick question.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389536,
                "title": "very-easy-solution",
                "content": "```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 666589,
                "title": "c-1-line-code-simple-and-short",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n\\t    *node = *(node->next);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n\\t    *node = *(node->next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666519,
                "title": "c-python-illustration-of-linked-list",
                "content": "Note, this post is a modified version of the following post:\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/discuss/65547/My-C%2B%2B-solution-in-1-line \\n\\nNote: The tricky point is that we can not use: \\n    node=node->next\\nBecause we have not change the address content stored in the previous node.\\nIt just likes that you change your room number but remains everything in the room, isn\\u2019t it\\n\\nIn fact , a linked list will be stored like this:\\n\\n**head ->  {val1,   address2}    {val2, address3}  {val3, address4}   {val4, NULL}**\\n\\nSo, if we are given access to the *cur = {val3, address4}\\n\\nIf we want to delete the *cur, we have to change the content stored in *cur.\\n\\nIf we use cur=cur->next, what happens ?\\n\\nOOPS ! nothing happens ... because the \"address#\" stored in the linked list keeps no changing!\\n\\nSo \"cur=cur->next\" makes no impact on the linked list.\\n\\nC++\\n```\\nclass Solution {// BEST1:\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node = *(node->next);\\n    }\\n};\\n```\\nExplanation:\\nRecall the definition of ListNode:\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\n ```\\n Let\\'s imagaing each List Node as something like folllowing in the memory:\\n {val, address_to_next}\\n  So \\n  ```\\n   *node = *(node->next);\\n   ```\\n   means you copy EVERYTHING from one (the obejct pointed by node->next) to another (the object pointed by node)\\n   So its function is the  same as:\\n   ```\\n\\t node->val = node->next->val;\\n     node->next = node->next->next; \\n```\\n\\n```\\nclass Solution { //BEST3: Same as BEST1\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val = node->next->val;\\n       node->next = node->next->next; \\n    }\\n};\\n```\\n\\n```\\nclass Solution { // BEST2:\\npublic: // if the node should be freed, we need 3 lines\\n    void deleteNode(ListNode* node) {\\n        ListNode* temp = node->next;\\n        *node = *temp;\\n        delete temp;\\n    }\\n};\\n```\\n\\nPython:\\n```\\ndef deleteNode(self, node):\\n    node.val = node.next.val\\n    node.next = node.next.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {// BEST1:\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node = *(node->next);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\n ```\n```\\n   *node = *(node->next);\\n   ```\n```\\n\\t node->val = node->next->val;\\n     node->next = node->next->next; \\n```\n```\\nclass Solution { //BEST3: Same as BEST1\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val = node->next->val;\\n       node->next = node->next->next; \\n    }\\n};\\n```\n```\\nclass Solution { // BEST2:\\npublic: // if the node should be freed, we need 3 lines\\n    void deleteNode(ListNode* node) {\\n        ListNode* temp = node->next;\\n        *node = *temp;\\n        delete temp;\\n    }\\n};\\n```\n```\\ndef deleteNode(self, node):\\n    node.val = node.next.val\\n    node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65532,
                "title": "simple-4ms-c-solution",
                "content": "    void deleteNode(struct ListNode* node) {\\n        struct ListNode* temp;\\n        temp=node->next;\\n        node->val=temp->val;\\n        node->next=temp->next;\\n        free(temp);\\n    }\\n\\nEg.a->b->c->d->e->....->z->NULL\\nNow suppose we wan't to delete node 'c',we can't directly do b->d and free(c) as we have access only to the node to be deleted,i.e.,'c'.But we can access d via c, so we copy d's info into c's info and make c point e, in short, c is now the same as d and so we delete d and get the desired result.",
                "solutionTags": [],
                "code": "    void deleteNode(struct ListNode* node) {\\n        struct ListNode* temp;\\n        temp=node->next;\\n        node->val=temp->val;\\n        node->next=temp->next;\\n        free(temp);\\n    }\\n\\nEg.a->b->c->d->e->....->z->NULL\\nNow suppose we wan't to delete node 'c',we can't directly do b->d and free(c) as we have access only to the node to be deleted,i.e.,'c'.But we can access d via c, so we copy d's info into c's info and make c point e, in short, c is now the same as d and so we delete d and get the desired result.",
                "codeTag": "Unknown"
            },
            {
                "id": 65559,
                "title": "a-js-solution",
                "content": "    var deleteNode = function(node) {\\n        \\n        if(node.val !== undefined && node.next !== undefined){\\n            //copy the next node to this node\\n            node.val = node.next.val;\\n            node.next = node.next.next;\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var deleteNode = function(node) {\\n        \\n        if(node.val !== undefined && node.next !== undefined){\\n            //copy the next node to this node\\n            node.val = node.next.val;\\n            node.next = node.next.next;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3222696,
                "title": "c-beginner-friendly-solutions-beats-92-97",
                "content": "# Intuition\\n***Head is not given in this question so we have to go through another way, so here is the basic approach...***\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n 1. Just copy the next node val to the current node val & the copy the next to next node address to the current node(the node the is given)\\n 2. now take another ListNode type pointer that points to the node that is copied.\\n 3. delete that node using **delete POINTER_NAME** it prevents memoryleak\\nListNode* t;\\n        t=node->next;\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        delete t;\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       \\n        ListNode* t;\\n        t=node->next;\\n\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        delete t;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       \\n        ListNode* t;\\n        t=node->next;\\n\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        delete t;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246383,
                "title": "java-in-depth-explanation-easy-to-implement",
                "content": "We don\\'t need to consider the case that node is tail node. Hence, it\\'s simple. \\n  \\n  ```\\n  class Solution \\n{\\n    public void deleteNode(ListNode node) \\n    {\\n        // O(1) time | O(1) space\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  class Solution \\n{\\n    public void deleteNode(ListNode node) \\n    {\\n        // O(1) time | O(1) space\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851654,
                "title": "c-easy-90-faster-linked-list",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node)\\n    {\\n        //since it is given the element needed to be deleted is not the last node\\n        //so we do not need to care for that case.\\n        \\n        swap(node->val,node->next->val); //swaping the target node and the next of the target node\\n\\t\\t\\n        ListNode* temp = node->next;\\n        node->next = node->next->next;\\n        delete temp; \\n    }\\n};\\n```\\nNote: \\n\\n\\t\\t\\tListNode* temp = node->next;\\n\\t\\t\\tdelete temp; \\n\\t\\t\\t\\n***Skipping the above lines won\\'t give you error. The program will run perfectly fine but i have used these lines because it is very important and very good practice  to free the space from memoy,since in real world it can lead to memory leakage.***\\n\\n* **Try to understand the code rather than coping the code or reposting the code.**\\n* **Upvote my solution if you liked it.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node)\\n    {\\n        //since it is given the element needed to be deleted is not the last node\\n        //so we do not need to care for that case.\\n        \\n        swap(node->val,node->next->val); //swaping the target node and the next of the target node\\n\\t\\t\\n        ListNode* temp = node->next;\\n        node->next = node->next->next;\\n        delete temp; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454184,
                "title": "95-96-faster-and-simpler-solution-with-explanation",
                "content": "The solution is simply to copy the data from the next node over to the current node, and then to delete the node. \\n\\n\\n```\\nclass Solution:\\n    def deleteNode(self, node):\\n\\n        nextNode = node.next\\n        node.val = nextNode.val\\n        node.next = nextNode.next\\n```\\nRuntime: 32 ms, faster than 95.96% of Python3 online submissions for Delete Node in a Linked List.\\nMemory Usage: 14.8 MB, less than 61.46% of Python3 online submissions for Delete Node in a Linked List.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n\\n        nextNode = node.next\\n        node.val = nextNode.val\\n        node.next = nextNode.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405716,
                "title": "python-beginner-friendly",
                "content": "Do upvote if this helped you,\\nhappy learning :)\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        if not node:\\n            return\\n        node.val = node.next.val #new node value is the value of next node\\n        node.next = node.next.next \\n        \\n",
                "solutionTags": [],
                "code": "Do upvote if this helped you,\\nhappy learning :)\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        if not node:\\n            return\\n        node.val = node.next.val #new node value is the value of next node\\n        node.next = node.next.next \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 808803,
                "title": "c-short-solution-with-freeing-memory-most-posts-don-t-and-it-s-wrong",
                "content": "```\\nvoid deleteNode(struct ListNode* node) \\n{\\n    node->val = node->next->val;\\n    struct ListNode* temp = node->next;\\n    node->next = node->next->next;\\n    free(temp);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid deleteNode(struct ListNode* node) \\n{\\n    node->val = node->next->val;\\n    struct ListNode* temp = node->next;\\n    node->next = node->next->next;\\n    free(temp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 666376,
                "title": "c-o-1-simple-solution",
                "content": "```\\npublic class Solution {\\n    public void DeleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public void DeleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297138,
                "title": "python-faster-than-97-24-ms",
                "content": "```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        cur = node\\n        while node.next!=None:\\n            node.val = node.next.val\\n            cur = node\\n            node = node.next\\n        cur.next = None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        cur = node\\n        while node.next!=None:\\n            node.val = node.next.val\\n            cur = node\\n            node = node.next\\n        cur.next = None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231739,
                "title": "237-time-95-56-and-space-86-81-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution is for deleting a node in a singly-linked list without being given the head of the list. The solution takes in a node to be deleted as its input and modifies the list by deleting that node.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. The ListNode class is defined with val and next attributes.\\n2. The Solution class is defined with a deleteNode method which takes in a node of type ListNode as input and returns None.\\n3. Inside the deleteNode method, the value of the given node is updated to the value of its next node using node.val = node.next.val. Essentially, the value of the node to be deleted is overwritten by the value of its next node.\\n4. Then, the next pointer of the given node is updated to skip over the next node and point to the node after that using node.next = node.next.next. This effectively removes the next node from the list and connects the current node to the node after it.\\n5. The modified linked list is returned. Since the input list is modified in-place, the method does not explicitly return anything.\\nOverall, this solution has a time complexity of O(1) since it only updates the pointers of the given node and its next node, and does not require any traversal of the list.\\n\\n# Complexity\\n- Time complexity:\\n95.56%\\n\\n- Space complexity:\\n86.81%\\n\\n# Code\\n```\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteNode(self, node: ListNode) -> None:\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteNode(self, node: ListNode) -> None:\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132058,
                "title": "best-o-1-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode* curr = node, * nxt = node->next;\\n        while (nxt->next != NULL) {\\n            curr->val = nxt->val;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n        curr->val = nxt->val;\\n        curr->next = NULL;\\n    }\\n};\\n```\\n\\n# Approach 2\\nOptimal \\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode* curr = node, * nxt = node->next;\\n        while (nxt->next != NULL) {\\n            curr->val = nxt->val;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n        curr->val = nxt->val;\\n        curr->next = NULL;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775186,
                "title": "1-line-java-0ms-solution-using-for-loop",
                "content": "O(1) Solution in a single line. Java using for loop\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        for(boolean b=true; b; b=false, node.val = node.next.val, node.next = node.next.next);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        for(boolean b=true; b; b=false, node.val = node.next.val, node.next = node.next.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699687,
                "title": "python3-one-liner-o-o-holly-shch-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nSince we do not have the access to the previous node, we can simply turn the current node into the next node by copying the value, and then delete the next node instead of the current. Do not forget delete the link of the next node to the `next.next` node by assigning the `None` to prevent memory leak.\\n\\n```\\nclass Solution:\\n    def deleteNode(self, node):\\n\\t\\tnode.val, node.next.next, node.next = node.next.val, None, node.next.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n\\t\\tnode.val, node.next.next, node.next = node.next.val, None, node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696332,
                "title": "3-approach-c-no-memory-leak-tc-1-space-1",
                "content": "**Approach :1**\\n\\n\\n\\n        *node=*node->next; //just copy\\n\\n\\n**Approach : 2**\\n\\n        node->val = node->next->val; //delete node given next value\\n        node->next = node->next->next; //making link\\n\\t\\t\\n\\t\\t\\n**Approach : 3**\\n     \\n\\t    ListNode *temp=node->next; //store delete node in temp\\n        node->val=node->next->val; //copy the data\\n        node->next=node->next->next; //making link also break link\\n        delete temp; //delet the data because don\\'t want memeory leak\\n\\t\\t\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**Approach :1**\\n\\n\\n\\n        *node=*node->next; //just copy\\n\\n\\n**Approach : 2**\\n\\n        node->val = node->next->val; //delete node given next value\\n        node->next = node->next->next; //making link\\n\\t\\t\\n\\t\\t\\n**Approach : 3**\\n     \\n\\t    ListNode *temp=node->next; //store delete node in temp\\n        node->val=node->next->val; //copy the data\\n        node->next=node->next->next; //making link also break link\\n        delete temp; //delet the data because don\\'t want memeory leak\\n\\t\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2586845,
                "title": "python-99-23-faster-simplest-solution-with-visual-explanation-beg-to-adv-linked-list",
                "content": "***Found helpful, Do upvote!!***\\nHow do we normally remove/ delete node from a linked list when head is provided:\\n```python\\nwhile head is not None and head.val == val: # head node should not be empty and we are checking if head value is identical to the value given.\\n            head = head.next # # updating the head node to the next one. \\n        current = head # if not equal then we are assiging the head to current var.\\n        while current is not None: # cheking for head not be a empty one.\\n            if current.next is not None and current.next.val == val: # checking for next node value is it equal to the given value.\\n                current.next = current.next.next # if yes, then we remove the next one by skipping it & assiging the next as next to next node\\n            else:\\n                current = current.next # else we`ll just assign the next node to current.\\n        return head \\n```\\n**Problem statement link :-** https://leetcode.com/problems/remove-linked-list-elements/\\n\\n**Approach we are following to solve this question:-**\\n1. We`ll copy the value of next node in the current node.(node.value = node.next.val)\\n2. Then will remove the next node by pointing the current node next to the next node of current next node (i.e node.next.next)\\n\\nWhy we used this approach is :\\n1. We are not given with head node.\\n2. Also it is guaranteed that they wouldn`t ask us to remove the last node of the provided linked list.\\n\\n**Visual explantion:**\\nFor example below is the given linked list and node that needs ot be deleted is 3.\\n![image](https://assets.leetcode.com/users/images/3a7582cd-95c2-4035-ac90-f8acce4c8d86_1663409764.8280253.png)\\nAfter coping the next node it`d look like :\\n![image](https://assets.leetcode.com/users/images/7411b0bc-8922-417c-a10a-0f1af0483412_1663409898.5257802.png)\\nNow we have to update the next pointer i.e node.next.next\\n![image](https://assets.leetcode.com/users/images/0d98c204-8971-49da-ada5-a3fc6b9b8ce5_1663409956.5019855.png)\\nFinally we have the desired list:\\n![image](https://assets.leetcode.com/users/images/2abdb5d2-5f9c-44f4-8980-f50ec64a20a0_1663410001.386711.png)\\n\\n\\n**Lets checkout the code now**\\n**1. Without using temp pointer:**\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        node.val = node.next.val # copying next node value in the currernt node.\\n        node.next = node.next.next # to delete the next node that we copied, we are updating the reference of the node to next to next node.\\n```\\n**2. With using temp pointer:**\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        temp = node.next # making a temp pointer to save the next node.\\n        node.val = temp.val # copying the value of next node value to the current node.\\n        node.next = temp.next # update the reference to the next to next node.\\n```\\n\\n***Found helpful, Do upvote!!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python\\nwhile head is not None and head.val == val: # head node should not be empty and we are checking if head value is identical to the value given.\\n            head = head.next # # updating the head node to the next one. \\n        current = head # if not equal then we are assiging the head to current var.\\n        while current is not None: # cheking for head not be a empty one.\\n            if current.next is not None and current.next.val == val: # checking for next node value is it equal to the given value.\\n                current.next = current.next.next # if yes, then we remove the next one by skipping it & assiging the next as next to next node\\n            else:\\n                current = current.next # else we`ll just assign the next node to current.\\n        return head \\n```\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        node.val = node.next.val # copying next node value in the currernt node.\\n        node.next = node.next.next # to delete the next node that we copied, we are updating the reference of the node to next to next node.\\n```\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        \\n        temp = node.next # making a temp pointer to save the next node.\\n        node.val = temp.val # copying the value of next node value to the current node.\\n        node.next = temp.next # update the reference to the next to next node.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040372,
                "title": "java-100-fast-explained",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        \\n        // now as we can\\'t go in reverse direction our approach would be manipulation of \\n        // a. links\\n        // b. values of the node\\n        \\n        // only link change would not be sufficient as we do not have access to the prev node\\n        \\n        // we can swap the value of 5, 1 (as in example)\\n        // and then delete the 5 valued node\\n        \\n        if(node != null && node.next != null)\\n        {\\n            // putting the value of next node into our current node\\n            node.val = node.next.val;\\n            \\n            // our list looks like:\\n            // 4->1->1->9->null\\n            \\n            // connecting node to 9, deleting the mid 1\\n            node.next = node.next.next;\\n        }\\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        \\n        // now as we can\\'t go in reverse direction our approach would be manipulation of \\n        // a. links\\n        // b. values of the node\\n        \\n        // only link change would not be sufficient as we do not have access to the prev node\\n        \\n        // we can swap the value of 5, 1 (as in example)\\n        // and then delete the 5 valued node\\n        \\n        if(node != null && node.next != null)\\n        {\\n            // putting the value of next node into our current node\\n            node.val = node.next.val;\\n            \\n            // our list looks like:\\n            // 4->1->1->9->null\\n            \\n            // connecting node to 9, deleting the mid 1\\n            node.next = node.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1554468,
                "title": "5-lines-code-very-easy-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode*temp,*todelete;\\n        node->val=node->next->val;\\n        todelete=node->next;\\n        node->next=node->next->next;\\n        delete todelete;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1533555,
                "title": "c-easy-solution-even-example-not-needed",
                "content": "\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        int x= node->next->val;\\n        ListNode *ptr=node->next->next;\\n        node->val=x;\\n        node->next=ptr;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        int x= node->next->val;\\n        ListNode *ptr=node->next->next;\\n        node->val=x;\\n        node->next=ptr;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1517762,
                "title": "super-easy-c-code-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) \\n    {\\n        ListNode* p = node->next;       //pointer to the node which is next to the deleting node\\n        node->val = p->val;             //copy the value of next node to the value of deleting node\\n        node->next = p->next;           //copy the address of next-to-next node to the next of deleting node\\n        delete p;                       //delete the next node\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) \\n    {\\n        ListNode* p = node->next;       //pointer to the node which is next to the deleting node\\n        node->val = p->val;             //copy the value of next node to the value of deleting node\\n        node->next = p->next;           //copy the address of next-to-next node to the next of deleting node\\n        delete p;                       //delete the next node\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484786,
                "title": "easy-problem",
                "content": "If you want to read more about LeetCode Notes,you can follow my Blog [iamyqhp.com](http://iamyqhp.com/)\\n# 237. Delete Node in a Linked List\\n\\nThis is a very easy problem.We can draw a picture to understand it.\\n\\n![](https://assets.leetcode.com/users/images/157daca0-0287-48b4-9107-28355855212c_1632556194.4572675.png)\\n\\n\\n**Solution**\\n\\n```java\\n  public void deleteNode(ListNode node) {\\n    //copy the next node value\\n    node.val = node.next.val;\\n    //delete the next node\\n    node.next = node.next.next;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n  public void deleteNode(ListNode node) {\\n    //copy the next node value\\n    node.val = node.next.val;\\n    //delete the next node\\n    node.next = node.next.next;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399648,
                "title": "c-very-very-easy-solution-in-2-line",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val=node->next->val;  //node value is equal to node next val\\n        node->next=node->next->next; //now point next to next\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val=node->next->val;  //node value is equal to node next val\\n        node->next=node->next->next; //now point next to next\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289393,
                "title": "easy-o-1-solution-with-explanation",
                "content": "**Please Upvote if you Liked the Post**\\n\\n```\\n/* The only trick here is to make a pointer point next to node to be deleted  \\n(call that pointer to be temp)and copy its value to\\nthe given node and now change the link from this node(given node) to temp.next , by this way we \\nremoved the node to be deleted.*/\\n\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        ListNode temp = node.next;\\n        \\n        node.val = temp.val;\\n        node.next = temp.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* The only trick here is to make a pointer point next to node to be deleted  \\n(call that pointer to be temp)and copy its value to\\nthe given node and now change the link from this node(given node) to temp.next , by this way we \\nremoved the node to be deleted.*/\\n\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        ListNode temp = node.next;\\n        \\n        node.val = temp.val;\\n        node.next = temp.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123350,
                "title": "single-line-code-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    void deleteNode(ListNode* node) \\n    {\\n        *node=(*(node->next));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void deleteNode(ListNode* node) \\n    {\\n        *node=(*(node->next));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097986,
                "title": "kotlin-simple",
                "content": "```\\n    fun deleteNode(node: ListNode?) {\\n        node!!.`val` = node.next.`val`\\n        node!!.next = node.next.next\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun deleteNode(node: ListNode?) {\\n        node!!.`val` = node.next.`val`\\n        node!!.next = node.next.next\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087547,
                "title": "delete-node-without-head-pointer-easy-c-c-solution-with-steps",
                "content": "1. Take a temporary pointer i.e. temp.\\n2. Store the address of the next node to the given node in the temp i.e. ListNode *temp = node->next.\\n3. Copy the data (val) of the next node to the given node into the data (val)  field of the given node i.e. node->val = temp->val OR node->val = node->next->val.\\n4. Now we have to delete the next node to the given node, hence change the next field of the given node to the next to next node i.e  node->next = temp->next OR node->next = node->next->next.\\n5. Make next field of the node to be deleted as NULL i.e temp->next = NULL (To disconnect the link).\\n6. Delete that node i.e delete temp.\\n\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        ListNode *temp = node->next;\\n        node->val = temp->val;\\n\\t\\t//node->val = node->next->val;\\n        node->next = temp->next;\\n\\t\\t//node->next = node->next->next;\\n        temp->next = NULL;\\n        \\n        delete temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        ListNode *temp = node->next;\\n        node->val = temp->val;\\n\\t\\t//node->val = node->next->val;\\n        node->next = temp->next;\\n\\t\\t//node->next = node->next->next;\\n        temp->next = NULL;\\n        \\n        delete temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004800,
                "title": "python-easy-cool-solution-o-1-time-o-1-space",
                "content": "\\tclass Solution:\\n\\t\\tdef deleteNode(self, node):\\n\\t\\t\\tnode.val = node.next.val\\n\\t\\t\\tnode.next = node.next.next",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef deleteNode(self, node):\\n\\t\\t\\tnode.val = node.next.val\\n\\t\\t\\tnode.next = node.next.next",
                "codeTag": "Java"
            },
            {
                "id": 964012,
                "title": "go-one-liner",
                "content": "\\n```\\nfunc deleteNode(node *ListNode) {\\n    *node = *node.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteNode(node *ListNode) {\\n    *node = *node.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 962428,
                "title": "c-o-1-solution",
                "content": "# Approach\\nIt\\'s difficult to delete the given node under given conditions. So instead of deleting the node, we assign the value of current node to its next node, then delete the next node.\\n\\n```\\npublic class Solution {\\n    public void DeleteNode(ListNode node) {\\n        \\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```\\n\\n# Complexity\\n* Time complexity: O(1)\\n* Space complexity: O(1)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void DeleteNode(ListNode node) {\\n        \\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665839,
                "title": "c-o-1-with-no-memory-leak",
                "content": "Copy the value of node next to target node to the target node.\\nAnd delete the next node.\\n\\nNote: Often the intension behind asking these questions is to see how you handle the memory. [applies only to c++]\\n```\\nvoid deleteNode( ListNode* node ) {\\n\\tListNode *tmp = node->next;\\n\\tnode->val = tmp->val;\\n\\tnode->next = tmp->next;\\n\\tdelete tmp;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvoid deleteNode( ListNode* node ) {\\n\\tListNode *tmp = node->next;\\n\\tnode->val = tmp->val;\\n\\tnode->next = tmp->next;\\n\\tdelete tmp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 544339,
                "title": "c-solution",
                "content": "Runtime: 4 ms, faster than 95.39% of C online submissions for Delete Node in a Linked List.\\nMemory Usage: 6 MB, less than 100.00% of C online submissions for Delete Node in a Linked List.\\n```\\nvoid deleteNode(struct ListNode* node) \\n{\\n    struct ListNode *temp,*q=NULL;\\n    temp=node;\\n    while(temp->next!=NULL)\\n    {\\n        q=temp;\\n        temp->val=temp->next->val;\\n        temp=temp->next;\\n    }\\n    q->next=NULL;\\n    free(temp);   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid deleteNode(struct ListNode* node) \\n{\\n    struct ListNode *temp,*q=NULL;\\n    temp=node;\\n    while(temp->next!=NULL)\\n    {\\n        q=temp;\\n        temp->val=temp->next->val;\\n        temp=temp->next;\\n    }\\n    q->next=NULL;\\n    free(temp);   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381260,
                "title": "easy-c-solution-2-lines",
                "content": "Runtime: 8 ms, faster than 98.89% of C++ online submissions for Delete Node in a Linked List.\\nMemory Usage: 9.2 MB, less than 92.31% of C++ online submissions for Delete Node in a Linked List.\\n\\n```\\nvoid deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 8 ms, faster than 98.89% of C++ online submissions for Delete Node in a Linked List.\\nMemory Usage: 9.2 MB, less than 92.31% of C++ online submissions for Delete Node in a Linked List.\\n\\n```\\nvoid deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65505,
                "title": "java-solution",
                "content": "```\\npublic void deleteNode(ListNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        if(node.next == null) {\\n            node = null;\\n            return;\\n        }\\n        \\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic void deleteNode(ListNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        if(node.next == null) {\\n            node = null;\\n            return;\\n        }\\n        \\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4004985,
                "title": "as-easy-as-erasing-with-eraser-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        while(node) {\\n            node->val = node->next->val;\\n            if(node->next != NULL && node->next->next == NULL) node->next = NULL;\\n            node = node->next;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        while(node) {\\n            node->val = node->next->val;\\n            if(node->next != NULL && node->next->next == NULL) node->next = NULL;\\n            node = node->next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484671,
                "title": "100-java-solution-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n-----------100%--------\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\nListNode temp =new ListNode();\\n        while(node.next !=null)        {\\n            node.val = node.next.val;\\n             temp = node;\\n            node= node.next;\\n        }\\n\\n        temp.next = null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\nListNode temp =new ListNode();\\n        while(node.next !=null)        {\\n            node.val = node.next.val;\\n             temp = node;\\n            node= node.next;\\n        }\\n\\n        temp.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358604,
                "title": "delete-node-in-ll",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n     node.val=node.next.val;\\n     node.next=node.next.next;\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n     node.val=node.next.val;\\n     node.next=node.next.next;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204311,
                "title": "two-line-code-c",
                "content": "```\\nvoid deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nvoid deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052213,
                "title": "c-solution-in-just-2-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs its given in question we just have to remove it from th list not from the memory. So we do it only that\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nselect the next node and put its values(data and next) in current node,\\nthis will nonnect the current node to the 2nd next node of list\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nvoid deleteNode(struct ListNode* node) {\\n    node->val=node->next->val;\\n    node->next=node->next->next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nvoid deleteNode(struct ListNode* node) {\\n    node->val=node->next->val;\\n    node->next=node->next->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699951,
                "title": "c-one-line-solution-pointers-clean-code",
                "content": "Play with the pointers and it will become a very easy problem.\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697280,
                "title": "python-c-java-javascript-faster-than-100-simple-short-solution-2-line-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q237. Delete Node in a Linked List***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode *t=node->next;\\n        *node=*(node->next);\\n        delete t;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **JavaScript  Code** :\\n```\\nvar deleteNode = function(node) {\\n    node.val=node.next.val;\\n    node.next=node.next.next;\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode *t=node->next;\\n        *node=*(node->next);\\n        delete t;\\n    }\\n};\\n```\n```\\nvar deleteNode = function(node) {\\n    node.val=node.next.val;\\n    node.next=node.next.next;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696866,
                "title": "2-line-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvoid deleteNode(ListNode* node) {\\n\\t\\tnode->val=node->next->val;\\n\\t\\tnode->next=node->next->next;\\n\\t}\\n};\\n```\\nInstead of Deleting that Node Just assign Next node value to that node and Skip the next node",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvoid deleteNode(ListNode* node) {\\n\\t\\tnode->val=node->next->val;\\n\\t\\tnode->next=node->next->next;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696852,
                "title": "python-easy-solution-in-5-lines",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val=node.next.val\\n        if node.next.next:\\n            node.next=node.next.next\\n        else:\\n            node.next=None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val=node.next.val\\n        if node.next.next:\\n            node.next=node.next.next\\n        else:\\n            node.next=None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696849,
                "title": "0ms-100-faster-java-solution",
                "content": "Upvote if it helped :)\\n\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n          ListNode nextNode = node.next;\\n\\n        node.val = nextNode.val;\\n\\n        node.next = nextNode.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n          ListNode nextNode = node.next;\\n\\n        node.val = nextNode.val;\\n\\n        node.next = nextNode.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658492,
                "title": "my-2-line-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        node -> val = node -> next -> val;\\n        node -> next = node -> next -> next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        node -> val = node -> next -> val;\\n        node -> next = node -> next -> next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585650,
                "title": "100-best-solution-explained-for-interview-purpose",
                "content": "\\u2714\\uFE0F 100% Best Solution Explained For Interview Purpose\\n\\nPLEASE UPVOTE !!! if you think it is benificial\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        if(node==NULL)delete node;\\n        else\\n        {\\n            swap(node->val,node->next->val);\\n            ListNode*temp=node->next;\\n            node->next=temp->next;\\n            delete temp;\\n        }\\n    }\\n};\\n```\\nHope you like the solution",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        if(node==NULL)delete node;\\n        else\\n        {\\n            swap(node->val,node->next->val);\\n            ListNode*temp=node->next;\\n            node->next=temp->next;\\n            delete temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096080,
                "title": "delete-node-without-head-pointer-easiest-approach-with-explanation",
                "content": "See our task is to delete the given node and generally the head pointer is given and we perform deletion.**But what to do when the head pointer isn\\'t provided?** In that case you just need to store the next node somewhere and update the value of the node to be deleted by the next node and then connect the node to be deleted and next -> next.\\n```\\nclass Solution\\n{\\n    public:\\n        void deleteNode(ListNode *node)\\n        {\\n            ListNode *temp = node->next;\\n            node->val = temp->val;\\n            node->next = temp->next;\\n        }\\n};\\n```\\n\\nDo upvote the solution if you liked it.",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        void deleteNode(ListNode *node)\\n        {\\n            ListNode *temp = node->next;\\n            node->val = temp->val;\\n            node->next = temp->next;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035766,
                "title": "2-lines-swift-solution",
                "content": "```\\nclass Solution {\\n    func deleteNode(_ node: ListNode?) {\\n        node?.val = node?.next?.val ?? 0\\n        node?.next = node?.next?.next   \\n    }\\n}",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func deleteNode(_ node: ListNode?) {\\n        node?.val = node?.next?.val ?? 0\\n        node?.next = node?.next?.next   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2024807,
                "title": "python-simple-o-1-solution",
                "content": "```\\n\\'\\'\\'\\nWe are given only the node. the head is not given.\\nSo instead of deleting the given node delete the next node of change the value of\\nthe given node with the next node\\'s value. \\nBut this approach only change the value of the given node not link with previous node.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\n# Time: O(1)\\n# Space: O(1)\\n        \\n```\\n\\n**https://github.com/SamirPaul1/DSAlgo**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\'\\'\\'\\nWe are given only the node. the head is not given.\\nSo instead of deleting the given node delete the next node of change the value of\\nthe given node with the next node\\'s value. \\nBut this approach only change the value of the given node not link with previous node.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\\n# Time: O(1)\\n# Space: O(1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021562,
                "title": "very-easy-and-simple-cpp-solution",
                "content": "```\\nvoid deleteNode(ListNode* node) {\\n        ListNode* temp = node->next;\\n        node->val = temp->val;\\n        node->next = temp->next;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid deleteNode(ListNode* node) {\\n        ListNode* temp = node->next;\\n        node->val = temp->val;\\n        node->next = temp->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1973572,
                "title": "python-two-line-code",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n\\t\\tnode.val = node.next.val\\n\\t\\tnode.next = node.next.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n\\t\\tnode.val = node.next.val\\n\\t\\tnode.next = node.next.next",
                "codeTag": "Java"
            },
            {
                "id": 1614830,
                "title": "c-very-very-easy-solution-faster-than-98",
                "content": "Please upvote, if you like... Happy Coding :-)\\n```\\n\\nvoid deleteNode(ListNode* node) {\\n        \\n        ListNode* temp = node->next;\\n        node->val = temp->val;\\n        node->next = temp->next;\\n    \\n        delete temp;\\n    }\\n```\\n\\n**Explanation:**\\n\\nSince we have the access to the node to be deleted and don\\'t have the access to head node of the list as per the problem description.\\nSo we are doing small trick here to delete the given node.\\n\\n***Example***: Try to delete 2 from below list.\\n1->2->3->4->NULL.\\n\\nLets consider the node\\'s address start from 100 like this **1(100)->2(101)->3(102)->4(103)->NULL**.\\n\\n```\\n//Here we are storing the address of the next node of 2 (to be deleted) to temporary variable (that is node 3).\\nListNode* temp = node->next; // temp will have node at address 102.\\n```\\n\\n```\\n//Then storing the value from the next node to current node.\\n//Now the list will look like \"1(100)->3(101)->3(102)->4(103)->NULL\"\\nnode->val = temp->val;\\n```\\n\\n```\\n// Now linking the 4th node\\'s address to the second node\\'s next pointer and ignoring the third node(\"3(102)\").\\n// Now the list will look like \"1(100)->3(101)->4(103)->NULL\"\\nnode->next = temp->next;\\n```\\n\\n```\\n// Finaly deleting the third node (\"3(102)\") wich is initially stored in the temp variable.\\ndelete temp;\\n```\\n\\nIf you have any suggesion or query, feel free to drop a comment...",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nvoid deleteNode(ListNode* node) {\\n        \\n        ListNode* temp = node->next;\\n        node->val = temp->val;\\n        node->next = temp->next;\\n    \\n        delete temp;\\n    }\\n```\n```\\n//Here we are storing the address of the next node of 2 (to be deleted) to temporary variable (that is node 3).\\nListNode* temp = node->next; // temp will have node at address 102.\\n```\n```\\n//Then storing the value from the next node to current node.\\n//Now the list will look like \"1(100)->3(101)->3(102)->4(103)->NULL\"\\nnode->val = temp->val;\\n```\n```\\n// Now linking the 4th node\\'s address to the second node\\'s next pointer and ignoring the third node(\"3(102)\").\\n// Now the list will look like \"1(100)->3(101)->4(103)->NULL\"\\nnode->next = temp->next;\\n```\n```\\n// Finaly deleting the third node (\"3(102)\") wich is initially stored in the temp variable.\\ndelete temp;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1613525,
                "title": "100-fastest-solution-in-java",
                "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        ListNode prev = null;\\n        while(node.next != null){\\n            node.val = node.next.val;\\n            prev = node;\\n            node = node.next;\\n        }\\n        prev.next = null;\\n    }\\n}\\n```\\nComment the better way or more concise solution..",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        ListNode prev = null;\\n        while(node.next != null){\\n            node.val = node.next.val;\\n            prev = node;\\n            node = node.next;\\n        }\\n        prev.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565800,
                "title": "python-o-1-simple-two-line-solution",
                "content": "O(1)\\n```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357493,
                "title": "delete-given-node-o-1-explained",
                "content": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Delete Node in a Linked List.\\nMemory Usage: 38.4 MB, less than 49.67% of Java online submissions for Delete Node in a Linked List.\\n\\nGiven 4 -> 5 -> 1-> 9\\nNode to delete = 5\\n\\nstep 1 :  4 -> 1 -> 1-> 9\\nstep 2 :  4 -> 1 -> 9\\n\\nstep 1 :  4 -> 1 -> 1 -> 9\\nwe delete this------^\\n*/\\nclass Solution {\\n    public void deleteNode(ListNode node) \\n    {\\n       node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Delete Node in a Linked List.\\nMemory Usage: 38.4 MB, less than 49.67% of Java online submissions for Delete Node in a Linked List.\\n\\nGiven 4 -> 5 -> 1-> 9\\nNode to delete = 5\\n\\nstep 1 :  4 -> 1 -> 1-> 9\\nstep 2 :  4 -> 1 -> 9\\n\\nstep 1 :  4 -> 1 -> 1 -> 9\\nwe delete this------^\\n*/\\nclass Solution {\\n    public void deleteNode(ListNode node) \\n    {\\n       node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255341,
                "title": "c-solution-in-2-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 923143,
                "title": "easy-python-4-lines-solution-o-1",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        to_be_del = node.next\\n        node.next = node.next.next\\n        del(to_be_del)\\n        \\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        to_be_del = node.next\\n        node.next = node.next.next\\n        del(to_be_del)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 808328,
                "title": "c-solution",
                "content": "```\\nvoid deleteNode(struct ListNode* node) \\n{\\n    node->val = node->next->val;\\n    struct ListNode* temp = node->next;\\n    node->next = node->next->next;\\n    free(temp);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid deleteNode(struct ListNode* node) \\n{\\n    node->val = node->next->val;\\n    struct ListNode* temp = node->next;\\n    node->next = node->next->next;\\n    free(temp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786156,
                "title": "simplest-js-solution",
                "content": "```\\nvar deleteNode = function(node) {\\n    Object.assign(node, node.next);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteNode = function(node) {\\n    Object.assign(node, node.next);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678293,
                "title": "one-solution-c-struct-pointer-you-should-know",
                "content": "```\\n*(node)=*(node->next)\\n```\\nThe val and pointer of node->next replace node\\'s.",
                "solutionTags": [],
                "code": "```\\n*(node)=*(node->next)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654837,
                "title": "listnode-class-implementation-for-java",
                "content": "Sharing a class that I found useful while coding.\\n\\n1. `equals` and `hashCode` are useful to run comparisons from unit tests (e.g. `assertEquals(head1,head2)`)\\n2. `ListNode.createList(1,2,3,4)` will create a list for you given a list of numbers\\n3. `head.filter(x -> x.val == 5)` will return the `node` with the given value or `null` (in case of node not found) \\n\\n**Usage examples**\\n\\n```\\n    @Test\\n    public void filter() {\\n        ListNode list = createList(1, 2, 3);\\n        assertEquals(2, list.filter(x -> x.val == 2).val);\\n    }\\n\\n    @Test\\n    public void notFoundFilter() {\\n        ListNode list = createList(1, 2, 3);\\n        assertNull( list.filter(x -> x.val == 4));\\n    }\\n\\n    @Test\\n    public void test1() {\\n        ListNode actual = createList(4, 5, 1, 9);\\n        ListNode expected = createList(4, 1, 9);\\n        new DeleteNodeInALinkedList().deleteNode(actual.filter(x -> x.val == 5));\\n        assertEquals(expected, actual);\\n    }\\n\\n```\\n**Implementation**\\n```\\npublic class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode(int x) {\\n        val = x;\\n    }\\n\\n    public static ListNode createList(int... values) {\\n        ListNode head = new ListNode(values[0]);\\n        ListNode prev = head;\\n        for (int i = 1; i < values.length; i++) {\\n            prev.next = new ListNode(values[i]);\\n            prev = prev.next;\\n        }\\n        return head;\\n    }\\n\\n    public ListNode filter(Predicate<ListNode> f) {\\n\\n        ListNode node = this;\\n        while (node != null && !f.test(node)) {\\n            node = node.next;\\n        }\\n        return node;\\n    }\\n\\n    @Override\\n    public String toString() {\\n\\n        return val + \"->\" + next;\\n    }\\n\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null || getClass() != o.getClass()) return false;\\n        ListNode listNode = (ListNode) o;\\n        return val == listNode.val &&\\n                Objects.equals(next, listNode.next);\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(val, next);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    @Test\\n    public void filter() {\\n        ListNode list = createList(1, 2, 3);\\n        assertEquals(2, list.filter(x -> x.val == 2).val);\\n    }\\n\\n    @Test\\n    public void notFoundFilter() {\\n        ListNode list = createList(1, 2, 3);\\n        assertNull( list.filter(x -> x.val == 4));\\n    }\\n\\n    @Test\\n    public void test1() {\\n        ListNode actual = createList(4, 5, 1, 9);\\n        ListNode expected = createList(4, 1, 9);\\n        new DeleteNodeInALinkedList().deleteNode(actual.filter(x -> x.val == 5));\\n        assertEquals(expected, actual);\\n    }\\n\\n```\n```\\npublic class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode(int x) {\\n        val = x;\\n    }\\n\\n    public static ListNode createList(int... values) {\\n        ListNode head = new ListNode(values[0]);\\n        ListNode prev = head;\\n        for (int i = 1; i < values.length; i++) {\\n            prev.next = new ListNode(values[i]);\\n            prev = prev.next;\\n        }\\n        return head;\\n    }\\n\\n    public ListNode filter(Predicate<ListNode> f) {\\n\\n        ListNode node = this;\\n        while (node != null && !f.test(node)) {\\n            node = node.next;\\n        }\\n        return node;\\n    }\\n\\n    @Override\\n    public String toString() {\\n\\n        return val + \"->\" + next;\\n    }\\n\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null || getClass() != o.getClass()) return false;\\n        ListNode listNode = (ListNode) o;\\n        return val == listNode.val &&\\n                Objects.equals(next, listNode.next);\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(val, next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596086,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func deleteNode(_ node: ListNode?) {\\n        guard let nextNode = node?.next else { return }\\n            \\n        node?.val = nextNode.val\\n        node?.next = nextNode.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func deleteNode(_ node: ListNode?) {\\n        guard let nextNode = node?.next else { return }\\n            \\n        node?.val = nextNode.val\\n        node?.next = nextNode.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487679,
                "title": "java-solution-to-delete-the-node-without-head-pointer",
                "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;          // copy the next node\\'s value into the current node\\n        node.next=node.next.next;       // connect the current node to the next of next node\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;          // copy the next node\\'s value into the current node\\n        node.next=node.next.next;       // connect the current node to the next of next node\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 351974,
                "title": "node-actually-deleted",
                "content": "```\\nvar deleteNode = function(node) {\\n    if (!node.next) return;\\n    \\n    // If we reach here, we have at least 2 nodes\\n    // We stop on the 2nd to last node\\n    while (node.next.next) {\\n        node.val = node.next.val;\\n        node = node.next;\\n    }\\n    // Get value of last node and delete last node\\n    node.val = node.next.val\\n    node.next = null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteNode = function(node) {\\n    if (!node.next) return;\\n    \\n    // If we reach here, we have at least 2 nodes\\n    // We stop on the 2nd to last node\\n    while (node.next.next) {\\n        node.val = node.next.val;\\n        node = node.next;\\n    }\\n    // Get value of last node and delete last node\\n    node.val = node.next.val\\n    node.next = null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 147118,
                "title": "javascript-simple-solution",
                "content": "```\\nvar deleteNode = function(node) {\\n  node.val = node.next.val;\\n  node.next = node.next.next;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deleteNode = function(node) {\\n  node.val = node.next.val;\\n  node.next = node.next.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65619,
                "title": "ac-java-solution",
                "content": "    public void deleteNode(ListNode node) {\\n      if (node == null) return;\\n      node.val = node.next.val;\\n      node.next = node.next.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void deleteNode(ListNode node) {\\n      if (node == null) return;\\n      node.val = node.next.val;\\n      node.next = node.next.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4057957,
                "title": "easy-solution-for-better-understanding",
                "content": "# **Please Upvote\\uD83D\\uDC4D**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n      \\n        if(node==NULL || node->next==NULL){\\n            //it will not delete if linkedlist is empty or it is last node\\n            return;\\n        }\\n        ListNode *nextNode=node->next;\\n        node->val=nextNode->val;\\n        node->next=nextNode->next;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n      \\n        if(node==NULL || node->next==NULL){\\n            //it will not delete if linkedlist is empty or it is last node\\n            return;\\n        }\\n        ListNode *nextNode=node->next;\\n        node->val=nextNode->val;\\n        node->next=nextNode->next;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484669,
                "title": "100-java-solution-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n-----------100%--------\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\nListNode temp =new ListNode();\\n        while(node.next !=null)        {\\n            node.val = node.next.val;\\n             temp = node;\\n            node= node.next;\\n        }\\n\\n        temp.next = null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\nListNode temp =new ListNode();\\n        while(node.next !=null)        {\\n            node.val = node.next.val;\\n             temp = node;\\n            node= node.next;\\n        }\\n\\n        temp.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435707,
                "title": "2-lines-simple-code-full-explanation-begginers-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCopy the node->next->value to node and then link node->next to node->next->next.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet us take an example-:\\n**4 5 1 9**   *Node to be deleted(node)= 5*\\n- First we will copy the data of node->next to node  i.e **node->val=node->next->val**\\nAfter this the LL will look like\\n**4 1 1 9**\\n- Then we will connect **node->next = node->next->next**\\nAfter this the LL will look like\\n**4 1 9**\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268116,
                "title": "o-1-best-explanation-beginner-friendly",
                "content": "# Intuition\\nLet us understand with a example:\\nhead= 4,5,1,9\\nnode=5\\n1.First of all we will give the data of the node\\'s next element(i.e 1) to the  node(i.e 5).\\nAt this stage our list will look like:\\n4,5,5,9\\n2.Now we will change node\\'s next to node\\'s next\\'s next(i.e node ke next ka next) \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val; \\n        node->next=node->next->next;\\n        \\n    }\\n};\\nDO Upvote if you got the solution\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val; \\n        node->next=node->next->next;\\n        \\n    }\\n};\\nDO Upvote if you got the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222267,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211165,
                "title": "easy-python-solution-99-40-run-time",
                "content": "![image.png](https://assets.leetcode.com/users/images/6c9ca834-2a30-44ad-ba2a-952f54371d3e_1676915275.049323.png)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        while node:\\n            val=node.next.val\\n            node.val=val\\n            node.next=node.next.next\\n            break\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        while node:\\n            val=node.next.val\\n            node.val=val\\n            node.next=node.next.next\\n            break\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173433,
                "title": "java-with-visualization-faster-than-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WhatsApp Image 2023-02-12 at 1.56.21 AM.jpeg](https://assets.leetcode.com/users/images/1fdc87ff-4cdb-4572-a923-93dfe5bffbc2_1676147393.3905125.jpeg)\\n\\n# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val= node.next.val;\\n        node.next= node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Brainteaser"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val= node.next.val;\\n        node.next= node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140461,
                "title": "simple-js-solution-o-1-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDeleting a node in a singly linked list is to manipulate the values and references of the nodes in the list, instead of physically removing the node from memory.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the input node is null, if so return as there is nothing to delete.\\n- If the node is not null, update its value to be the value of its next node and its next reference to be the next reference of its next node.\\n- This effectively removes the next node and connects the current node to the node after the next node, thus deleting the current node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} node\\n * @return {void} Do not return anything, modify node in-place instead.\\n */\\nvar deleteNode = function(node) {\\n    \\n    if(node ===  null) return;\\n    \\n       else{\\n           if(node.next!==null){\\n                node.val = node.next.val;\\n                node.next =  node.next.next;\\n           }\\n       }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} node\\n * @return {void} Do not return anything, modify node in-place instead.\\n */\\nvar deleteNode = function(node) {\\n    \\n    if(node ===  null) return;\\n    \\n       else{\\n           if(node.next!==null){\\n                node.val = node.next.val;\\n                node.next =  node.next.next;\\n           }\\n       }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2741677,
                "title": "c-3-different-approach",
                "content": "This was my initial thought, however after submitting, I realised that my runtime was longer, after which the approach 2 code below immediately entered my head.\\n* Approach 1\\n```\\n#define fast ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        fast\\n        while(node->next->next){\\n            node->val = node->next->val;\\n            node = node->next;\\n        }\\n        node->val = node->next->val;\\n        node->next = NULL;\\n    }\\n};\\n```\\n<br>\\n\\nThis is O(1) sol. \\n* Approach 2\\n```\\n#define fast ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        fast \\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```\\n<br>\\n\\nThis is O(1) sol. Only 1 line by making address of node and its next node same.\\n* Approach 3 \\n\\n```\\n#define fast ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        fast \\n        *node=*node->next;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n#define fast ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        fast\\n        while(node->next->next){\\n            node->val = node->next->val;\\n            node = node->next;\\n        }\\n        node->val = node->next->val;\\n        node->next = NULL;\\n    }\\n};\\n```\n```\\n#define fast ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        fast \\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n    }\\n};\\n```\n```\\n#define fast ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        fast \\n        *node=*node->next;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2712604,
                "title": "c-easy-to-understand-don-t-be-that-person-that-leaks-memory-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        if(node->next == NULL){\\n            delete node;\\n        }\\n        swap(node->val,node->next->val);\\n        ListNode* temp = node->next;\\n        node->next=node->next->next;\\n        delete temp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        if(node->next == NULL){\\n            delete node;\\n        }\\n        swap(node->val,node->next->val);\\n        ListNode* temp = node->next;\\n        node->next=node->next->next;\\n        delete temp;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700053,
                "title": "js-simple-2-step-solution-o-1-javascript",
                "content": "```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```\\n\\n**please upvote**",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699758,
                "title": "2-lines-of-code-o-1",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n      node->val = node->next->val;\\n      node->next = node->next->next;\\n    }\\n};\\n\\n```\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n      node->val = node->next->val;\\n      node->next = node->next->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698943,
                "title": "java-2-lines-solution",
                "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698077,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "\\n\\n\\n\\t\\t\\t\\t            class Solution {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpublic void deleteNode(ListNode node) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.val = node.next.val;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.next = node.next.next;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpublic void deleteNode(ListNode node) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.val = node.next.val;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.next = node.next.next;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2697307,
                "title": "2-line-c-python-solution-with-visualization",
                "content": "We set the value of the current node to that of the next node and connect this node to it\\'s following node, thus removing the next node.\\n![linkedListremoval_visualization.png](https://assets.leetcode.com/users/images/71d54f44-96cf-440e-8cf1-0545046bce7b_1665642524.3168318.png)\\n\\n*Please upvote to motivate me to write more solutions*\\n\\n# C++ Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n    }\\n};\\n```\\n\\n# Python code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n    }\\n};\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697265,
                "title": "java-2-lines-code-easy-solution",
                "content": "IF YOU LIKE THE SOLUTION \\nMAKE SURE TO UPVOTE IT !\\n\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n\\t\\n        // just swap the data with the node.next node and delete the next node because we copied the data already\\n\\t\\t//We can delete next node safely.\\n        // it was given that node never be the tail of Linked List\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```\\n\\n\\t",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n\\t\\n        // just swap the data with the node.next node and delete the next node because we copied the data already\\n\\t\\t//We can delete next node safely.\\n        // it was given that node never be the tail of Linked List\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697119,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val \\n        node.next = node.next.next\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val \\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696650,
                "title": "c-faster-easy-to-understand",
                "content": "* ***Linked List***\\n\\n* ***Time Complexity :- O(1)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        // swap the value of node and node -> next\\n        \\n        swap(node -> val, node -> next -> val);\\n        \\n        // now point the node -> next to node -> next -> next\\n        \\n        node -> next = node -> next -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        // swap the value of node and node -> next\\n        \\n        swap(node -> val, node -> next -> val);\\n        \\n        // now point the node -> next to node -> next -> next\\n        \\n        node -> next = node -> next -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696413,
                "title": "c-o-1-2-lines-of-code",
                "content": "```\\nvoid deleteNode(ListNode* node) {\\n\\tnode -> val = node -> next -> val;\\n\\tnode -> next = node -> next -> next;\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nvoid deleteNode(ListNode* node) {\\n\\tnode -> val = node -> next -> val;\\n\\tnode -> next = node -> next -> next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2696209,
                "title": "daily-leetcoding-challenge-october-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/delete-node-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/delete-node-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2489424,
                "title": "easy-solution-c",
                "content": "// simple easy // and very fast solution \\n\\nApproach : instead of deleting the node given we delete next node and copy its data to the node given \\n\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        // here we are not given the head we have only given a node \\n        // we dont have previous we only have is next \\n        \\n        node->val = node->next->val ; // we copy the data of next node \\n        \\n        // and point the next node to its next \\n        \\n        node->next = node->next->next ; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        \\n        // here we are not given the head we have only given a node \\n        // we dont have previous we only have is next \\n        \\n        node->val = node->next->val ; // we copy the data of next node \\n        \\n        // and point the next node to its next \\n        \\n        node->next = node->next->next ; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2457174,
                "title": "easy-python-code-o-1",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```\\n\\n**please upvote, if this helped**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358670,
                "title": "c-easiest-o-1-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       ListNode* next=node->next;\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        delete next; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       ListNode* next=node->next;\\n        node->val=node->next->val;\\n        node->next=node->next->next;\\n        delete next; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153669,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133762,
                "title": "easy-2-line-code-100-0ms",
                "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079913,
                "title": "2-line-easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058015,
                "title": "javascript-solution",
                "content": "WE DON\\'T DELETE THE NODE, WE ACTUALLY REPLACE THE VALUE OF THE NODE WITH THE NEXT NODE VALUE AND THEN SKIP THE NODE\\n```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val\\n    node.next = node.next.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteNode = function(node) {\\n    node.val = node.next.val\\n    node.next = node.next.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057234,
                "title": "two-lines-of-code-in-java-0ms-100-faster",
                "content": "You really don\\'t need a loop or anything for this type of question. All you have to do is to copy the value of the node next to node to be deleted. After that you can skip over the next node entirely by just change the ```next``` value to one after the current next\\'s value\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```next```\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836168,
                "title": "easy-solution-in-c",
                "content": "```**Easier solution  faster than 95.04%\\nI am changing value of next node with this current node then and then deleting the next node**\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nvoid deleteNode(struct ListNode* node) {\\n    struct ListNode *prev=node;\\n    node=node->next;\\n    prev->val=node->val;\\n    prev->next=node->next;\\n    free (node);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```**Easier solution  faster than 95.04%\\nI am changing value of next node with this current node then and then deleting the next node**\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nvoid deleteNode(struct ListNode* node) {\\n    struct ListNode *prev=node;\\n    node=node->next;\\n    prev->val=node->val;\\n    prev->next=node->next;\\n    free (node);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1810763,
                "title": "delete-node-in-a-linked-list-in-c-2-lines-sol",
                "content": "class Solution {\\npublic:\\n\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    void deleteNode(ListNode* node) {\\n        node->val = node->next->val;\\n        node->next = node->next->next;\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1791901,
                "title": "2-lines-solution-in-java-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789664,
                "title": "my-2-lines-of-java-code-0ms-time-o-1-time-complexity-easy-to-understand",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Delete Node in a Linked List.\\nMemory Usage: 43.5 MB, less than 27.80% of Java online submissions for Delete Node in a Linked List.\\n\\n```\\npublic void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n}\\n```\\n\\n## Explanation:\\n\\nExample Testcase: 1 -> 2 -> 3 -> 4 -> null\\n\\nIf you want to delete the node that is given, in this example we need to delete \"2\" from the list, so we can easily store the 3\\'s value in 2.\\n\\n* if we use, 2.data = 2.next.data; // means we are storing 3\\'s data in 2\\n* and if we use, 2.next = 2.next.next // means we are pointing to the 3\\'s next through 2\\'s next\\n\\nIn this process we can store 3\\'s data and next in the 2\\'s place and we can simply vanish 2 from the list. As because 1 is pointing to the 2, so we replaced the 2 with 3, so now 1 is directly pointing to the 3 instead of 2.\\n\\nSo simple and easy to understand. Have fun! :)",
                "solutionTags": [],
                "code": "```\\npublic void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760390,
                "title": "easy-1-line-c-solution-with-pointer-explanation",
                "content": "A pointer is a variable that holds memory address of another variable. \\nHere, node is a pointer of type ListNode.\\nA pointer is dereferenced with * operator to access the memory location. \\nHere, \\\\*node refers to the memory location that node is pointing to.\\n\\n Thus, this code overwrites the memory location of node with the memory location of node->next;\\n\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node=*node->next; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        *node=*node->next; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737237,
                "title": "java-2line-0ms-explained",
                "content": "**Go through code Dry Run it once and you will get it for sure.**`\\nWe know that the refrence to the node is not given to us.\\nSo the only thing we can do is Assign the value of next next node to  \\nthe node to be deleted and then point the node to next of the next node to be deleted.\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        // 1.Assigned node the next node value.\\n        node.val=node.next.val;\\n\\t\\t// 2.Break connection .\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        // 1.Assigned node the next node value.\\n        node.val=node.next.val;\\n\\t\\t// 2.Break connection .\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675070,
                "title": "java-simple-solution-with-explanation",
                "content": "**\\'\\'\\'\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n\\t    // Copy the value from the next node into the current one\\n\\t\\t// Then, skip to the next node\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }\\n}**",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public void deleteNode(ListNode node) {\\n\\t    // Copy the value from the next node into the current one\\n\\t\\t// Then, skip to the next node\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1664129,
                "title": "minimal-complication-two-line-python-solution",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639823,
                "title": "java-100-fast-solution-basic-operation",
                "content": "\"\"\"\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node == null) return;\\n        node.val=node.next.val;\\n        node.next = node.next.next;\\n    }\\n    \\n}\\n\"\"\"",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node == null) return;\\n        node.val=node.next.val;\\n        node.next = node.next.next;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1631597,
                "title": "java-easy-solution",
                "content": "\"\\'\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next=node.next.next;\\n        \\n        \\n    }\\n}\\n\"\\'",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next=node.next.next;\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1609824,
                "title": "very-easy-java-solution-o-1-with-explanation",
                "content": "The trick is, you copy from next node to current node and then delete the next node from the chain.\\n\\n```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560899,
                "title": "c-3-lines-of-code-wtith-explanation-o-1",
                "content": "**This can be easily understood by analysing the pointers**\\n\\n- Linked list basic node structure:  **{value, address of next node}**\\n- So, linked list is something similar to this\\n\\t- **(head_value, addr_2)---->(val_2, addr_3)---->(val_3, addr_4)---->(val_4, addr_5)---->NULL**\\n\\t        \\n- Let\\'s say Node to be deleted is **2nd node** pointed by a pointer *node = (val_2, addr_3)\\n- Now, we take another pointer to point to next node\\n``` \\nListNode* nextNode = node->next;\\n```\\n- Then we copy the next node to current node\\n```\\n// here, we are deferecing pointers \\n// so we are copying the next node content to current node i.e. (node_value, address_of_next_node)\\n//now current node has nextNode\\'s value and it has address of (node->next->next) node\\n// so we updated current node next pointer, by pointing it to (node->next->next) node\\n*node = *nextNode; \\n\\n// after copying node it looks something like this\\n// - (head_value, addr_2)---->(val_3, addr_4)        (val_3, addr_4)---->(val_4, addr_5)---->NULL\\n//                                     |___________________________________________^\\n\\n\\n// second node has node_value of 3rd node\\n// also second node has address of 4th node so, 2nd node next pointer point to 4th node\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n```\\n- and finally delete the  node pointed by **temp pointer**  because we have already copy it\\'s content to current node\\n\\n#### Here\\'s the final code. Time and Space: O(1)\\n#### Upvote if it has helped you. Thanks:)\\n```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       ListNode* nextNode = node->next;\\n       *node = *nextNode;\\n       delete nextNode;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` \\nListNode* nextNode = node->next;\\n```\n```\\n// here, we are deferecing pointers \\n// so we are copying the next node content to current node i.e. (node_value, address_of_next_node)\\n//now current node has nextNode\\'s value and it has address of (node->next->next) node\\n// so we updated current node next pointer, by pointing it to (node->next->next) node\\n*node = *nextNode; \\n\\n// after copying node it looks something like this\\n// - (head_value, addr_2)---->(val_3, addr_4)        (val_3, addr_4)---->(val_4, addr_5)---->NULL\\n//                                     |___________________________________________^\\n\\n\\n// second node has node_value of 3rd node\\n// also second node has address of 4th node so, 2nd node next pointer point to 4th node\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399790,
                "title": "c-2-lines-easy-o-1-time",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* &node) { \\n        node->val= node->next->val;  //setting value of node to next node\\'s value\\n        node->next= node->next->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* &node) { \\n        node->val= node->next->val;  //setting value of node to next node\\'s value\\n        node->next= node->next->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565043,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565706,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565837,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565325,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1564538,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565866,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1566353,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565970,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1566347,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1643550,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565043,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565706,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565837,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565325,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1564538,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565866,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1566353,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1565970,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1566347,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1643550,
                "content": [
                    {
                        "username": "siva9144",
                        "content": "The API contains only one parameter, but don\\'t we require at least two parameters, one being the list itself, one being the node to delete/or the node with the value to delete? Can someone explain?"
                    },
                    {
                        "username": "d1v_",
                        "content": "I\\'ve explained all queries about this problem \\uD83D\\uDC49 [Click here](https://leetcode.com/problems/delete-node-in-a-linked-list/description/comments/1961065)"
                    },
                    {
                        "username": "timopheykor",
                        "content": "The node to delete is already part of the list. The question is phrased poorly, but that\\'s the challenge. The problem doesn\\'t check if a specific memory address was deleted - it just checks the values of the nodes. This information should have been much more clear. Using this information, you can \"delete\" the node using only the passed node parameter."
                    },
                    {
                        "username": "designAndCode",
                        "content": "This problem should be described as removing the value at that corresponding index in the linkedin list, \\nNOT delete the node, no one can delete the fucking node correctly without access to its predecessor."
                    },
                    {
                        "username": "d1v_",
                        "content": "you are correct that node can\\'t be deleted without access to its predecessor `But we can delete the next node`."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "[@bhanu_reddy007](/bhanu_reddy007) but we are not provided with head\\n"
                    },
                    {
                        "username": "bhanu_reddy007",
                        "content": "copy the the next node in to current node and delete the next node1"
                    },
                    {
                        "username": "mo10",
                        "content": "Since the node is guarentee not to be the tail, the following code works. Move the value and skip the next node.\\n\\n    public void deleteNode(ListNode node) {\\n\\n\\t\\tnode.val = node.next.val;\\n\\t\\tnode.next = node.next.next;\\n\\n\\t}"
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "wtf , you should be reported . You fucking destroyed a ques"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "DONT POST SOLUTIONS HERE!"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Give your brain to me :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": " W solution."
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "[@Fanie](/Fanie) read the posted date before speaking "
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "that post is from 2015,  just as you should analyze a problem before starting your solution, you can chill out before blaming someone.[@Bingo_o](/Bingo_o) "
                    },
                    {
                        "username": "Fanie",
                        "content": "No solutions here. "
                    },
                    {
                        "username": "leorts",
                        "content": "or *node = *(node->next)"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "wtf bro no solutions dudee."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why do you paste solution here?\\nYou have Solutions tab for this."
                    },
                    {
                        "username": "sidhT",
                        "content": "In the example, they are predicting two parameters and in the given method, only one parameter is added. Hope it is not intentional."
                    },
                    {
                        "username": "smfwuxiao",
                        "content": "This question is stupid and should be deleted intermediately."
                    },
                    {
                        "username": "d1v_",
                        "content": "Question is not stupid. It\\'s just a little bit tricky."
                    },
                    {
                        "username": "csgerber",
                        "content": "Not to mention that LC cant seem to consistently benchmark the correct answer and automatically assign two lines of code as the _only_ solution to the question...."
                    },
                    {
                        "username": "kingfighters",
                        "content": "[@godshiva](/godshiva) indeed"
                    },
                    {
                        "username": "godshiva",
                        "content": "Or at least marked as easy"
                    },
                    {
                        "username": "ieuphonos",
                        "content": "Judged from the info given, the function should take two paramters -- (ListNode head, int val). \\n\\nWith some revision this problem could still be of some use ;)"
                    },
                    {
                        "username": "sameerkali",
                        "content": "everyone is asking questions no one is answering."
                    },
                    {
                        "username": "leaping_tiger",
                        "content": "From the description it appears that you need to know the head of the Linked List in order to traverse it and then delete the node. But in reality you are given a node to delete and you just need to copy the value and pointer from the next node."
                    },
                    {
                        "username": "ahmad88me",
                        "content": "For the python code, it doesn\\'t show how the list will be passed. Passing only the node to be deleted without passing the node is strange. Something is missing.\\n"
                    },
                    {
                        "username": "yangdu",
                        "content": "Emmm.... I think, this operation needs 2 params: head of list,  and node to be removed.\\n\\n....\\n...\\n...\\nSome guys change  value and next of node....That is awesome,  they are really smart guys.\\n\\nBut teamleader may kill me.....hahaha  , so  stupid question."
                    },
                    {
                        "username": "sameerkali",
                        "content": "what happens next \\uD83D\\uDE02"
                    },
                    {
                        "username": "skyhaoshen",
                        "content": "How to become another person in the world? Two steps.\\nOne, change your appearance to whom you want to be.\\nTwo, kill that person."
                    },
                    {
                        "username": "2030019",
                        "content": "lmao"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That is the key!"
                    }
                ]
            },
            {
                "id": 1566251,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1566947,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1567423,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1566826,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1567235,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1565632,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1565667,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1567697,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1570130,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1568264,
                "content": [
                    {
                        "username": "nikita",
                        "content": "For \"Delete Node in a Linked List\", the soln is expecting only the node to be deleted and not the original list. Without the head of the list how are we expected to traverse the singly linked list to get to the previous node to delete in place? Please see https://leetcode.com/problems/delete-node-in-a-linked-list/"
                    },
                    {
                        "username": "raju9525",
                        "content": "Are you mad baby? give same link of same question"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys, \\n\\nfor everyone having problem with this challenge,\\nI wrote here a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-237-delete-node-in-a-linked-list-8944138d1513"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372645.png)\\n![image](https://assets.leetcode.com/users/wufengxuan1230/image_1574372707.png)\\n\\n"
                    },
                    {
                        "username": "tanu-bluecode",
                        "content": "The funciton definition is not matching the input. Strange..!!"
                    },
                    {
                        "username": "cccbean",
                        "content": "I am kind new to Java. Can anyone answer my question ? Thanks!\\n\\nnode = node.next; \\n\\nWhy this doesn't work?"
                    },
                    {
                        "username": "m-d-f",
                        "content": "\\tvoid deleteNode(struct ListNode* node) {\\n\\t\\tnode->val = node->next->val;\\n\\t\\tnode->next = node->next->next;\\n\\t}"
                    },
                    {
                        "username": "danielwong2268",
                        "content": "How can you delete a node from a linked list, given only the node, when you do not have a variable pointing at the linked list from which you want to delete the node? Maybe I am missing something here.\\n\\nNote: I'm using Javascript."
                    },
                    {
                        "username": "nikhilvaibhav545",
                        "content": "I don\\'t know why this question has been accepted at the first place. Such a stupid question. *deleting node* is highly misleading when we are not doing the same.\\nRemove this question or atleast add proper description to the question."
                    },
                    {
                        "username": "littlefishes",
                        "content": "DELECT CURRENT NODE \\nwill be more intuitive"
                    },
                    {
                        "username": "Maor-Busk",
                        "content": "How am i suppose to write a function to magically remove a random number or node without knowing its index or value...somethings like \"RemoveKFromList\", and not just remove something....i can\\'t seem to understand the purpose here."
                    }
                ]
            },
            {
                "id": 1567308,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1567234,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1961065,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1568339,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1568254,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1568205,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1569393,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1567928,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1564868,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1830886,
                "content": [
                    {
                        "username": "ampilogov",
                        "content": "Add Swift please for this problem"
                    },
                    {
                        "username": "lovchanel",
                        "content": "This might sound so dumb, but wouldn't node=node.next work?"
                    },
                    {
                        "username": "d1v_",
                        "content": "  `EVERYTHING IS CORRECT IN THIS PROBLEM.`\n`Let me help you if you're finding any difficulty in understanding or solving the problem.`\nMost of the people are saying that `Problem statement and function definition with only one parameter are wrong`. \nJust read the problem statement properly and then you'll get to know that Problem statement and function definition with only one parameter are totally correct. `THERE  IS NO REQUIREMENT OF 2 PARAMETERS`.\n\n`Explanation :`\nAccording to the problem statement, we've to remove the value of given node and decrease the number of nodes by one.\n\n`Note:` It is given that-\n\n`1-` Given node can't be the last node of the linked list.\n`2-` All the values before node should be in the same order.\nAll the values after node should be in the same order.\n`Steps:`\n`1-` In order to remove the value of given node, we'll repalce the value of given node with the value of next node.\n`2-` connect the given node with next to next node to decrease the number of nodes by one.\n\nOrder of values will be same after performing above steps."
                    },
                    {
                        "username": "mirandanathan",
                        "content": "90% Reading Comprehension, 10% Basic Python Gramma, 0% Algrethem! It is a wordy question. \\n\\n        if node.next: node.val, node.next = node.next.val, node.next.next"
                    },
                    {
                        "username": "ByteBeats",
                        "content": "What does this problem description mean?\\nWhy no enough parameters in the function definition?\\n\\nShouldn\\'t it be \\n\\n`public void deleteNode(ListNode head, ListNode node){}`\\n\\n?"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "if there would be head isn\\'t this would be an easy one ?\\n"
                    },
                    {
                        "username": "liaotl10",
                        "content": "\\u53EA\\u60F3\\u5410\\u4E2A\\u69FD\\u3002\\u672C\\u6765\\u8FD8\\u5728\\u627Ehead\\u3002\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "ymymrydzh",
                        "content": "\\u6709\\u6BDB\\u75C5\\u5427\\uFF0C\\u51FA\\u8FD9\\u79CD\\u9898\\uFF0C\\u6CA1\\u9898\\u76EE\\u4E86\\u53EF\\u4EE5\\u4E0D\\u51FA"
                    },
                    {
                        "username": "kumar14",
                        "content": "    *node= *node->next;              //just write it into given code"
                    },
                    {
                        "username": "roshan172",
                        "content": "Runtime: 8 ms, faster than 99.02% of C++ online submissions for Delete Node in a Linked List."
                    },
                    {
                        "username": "Rebv18",
                        "content": "terribly written question....you're asking me to create a memory leak. This question is like me saying, clean my car, but DON'T remove any of the dirt, but clean my car. \n\n\"Delete\" the node but don't remove it from heap memory and create a memory leak, but \"delete\" the node."
                    }
                ]
            },
            {
                "id": 1570459,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1570431,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1570286,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1570056,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1569700,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1569039,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1567626,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1567233,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1566250,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1568475,
                "content": [
                    {
                        "username": "noo6programmer",
                        "content": "void deleteNode(struct ListNode* node) \\n{ \\n    node->val = (node->next)->val;\\n    node->next = (node->next)->next;\\n}"
                    },
                    {
                        "username": "nirbhayluthra",
                        "content": "void deleteNode(ListNode* node) {\\n      node->val=node->next->val;\\n        node->next=node->next->next;\\n\\n    }"
                    },
                    {
                        "username": "boycao",
                        "content": "Thought this problem has a very misleading description. Deleting a node to me sounds like we want to remove the current node, in value but also physically in memory. So i would think of to remove it through changing the linkedlist, and later let the node get garbage collected. Instead of simply copying the next one over..."
                    },
                    {
                        "username": "jeyam95",
                        "content": "public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }"
                    },
                    {
                        "username": "GavynB",
                        "content": "It would be a relatively simple question, but where are we deleting the node from? We don\\'t really have a reference to a list that we\\'re deleting the individual node from. And if the entire list is being passed through the parameter, then how do we know which value to delete? There\\'s nothing to reference in memory so I can\\'t \"delete\" the node from anything."
                    },
                    {
                        "username": "lydhr",
                        "content": "C++\\n\\nWhy `node=node->next; ` is incorrect while `*node=*node->next;` is correct?"
                    },
                    {
                        "username": "tamajit",
                        "content": "The questions asks to delete the node. But basically in this problem the next node will be  deleted. But removing the next node does not mean that the node is deleted. Though visually the linkedlist will be same but the memory of the node that has to be deleted is still there. So,I have a doubt about the correctness of the problem."
                    },
                    {
                        "username": "Wenzhu_Zhao",
                        "content": "For singly linked list, we can only know the current node and its next, we cannot know its previous, so how can we change the relation between its previous and the node itself? And I don't think change the value of the node is a good idea, the operation unit is the node, if change the value in the node, we need to change all nodes after the deleted node. So dose this problem just want us solve the example or for general singly linked list?"
                    },
                    {
                        "username": "tf_",
                        "content": " node.val = node.next.val;\\n node.next = node.next.next;"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "node = (node->next);"
                    }
                ]
            },
            {
                "id": 1997558,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1950218,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1873753,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1732798,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1712291,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1643685,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1576706,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1576703,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1576681,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1576367,
                "content": [
                    {
                        "username": "kashyapsupriya61275",
                        "content": "please can someone answer this? if the node to be deleted is the second last node than will  node.next=node.next.next; throw an exception?"
                    },
                    {
                        "username": "d1v_",
                        "content": "no, it will not throw any exception in this case.\\nnode.next = next to second last node i.e. \\'last node\\'\\nnode.next.next = NULL ; which is totally fine\\nI hope, this will help u."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "you can just change the value of current node to the next node, no need to delete a node, as their is no access of head"
                    },
                    {
                        "username": "nerdstv",
                        "content": "This is the easiest leet code problem, I have ever solved."
                    },
                    {
                        "username": "shevan05",
                        "content": "Hint: You don\\'t need access to the previous element. You can copy the value from the next node to the current value. Do it recursively and then eliminate the last node.\\n\\nExample:\\n4 -> 1 -> None  =>  1 -> 1 -> None  =>  1 -> None (replace 1 -> None with None)"
                    },
                    {
                        "username": "bulakhov",
                        "content": "I don\\'t even understand why it\\'s medium. It\\'s easy. 1-2 minutes to implement basic code. More 2 minutes to realize you can short it to 2 lines."
                    },
                    {
                        "username": "rajender7",
                        "content": "Please remove this question immediately.  \\uD83D\\uDCCC\\uD83D\\uDCCC\\uD83D\\uDCCC"
                    },
                    {
                        "username": "gkeepa",
                        "content": "can anyone explain why cant i do\\nnode=node.next"
                    },
                    {
                        "username": "Veejnas7",
                        "content": "![image](https://assets.leetcode.com/users/images/e479abf0-1961-474f-b7cf-4cf041f4b9d1_1651598186.8547819.png)\\n"
                    },
                    {
                        "username": "singhabhay11",
                        "content": "node.val=node.next.val;\\n            node.next=node.next.next;"
                    },
                    {
                        "username": "Anubrata447",
                        "content": "\\nvoid deleteNode(struct ListNode* node) {\\n\\n    node->val=node->next->val;   \\n\\t\\n    node->next=node->next->next;\\n}"
                    },
                    {
                        "username": "sumitkhopkar25",
                        "content": "Can someone please tell me why doesn\\'t node = node.next work?"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "because it will modify node only not the head, so we change it by going at the address that is by reference not by value.\\nhope you undertoooooooooooooooooooooooooooooooooood :)"
                    }
                ]
            },
            {
                "id": 1576060,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1575230,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1575227,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1574825,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1573966,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1573911,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1573858,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1573853,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1573533,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1572918,
                "content": [
                    {
                        "username": "Huds0n",
                        "content": "I would really appreciate. But not able to understand the question in first go. :>"
                    },
                    {
                        "username": "almagest9110",
                        "content": "I understand what they were trying to do here, but this seems hella weird to pop up for interviews. Thoughts?"
                    },
                    {
                        "username": "peterx123",
                        "content": "LOL. Changing the value instead of deleting the node is interesting."
                    },
                    {
                        "username": "dongersgg",
                        "content": "Fast and easy to follow solution for my fellow colleagues.\\nhttps://youtu.be/2tVXWX-VM34?rel=0"
                    },
                    {
                        "username": "Krishnaabhi1",
                        "content": "var deleteNode = function(node) {\\n  // copy next node value to existing node.\\n  node.val = node.next.val;\\n  // copy next node reference to existing node.\\n  node.next = node.next.next;\\n};"
                    },
                    {
                        "username": "ivabby",
                        "content": "Checkout this link : https://codingsolutions1.blogspot.com/2020/06/delete-node-in-linked-list.html"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/fEbeRjHbrm8](https://youtu.be/fEbeRjHbrm8)"
                    },
                    {
                        "username": "Abhishek_Majety",
                        "content": "Almost everyone came up with the same solution:\\n\\'\\'\\' **node.val = node.next.val \\nnode.next = node.next.next**\\'\\'\\'\\nIn this regard, how come the same solution has a minimum of 20 ms and a maximum of 40+ ms.\\nJust curious to know the reason behind it!"
                    },
                    {
                        "username": "fengvang24",
                        "content": "Runtime depends on internet connection as well."
                    },
                    {
                        "username": "laodasb",
                        "content": "idiot problem\\n\\u7B54\\u6848\\u662F\\u7528\\u628A\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u7684\\u503C\\u653E\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u3002\\u3002\\u7136\\u540E\\u5220\\u4E86\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n\\u771FTM\\u6492\\u5E01\\u7684\\u4E00\\u9053\\u9898"
                    },
                    {
                        "username": "JarryChen",
                        "content": "Maybe delete node in a linked list isn\\'t difficult, but what this problem confused me is the parameter, where is the delete node?\\nonly one parameter?"
                    }
                ]
            },
            {
                "id": 1572664,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1572365,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1572145,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1571874,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1571478,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1570801,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1576251,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1575448,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1575062,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1574681,
                "content": [
                    {
                        "username": "Nathaniscoding",
                        "content": "this is a MDZZ question"
                    },
                    {
                        "username": "prisci1la",
                        "content": "There is literally an one-line solution. lmao"
                    },
                    {
                        "username": "Art0rias",
                        "content": "when deleting the node or sth comes to us ,we always potentially take it that we shoude be given a listnode head and a node value.but this time the problem only gives us the node pointer to which should be deleted .that is very amusing right?solution is simple,but unexpected thinking route can be really valuable.Thanks leetcode!"
                    },
                    {
                        "username": "jshore",
                        "content": "This question has a subtle complexity to it that isn't easily appreciated with a quick glance. \n\nA good question to ask is \"*Why* would we want to design a linked list's delete method to work in this fashion?\". Specifically, why not develop a method that can iterate through the list, keep track of the previous node, and set the previous node's `next` field to reference the node after the one being deleted? After all, that is a commonly conceived way of deleting a node.\n\nThe answer to this proposed questioning is that we can separate functionality and increase efficiency with some clever thinking. \n\nFirst, the internal implemention of a linked list should be private. We wouldn't be writing this method outside of our linked list, because we can't create nodes outside of the list... unless the design is **very** poor. The only way to delete a node is to find it first, and the only way to find it is with a value, which is either a primitive type or object reference. Hence, we'd need to either iterate through the list to find the correct node and then update pointers like the question aboveimpossible in this scenarioor we have to cleverly update the pointers to get the same effect.\n\nA **very critical assumption** in this problem is that some form a `find()` helper methodto return the first node that contains the passed *value*already exists. In that `find()` method, we would iterate through the list until we find the first occurance of a node with the supplied value, and then return it. Why iterate through the list again to delete a node if we've already found it? Well, we don't need to, and we can simply operate on the node's fields to get the same effect. See the increased efficiency here?\n\nSo, by using clever means of deleting the nodeI won't spoil it here, see some community submissions if you're stuckwe can separate `find()` and `delete()` functionality. `delete()` reuses our code to find a node, and can delete said node without iterating through a list of values to find it. Note that the `delete()` that accepts a node should be private to the linked list class, and the `delete()` that accepts an object/value would be publicly accessible.\n\nFinally, you might ask \"Why would the `find()` method be a helper (private)? Wouldn't we want to include that as a public method on our list?\" Good question. Yes, you may want to include a find method of some sort, probably written as `contains()` to indicate with a boolean whether the value/object is in the list. In that public `contains()` method you can use a check against the result of `find()`, again reusing that find functionality and keeping contains functionality separate.\n\n"
                    },
                    {
                        "username": "ziddletwix",
                        "content": "I feel like if node.next is null (i.e. we are deleting the last node in the list), then node.next.next should cause an error. Why does it not? Total python novice, was surprised my solution worked."
                    },
                    {
                        "username": "Garlicala",
                        "content": "After reading the answer, I was like... speechless. This is not deleting the node, this is fxxking swapping the value!!!"
                    },
                    {
                        "username": "KeshriRajj",
                        "content": "\\n\\n\\n\\nnode.val=node.next.val;\\nnode.next=node.next.next;\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "prolifick1",
                        "content": "this should probably be the introductory problem for everyone new to leetcode."
                    },
                    {
                        "username": "amberk2001",
                        "content": "Simplest Java Solution:\\n\\t\\n\\t    node.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "rheau04",
                        "content": "node.val = node.next.val\\n        node.next = node.next.next"
                    }
                ]
            },
            {
                "id": 1572228,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 1572153,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2063984,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2061722,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2059510,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2047869,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2043087,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2037886,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2036051,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2011173,
                "content": [
                    {
                        "username": "yaleeter",
                        "content": "void deleteNode(struct ListNode* node) {\\n    *node = *(node->next);\\n}"
                    },
                    {
                        "username": "haoguoxuan",
                        "content": "this is ridiculous, the question itself is just stupid"
                    },
                    {
                        "username": "startupveteran",
                        "content": "SPOILER ALERT!!!\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nI see the solutions, but I don\\'t understand it.\\n\\nWhy can\\'t I just have:\\n\\n`node = node.next\\n`\\n?\\n\\nWouldn\\'t that carry over both the value and the .next linkage to subsequent nodes?\\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The only thing making this problem medium is its description. Please make it concise and put the problem in the easy category.\n\n`Feedback`"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "This is the perfect example of how we complicate things by overthinking it."
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, need to delete a node from Singly Linked List.\\nThis is very easy. You just think that how previous node will connect next to that node which want to delete.\\n\\nApproach\\n1- Previous node of Target node should be connected to next of target node.\\n2- And the value of previous should be mapped to next one."
                    },
                    {
                        "username": "alokv0521",
                        "content": "i am using a temporary node temp for exchanging the  nodes. no problem occurred during execution of program without deleting the temp node. but when i delete the node, i got runtime error ....plzz  explain why?"
                    },
                    {
                        "username": "dinesh2003s",
                        "content": "worst question i am ever seen...."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "If you want to type comment about how stupid this question is, because you litteraly reversed linked list and still could not access the head, but simple \"removing\" the node to the next pointer is the answer, then you dont have to do it, i commented"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Should be labelled Easy"
                    }
                ]
            },
            {
                "id": 2009850,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 2008313,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1993432,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1979647,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1966418,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1966304,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1964293,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1964100,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1957584,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1954561,
                "content": [
                    {
                        "username": "yashbhargava_cs21",
                        "content": "when leet code wants to play with you\\uD83D\\uDE02"
                    },
                    {
                        "username": "Akhil_Tomar",
                        "content": "To delete the node we need two parameters whereas we are provided just one , instead of deleting to solve this one can assign the value pointer of the next node to the given node.\\n\\n `node->val=node->next->val;`\\n  `node->next=node->next->next;`\\n\\nThis should do. Leetcode should change this question."
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "We can change the value of current node to the value of next node until we reach the end, and if the next node is equal to NULL then we can set current node to NULL"
                    },
                    {
                        "username": "psionl0",
                        "content": "Once I got out of the mind set that I had to delete the node itself the problem became easy. Just copy the next node\\'s val to the current node\\'s val then delete the next node (for which you have a pointer to)."
                    },
                    {
                        "username": "Rahul_Kaper",
                        "content": "is it possible to solve this via recursion?"
                    },
                    {
                        "username": "besseddrest",
                        "content": "given the easy solution (which shall not be posted here), can someone explain why it cannot be simplified further to:\\n `node = node.next`"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "This should be marked as Easy."
                    },
                    {
                        "username": "hemanthraaj31",
                        "content": "The problems\\'s title would have been mentioned as \"Delete node value in Linked list\" instead of the actual one. But in the description, it is clear that we should remove the value of given node."
                    },
                    {
                        "username": "spookie886",
                        "content": "I actually do not know how to solve this"
                    },
                    {
                        "username": "uma_gadde",
                        "content": "Can\\'t believe this is a leetcode question!! That too medium level ;)"
                    }
                ]
            },
            {
                "id": 1950220,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1942038,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1930789,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1908532,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1867013,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1844349,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1842748,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1841981,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1838265,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1826613,
                "content": [
                    {
                        "username": "vyomverma",
                        "content": "easy for a medium level problem"
                    },
                    {
                        "username": "lizzler",
                        "content": "this should be marked as easy!"
                    },
                    {
                        "username": "santhoshsk32",
                        "content": "Why the problem is given with a description that all the values of the linked lists are unique ? Does that have anything to do with the logic for solving this problem??"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The problem in itself is very easy. But understand what I must do was very hard for me, because of this word \"delete'. In fact, we don't delete this node, we just change its value. The unique node that must be deleted it's the tail node."
                    },
                    {
                        "username": "Hisenberg123",
                        "content": "It took me a while to understand this question right.\\nExample : \\nhead - [1,2,3,4,5,6,7,8,9] , node - 6\\nwe will have access to the linked list from 6, [6,7,8,9]\\n"
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "class Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n       node->val=node->next->val;\\n       node->next=node->next->next;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_More",
                        "content": "Node is not to be deleted from memory, and the given node is not last node,\nso, we have to change the val of node and node.next as follows,\n        node.val = node.next.val;\n        node.next = node.next.next; "
                    },
                    {
                        "username": "DosU",
                        "content": "yeap, a medium one"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Bruhh why is this a medium level. Please make it easy one. Question is too straight forward."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be mark as easy"
                    }
                ]
            },
            {
                "id": 1807883,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1793693,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1789036,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1786847,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1786024,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1783579,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1777401,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1777189,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1772543,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1770150,
                "content": [
                    {
                        "username": "bortengineer",
                        "content": "Trick question :/\\nRename it from \"Delete a node\" to \"Remove a value from a list\"."
                    },
                    {
                        "username": "vikashkumarmishra14",
                        "content": "why is this medium ??"
                    },
                    {
                        "username": "Saurabhgiriltp",
                        "content": "interesting , if you are confused with that question then print the given note at a time , then you can able to understand , why this question consist only one parameter .................................. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You DON\\'T have to \"Delete\""
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/3136202/js-two-solution-constant-time-constant-space-explanation/\\n\\nConst Space and Time with 2 solution with explanation"
                    },
                    {
                        "username": "bhaskarsaini",
                        "content": "As the given function is void type so no need to worry about return anything.\\n Just think how you could change things with only given node."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "So seems like a stupid question, Right?\\nNo it\\'s not, it\\'s an intresting one\\nactually what do we need to do is just swap the values of current node and the next node and take the given node to last and remove it.\\nIt says in Problem that removing node means:-\\n\"The value of the given node should not exist in the linked list.\"\\nalso the number of nodes should reduce by one\\n\\n"
                    },
                    {
                        "username": "RuntimeTerror16",
                        "content": "I don\\'t understood the problem. Second parameter is missing in function"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/237_Delete_Node_in_a_Linked_List.cpp"
                    },
                    {
                        "username": "vyomverma",
                        "content": "Head kaha hai...!!"
                    }
                ]
            },
            {
                "id": 1766951,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1765175,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1761837,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1761593,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1760468,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1748435,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1746990,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1741311,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1731683,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1715844,
                "content": [
                    {
                        "username": "shekharshashank",
                        "content": "How is this questions marked as a medium level question. "
                    },
                    {
                        "username": "aditya_sharma_024",
                        "content": "two parameters should be given in the question. this question is not understable"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/comments/1746990"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hrishavratan",
                        "content": "Do not try to remove the node , in fact copy value of next node to this node and remove next node."
                    },
                    {
                        "username": "Goro_Majima",
                        "content": "Think Like this, If we can\\'t delete the node physically(I mean the way we traditionally do), can we do something with copying the elements.\\nMost important Hint -> Think in terms of tail While solving this question like what will become of the new tail.\\nGood Luck!"
                    },
                    {
                        "username": "Roshan_04",
                        "content": "What if the given node is last node?"
                    },
                    {
                        "username": "mars_999",
                        "content": "1. If the given node(to delete) is last node, then we need to make the previous node\\'s next to be null . Without providing head of the singly linked list, there is no other way we can reach the previous node."
                    },
                    {
                        "username": "mars_999",
                        "content": "Although tricky, this problem should be tagged as easy.  Actually a good question , it is not deleting the node. But the description of the question explains everything."
                    },
                    {
                        "username": "user5822gZ",
                        "content": "The fact that it's Medium made me think longer than I should on this, and I came up with the exact same solution I would've done if it was marked Easy. Weird difficulty, I probably am missing something, but not in the task itself, but in the perception of it."
                    },
                    {
                        "username": "rohan-zende",
                        "content": "Logical Question ."
                    },
                    {
                        "username": "shivanigam",
                        "content": "since node was not a tail \\nwe can use \\n     node.val=node.next.val;\\n        node.next=node.next.next;\\n\\nand if node was a tail we gett a error here because node.next wouldnt be existed if it was not a tail.."
                    }
                ]
            },
            {
                "id": 1715831,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1701044,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1687337,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1682754,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1651608,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1644999,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1644032,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1644030,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1643733,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1643580,
                "content": [
                    {
                        "username": "shivanigam",
                        "content": "     \\n\\n\\n\\nvery easy java solution\\n\\n\\n\\nnode.val=node.next.val;\\n        node.next=node.next.next;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(1) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/delete-node-in-a-linked-list/solutions/2863165/easy-c-o-1-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "dhuratj915",
                        "content": "class Solution {\\n    public void deleteNode(ListNode node) {\\n        if(node.next==null)\\n        {\\n            node=null;\\n        }\\n        else\\n        {\\n           node.val=node.next.val;\\n           node.next=node.next.next;\\n        }\\n    }\\n} "
                    },
                    {
                        "username": "Qyum",
                        "content": "Dumbest questions like me"
                    },
                    {
                        "username": "sd98754",
                        "content": "LeetCode should have a review system before posting a  question so that this kind of question could be delted right away."
                    },
                    {
                        "username": "SteveBronder",
                        "content": "It would be nice if the problem could check if you actually deleted the node and not just swapped it and left it hanging. Otherwise a lot of solutions here are just removing the node and not actually deleting it, causing a memory leak."
                    },
                    {
                        "username": "acbthisisit",
                        "content": "imagine a person coming to LC and sees the problem . He will not come back :)"
                    },
                    {
                        "username": "acbthisisit",
                        "content": "where is the head;"
                    },
                    {
                        "username": "KHARSH",
                        "content": "In this, we are not actually deleting the node we are just swapping the values and changing pointers and actually, this does not seem possible with one node also in the case of a single linked list."
                    },
                    {
                        "username": "Mallikarjun_K",
                        "content": "The answer is very simple if we understand the algorithm that is we should copy the next node\\'s value to current node/given node and delete the next node"
                    }
                ]
            },
            {
                "id": 1643358,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1643347,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1643137,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1643122,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1643092,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1643091,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1642896,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1642854,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1631958,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            },
            {
                "id": 1567927,
                "content": [
                    {
                        "username": "Vasanthvivi",
                        "content": "where is the node param to be deleted?"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "I think this problem should be marked as easy\\n"
                    },
                    {
                        "username": "avinash2678",
                        "content": "       ` 1. here we have the node that need to be deleted.\\n         2. we don\\'t have access to the entire linked list\\n         3. Delete the given node. Note that by deleting the node, we do not mean removing it from memory value should not exist in the list \\n         4. So here we can set current node value = next node value\\n        5.  current node.next point to next node.next `"
                    },
                    {
                        "username": "bajrang11082002",
                        "content": "  void deleteNode(ListNode* node) {\\n        *node = *node->next;\\n    }"
                    },
                    {
                        "username": "coder481",
                        "content": "Why this question is medium level?"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Here in this question as only the node that is to be deleted is given and it is clearly mentioned that the nodes value needs to be removed not the memory so, the simple idea to do so is by just updating the nodes value and address."
                    },
                    {
                        "username": "aserian",
                        "content": "Python solution using gc:\\n\\n```\\nimport gc\\n\\nclass Solution:\\n    def deleteNode(self, node):\\n        \"\"\"\\n        :type node: ListNode\\n        :rtype: void Do not return anything, modify node in-place instead.\\n        \"\"\"\\n\\n        parent = gc.get_referrers(node)\\n\\n        if not parent:\\n            # this case the node is the first in the list\\n            # we know there are at least 2 nodes so we guaranteed have a next\\n            node.val = node.next.val\\n            if node.next.next:\\n                node.next = node.next.next\\n            else:\\n                node.next = None\\n        else:\\n            parent[0][\\'next\\'] = node.next\\n```\\n\\nI assume this problem expects you to use language specific knowledge to use reflection to get the parent of the node you are given. Highly language specific and not a great question overall."
                    },
                    {
                        "username": "dpang06",
                        "content": "This should not be medium. Only two lines of code without any skills."
                    },
                    {
                        "username": "ritikarairitu8",
                        "content": "https://leetcode.com/problems/delete-node-in-a-linked-list/discussion/"
                    },
                    {
                        "username": "milu",
                        "content": "void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Best Time to Buy and Sell Stock with Transaction Fee",
        "question_content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>fee</code> representing a transaction fee.</p>\n\n<p>Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</li>\n\t<li>The transaction fee is only charged once for each stock purchase and sale.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,3,2,8,4,9], fee = 2\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,3,7,5,10,3], fee = 3\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt; 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= fee &lt; 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 108870,
                "title": "most-consistent-ways-of-dealing-with-the-series-of-stock-problems",
                "content": "Note: this is a repost of my original post [here](https://discuss.leetcode.com/topic/97310/most-consistent-ways-of-dealing-with-the-series-of-stock-problems) with updated solutions for this problem ([714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)). If you are only looking for solutions, you can go directly to each section in part **`II -- Applications to specific cases`**.\\n\\n---\\nUp to this point, I believe you have finished the following series of stock problems: \\n1. [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description)\\n2. [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description)\\n3. [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description)\\n4. [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description)\\n5. [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/#/description)\\n6. [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)\\n\\nFor each problem, we\\'ve got a couple of excellent posts explaining how to approach it. However, most of the posts failed to identify the connections among these problems and made it hard to develop a consistent way of dealing with this series of problems. Here I will introduce the most generalized solution applicable to all of these problems, and its specialization to each of the six problems above.\\n \\n---\\n**`I -- General cases`**\\n\\nThe idea begins with the following question: **Given an array representing the price of stocks on each day, what determines the maximum profit we can obtain?**\\n\\nMost of you can quickly come up with answers like \"it depends on which day we are and how many transactions we are allowed to complete\". Sure, those are important factors as they manifest themselves in the problem descriptions. However, there is a hidden factor that is not so obvious but vital in determining the maximum profit, which is elaborated below.\\n\\nFirst let\\'s spell out the notations to streamline our analyses. Let `prices` be the stock price array with length `n`, `i` denote the `i-th` day (`i` will go from `0` to `n-1`), `k` denote the maximum number of transactions allowed to complete, `T[i][k]` be the maximum profit that could be gained at the end of the `i-th` day with at most `k` transactions. Apparently we have base cases: `T[-1][k] = T[i][0] = 0`, that is, no stock or no transaction yield no profit (note the first day has `i = 0` so `i = -1` means no stock). Now if we can somehow relate `T[i][k]` to its subproblems like `T[i-1][k], T[i][k-1], T[i-1][k-1], ...`, we will have a working recurrence relation and the problem can be solved recursively. So how do we achieve that?\\n\\nThe most straightforward way would be looking at actions taken on the `i-th` day. How many options do we have? The answer is three: **buy**, **sell**, **rest**. Which one should we take? The answer is: we don\\'t really know, but to find out which one is easy. We can try each option and then choose the one that maximizes our profit, provided there are no other restrictions. However, we do have an extra restriction saying no multiple transactions are allowed at the same time, meaning if we decide to **buy** on the `i-th` day, there should be `0` stock held in our hand before we buy; if we decide to **sell** on the `i-th` day, there should be exactly `1` stock held in our hand before we sell. The number of stocks held in our hand is the hidden factor mentioned above that will affect the action on the `i-th` day and thus affect the maximum profit.\\n\\nTherefore our definition of `T[i][k]` should really be split into two: `T[i][k][0]` and `T[i][k][1]`, where the **former** denotes the maximum profit at the end of the `i-th` day with at most `k` transactions and with `0` stock in our hand AFTER taking the action, while the **latter** denotes the maximum profit at the end of the `i-th` day with at most `k` transactions and with `1` stock in our hand AFTER taking the action. Now the base cases and the recurrence relations can be written as:\\n\\n1. Base cases:\\n`T[-1][k][0] = 0, T[-1][k][1] = -Infinity`\\n`T[i][0][0] = 0, T[i][0][1] = -Infinity`\\n\\n2. Recurrence relations:\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])`\\n\\nFor the base cases, `T[-1][k][0] = T[i][0][0] = 0` has the same meaning as before while `T[-1][k][1] = T[i][0][1] = -Infinity` emphasizes the fact that it is impossible for us to have `1` stock in hand if there is no stock available or no transactions are allowed.\\n\\nFor `T[i][k][0]` in the recurrence relations, the actions taken on the `i-th` day can only be **rest** and **sell**, since we have `0` stock in our hand at the end of the day. `T[i-1][k][0]` is the maximum profit if action **rest** is taken, while `T[i-1][k][1] + prices[i]` is the maximum profit if action **sell** is taken. Note that the maximum number of allowable transactions remains the same, due to the fact that a transaction consists of two actions coming as a pair -- **buy** and **sell**. Only action **buy** will change the maximum number of transactions allowed (well, there is actually an alternative interpretation, see my [comment](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems/111002) below).\\n\\nFor `T[i][k][1]` in the recurrence relations, the actions taken on the `i-th` day can only be **rest** and **buy**, since we have `1` stock in our hand at the end of the day. `T[i-1][k][1]` is the maximum profit if action **rest** is taken, while `T[i-1][k-1][0] - prices[i]` is the maximum profit if action **buy** is taken. Note that the maximum number of allowable transactions decreases by one, since buying on the `i-th` day will use one transaction, as explained above.\\n\\nTo find the maximum profit at the end of the last day, we can simply loop through the `prices` array and update `T[i][k][0]` and `T[i][k][1]` according to the recurrence relations above. The final answer will be `T[i][k][0]` (we always have larger profit if we end up with `0` stock in hand).\\n\\n---\\n**`II -- Applications to specific cases`**\\n\\nThe aforementioned six stock problems are classified by the value of `k`, which is the maximum number of allowable transactions (the last two also have additional requirements such as \"cooldown\" or \"transaction fee\"). I will apply the general solution to each of them one by one.\\n\\n<br>\\n\\n**Case I: `k = 1`**\\n\\nFor this case, we really have two unknown variables on each day: `T[i][1][0]` and `T[i][1][1]`, and the recurrence relations say:\\n\\n`T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])`\\n`T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])`\\n\\nwhere we have taken advantage of the base case`T[i][0][0] = 0` for the second equation.\\n\\nIt is straightforward to write the `O(n)` time and `O(n)` space solution, based on the two equations above. However, if you notice that the maximum profits on the `i-th` day actually only depend on those on the `(i-1)-th` day, the space can be cut down to `O(1)`. Here is the space-optimized solution:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i10;\\n}\\n```\\nNow let\\'s try to gain some insight of the solution above. If we examine the part inside the loop more carefully, `T_i11` really just represents the maximum value of the negative of all stock prices up to the `i-th` day, or equivalently the minimum value of all the stock prices. As for `T_i10`, we just need to decide which action yields a higher profit, sell or rest. And if action sell is taken, the price at which we bought the stock is `T_i11`, i.e., the minimum value before the `i-th` day. This is exactly what we would do in reality if we want to gain maximum profit. I should point out that this is not the only way of solving the problem for this case. You may find some other nice solutions [here](https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input).\\n\\n<br>\\n\\n**Case II: `k = +Infinity`**\\n\\nIf `k` is positive infinity, then there isn\\'t really any difference between `k` and `k - 1` (wonder why? see my [comment](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/9) below), which implies `T[i-1][k-1][0] = T[i-1][k][0]` and `T[i-1][k-1][1] = T[i-1][k][1]`. Therefore, we still have two unknown variables on each day: `T[i][k][0]` and `T[i][k][1]` with `k = +Infinity`, and the recurrence relations say:\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nwhere we have taken advantage of the fact that `T[i-1][k-1][0] = T[i-1][k][0]` for the second equation. The `O(n)` time and `O(1)` space solution is as follows:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n    \\n    return T_ik0;\\n}\\n```\\n(**Note**: The caching of the old values of `T_ik0`, that is, the variable `T_ik0_old`, is [unnecessary](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/24). Special thanks to [0x0101](https://discuss.leetcode.com/user/0x0101) and [elvina](https://discuss.leetcode.com/user/elvina) for clarifying this.)\\n\\nThis solution suggests a greedy strategy of gaining maximum profit: as long as possible, buy stock at each local minimum and sell at the immediately followed local maximum. This is equivalent to finding increasing subarrays in `prices` (the stock price array), and buying at the beginning price of each subarray while selling at its end price. It\\'s easy to show that this is the same as accumulating profits as long as it is profitable to do so, as demonstrated in this [post](https://discuss.leetcode.com/topic/726/is-this-question-a-joke).\\n\\n<br>\\n\\n**Case III: `k = 2`**\\n\\nSimilar to the case where `k = 1`, except now we have four variables instead of two on each day: `T[i][1][0]`, `T[i][1][1]`, `T[i][2][0]`, `T[i][2][1]`, and the recurrence relations are:\\n\\n`T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])`\\n`T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])`\\n`T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])`\\n`T[i][1][1] = max(T[i-1][1][1], -prices[i])`\\n\\nwhere again we have taken advantage of the base case`T[i][0][0] = 0` for the last equation. The `O(n)` time and `O(1)` space solution is as follows:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;\\n    int T_i20 = 0, T_i21 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i20 = Math.max(T_i20, T_i21 + price);\\n        T_i21 = Math.max(T_i21, T_i10 - price);\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i20;\\n}\\n```\\nwhich is essentially the same as the one given [here](https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1).\\n\\n<br>\\n\\n**Case IV: `k is arbitrary`**\\n\\nThis is the most general case so on each day we need to update all the maximum profits with different `k` values corresponding to `0` or `1` stocks in hand at the end of the day. However, there is a minor optimization we can do if `k` exceeds some critical value, beyond which the maximum profit will no long depend on the number of allowable transactions but instead will be bound by the number of available stocks (length of the `prices` array). Let\\'s figure out what this critical value will be.\\n\\nA profitable transaction takes at least two days (buy at one day and sell at the other, provided the buying price is less than the selling price). If the length of the `prices` array is `n`, the maximum number of profitable transactions is `n/2` (integer division). After that no profitable transaction is possible, which implies the maximum profit will stay the same. Therefore the critical value of `k` is `n/2`. If the given `k` is no less than this value, i.e., `k >= n/2`, we can extend `k` to positive infinity and the problem is equivalent to **`Case II`**.\\n\\nThe following is the `O(kn)` time and `O(k)` space solution. Without the optimization, the code will be met with TLE for large `k` values.\\n\\n```\\npublic int maxProfit(int k, int[] prices) {\\n    if (k >= prices.length >>> 1) {\\n        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n        for (int price : prices) {\\n            int T_ik0_old = T_ik0;\\n            T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n            T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n        }\\n        \\n        return T_ik0;\\n    }\\n        \\n    int[] T_ik0 = new int[k + 1];\\n    int[] T_ik1 = new int[k + 1];\\n    Arrays.fill(T_ik1, Integer.MIN_VALUE);\\n        \\n    for (int price : prices) {\\n        for (int j = k; j > 0; j--) {\\n            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);\\n            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);\\n        }\\n    }\\n        \\n    return T_ik0[k];\\n}\\n```\\n\\nThe solution is similar to the one found in this [post](https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java). Here I used backward looping for the `T` array to avoid using temporary variables. It turns out that it is [possible](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/26) to do forward looping without temporary variables, too.\\n\\n<br>\\n\\n**Case V: `k = +Infinity but with cooldown`**\\n\\nThis case resembles **`Case II`** very much due to the fact that they have the same `k` value, except now the recurrence relations have to be modified slightly to account for the \"**cooldown**\" requirement. The original recurrence relations for **`Case II`** are given by\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nBut with \"cooldown\", we cannot buy on the `i-th` day if a stock is sold on the `(i-1)-th` day. Therefore, in the second equation above, instead of `T[i-1][k][0]`, we should actually use `T[i-2][k][0]` if we intend to buy on the `i-th` day. Everything else remains the same and the new recurrence relations are\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])`\\n\\nAnd here is the `O(n)` time and `O(1)` space solution:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);\\n        T_ik0_pre = T_ik0_old;\\n    }\\n    \\n    return T_ik0;\\n}\\n```\\n\\n[dietpepsi](https://discuss.leetcode.com/user/dietpepsi) shared a very nice solution [here](https://discuss.leetcode.com/topic/30421/share-my-thinking-process) with thinking process, which turns out to be the same as the one above.\\n\\n<br>\\n\\n**Case VI: `k = +Infinity but with transaction fee`**\\n\\nAgain this case resembles **`Case II`** very much as they have the same `k` value, except now the recurrence relations need to be modified slightly to account for the \"**transaction fee**\" requirement. The original recurrence relations for **`Case II`** are given by\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nSince now we need to pay some fee (denoted as `fee`) for each transaction made, the profit after buying or selling the stock on the `i-th` day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee)`\\n\\nor\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee)`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nNote we have two options as for when to subtract the `fee`. This is because (as I mentioned above) each transaction is characterized by two actions coming as a pair - - **buy** and **sell**. The fee can be paid either when we buy the stock (corresponds to the first set of equations) or when we sell it (corresponds to the second set of equations). The following are the `O(n)` time and `O(1)` space solutions corresponding to these two options, where for the second solution we need to pay attention to possible overflows.\\n\\n\\n**Solution I** -- pay the fee when buying the stock:\\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);\\n    }\\n        \\n    return T_ik0;\\n}\\n```\\n\\n**Solution II** -- pay the fee when selling the stock:\\n \\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        long T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n        \\n    return (int)T_ik0;\\n}\\n```\\n---\\n**`III -- Summary`**\\n\\nIn summary, the most general case of the stock problem can be characterized by three factors, the ordinal of the day `i`, the maximum number of allowable transactions `k`, and the number of stocks in our hand at the end of the day. I have shown the recurrence relations for the maximum profits and their termination conditions, which leads to the `O(nk)` time and `O(k)` space solution. The results are then applied to each of the six cases, with the last two using slightly modified recurrence relations due to the additional requirements. I should mention that [peterleetcode](https://discuss.leetcode.com/user/peterleetcode) also introduced a nice solution [here](https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions) which generalizes to arbitrary `k` values. If you have a taste, take a look.\\n\\nHope this helps and happy coding!",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i10;\\n}\\n```\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n    \\n    return T_ik0;\\n}\\n```\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;\\n    int T_i20 = 0, T_i21 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i20 = Math.max(T_i20, T_i21 + price);\\n        T_i21 = Math.max(T_i21, T_i10 - price);\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i20;\\n}\\n```\n```\\npublic int maxProfit(int k, int[] prices) {\\n    if (k >= prices.length >>> 1) {\\n        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n        for (int price : prices) {\\n            int T_ik0_old = T_ik0;\\n            T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n            T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n        }\\n        \\n        return T_ik0;\\n    }\\n        \\n    int[] T_ik0 = new int[k + 1];\\n    int[] T_ik1 = new int[k + 1];\\n    Arrays.fill(T_ik1, Integer.MIN_VALUE);\\n        \\n    for (int price : prices) {\\n        for (int j = k; j > 0; j--) {\\n            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);\\n            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);\\n        }\\n    }\\n        \\n    return T_ik0[k];\\n}\\n```\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);\\n        T_ik0_pre = T_ik0_old;\\n    }\\n    \\n    return T_ik0;\\n}\\n```\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);\\n    }\\n        \\n    return T_ik0;\\n}\\n```\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        long T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n        \\n    return (int)T_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 108871,
                "title": "2-solutions-2-states-dp-solutions-clear-explanation",
                "content": "Given any <strong><code>day I</strong></code>, its max profit status boils down to one of the two status below:\\n\\n**(1) buy status**:\\n<strong><code>buy[i]</strong></code> represents the **max profit** at <strong><code>day i</strong></code> in **buy status**, given that **the last action you took is a buy action** at <strong><code>day K</strong></code>, where <strong><code>K<=i</strong></code>. **And you have the right to sell at <strong><code>day i+1</strong></code>, or do nothing.**\\n**(2) sell status**:\\n<strong><code>sell[i]</strong></code> represents the **max profit** at <strong><code>day i</strong></code> in **sell status**, given that **the last action you took is a sell action** at <strong><code>day K</strong></code>, where <strong><code>K<=i</strong></code>. **And you have the right to buy at <strong><code>day i+1</strong></code>, or do nothing.**\\n\\nLet\\'s walk through from **base case**.\\n\\n**Base case:**\\nWe can start from **buy status**, which means we buy stock at <strong><code>day 0</strong></code>.\\n<strong><code>buy[0]=-prices[0]</strong></code>;\\nOr we can start from **sell status**, which means we sell stock at <strong><code>day 0</strong></code>. \\nGiven that we don\\'t have any stock at hand in day 0, we set sell status to be 0.\\n<strong><code>sell[0]=0</strong></code>;\\t      \\n\\n**Status transformation:**\\nAt <strong><code>day i</strong></code>, we may **buy** stock (from **previous sell status**) or do nothing (from **previous buy status**):\\n<strong><code>buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]);</strong></code>\\nOr\\nAt <strong><code>day i</strong></code>, we may **sell** stock (from previous **buy status**) or keep holding (from **previous sell status**):\\n<strong><code>sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); </strong></code>\\n\\n**Finally:**\\nWe will return <strong><code>sell[last_day]</strong></code> as our result, which represents the max profit at the last day, given that you took sell action at any day before the last day.\\n\\n**We can apply transaction fee at either buy status or sell status.**  \\n\\n\\n\\n\\nSo here come our two solutions:\\n\\n**Solution I** -- pay the fee when buying the stock:\\n\\n    public int maxProfit(int[] prices, int fee) {\\n\\t        if (prices.length <= 1) return 0;\\n\\t        int days = prices.length, buy[] = new int[days], sell[] = new int[days];\\n\\t        buy[0]=-prices[0]-fee;\\n\\t        for (int i = 1; i<days; i++) {\\n\\t            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i] - fee); // keep the same as day i-1, or buy from sell status at day i-1\\n\\t            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); // keep the same as day i-1, or sell from buy status at day i-1\\n\\t        }\\n\\t        return sell[days - 1];\\n\\t    }\\n\\n**Solution II** -- pay the fee when selling the stock:\\n\\n        public int maxProfit(int[] prices, int fee) {\\n\\t        if (prices.length <= 1) return 0;\\n\\t        int days = prices.length, buy[] = new int[days], sell[] = new int[days];\\n\\t        buy[0]=-prices[0];\\n\\t        for (int i = 1; i<days; i++) {\\n\\t            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]); // keep the same as day i-1, or buy from sell status at day i-1\\n\\t            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i] - fee); // keep the same as day i-1, or sell from buy status at day i-1\\n\\t        }\\n\\t        return sell[days - 1];\\n\\t    }",
                "solutionTags": [],
                "code": "Given any <strong><code>day I</strong></code>, its max profit status boils down to one of the two status below:\\n\\n**(1) buy status**:\\n<strong><code>buy[i]</strong></code> represents the **max profit** at <strong><code>day i</strong></code> in **buy status**, given that **the last action you took is a buy action** at <strong><code>day K</strong></code>, where <strong><code>K<=i</strong></code>. **And you have the right to sell at <strong><code>day i+1</strong></code>, or do nothing.**\\n**(2) sell status**:\\n<strong><code>sell[i]</strong></code> represents the **max profit** at <strong><code>day i</strong></code> in **sell status**, given that **the last action you took is a sell action** at <strong><code>day K</strong></code>, where <strong><code>K<=i</strong></code>. **And you have the right to buy at <strong><code>day i+1</strong></code>, or do nothing.**\\n\\nLet\\'s walk through from **base case**.\\n\\n**Base case:**\\nWe can start from **buy status**, which means we buy stock at <strong><code>day 0</strong></code>.\\n<strong><code>buy[0]=-prices[0]</strong></code>;\\nOr we can start from **sell status**, which means we sell stock at <strong><code>day 0</strong></code>. \\nGiven that we don\\'t have any stock at hand in day 0, we set sell status to be 0.\\n<strong><code>sell[0]=0</strong></code>;\\t      \\n\\n**Status transformation:**\\nAt <strong><code>day i</strong></code>, we may **buy** stock (from **previous sell status**) or do nothing (from **previous buy status**):\\n<strong><code>buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]);</strong></code>\\nOr\\nAt <strong><code>day i</strong></code>, we may **sell** stock (from previous **buy status**) or keep holding (from **previous sell status**):\\n<strong><code>sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); </strong></code>\\n\\n**Finally:**\\nWe will return <strong><code>sell[last_day]</strong></code> as our result, which represents the max profit at the last day, given that you took sell action at any day before the last day.\\n\\n**We can apply transaction fee at either buy status or sell status.**  \\n\\n\\n\\n\\nSo here come our two solutions:\\n\\n**Solution I** -- pay the fee when buying the stock:\\n\\n    public int maxProfit(int[] prices, int fee) {\\n\\t        if (prices.length <= 1) return 0;\\n\\t        int days = prices.length, buy[] = new int[days], sell[] = new int[days];\\n\\t        buy[0]=-prices[0]-fee;\\n\\t        for (int i = 1; i<days; i++) {\\n\\t            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i] - fee); // keep the same as day i-1, or buy from sell status at day i-1\\n\\t            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); // keep the same as day i-1, or sell from buy status at day i-1\\n\\t        }\\n\\t        return sell[days - 1];\\n\\t    }\\n\\n**Solution II** -- pay the fee when selling the stock:\\n\\n        public int maxProfit(int[] prices, int fee) {\\n\\t        if (prices.length <= 1) return 0;\\n\\t        int days = prices.length, buy[] = new int[days], sell[] = new int[days];\\n\\t        buy[0]=-prices[0];\\n\\t        for (int i = 1; i<days; i++) {\\n\\t            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]); // keep the same as day i-1, or buy from sell status at day i-1\\n\\t            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i] - fee); // keep the same as day i-1, or sell from buy status at day i-1\\n\\t        }\\n\\t        return sell[days - 1];\\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3667440,
                "title": "beats-100-c-java-python-beginner-friendly",
                "content": "**Explore Related Problems to Enhance Conceptual Understanding**\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)\\n3. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/)\\n4. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/)\\n5. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)\\n\\n# Intuition\\nThe intuition behind the solution is to keep track of the minimum cost to buy a stock at each day and the maximum profit that can be achieved by selling the stock at each day.\\n\\n# Approach:\\n1. Initialize two variables: `buy` and `sell`. Set `buy` to negative infinity and `sell` to zero. These variables will keep track of the maximum profit at each day.\\n2. Iterate through the prices of the stocks starting from the first day.\\n3. Update the `buy` variable by taking the maximum of its current value and the previous `sell` value minus the stock price. This represents the maximum profit after buying the stock.\\n   `buy = max(buy, sell - price)`\\n\\n4. Update the `sell` variable by taking the maximum of its current value and the previous `buy` value plus the stock price minus the transaction fee. This represents the maximum profit after selling the stock.\\n   `sell = max(sell, buy + price - fee)`\\n\\n5. After iterating through all the prices, the maximum profit will be stored in the `sell` variable.\\n6. Return the value of `sell` as the maximum profit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int buy = INT_MIN;\\n        int sell = 0;\\n\\n        for (int price : prices) {\\n            buy = max(buy, sell - price);\\n            sell = max(sell, buy + price - fee);\\n        }\\n\\n        return sell;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int buy = Integer.MIN_VALUE;\\n        int sell = 0;\\n\\n        for (int price : prices) {\\n            buy = Math.max(buy, sell - price);\\n            sell = Math.max(sell, buy + price - fee);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        buy = float(\\'-inf\\')\\n        sell = 0\\n\\n        for price in prices:\\n            buy = max(buy, sell - price)\\n            sell = max(sell, buy + price - fee)\\n\\n        return sell\\n```\\n\\nRelated problems\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/2e94ef11-230e-433b-8ee6-395ad6853167_1687396465.6220565.png)\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int buy = INT_MIN;\\n        int sell = 0;\\n\\n        for (int price : prices) {\\n            buy = max(buy, sell - price);\\n            sell = max(sell, buy + price - fee);\\n        }\\n\\n        return sell;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int buy = Integer.MIN_VALUE;\\n        int sell = 0;\\n\\n        for (int price : prices) {\\n            buy = Math.max(buy, sell - price);\\n            sell = Math.max(sell, buy + price - fee);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        buy = float(\\'-inf\\')\\n        sell = 0\\n\\n        for price in prices:\\n            buy = max(buy, sell - price)\\n            sell = max(sell, buy + price - fee)\\n\\n        return sell\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201603,
                "title": "python-greedy-is-good",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if n < 2:\\n             return 0\\n        ans = 0\\n        minimum = prices[0]\\n        for i in range(1, n):\\n            if prices[i] < minimum:\\n                minimum = prices[i]\\n            elif prices[i] > minimum + fee:\\n                ans += prices[i] - fee - minimum\\n                minimum = prices[i] - fee\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if n < 2:\\n             return 0\\n        ans = 0\\n        minimum = prices[0]\\n        for i in range(1, n):\\n            if prices[i] < minimum:\\n                minimum = prices[i]\\n            elif prices[i] > minimum + fee:\\n                ans += prices[i] - fee - minimum\\n                minimum = prices[i] - fee\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108867,
                "title": "c-concise-solution-o-n-time-o-1-space",
                "content": "The solution maintains two states:\\n```\\ns0 = profit having no stock\\ns1 = profit having 1 stock\\n```\\nThe code iterates through the stock prices, and updates s0, s1 respectively. The run time is O(n).\\n```\\nupdate s0 by selling the stock from s1, so s0 = max(s0, s1+p);\\nupdate s1 by buying the stock from s0, so s1 = max(s1, s0-p-fee);\\n```\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int s0 = 0, s1 = INT_MIN; \\n        for(int p:prices) {\\n            int tmp = s0;\\n            s0 = max(s0, s1+p);\\n            s1 = max(s1, tmp-p-fee);\\n        }\\n        return s0;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\ns0 = profit having no stock\\ns1 = profit having 1 stock\\n```\n```\\nupdate s0 by selling the stock from s1, so s0 = max(s0, s1+p);\\nupdate s1 by buying the stock from s0, so s1 = max(s1, s0-p-fee);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668244,
                "title": "detailed-explanation-fastest-cakewalk-solution-for-everyone",
                "content": "\\uD83D\\uDE07 ***It took me a lot of time to craft these solutions so please do upvote if you find this useful.***\\n\\n# What to Expect?\\nI will take you from the brute force **recursion**, then to **memoization**, then **tabulation**, then **space optimisation** and finally the **two integer variables** super optimised solution!!! And I promise if you read from the beginning till the end you will not only understand all the solutions without any doubt but also understand how some poeple come up with solutions that look mind blowing.\\n\\n# Intuition\\n- In the question we have a transaction fee, but it is not mentioned very clearly whether the transaction fee is for every buy and every sell or for a buy - sell pair. So let\\'s me make it clear, the transaction fee is for a buy - sell pair and **not for every buy and every sell**.\\n- Now upon reading the question carefully we can see that on every index we have 3 choices: Either **buy**, or **sell**, or **do nothing** and move on. But at the same time you **can only buy** if you currently have **no stock** that\\'s yet to be sold. Similarly you **can only sell** when you have bought a stock previously that\\'s **not sold yet**.\\n- So from this intuition we can think of a brute force of trying out every possible choices for every index. So recursion should immediately come to your mind whenever you come across this type of situtaion.\\n- So now with this thought process in mind let us first explore the recursive approach. But it will give **TLE**, so don\\'t worry I will take you to the most optimised solution for this problem.\\n\\n<hr/>\\n\\n# Pure Recursion - TLE \\u274C \\n\\nThis is very important for understanding the best solution\\n## Algorithm (Very important)\\n\\n1. Define the `maxProfitHelper` recursive function:\\n    - Check the **base case**, if the current index `idx` is equal to the size of the prices array, that means that you have nothing to buy/sell so **no more profit** can be earned, thus `return 0`.\\n    - Now let us explore every path: **buy**, **sell**, **move_on**. And our recursive helper function will depend on 2 parameters only: `idx` to denote the current index in prices and a boolean `canBuy` to denote whether we are allowed to buy or allowed to sell.\\n    - Initialize variables `buy` and `sell` to very large negative values (`-1e9`). This is to ensure that when we are allowed to buy, the sell **should not contribute** to the answer and when we are allowed to sell, the buy **should not contribute** to the answer.\\n    - If `canBuy` is true, then we **may buy** but **cannot sell**. So calculate the profit that can be obtained by buying the stock at the current index `idx` and recursively calling `maxProfitHelper` for the next index (`idx + 1`) in the prices array and `!canBuy = false`.\\n    - If `canBuy` is false, then we **cannot buy** but we **may sell**. So calculate the profit that can be obtained by selling the stock at the current index `idx` **(don\\'t forget to subtract the transaction fee here)** and recursively calling `maxProfitHelper` for the next index (`idx + 1`) in the prices array and `!canBuy = true`.\\n    - And now we also have another path to choose: The `move_on` path which can be chosen irrespective of the `canBuy` flag. In this path we just call `maxProfitHelper` for the next index (`idx + 1`) without adding or subtracting anything.\\n    - Now finally our overall maximum profit will be the maximum of `buy`, `sell` and `move_on`. But if you observe carefully for any of the recursion we will only explore two paths either `buy - move_on` or `sell move_on` since we cannot buy and sell in the same index. And this is why we initially set buy and sell to very large negative number.\\n    - Return this maximum profit.\\n\\n2. In the `maxProfit` function:\\n    - Initialize the variable `n` to the size of the prices vector.\\n    - Call the `maxProfitHelper` function with the initial state (`idx = 0`, `canBuy = true`) parameters.\\n    - Return the maximum profit obtained from the `maxProfitHelper` function.\\n\\n## Complexity analysis\\n    Consider \\'n\\' is the size of `prices` array.\\n#### Time complexity: $O(2^n)$\\n- Since for every index we can only explore 2 paths, either `buy - move_on` or `sell - move_on`. And we are doing this on every index starting from `0` to `n - 1`;\\n\\n#### Space complexity: $O(n)$\\n- Since at any point of time the maximum depth of recursion will be the size of the array **(`idx` goes from `0` to `n - 1`)**\\n\\n## Code - Don\\'t submit this. It will give TLE \\u274C\\n``` C++ []\\nclass Solution {\\nprivate:\\n    int maxProfitHelper(int idx, bool canBuy, int fee, vector<int> &prices) {\\n        //Base case\\n        if(idx == prices.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all possible paths\\n        int buy = -1e9, sell = -1e9;\\n        if(canBuy) {\\n            buy = -prices[idx] + maxProfitHelper(idx + 1, !canBuy, fee, prices);\\n        } else {\\n            sell = prices[idx] - fee + maxProfitHelper(idx + 1, !canBuy, fee, prices);\\n        }\\n        int move_on = maxProfitHelper(idx + 1, canBuy, fee, prices);\\n        return max({buy, sell, move_on});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        return maxProfitHelper(0, true, fee, prices);\\n    }\\n};\\n\\n```\\n\\n<hr/>\\n\\n# Memoization - Accepted \\u2705\\n\\nKeep going you are doing great! \\uD83D\\uDC4D\\n## What to add in previous code?\\n\\nJust some slight changes in the previous code will convert it into memoization. Firstly because there are a lot of overlapping subproblems, we can cache the results of the states in a `dp` array. Since we have two parameter where `idx` goes from `0` to `n` and `canBuy` switches between `true (1)` and `false (0)` we define dp of size `n + 1` by `2`. And then inside the `maxProfitHelper` we can check if `dp[idx][canBuy]` is already calculated or not. If already calculated we just return the result stored in `dp[idx][canBuy]`. Otherwise we can do the recursion and calculate the max profit and store it in `dp[idx][canBuy]` and return it. See code below for more clarity.\\n\\n## Complexity analysis\\n    Consider \\'n\\' is the size of `prices` array.\\n#### Time complexity: $O(2n)$\\n- Since at max for every index we will caluclate the result twice once for `canBuy = false (0)` and for `canBuy = true (1)`\\n\\n#### Space complexity: $O(3n)$\\n- `2n` space for the `dp` array and `n` space for the `recursion stack`\\n\\n## Code\\n``` C++ []\\nclass Solution {\\nprivate:\\n    int maxProfitHelper(int idx, bool canBuy, int fee, vector<int> &prices, vector<vector<int>>& dp) {\\n        //Base case\\n        if(idx == prices.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all possible paths\\n        if(dp[idx][canBuy] != -1e9) {\\n            //Means result was already calculated\\n            return dp[idx][canBuy];\\n        }\\n        int buy = -1e9, sell = -1e9;\\n        if(canBuy) {\\n            buy = -prices[idx] + maxProfitHelper(idx + 1, !canBuy, fee, prices, dp);\\n        } else {\\n            sell = prices[idx] - fee + maxProfitHelper(idx + 1, !canBuy, fee, prices, dp);\\n        }\\n        int move_on = maxProfitHelper(idx + 1, canBuy, fee, prices, dp);\\n        return dp[idx][canBuy] = max({buy, sell, move_on});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2, -1e9));\\n        return maxProfitHelper(0, true, fee, prices, dp);\\n    }\\n};\\n```\\n<hr/>\\n\\n# Tabulation - Accepted \\u2705\\u2705\\n\\nGreat job! Keep going \\uD83D\\uDCAF\\n## What to change in previous code?\\n\\nConverting a memoization solution to tabulation is very easy too. In memoization we go top-down. In tabulation we go bottom-up. So in tabulation we first calculate the base case and then go in the backward direction to reach the initial state. This will more clear from the code below.\\n\\n## Complexity analysis\\n    Consider \\'n\\' is the size of `prices` array.\\n#### Time complexity: $O(2n)$\\n- Since at max for every index we will caluclate the result twice once for `canBuy = false (0)` and for `canBuy = true (1)`\\n\\n#### Space complexity: $O(2n)$\\n- `2n` space for the `dp` array.\\n\\n## Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2));\\n\\n        //Base case\\n        dp[n][0] = 0; dp[n][1] = 0;\\n\\n        //You can also skip typing the above base case by directly assigning every element of dp as 0 like below\\n        //vector<vector<int>> dp(n + 1, vector<int>(2, 0));\\n\\n\\n        //Explore all paths (bottom-up)\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            for(int canBuy = 1; canBuy >= 0; canBuy--) {\\n                //Observe that this block is same as memoization\\n                int buy = -1e9, sell = -1e9;\\n                if(canBuy) {\\n                    buy = -prices[idx] + dp[idx + 1][!canBuy];\\n                } else {\\n                    sell = prices[idx] - fee + dp[idx + 1][!canBuy];\\n                }\\n                int move_on = dp[idx + 1][canBuy];\\n                dp[idx][canBuy] = max({buy, sell, move_on});                \\n            }\\n        }\\n\\n        //idx = 0 and canBuy = true is the initial state\\n        return dp[0][1];\\n    }\\n};\\n```\\n<hr/>\\n\\n# Space Optimised Tabulation - Accepted \\u2705\\u2705\\n\\nYou have come a long way! Keep going champ \\uD83C\\uDFC6\\n## What to change in previous code?\\n\\nIn the previous tabulation code if you observe the inner loop body carefully, you will notice that `dp[idx][...]` is always dependent on `dp[idx + 1][...]`. So why not instead of storing the entire dp table we just keep track of two arrays current (`curr`) and `next`. Where `curr[...]` will represent `dp[idx][...]` and `next[...]` will represent `dp[idx + 1][...]`. And believe me we will just blindly replace `dp[idx][...]` with `curr[...]` and `dp[idx + 1][...]` with `next[...]`. See code below for more clarity.\\n\\n## Complexity analysis\\n    Consider \\'n\\' is the size of `prices` array.\\n#### Time complexity: $O(2n)$\\n- Since at max for every index we will caluclate the result twice once for `canBuy = false (0)` and for `canBuy = true (1)`\\n\\n#### Space complexity: $O(1)$\\n- We are just taking `4` spaces in total, 2 for `curr` and 2 for `next`\\n\\n## Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n\\n        //We assign 0 to all values to account for the base case without typing them out manually\\n        vector<int> curr(2, 0), next(2, 0);\\n\\n\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            for(int canBuy = 1; canBuy >= 0; canBuy--) {\\n                //This block is similar to the tabulation one\\n                int buy = -1e9, sell = -1e9;\\n                if(canBuy) {\\n                    buy = -prices[idx] + next[!canBuy];\\n                } else {\\n                    sell = prices[idx] - fee + next[!canBuy];\\n                }\\n                int move_on = next[canBuy];\\n                curr[canBuy] = max({buy, sell, move_on});                \\n            }\\n            next = curr;\\n        }\\n\\n        //Since at the end next will get assigned to curr\\n        return next[1];\\n    }\\n};\\n```\\n\\n<hr/>\\n\\n# Getting rid of the inner loop - Accepted \\u2705\\u2705\\u2705\\n\\nWait for it you are very close \\uD83D\\uDE09\\n## What to change in previous code?\\n\\nIn the previous code on close observation we notice that the inner loop is kind of extra as it is just iterating over 2 values. This is adding an additional time complxity. So why not remove it completely and do both the operation in the same loop. See code below for clarity.\\n\\n## Complexity analysis\\n    Consider \\'n\\' is the size of `prices` array.\\n#### Time complexity: $O(n)$\\n- We are just traversing `prices` array once\\n\\n#### Space complexity: $O(1)$\\n- We just take 4 spaces, 2 for `curr` and 2 for `next`\\n\\n## Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<int> curr(2, 0), next(2, 0);\\n\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            //For canBuy = true\\n            curr[1] = max(-prices[idx] + next[0], next[1]);\\n            //For canBuy = false\\n            curr[0] = max(prices[idx] - fee + next[1], next[0]);\\n            next = curr;\\n        }\\n\\n        return next[1];\\n    }\\n};\\n```\\n\\n# THE ULTIMATE SOLUTION - Accepted \\u2705\\u2705\\u2705\\u2705\\n\\nIf you compare this to the memoization it is sure to blow your mind \\uD83E\\uDD2F\\n## What to change in previous code?\\n\\nIn the previous code we are taking arrays for both curr and next. But both curr and next are just holding 2 values each. So why not use 4 integers instead. But yeah you might say that the space consumption still remains the same. So wait we are going to do another thing, that will bring down the space to **`2 integers only`**, which you will observe after reading the code below.\\n\\n## Complexity analysis\\n    Consider \\'n\\' is the size of `prices` array.\\n#### Time complexity: $O(n)$\\n- We are just traversing `prices` array once\\n\\n#### Space complexity: $O(1)$\\n- We are taking just 2 integer spaces. \\n\\n## Code - With 4 integers\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int c0, c1; //curr\\n        int n0, n1; //next\\n\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            //For canBuy = true\\n            c1 = max(-prices[idx] + n0, n1);\\n            //For canBuy = false\\n            c0 = max(prices[idx] - fee + n1, n0);\\n            //next = curr\\n            n0 = c0; n1 = c1\\n        }\\n\\n        //next[1]\\n        return n1;\\n    }\\n};\\n```\\n\\nNow observe the above solution carefully. Do you notice that c0 and c1 are just acting like temporary variables for storing the answer and the result actually doesn\\'t depend on c0 and c1, but only on n0 and n1.\\n\\n## Code - With just 2 integers \\uD83C\\uDFC6\\u2705\\u2B50\\uFE0F\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int n0 = 0, n1 = 0;\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            n1 = max(-prices[idx] + n0, n1);\\n            n0 = max(prices[idx] - fee + n1, n0); \\n        }\\n        return n1;\\n    }\\n};\\n\\n```\\n\\n***Now imagine someone putting up the last solution in the discuss section and people would be blown away by \"How someone could come up with this solution?\". So I think now you know the secret. It\\'s not hard, it\\'s just derived from the brute force. So if you find this useful please don\\'t forget to upvote this article!\\uD83D\\uDE07***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` C++ []\\nclass Solution {\\nprivate:\\n    int maxProfitHelper(int idx, bool canBuy, int fee, vector<int> &prices) {\\n        //Base case\\n        if(idx == prices.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all possible paths\\n        int buy = -1e9, sell = -1e9;\\n        if(canBuy) {\\n            buy = -prices[idx] + maxProfitHelper(idx + 1, !canBuy, fee, prices);\\n        } else {\\n            sell = prices[idx] - fee + maxProfitHelper(idx + 1, !canBuy, fee, prices);\\n        }\\n        int move_on = maxProfitHelper(idx + 1, canBuy, fee, prices);\\n        return max({buy, sell, move_on});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        return maxProfitHelper(0, true, fee, prices);\\n    }\\n};\\n\\n```\n``` C++ []\\nclass Solution {\\nprivate:\\n    int maxProfitHelper(int idx, bool canBuy, int fee, vector<int> &prices, vector<vector<int>>& dp) {\\n        //Base case\\n        if(idx == prices.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all possible paths\\n        if(dp[idx][canBuy] != -1e9) {\\n            //Means result was already calculated\\n            return dp[idx][canBuy];\\n        }\\n        int buy = -1e9, sell = -1e9;\\n        if(canBuy) {\\n            buy = -prices[idx] + maxProfitHelper(idx + 1, !canBuy, fee, prices, dp);\\n        } else {\\n            sell = prices[idx] - fee + maxProfitHelper(idx + 1, !canBuy, fee, prices, dp);\\n        }\\n        int move_on = maxProfitHelper(idx + 1, canBuy, fee, prices, dp);\\n        return dp[idx][canBuy] = max({buy, sell, move_on});\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2, -1e9));\\n        return maxProfitHelper(0, true, fee, prices, dp);\\n    }\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2));\\n\\n        //Base case\\n        dp[n][0] = 0; dp[n][1] = 0;\\n\\n        //You can also skip typing the above base case by directly assigning every element of dp as 0 like below\\n        //vector<vector<int>> dp(n + 1, vector<int>(2, 0));\\n\\n\\n        //Explore all paths (bottom-up)\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            for(int canBuy = 1; canBuy >= 0; canBuy--) {\\n                //Observe that this block is same as memoization\\n                int buy = -1e9, sell = -1e9;\\n                if(canBuy) {\\n                    buy = -prices[idx] + dp[idx + 1][!canBuy];\\n                } else {\\n                    sell = prices[idx] - fee + dp[idx + 1][!canBuy];\\n                }\\n                int move_on = dp[idx + 1][canBuy];\\n                dp[idx][canBuy] = max({buy, sell, move_on});                \\n            }\\n        }\\n\\n        //idx = 0 and canBuy = true is the initial state\\n        return dp[0][1];\\n    }\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n\\n        //We assign 0 to all values to account for the base case without typing them out manually\\n        vector<int> curr(2, 0), next(2, 0);\\n\\n\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            for(int canBuy = 1; canBuy >= 0; canBuy--) {\\n                //This block is similar to the tabulation one\\n                int buy = -1e9, sell = -1e9;\\n                if(canBuy) {\\n                    buy = -prices[idx] + next[!canBuy];\\n                } else {\\n                    sell = prices[idx] - fee + next[!canBuy];\\n                }\\n                int move_on = next[canBuy];\\n                curr[canBuy] = max({buy, sell, move_on});                \\n            }\\n            next = curr;\\n        }\\n\\n        //Since at the end next will get assigned to curr\\n        return next[1];\\n    }\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<int> curr(2, 0), next(2, 0);\\n\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            //For canBuy = true\\n            curr[1] = max(-prices[idx] + next[0], next[1]);\\n            //For canBuy = false\\n            curr[0] = max(prices[idx] - fee + next[1], next[0]);\\n            next = curr;\\n        }\\n\\n        return next[1];\\n    }\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int c0, c1; //curr\\n        int n0, n1; //next\\n\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            //For canBuy = true\\n            c1 = max(-prices[idx] + n0, n1);\\n            //For canBuy = false\\n            c0 = max(prices[idx] - fee + n1, n0);\\n            //next = curr\\n            n0 = c0; n1 = c1\\n        }\\n\\n        //next[1]\\n        return n1;\\n    }\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int n0 = 0, n1 = 0;\\n        for(int idx = n - 1; idx >= 0; idx--) {\\n            n1 = max(-prices[idx] + n0, n1);\\n            n0 = max(prices[idx] - fee + n1, n0); \\n        }\\n        return n1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152220,
                "title": "basic-idea-no-code-no-optimization",
                "content": "Imagine you have bank account with 0$ to begin with. If you buy stock with price `x`, your account balance is `-x`. Later if you sell at price `y`, your account balance is `-x+y`. Accounting this way, the account balance at the end of last day is the total profit realized.\\n\\nOn any given day, there are four theoretical possibilities:\\n* Buy\\n* No action (you own the stock)\\n* Sell\\n* Rest (you do not own the stock)\\n\\nLet `B[j]` be the *best possible account balance* at the end of day `j`, in the event that `j`th day is a *buy* day.\\nLet `N[j]` be the *best possible account balance* at the end of day `j`, in the event that `j`th day is a *no-action* day.\\nLet `S[j]` be the *best possible account balance* at the end of day `j`, in the event that `j`th day is a *sell* day.\\nLet `R[j]` be the *best possible account balance* at the end of day `j`, in the event that `j`th day is a *rest* day.\\n\\nOn the very first day (`j=0`), we have `B[0] = -prices[0]-fee`, `S[0] = -infinity`, `R[0] = 0`, `N[0] =  -infinity`. The infinity values are so chosen because sell and no-action cannot occur before buy.\\n\\nThe following recursion is natural:\\n```\\nB[j] = max(R[j-1], S[j-1]) - prices[j] - fee\\nS[j] = max(B[j-1], N[j-1]) + prices[j] \\nR[j] = max(R[j-1], S[j-1])\\nN[j] = max(N[j-1], B[j-1])\\n```\\nThe above reflect the facts that \\n* buy can happen only after rest or after sell\\n* sell can happen only after buy or after no-action\\n* rest can happen only after another rest or after sell\\n* no-action can happen only after another no-action or after buy\\n\\n `Max(B[n-1], S[n-1], R[n-1], N[n-1])` is the best profit.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nB[j] = max(R[j-1], S[j-1]) - prices[j] - fee\\nS[j] = max(B[j-1], N[j-1]) + prices[j] \\nR[j] = max(R[j-1], S[j-1])\\nN[j] = max(N[j-1], B[j-1])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439821,
                "title": "python-from-top-down-dp-to-bottom-up-dp-o-1-space-easy-to-understand",
                "content": "**Solution 1: Top down DP**\\n- Let `dp(i, canBuy)` is the maximum profit we can get from `prices[i..n-1]` with the `canBuy == True` flag means we can buy on `ith` day. \\n- For the `i`th day we have 2 options:\\n\\t- Skip it: profit = dp(i+1)\\n\\t- Buy it or Sale it\\n\\t\\t- If buy: profit = dp(i+1) - prices[i] \\n\\t\\t- If sale: profit = dp(i+1) + prices[i] - fee\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        \\n        @lru_cache(None)\\n        def dp(i, needBuy):\\n            if i == n:\\n                return 0\\n            \\n            ans = dp(i+1, needBuy)  # Skip\\n            if needBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])\\n            else:\\n                ans = max(ans, dp(i+1, True) + prices[i] - fee)\\n            return ans\\n                \\n        return dp(0, True)\\n```\\n**Complexity**\\n- Time: `O(N * 2 * 2)`, where `N  <= 5*10^4` is length of `prices` array.\\n- Space: `O(N * 2)`\\n\\n---\\n**Solution 2: Bottom up DP**\\n- Just convert from Top down DP to Bottom up DP.\\n- Let `dp[i][j]` is the maximum profit we can get from `prices[i..n-1]` with the `j == 1` flag means we can buy on `ith` day. \\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[0] * 2 for _ in range(n+1)]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][0] - prices[i])\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][1] + prices[i] - fee)\\n                \\n        return dp[0][1]\\n```\\n**Complexity**\\n- Time: `O(N * 2 * 2)`, where `N  <= 5*10^4` is length of `prices` array.\\n- Space: `O(N * 2)`\\n\\n---\\n**Solution 3: Bottom down DP (Space Optimized)**\\n- Since our dp only access 2 states: current dp state `dp`, previous dp state `dpPrev`.\\n- We can optimize to `O(1)` in Space Complexity.\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp, dpPrev = [0, 0], [0, 0]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[j] = max(dpPrev[j], dpPrev[0] - prices[i])\\n                else:\\n                    dp[j] = max(dpPrev[j], dpPrev[1] + prices[i] - fee)\\n            dpPrev = dp\\n                \\n        return dpPrev[1]\\n```\\n**Complexity**\\n- Time: `O(N * 2 * 2)`, where `N  <= 5*10^4` is length of `prices` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        \\n        @lru_cache(None)\\n        def dp(i, needBuy):\\n            if i == n:\\n                return 0\\n            \\n            ans = dp(i+1, needBuy)  # Skip\\n            if needBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])\\n            else:\\n                ans = max(ans, dp(i+1, True) + prices[i] - fee)\\n            return ans\\n                \\n        return dp(0, True)\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[0] * 2 for _ in range(n+1)]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][0] - prices[i])\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][1] + prices[i] - fee)\\n                \\n        return dp[0][1]\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp, dpPrev = [0, 0], [0, 0]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[j] = max(dpPrev[j], dpPrev[0] - prices[i])\\n                else:\\n                    dp[j] = max(dpPrev[j], dpPrev[1] + prices[i] - fee)\\n            dpPrev = dp\\n                \\n        return dpPrev[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112088,
                "title": "js-python-java-c-very-simple-state-machine-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis proplem is an introduction to **state machine** logic. In order to solve it, we can consider the two possible distinct states of being: having no stock and being ready to buy (**buying**) and owning stock and being ready to sell (**selling**).\\n\\nWe just need to iterate through the prices (**P**) and keep track of the best possible value for these two states of being for each day. The difficulty is that the tracks of the two states cross over regulary.\\n\\nFor example, if we consider the state of being ready to buy stock after this iteration (**buying**), it can be reached from being ready to buy today and doing nothing, ***OR*** it can be reached by being ready to sell today and selling (with the additional fee [**F**]). We just need to pick whichever one yields the best value.\\n\\nThe same is true of the **selling** state. The new **selling** state is the better result between the previous **selling** state with no action and the previous **buying** state with a stock purchase today.\\n\\n![State Machine Visual](https://i.imgur.com/9hpSjmS.png)\\n\\nWe should manually set our initial values for **buying** and **selling** to account for the first day and iterate from there.\\n\\nSince the fee is only administered once per buy/sell pair, we can technically account for it on either side, as we\\'re always going to want to return the **buying** state, having no outstanding stock left to sell.\\n\\n***Question: Should we be worried about updating buying before using it in the second equation?***\\nMathematically, it\\'s only ever a good day to buy ***or*** sell; it cannot be both.\\n\\nConsider the possible situations: In the first equation, if the old **buying** is greater than **selling + P[i] - F**, then the new **buying** will be the same as the old **buying**, so there will be no change for the second equation.\\n\\nBut what if **buying** changes? Let\\'s take an example:\\n```\\n  if:  buying = 10, P[i] = 4, F = 0\\nthen:  newBuying = max(10, selling + 4 - 0)\\n       newSelling = max(selling, newBuying - 4)\\n\\n  if:  selling <= 6                               // For values of selling less than 7\\nthen:  newBuying = max(10, <=10)                  // the old buying will still be largest\\n       newBuying = buying                         // so there\\'s no problem\\n\\n  if:  selling > 6                                // If selling is greater than 6\\nthen:  newBuying = max(10, >6 + 4)                // then buying will change\\n       newBuying = selling + 4                    // so we might have a problem\\n\\n  if:  newBuying = selling + 4                    // But here we see that selling cannot\\nthen:  newSelling = max(selling, selling + 4 - 4) // possibly change when buying does\\n```\\nAny positive value for **F** would only lower the value of **newBuying**, which would only make it so that **newBuying - P[i]** couldn\\'t even tie **selling** but would always be lower.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe code for all four languages is almost identical.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 47.3MB** (beats 98% / 79%).\\n```javascript\\nvar maxProfit = function(P, F) {\\n    let len = P.length, buying = 0, selling = -P[0]\\n    for (let i = 1; i < len; i++) {\\n        buying = Math.max(buying, selling + P[i] - F)\\n        selling = Math.max(selling, buying - P[i])\\n    }\\n    return buying\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **672ms / 21.3MB** (beats 89% / 82%).\\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int], F: int) -> int:\\n        buying, selling = 0, -P[0]\\n        for i in range(1, len(P)):\\n            buying = max(buying, selling + P[i] - F)\\n            selling = max(selling, buying - P[i])\\n        return buying\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 47.8MB** (beats 94% / 99%).\\n```java\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **88ms / 54.9MB** (beats 92% / 98%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P, int F) {\\n        int len = P.size(), buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = max(buying, selling + P[i] - F);\\n            selling = max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n  if:  buying = 10, P[i] = 4, F = 0\\nthen:  newBuying = max(10, selling + 4 - 0)\\n       newSelling = max(selling, newBuying - 4)\\n\\n  if:  selling <= 6                               // For values of selling less than 7\\nthen:  newBuying = max(10, <=10)                  // the old buying will still be largest\\n       newBuying = buying                         // so there\\'s no problem\\n\\n  if:  selling > 6                                // If selling is greater than 6\\nthen:  newBuying = max(10, >6 + 4)                // then buying will change\\n       newBuying = selling + 4                    // so we might have a problem\\n\\n  if:  newBuying = selling + 4                    // But here we see that selling cannot\\nthen:  newSelling = max(selling, selling + 4 - 4) // possibly change when buying does\\n```\n```javascript\\nvar maxProfit = function(P, F) {\\n    let len = P.length, buying = 0, selling = -P[0]\\n    for (let i = 1; i < len; i++) {\\n        buying = Math.max(buying, selling + P[i] - F)\\n        selling = Math.max(selling, buying - P[i])\\n    }\\n    return buying\\n};\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int], F: int) -> int:\\n        buying, selling = 0, -P[0]\\n        for i in range(1, len(P)):\\n            buying = max(buying, selling + P[i] - F)\\n            selling = max(selling, buying - P[i])\\n        return buying\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P, int F) {\\n        int len = P.size(), buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = max(buying, selling + P[i] - F);\\n            selling = max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108868,
                "title": "java-simple-dp-solutions-o-n",
                "content": "This problem is just like the other stock problems.\\nAt given day, we can do 1 out of 4 things: \\n\\n1. buy stock\\n2. hold stock\\n3. do nothing with empty portfolio\\n4. sell stock\\n\\nWe have 4 arrays with the length of # of the days, recording the max profit at given day if we do given operation. \\n\\nHere is the code: \\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if(prices.length <= 1) return 0;\\n        int[] buy = new int[prices.length];\\n        int[] hold = new int[prices.length];\\n        int[] skip = new int[prices.length];\\n        int[] sell = new int[prices.length];\\n        // the moment we buy a stock, our balance should decrease\\n        buy[0] = 0 - prices[0]; \\n        // assume if we have stock in the first day, we are still in deficit\\n        hold[0] = 0 - prices[0];\\n        for(int i = 1; i < prices.length; i++){\\n            // We can only buy on today if we sold stock\\n            // or skipped with empty portfolio yesterday\\n            buy[i] = Math.max(skip[i-1], sell[i-1]) - prices[i]; \\n            // Can only hold if we bought or already holding stock yesterday\\n            hold[i] = Math.max(buy[i-1], hold[i-1]);\\n            // Can skip only if we skipped, or sold stock yesterday\\n            skip[i] = Math.max(skip[i-1], sell[i-1]);\\n            // Can sell only if we bought, or held stock yesterday\\n            sell[i] = Math.max(buy[i-1], hold[i-1]) + prices[i] - fee;\\n        }\\n        // Get the max of all the 4 actions on the last day.\\n        int max = Math.max(buy[prices.length - 1], hold[prices.length - 1]);\\n        max = Math.max(skip[prices.length - 1], max);\\n        max = Math.max(sell[prices.length - 1], max);\\n        return Math.max(max, 0);\\n    }\\n}\\n```\\n\\nNow, you guys believe I have a higher IQ than Rex right?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if(prices.length <= 1) return 0;\\n        int[] buy = new int[prices.length];\\n        int[] hold = new int[prices.length];\\n        int[] skip = new int[prices.length];\\n        int[] sell = new int[prices.length];\\n        // the moment we buy a stock, our balance should decrease\\n        buy[0] = 0 - prices[0]; \\n        // assume if we have stock in the first day, we are still in deficit\\n        hold[0] = 0 - prices[0];\\n        for(int i = 1; i < prices.length; i++){\\n            // We can only buy on today if we sold stock\\n            // or skipped with empty portfolio yesterday\\n            buy[i] = Math.max(skip[i-1], sell[i-1]) - prices[i]; \\n            // Can only hold if we bought or already holding stock yesterday\\n            hold[i] = Math.max(buy[i-1], hold[i-1]);\\n            // Can skip only if we skipped, or sold stock yesterday\\n            skip[i] = Math.max(skip[i-1], sell[i-1]);\\n            // Can sell only if we bought, or held stock yesterday\\n            sell[i] = Math.max(buy[i-1], hold[i-1]) + prices[i] - fee;\\n        }\\n        // Get the max of all the 4 actions on the last day.\\n        int max = Math.max(buy[prices.length - 1], hold[prices.length - 1]);\\n        max = Math.max(skip[prices.length - 1], max);\\n        max = Math.max(sell[prices.length - 1], max);\\n        return Math.max(max, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600084,
                "title": "dp-state-machine-top-down-to-bottom-up-with-space-optimization-approaches",
                "content": "**UPDATE 3/2023:** This is kind of level-up from top-down -> top-down+memo -> bottom-up. Now doing bottom-up solution from the start (the way it\\'s described in [DP explore card](https://leetcode.com/explore/learn/card/dynamic-programming/): according to the LC\\'s DP framework: state, rec.relation, base cases. DP shines differently now and I have more fun with the approach.\\n\\ndp[i] - max profit you can achieve by the end of i-th day.\\nRR:\\n```\\nhave_stock = max(had_stock, didnt_have_stock - price)\\ndont_have_stock = max(didnt_have_stock, had_stock + price - fee)\\n```\\n\\nBase cases:\\n```\\nhad_stock = -prices[0]\\ndidnt_have_stock = 0\\n```\\nI pay fee when I sell stock (end of transaction)\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        \\n        had_stock = -prices[0]\\n        didnt_have_stock = 0\\n        \\n        for price in prices:\\n\\t\\t\\t# have stock today because I had the stock yesteday or didn\\'t have it yesterday and bought it today\\n            have_stock = max(had_stock, didnt_have_stock - price)\\n\\t\\t\\t# don\\'t have stock today because I didn\\'t have it yesteday or had it yesterday and sold today + paid fee\\n            dont_have_stock = max(didnt_have_stock, had_stock + price - fee)\\n            had_stock = have_stock # next day -> today\\'s state becomes yesterday\\'s state\\n            didnt_have_stock = dont_have_stock # next day -> today\\'s state becomes yesterday\\'s state\\n        return dont_have_stock # return state when you sold your stock\\n```\\n\\n---\\n\\n**UPDATE:** if you think you are good with the approach, here is the next problem to practice [198. House Robber](https://leetcode.com/problems/house-robber/)\\nIf you lost somewhere, there is a similar [post](https://leetcode.com/problems/house-robber/discuss/1615418/Alternative-DP-solution-State-machine-DP-with-explanation-(bottom-up-easy)) for the problem.\\n\\n**Update 7/2022:** There is some java and some python. Now you have an opportunity to lean Python too.\\n\\n*TOC:*\\n*1) Solution for the first 4 problems + BONUS*\\n*2) Top-Down to bottom-up with space optimization (Python) (educational purposes)*\\n*3) Top-down to bottom-up O(1) step-by-step guide with example (Java) (educational purposes)*\\n*4) Solutions for the rest of \"best time to buy and sell stock\" problems (Java)*\\n\\n---\\n**1) Solution for the first 4 problems:**\\nI am going to explain the approach on the problems **II-IV** [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/) because the problems **II** and **III** are simplified version of the problem **IV**. The one with **fee** is the same as **II**, except you just \"- fee\" everytime you **end** a transaction (i.e. sell your stock or you can tweak it take fee when you buy a stock).\\n\\n**Bonus:** Stocks with cool down period (or state)\\n\\n**Problem statement:**\\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day\\nFind the maximum profit you can achieve.\\n**Note**: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\n\\n**II**: You may complete at most **unlimited** transaction.\\n**III**: You may complete at most **2** transactions.\\n**IV**: You may complete at most **k** transactions.\\n\\n**1) State Machine Dynamic Programming** (good for interviews)\\n\\n**Btw, if you draw a similar state diagram for other \\'buy and sell stock\\' problems, you will solve them in snap-snap-done way.**\\n\\nThere are 2 states:\\n1. We have a stock - \\'IHaveStock\\' state.\\n2. We have no stock - \\'IHaveNoStock\\' state.\\n\\nTransition between the states:\\n* IHaveNoStock -> IHaveStock: bought a stock on the day\\n* IHaveNoStock -> IHaveNoStock: skip the day\\n--\\n* IHaveStock -> IHaveNoStock: sold existing stock on the day\\n* IHaveStock -> IHaveStock: skip the day\\n\\n---\\n\\n**Problem #2** 101 for the problems series\\n\\nLet\\'s start from a dry run on a simple case with **unlimited** number of transactions at a time (problem #2). Btw, a **transaction** is when you **BUY and SELL** (at least for the problem): Depicted with **yellow** BUY--...--SELL. **Green** steps are the way to the max profit.\\n\\nLet\\'s imagine that we have data only for 3 days.\\n**Input**: prices = [10,250,50]\\n**Output**: 240\\n\\n![image](https://assets.leetcode.com/users/images/27bffdd4-b528-43de-8fbf-d5c736446ca2_1657529733.63451.png)\\n\\nAs you can see the best for 3 days is 240: we buy on **day 1** (balance: -$10) and sell on **day 2**. We **skip day 3** (balance: +$240) \\n\\nAt the end of day 1 we have the states defined:\\n1. We bought a stock\\n```\\n// Day 0: \\'Buy stock day\\'. We had balance = 0. Today we bought the stock with prices[0]. Now we have -prices[0] balance\\nIHaveStock[0] = -prices[0];\\n```\\n2. We skipped the day:\\n```\\n// Day 0: We skipped the day. Thus balance was 0 and is 0\\nIHaveNoStock[0] = 0;\\n```\\n\\nProblem #2 transtion of states in code between days - **1 transaction**: get max of 2 actions we can do - buy/skip or sell/skip\\n```\\nIHaveStock[today] = Math.max(IHaveStock[yesterday], IHaveNoStock[yesterday] - prices[today]); // max of skip day or buy (-profit)\\nIHaveNoStock[today] = Math.max(IHaveNoStock[yesterday], IHaveStock[yesterday] + prices[today]); // max of skip day or sell(+profit)\\n```\\n\\nThe result of our business activity is stored in IHaveNoStock[lastDay]\\n\\n---\\n\\n**Problem #3**: 2 transactions\\n\\nLet\\'s start from a dry run again on a simple case with 2 transactions (problem #3). Depicted with **yellow** BUY--...--SELL. **Green** steps are the way to the max profit with the final **orange** step.\\n\\nLet\\'s imagine that we have now data for 4 days.\\n**Input**: prices = [10,250,50,500]\\n**Output**: 690\\n\\n![image](https://assets.leetcode.com/users/images/a81d580d-c4b8-44dd-9ce7-02412666454b_1657525517.6953585.png)\\n\\nAs you can see the best for 4 days profit is 690:\\n**Transaction #1:**\\nwe **buy** on **day 1** (balance: -$10) and **sell** on **day 2** (balance: +$240).\\n**Transaction #2:**\\nwe **buy** on **day 3** (balance: +$190) and **sell** on **day 4** (balance: +$690)\\n\\nAt the end of day 1 we have the states defined:\\n1. We bought a stock\\n```\\n// Day 0: \\'Buy stock day\\'. We had balance = 0. Today we bought the stock with prices[0]. Now we have -prices[0] balance\\nIHaveStock[0][1] = -prices[0]; // base case for transaction #1\\nIHaveStock[0][2] = -prices[0]; // base case for transaction #2\\n```\\n\\n*What\\'s interesting here is that for transaction #2 we set the base case to -prices[0] too. Without having transaction #1??? How come???\\nWe can buy and sell at the same day. So IHaveStock[0][1] means buy-and-sell. Thus we can start instantly from transaction #2 bypassing #1.*\\n\\n2. We skipped the day:\\n```\\n// Day 0: We skipped the day. Thus balance was 0 and is 0\\nIHaveNoStock[0][1] = 0; // base case for transaction #1\\nIHaveNoStock[0][2] = 0; // base case for transaction #2\\n```\\n\\nProblem #3 transtion of states in code between days - **2 transaction**: get max of 2 actions we can do - buy/skip or sell/skip\\n```\\n// transaction 1 start: max(I started transaction 1 yesterday (bought), or I start it today - buy: transaction 0 = no transaction(balance=0) - prices[today])\\nIHaveStock[today][1] = Math.max(IHaveStock[yesterday][1], IHaveNoStock[yesterday][0] - prices[today]);\\n// transaction 1 start: max(I had no stock yesterday or I had stock yesterday and sold it today)\\nIHaveNoStock[today][1] = Math.max(IHaveNoStock[yesterday][1], IHaveStock[yesterday][1] + prices[today]); # for transaction1\\n\\n// !!!\\n// ****** this is how transaction #1 end is connected to transaction #2 start ******\\n// IHaveStock[today][2] ... IHaveNoStock[yesterday][1]...\\n// !!!\\n\\n// transaction 2 start: max(I started transaction 2 yesterday (bought), or I start it today - buy: transaction 1 - prices[today])\\nIHaveStock[today][2] = Math.max(IHaveStock[yesterday][2], IHaveNoStock[yesterday][1] - prices[today]); # for transaction 2\\n// transaction 2 start: max(I had no stock yesterday or I had stock yesterday and sold it today)\\nIHaveNoStock[today][2] = Math.max(IHaveNoStock[yesterday][2], IHaveStock[yesterday][2] + prices[today]); # for transaction 2\\n```\\nThe result is stored in: IHaveNoStock[lastDay][2]\\n\\n---\\n\\n**Problem #4**: k-transactions\\nNow you can imagine that for 3 transactions you will need:\\n```\\nIHaveStock[today][2] = Math.max(IHaveStock[yesterday][2], IHaveNoStock[yesterday][1] - prices[today]); # for transaction 2\\n...\\nIHaveStock[today][3] = Math.max(IHaveStock[yesterday][3], IHaveNoStock[yesterday][2] - prices[today]); # for transaction 3\\n```\\n\\n---\\n\\n**Full source code for problem #2:**\\n```\\nvar n = prices.length;\\n\\n// max profit for a day if we have no stock (did not have yesterday or sold today)\\nvar noStock = new int[n];\\n// max profit for a day if we have a stock (had stock yesterday or bought today)\\nvar haveStock = new int[n];\\n\\n// Day 0: \\'Couch potato day\\'. No transaction made. We did not buy or sell. Thus profit = 0\\nnoStock[0] = 0;\\n// Day 0: \\'Buying stock day\\'. We had profit = 0. Bought stock with prices[0]. Now we have negative prices[0] profit\\nhaveStock[0] = -prices[0]; // !!! if you want to pay the fee when you buy - do not forget do \"- fee\" here\\n\\nfor (int day = 1; day < n; day++) {\\n\\t// max profit: 1) we do nothing today or 2) we sell stock and pay fee\\n    noStock[day] = Math.max(noStock[day - 1], haveStock[day - 1] + prices[day] - fee); // -fee is for the problem with fee :)\\n\\t// max profit: 1) we do nothing today or 2) we buy stock\\n    haveStock[day] = Math.max(haveStock[day - 1], noStock[day - 1] - prices[day]);\\n}\\n\\n// A transaction is over when we have no stock anymore. We return noStock[lastDay]. \\nreturn noStock[n - 1];\\n```\\n\\n**Space optimization 2d/1d -> O(1) :** there is no need to keep noStock and haveStock arrays as we see that today\\'s state depends only on yesterday\\'s state.\\n\\n```\\nvar n = prices.length;\\n\\nvar noStockYesterday = 0;\\nvar noStockToday = 0;\\nvar hadStockYesterday = -prices[0];\\nvar haveStockToday = 0;\\n\\nfor (int day = 1; day < n; day++) {\\n\\t// max profit: 1) we do nothing today or 2) we sell stock and pay fee\\n    noStockToday = Math.max(noStockYesterday, hadStockYesterday + prices[day] - fee);\\n\\t// max profit: 1) we do nothing today or 2) we buy stock\\n    haveStockToday = Math.max(hadStockYesterday, noStockYesterday - prices[day]);\\n    noStockYesterday = noStockToday;\\n    hadStockYesterday = haveStockToday;\\n}\\n\\nreturn noStockToday;\\n```\\n\\n**BONUS: Stocks with cooldown period after you sell**\\n\\nThe only difference between this one and problem #2 is that we cannot buy stock the next day after we sell. \\n\\n**Top-down**\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def dfs(day, no_stock):\\n            if day < 0:\\n                return 0\\n            \\n            if day == 0:\\n                if no_stock:\\n\\t\\t\\t\\t\\t# buy\\n                    return -prices[day]\\n                return 0\\n\\n            if (day, no_stock) in memo:\\n                return memo[day, no_stock]\\n\\n            have = float(-inf)\\n            do_not_have = float(-inf)\\n            if no_stock:\\n                # skip the day or buy new stock today\\n                have = max(dfs(day - 1, no_stock), dfs(day - 2, False) - prices[day])\\n            else:\\n                # skip the day or sell what you bought 2 days ago\\n                do_not_have = max(dfs(day - 1, no_stock), dfs(day - 1, True) + prices[day])\\n\\n            memo[day, no_stock] = max(do_not_have, have)\\n            return memo[day, no_stock]\\n\\n        N = len(prices)\\n        memo = defaultdict(int)\\n        return dfs(N - 1, False)\\n```\\n\\n**DP 1D:** Can you optimize it to O(1) space? If not yet, there\\'s a fully dedicated section to the optimization approach later\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        N = len(prices)\\n        IHaveNoStock = defaultdict(int)\\n        IHaveStock = defaultdict(int)\\n        \\n        IHaveNoStock[0] = 0 # skipped the day\\n        IHaveStock[0] = -prices[0] # bought on day 0\\n        \\n        for day in range(1, N):\\n            hadTwoDaysAgo = hadYesterday = IHaveStock[day - 1]\\n            if day > 1:\\n                # what you had yesterday or what you sold 2 days ago + buy new stock today\\n                hadTwoDaysAgo = max(hadYesterday, IHaveNoStock[day - 2] - prices[day])\\n            IHaveStock[day] = max(hadYesterday, hadTwoDaysAgo)\\n            # what you sold/had yesterday or sell what you bought/had 2 days ago\\n            IHaveNoStock[day] = max(IHaveNoStock[day - 1], hadTwoDaysAgo + prices[day])\\n        \\n        return IHaveNoStock[N - 1]\\n```\\n\\n**That\\'s it!**\\n\\n**[blink] !!! Upvote if you got better at DP !!! [/blink]**\\n\\n---\\n\\n**2) Top-Down to Bottom-Up with space optimization (Python)** (educational purposes)\\n99.99% (can I say 100%?) you will reuse the same approach/steps for all DP problems.\\n\\nThis is a \"classic\" way to approach DP problems - exponential top-down to bottom-up DP O(1).\\n\\n---\\n**Update 7/2022**: after 8 months of leetcoding and getting more experienced with DP (Aha, try dp on trees, bro :D)\\n\\nI consider now going from top (the main problem) to bottom (subproblems) is the logical way of solving such problems. Let me explain why:\\n\\n1. What\\'s the final goal we\\'re looking for in the problem aka the final/main problem, aka TOP-level problem? Find max profit for the **last day** if we do in previous days buy, sell, skip.\\n2. Subproblems, and this is where DP shines, are decisions we make in day -1, day - 2, day - ... day 0. The decision we made during previous days affect the future days outcomes (optimal substructure).\\n3. We repeat calculations (waste of resource, cache it with memoization!) for the days if you decided to skip a day\\n4. If you define **recurrence relation** and **base cases** correctly (that\\'s a bold statement), writing bottom-up, 2d->1d(if possible)->0d (if possible) turns to be a boring monotonous process:\\n\\t4.1. You copy and paste exactly the same **recurrence relation** code\\n\\t4.2. Reverse params direction in your method\\n\\t4.3. Copy and paste **base cases** and you\\'re done!\\n\\nLet\\'s see an updated top-down and bottom-up source code (now in python, sorry, Java folks, no time to type so much ;):\\n\\n**Top-down: TLE without memo, with memo - accepted**\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def dfs(day, no_stock):\\n            if day == 0: # base cases\\n                if no_stock:\\n                    memo[day, no_stock] = -prices[day] - fee # buy and pay the fee\\n                else:\\n                    memo[day, no_stock] = 0 # no stock, nothing to sell, skip the day\\n                return memo[day, no_stock]\\n            \\n            if (day, no_stock) in memo: # memo\\n                return memo[day, no_stock]\\n\\n            have = float(-inf)\\n            do_not_have = float(-inf)\\n            if no_stock:\\n                # max of skip the day or buy and pay the fee\\n                have = max(dfs(day - 1, no_stock), dfs(day - 1, False) - prices[day] - fee)\\n            else:\\n                # max of skip the day or sell\\n                do_not_have = max(dfs(day - 1, no_stock), dfs(day - 1, True) + prices[day])\\n\\n            memo[day, no_stock] = max(do_not_have, have)\\n            return memo[day, no_stock]\\n\\n        N = len(prices)\\n        memo = defaultdict(int)\\n        return dfs(N - 1, False)\\n```\\n\\n**Bottom-up DP 2D: accepted**\\nNow look what we do here with \"copy and paste\":\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        dp = defaultdict(int)\\n\\n        # base cases\\n        # have stock\\n        dp[0, True] = -prices[0] - fee # bought and paid the fee on day 0\\n        # have no stock\\n        dp[0, False] = 0 # no stock, skipped the day 0\\n\\n        # reverse params direction: in top-down it was N-1...0\\n        # now do 1... N-1, why start from 1 and not from 0? Because 0 is used by the base case!\\n        for day in range(1, N):\\n            for no_stock in [False, True]:\\n                # copy + paste: start\\n                have = float(-inf)\\n                do_not_have = float(-inf)\\n                if no_stock:\\n                    # max of skip the day or buy and pay the fee\\n                    have = max(dp[day - 1, no_stock], dp[day - 1, False] - prices[day] - fee)\\n                else:\\n                    # max of skip the day or sell\\n                    do_not_have = max(dp[day - 1, no_stock], dp[day - 1, True] + prices[day])\\n                dp[day, no_stock] = max(do_not_have, have)\\n                # copy + paste: end\\n\\n        return dp[N - 1, False]\\n```\\n\\n**Bottom-up DP 1D: accepted**\\nHere I just split 2D dp array into 2x1D:\\nTechnically it\\'s the same as written above, just removed extra variables, removed the inner have_stock loop, removed if-else and other variables.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n\\t\\tN = len(prices)\\n\\t\\thaveStock = defaultdict(int)\\n\\t\\thaveNoStock = defaultdict(int)\\n        \\n\\t\\thaveStock[0] = -prices[0] - fee\\n\\t\\thaveNoStock[0] = 0\\n        \\n\\t\\tfor day in range(1, N):\\n\\t\\t\\thaveNoStock[day] = max(haveNoStock[day - 1], haveStock[day - 1] + prices[day])\\n\\t\\t\\thaveStock[day] = max(haveStock[day - 1], haveNoStock[day - 1] - prices[day] - fee)\\n        \\n\\t\\treturn haveNoStock[N - 1]\\n```\\n\\n**Bottom-up DP O(1): accepted**\\nReplace 2x1D with a few variables:\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        IHadStockYesterday = -prices[0] - fee\\n        IHadNoStockYesterday = 0\\n\\n        IHaveStockToday = IHaveNoStockToday = 0\\n        for day in range(1, N):\\n            IHaveNoStockToday = max(IHadNoStockYesterday, IHadStockYesterday + prices[day])\\n            IHaveStockToday = max(IHadStockYesterday, IHadNoStockYesterday - prices[day] - fee)\\n            \\n            IHadStockYesterday, IHadNoStockYesterday = IHaveStockToday, IHaveNoStockToday\\n\\n        return IHaveNoStockToday\\n```\\n\\n---\\n\\n**3) Top-down to bottom-up O(1) step-by-step guide with example (Java)**\\n\\nComment from @eefiasfira\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/387072\\n\\nThis is Dynamic Programming at its finest. To get such insights:\\n\\n* **First try using a recursive Top Down approach to get max profit**\\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    var n = prices.length;\\n        \\n    // rec + memo (top-down)\\n\\treturn maxProfit(prices, fee, 0, 0, new Integer[n][2]);\\n}\\n    \\nprivate int maxProfit(int[] nums, int fee, int day, Integer haveStock, Integer[][] memo) {\\n\\tif (day == nums.length) {\\n\\t\\treturn 0;\\n    }\\n        \\n\\tif (memo[day][haveStock] != null) {\\n\\t\\treturn memo[day][haveStock];\\n    }\\n\\n    var keepStockProfit = maxProfit(nums, fee, day + 1, haveStock, memo);\\n        \\n    var operationProfit = 0;\\n\\tif (haveStock == 1) {\\n        // sell\\n\\t\\toperationProfit = nums[day] + maxProfit(nums, fee, day + 1, 0, memo) - fee;\\n    }\\n\\telse {\\n\\t\\t// buy\\n\\t\\toperationProfit = maxProfit(nums, fee, day + 1, 1, memo) - nums[day];\\n\\t}\\n        \\n\\treturn memo[day][haveStock] = Math.max(keepStockProfit, operationProfit);\\n}\\n```\\n\\n* **Then try drawing the recursion tree on paper to figure out sub-problems that can be cached in a table.**\\nThis is an ordinary \"brute force\" decision tree.\\nIgnore K, that\\'s for problem IV.\\n![image](https://assets.leetcode.com/users/images/76407c80-c930-4f5b-ac08-88ce56d2c1c0_1638083133.0273001.png)\\n*Image taken from https://www.codingninjas.com/*\\n\\n* **Then look at the key/values that the recursion is setting in the table (cache) and under what conditions**\\nLook at *memo[day][haveStock]*\\n\\n* **Next develop a bottoms-up DP solution that builds the table mentioned above directly by watching the recursion tree for which values got calculated first, which got done next**\\n\\n**Update 7/2022:** Pay attention to \"day + 1\" (in top-down) change to \"day - 1\" (bottom-up)\\n\\n```\\n// dp 2d bottom-up\\n\\nvar dp = new int[n][2];\\nvar maxProfit = 0;\\n        \\ndp[0][0] = -prices[0]; // this gets calculated first - day0, bought stock, thus negative balance\\nfor (int day = 1; day < n; day++) {\\n\\tfor (int haveStock = 0; haveStock < 2; haveStock++) {\\n\\t\\tvar keepStockProfit = dp[day - 1][haveStock];\\n\\n        var operationProfit = 0;\\n        if (haveStock == 1) {\\n\\t\\t\\t// sell\\n\\t\\t\\toperationProfit = prices[day] + dp[day - 1][0] - fee;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// buy\\n\\t\\t\\toperationProfit = dp[day - 1][1] - prices[day];\\n\\t\\t}\\n\\n\\t\\tmaxProfit = dp[day][haveStock] = Math.max(keepStockProfit, operationProfit);\\n\\t}\\n}\\n\\nreturn maxProfit;\\n```\\nRemove haveStock param and haveStock\\'s loop\\n```\\nvar dp = new int[n][2];\\nvar maxProfit = 0;\\n        \\ndp[0][0] = -prices[0];\\nfor (int day = 1; day < n; day++) {\\n\\tvar keepStockProfit = dp[day - 1][0];\\n    var operationProfit = dp[day - 1][1] - prices[day];\\n            \\n    maxProfit = dp[day][0] = Math.max(keepStockProfit, operationProfit);\\n\\n    keepStockProfit = dp[day - 1][1];\\n\\toperationProfit = prices[day] + dp[day - 1][0] - fee;\\n            \\n\\tmaxProfit = dp[day][1] = Math.max(keepStockProfit, operationProfit);\\n}\\n\\nreturn maxProfit;\\n```\\n\\nCompacting source code\\n```\\nvar dp = new int[n][2];\\nvar maxProfit = 0;\\n        \\ndp[0][0] = -prices[0];\\nfor (int day = 1; day < n; day++) {\\n\\tdp[day][0] = Math.max(dp[day - 1][0], dp[day - 1][1] - prices[day]);\\n    maxProfit = dp[day][1] = Math.max(dp[day - 1][1], prices[day] + dp[day - 1][0] - fee);\\n}\\n\\nreturn maxProfit;\\n```\\n\\n**After doing this you\\'ll notice that you\\'re wasting space by using a table because to calculate the next state you only need 2 variables.\\nWhen you change the code to use 2 variables, you\\'ll land up with this solution.**\\n\\nWe do not need the dp table as we clearly see that today (day) depends on yesterday (day - 1)\\n\\n```\\n// dp[day][0] -> dayHaveStock profit\\n// dp[day][1] -> dayNoStock profit\\n\\nvar maxProfit = 0;\\n        \\nvar dayNoStock = 0;\\nvar dayHaveStock = -prices[0];\\nfor (int day = 1; day < n; day++) {\\n\\tdayHaveStock = Math.max(dayHaveStock, dayNoStock - prices[day]);\\n    maxProfit = dayNoStock = Math.max(dayNoStock, prices[day] + dayHaveStock - fee);\\n}\\n\\nreturn maxProfit;\\n```\\n\\nFor other problems in the \"buy and sell stock\" series you just add a few more states. For example: \\n```\\nmaxProfit(int[] nums, int fee, int isCooldown, int transactionsLeft, int isItCloudyToday, int maxBudgetCapReached)\\n```\\nand add here and there the \"business logic\".\\n\\n**[blink] !!! Upvote if you got better at DP !!! [/blink]**\\n;)\\n\\n---\\n\\n**4) Solutions for the rest of \"best time to buy and sell stock\" problems:**\\n\\nSame idea, except state machines have more states. \\n\\n* problem ii - same as above, but w/o \" - fee\"\\n* problem iii:\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        var n = prices.length;\\n        \\n        // dp 2d\\n//         var haveStock = new int[n][3];\\n//         var noStock = new int[n][3];\\n\\n//         // bought and sold on the 1st day\\n//         noStock[0][1] = 0;\\n//         // bought and sold on the 1st day\\n//         noStock[0][2] = 0;\\n        \\n//         // bought on the 1st day. T #1\\n//         haveStock[0][1] = -prices[0];\\n//         // bought, sold, bought on the 1st day. Thus T #2\\n//         haveStock[0][2] = -prices[0];\\n\\n//         for (int day = 1; day < n; day++) {\\n//             haveStock[day][1] = Math.max(haveStock[day - 1][1], noStock[day - 1][0] - prices[day]); \\n//             noStock[day][1] = Math.max(noStock[day - 1][1], haveStock[day - 1][1] + prices[day]);\\n//             haveStock[day][2] = Math.max(haveStock[day - 1][2], noStock[day - 1][1] - prices[day]);\\n//             noStock[day][2] = Math.max(noStock[day - 1][2], haveStock[day - 1][2] + prices[day]);\\n//         }\\n        \\n//         return noStock[n - 1][2];\\n\\n        // dp O(1)\\n        var noStockTodayT1 = 0;\\n        var noStockYesterdayT1 = 0;\\n        \\n        var noStockTodayT2 = 0;\\n        var noStockYesterdayT2 = 0;\\n        \\n        var haveStockTodayT1 = 0;\\n        var hadStockYesterdayT1 = -prices[0];\\n        \\n        var haveStockTodayT2 = 0;\\n        var hadStockYesterdayT2 = -prices[0];\\n\\n        for (int day = 1; day < n; day++) {\\n            haveStockTodayT1 = Math.max(hadStockYesterdayT1, -prices[day]); \\n            noStockTodayT1 = Math.max(noStockYesterdayT1, hadStockYesterdayT1 + prices[day]);\\n            haveStockTodayT2 = Math.max(hadStockYesterdayT2, noStockYesterdayT1 - prices[day]);\\n            noStockTodayT2 = Math.max(noStockYesterdayT2, hadStockYesterdayT2 + prices[day]);\\n            \\n            hadStockYesterdayT1 = haveStockTodayT1;\\n            hadStockYesterdayT2 = haveStockTodayT2;\\n            noStockYesterdayT1 = noStockTodayT1;\\n            noStockYesterdayT2 = noStockTodayT2;            \\n        }\\n        \\n        return noStockTodayT2;\\n\\n        // top-down + memo\\n        //return maxProfit(prices, 0, 0, k, new Integer[prices.length][2][k + 1]);\\n    }\\n    \\n    private int maxProfit(int[] nums, int day, int canSell, int transLeft, Integer[][][] memo) {\\n        if (day == nums.length || transLeft == 0) {\\n            return 0;\\n        }\\n        \\n        if (memo[day][canSell][transLeft] != null) {\\n            return memo[day][canSell][transLeft];\\n        }\\n        \\n        // do nothing - skip day\\n        var noActionsProfit = maxProfit(nums, day + 1, canSell, transLeft, memo);\\n        var actionProfit = 0;\\n        \\n        if (canSell == 1) {\\n            actionProfit = nums[day] + maxProfit(nums, day + 1, 0, transLeft - 1, memo);\\n        }\\n        else {\\n            actionProfit = maxProfit(nums, day + 1, 1, transLeft, memo) - nums[day];\\n        }\\n        \\n        return memo[day][canSell][transLeft] = Math.max(noActionsProfit, actionProfit);\\n    }\\n}\\n```\\n\\n* problem iv:\\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        // !!!\\n        // for more details look at problem #3\\n        // !!!\\n        var n = prices.length;\\n\\n        if (k == 0 || n == 0) {\\n            return 0;\\n        }\\n\\n//         // dp 2 x 2d\\n//         var haveStock = new int[n][k + 1];\\n//         var noStock = new int[n][k + 1];\\n\\n//         for (int i = 1; i <= k; i++) {\\n//             // bought, sold, bought on the 1st day. Thus T #i\\n//             haveStock[0][i] = -prices[0];\\n//         }\\n\\n//         for (int day = 1; day < n; day++) {\\n//             for (int i = 1; i <= k; i++) {\\n//                 haveStock[day][i] = Math.max(haveStock[day - 1][i], noStock[day - 1][i - 1] - prices[day]); \\n//                 noStock[day][i] = Math.max(noStock[day - 1][i], haveStock[day - 1][i] + prices[day]);\\n//             }\\n//         }\\n        \\n//         return noStock[n - 1][k];\\n        \\n        // dp 2 x 1d\\n        var yesterdayHadStock = new int[k + 1];\\n        var yesterdayNoStock = new int[k + 1];\\n\\n        for (int i = 1; i <= k; i++) {\\n            // bought, sold, bought on the 1st day. Thus T #i\\n            yesterdayHadStock[i] = -prices[0];\\n        }\\n\\n        var todayHaveStock = new int[k + 1];\\n        var todayNoStock = new int[k + 1];\\n\\n        for (int day = 1; day < n; day++) {\\n            for (int i = 1; i <= k; i++) {\\n                todayHaveStock[i] = Math.max(yesterdayHadStock[i], yesterdayNoStock[i - 1] - prices[day]); \\n                todayNoStock[i] = Math.max(yesterdayNoStock[i], yesterdayHadStock[i] + prices[day]);\\n                // move today to yesterday\\n                yesterdayHadStock[i] = todayHaveStock[i];\\n                yesterdayNoStock[i] = todayNoStock[i];\\n            }\\n        }\\n        \\n        return yesterdayNoStock[k];\\n    }\\n}\\n```\\n* with cooldown (alternative solution):\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //return maxProfit(prices, 0, 0, 0, new Integer[prices.length][2][2]);\\n        \\n        var n = prices.length;\\n        // 2d dp\\n//         var noStock = new int[n];\\n//         var haveStock = new int[n];\\n//         var justSold = new int[n];\\n        \\n//         noStock[0] = 0;\\n//         haveStock[0] = -prices[0];\\n//         justSold[0] = Integer.MIN_VALUE;\\n        \\n//         for (int day = 1; day < n; day++) {\\n//             noStock[day] = Math.max(noStock[day - 1], justSold[day - 1]);\\n//             haveStock[day] = Math.max(haveStock[day - 1], noStock[day - 1] - prices[day]);\\n//             justSold[day] = haveStock[day - 1] + prices[day];\\n//         }\\n        \\n//         return Math.max(justSold[n - 1], noStock[n - 1]);\\n        \\n        // 0d dp\\n\\n        var noStockYesterday = 0;\\n        var noStockToday = 0;\\n        var hadStockYesterday = -prices[0];\\n        var haveStockToday = 0;\\n        var justSoldYesterday = Integer.MIN_VALUE;\\n        var justSoldToday = 0;\\n\\n        for (int day = 1; day < n; day++) {\\n            noStockToday = Math.max(noStockYesterday, justSoldYesterday);\\n            haveStockToday = Math.max(hadStockYesterday, noStockYesterday - prices[day]);\\n            justSoldToday = hadStockYesterday + prices[day];\\n            \\n            noStockYesterday = noStockToday;\\n            hadStockYesterday = haveStockToday;\\n            justSoldYesterday = justSoldToday;\\n        }\\n        \\n        return Math.max(justSoldToday, noStockToday);\\n\\n    }\\n    \\n    private int maxProfit(int[] prices, int day, int isCooldown, int haveStock, Integer[][][] memo) {\\n        if (day == prices.length) {\\n            return 0;\\n        }\\n        \\n        if (memo[day][haveStock][isCooldown] != null) {\\n            return memo[day][haveStock][isCooldown];\\n        }\\n        \\n        var doNothingDay = maxProfit(prices, day + 1, 0, haveStock, memo);\\n        var operationDay = 0;\\n        if (haveStock == 1) {\\n            // sell\\n            operationDay = prices[day] + maxProfit(prices, day + 1, 1, 0, memo);\\n        }\\n        else {\\n            // buy\\n            if (isCooldown == 0) {\\n                operationDay = maxProfit(prices, day + 1, 0, 1, memo) - prices[day];\\n            }\\n        }    \\n        return memo[day][haveStock][isCooldown] = Math.max(doNothingDay, operationDay);\\n    }\\n}\\n```\\n\\n**[blink] !!! Upvote if you got better at DP !!! [/blink]**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nhave_stock = max(had_stock, didnt_have_stock - price)\\ndont_have_stock = max(didnt_have_stock, had_stock + price - fee)\\n```\n```\\nhad_stock = -prices[0]\\ndidnt_have_stock = 0\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        \\n        had_stock = -prices[0]\\n        didnt_have_stock = 0\\n        \\n        for price in prices:\\n\\t\\t\\t# have stock today because I had the stock yesteday or didn\\'t have it yesterday and bought it today\\n            have_stock = max(had_stock, didnt_have_stock - price)\\n\\t\\t\\t# don\\'t have stock today because I didn\\'t have it yesteday or had it yesterday and sold today + paid fee\\n            dont_have_stock = max(didnt_have_stock, had_stock + price - fee)\\n            had_stock = have_stock # next day -> today\\'s state becomes yesterday\\'s state\\n            didnt_have_stock = dont_have_stock # next day -> today\\'s state becomes yesterday\\'s state\\n        return dont_have_stock # return state when you sold your stock\\n```\n```\\n// Day 0: \\'Buy stock day\\'. We had balance = 0. Today we bought the stock with prices[0]. Now we have -prices[0] balance\\nIHaveStock[0] = -prices[0];\\n```\n```\\n// Day 0: We skipped the day. Thus balance was 0 and is 0\\nIHaveNoStock[0] = 0;\\n```\n```\\nIHaveStock[today] = Math.max(IHaveStock[yesterday], IHaveNoStock[yesterday] - prices[today]); // max of skip day or buy (-profit)\\nIHaveNoStock[today] = Math.max(IHaveNoStock[yesterday], IHaveStock[yesterday] + prices[today]); // max of skip day or sell(+profit)\\n```\n```\\n// Day 0: \\'Buy stock day\\'. We had balance = 0. Today we bought the stock with prices[0]. Now we have -prices[0] balance\\nIHaveStock[0][1] = -prices[0]; // base case for transaction #1\\nIHaveStock[0][2] = -prices[0]; // base case for transaction #2\\n```\n```\\n// Day 0: We skipped the day. Thus balance was 0 and is 0\\nIHaveNoStock[0][1] = 0; // base case for transaction #1\\nIHaveNoStock[0][2] = 0; // base case for transaction #2\\n```\n```\\n// transaction 1 start: max(I started transaction 1 yesterday (bought), or I start it today - buy: transaction 0 = no transaction(balance=0) - prices[today])\\nIHaveStock[today][1] = Math.max(IHaveStock[yesterday][1], IHaveNoStock[yesterday][0] - prices[today]);\\n// transaction 1 start: max(I had no stock yesterday or I had stock yesterday and sold it today)\\nIHaveNoStock[today][1] = Math.max(IHaveNoStock[yesterday][1], IHaveStock[yesterday][1] + prices[today]); # for transaction1\\n\\n// !!!\\n// ****** this is how transaction #1 end is connected to transaction #2 start ******\\n// IHaveStock[today][2] ... IHaveNoStock[yesterday][1]...\\n// !!!\\n\\n// transaction 2 start: max(I started transaction 2 yesterday (bought), or I start it today - buy: transaction 1 - prices[today])\\nIHaveStock[today][2] = Math.max(IHaveStock[yesterday][2], IHaveNoStock[yesterday][1] - prices[today]); # for transaction 2\\n// transaction 2 start: max(I had no stock yesterday or I had stock yesterday and sold it today)\\nIHaveNoStock[today][2] = Math.max(IHaveNoStock[yesterday][2], IHaveStock[yesterday][2] + prices[today]); # for transaction 2\\n```\n```\\nIHaveStock[today][2] = Math.max(IHaveStock[yesterday][2], IHaveNoStock[yesterday][1] - prices[today]); # for transaction 2\\n...\\nIHaveStock[today][3] = Math.max(IHaveStock[yesterday][3], IHaveNoStock[yesterday][2] - prices[today]); # for transaction 3\\n```\n```\\nvar n = prices.length;\\n\\n// max profit for a day if we have no stock (did not have yesterday or sold today)\\nvar noStock = new int[n];\\n// max profit for a day if we have a stock (had stock yesterday or bought today)\\nvar haveStock = new int[n];\\n\\n// Day 0: \\'Couch potato day\\'. No transaction made. We did not buy or sell. Thus profit = 0\\nnoStock[0] = 0;\\n// Day 0: \\'Buying stock day\\'. We had profit = 0. Bought stock with prices[0]. Now we have negative prices[0] profit\\nhaveStock[0] = -prices[0]; // !!! if you want to pay the fee when you buy - do not forget do \"- fee\" here\\n\\nfor (int day = 1; day < n; day++) {\\n\\t// max profit: 1) we do nothing today or 2) we sell stock and pay fee\\n    noStock[day] = Math.max(noStock[day - 1], haveStock[day - 1] + prices[day] - fee); // -fee is for the problem with fee :)\\n\\t// max profit: 1) we do nothing today or 2) we buy stock\\n    haveStock[day] = Math.max(haveStock[day - 1], noStock[day - 1] - prices[day]);\\n}\\n\\n// A transaction is over when we have no stock anymore. We return noStock[lastDay]. \\nreturn noStock[n - 1];\\n```\n```\\nvar n = prices.length;\\n\\nvar noStockYesterday = 0;\\nvar noStockToday = 0;\\nvar hadStockYesterday = -prices[0];\\nvar haveStockToday = 0;\\n\\nfor (int day = 1; day < n; day++) {\\n\\t// max profit: 1) we do nothing today or 2) we sell stock and pay fee\\n    noStockToday = Math.max(noStockYesterday, hadStockYesterday + prices[day] - fee);\\n\\t// max profit: 1) we do nothing today or 2) we buy stock\\n    haveStockToday = Math.max(hadStockYesterday, noStockYesterday - prices[day]);\\n    noStockYesterday = noStockToday;\\n    hadStockYesterday = haveStockToday;\\n}\\n\\nreturn noStockToday;\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def dfs(day, no_stock):\\n            if day < 0:\\n                return 0\\n            \\n            if day == 0:\\n                if no_stock:\\n\\t\\t\\t\\t\\t# buy\\n                    return -prices[day]\\n                return 0\\n\\n            if (day, no_stock) in memo:\\n                return memo[day, no_stock]\\n\\n            have = float(-inf)\\n            do_not_have = float(-inf)\\n            if no_stock:\\n                # skip the day or buy new stock today\\n                have = max(dfs(day - 1, no_stock), dfs(day - 2, False) - prices[day])\\n            else:\\n                # skip the day or sell what you bought 2 days ago\\n                do_not_have = max(dfs(day - 1, no_stock), dfs(day - 1, True) + prices[day])\\n\\n            memo[day, no_stock] = max(do_not_have, have)\\n            return memo[day, no_stock]\\n\\n        N = len(prices)\\n        memo = defaultdict(int)\\n        return dfs(N - 1, False)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        N = len(prices)\\n        IHaveNoStock = defaultdict(int)\\n        IHaveStock = defaultdict(int)\\n        \\n        IHaveNoStock[0] = 0 # skipped the day\\n        IHaveStock[0] = -prices[0] # bought on day 0\\n        \\n        for day in range(1, N):\\n            hadTwoDaysAgo = hadYesterday = IHaveStock[day - 1]\\n            if day > 1:\\n                # what you had yesterday or what you sold 2 days ago + buy new stock today\\n                hadTwoDaysAgo = max(hadYesterday, IHaveNoStock[day - 2] - prices[day])\\n            IHaveStock[day] = max(hadYesterday, hadTwoDaysAgo)\\n            # what you sold/had yesterday or sell what you bought/had 2 days ago\\n            IHaveNoStock[day] = max(IHaveNoStock[day - 1], hadTwoDaysAgo + prices[day])\\n        \\n        return IHaveNoStock[N - 1]\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def dfs(day, no_stock):\\n            if day == 0: # base cases\\n                if no_stock:\\n                    memo[day, no_stock] = -prices[day] - fee # buy and pay the fee\\n                else:\\n                    memo[day, no_stock] = 0 # no stock, nothing to sell, skip the day\\n                return memo[day, no_stock]\\n            \\n            if (day, no_stock) in memo: # memo\\n                return memo[day, no_stock]\\n\\n            have = float(-inf)\\n            do_not_have = float(-inf)\\n            if no_stock:\\n                # max of skip the day or buy and pay the fee\\n                have = max(dfs(day - 1, no_stock), dfs(day - 1, False) - prices[day] - fee)\\n            else:\\n                # max of skip the day or sell\\n                do_not_have = max(dfs(day - 1, no_stock), dfs(day - 1, True) + prices[day])\\n\\n            memo[day, no_stock] = max(do_not_have, have)\\n            return memo[day, no_stock]\\n\\n        N = len(prices)\\n        memo = defaultdict(int)\\n        return dfs(N - 1, False)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        dp = defaultdict(int)\\n\\n        # base cases\\n        # have stock\\n        dp[0, True] = -prices[0] - fee # bought and paid the fee on day 0\\n        # have no stock\\n        dp[0, False] = 0 # no stock, skipped the day 0\\n\\n        # reverse params direction: in top-down it was N-1...0\\n        # now do 1... N-1, why start from 1 and not from 0? Because 0 is used by the base case!\\n        for day in range(1, N):\\n            for no_stock in [False, True]:\\n                # copy + paste: start\\n                have = float(-inf)\\n                do_not_have = float(-inf)\\n                if no_stock:\\n                    # max of skip the day or buy and pay the fee\\n                    have = max(dp[day - 1, no_stock], dp[day - 1, False] - prices[day] - fee)\\n                else:\\n                    # max of skip the day or sell\\n                    do_not_have = max(dp[day - 1, no_stock], dp[day - 1, True] + prices[day])\\n                dp[day, no_stock] = max(do_not_have, have)\\n                # copy + paste: end\\n\\n        return dp[N - 1, False]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n\\t\\tN = len(prices)\\n\\t\\thaveStock = defaultdict(int)\\n\\t\\thaveNoStock = defaultdict(int)\\n        \\n\\t\\thaveStock[0] = -prices[0] - fee\\n\\t\\thaveNoStock[0] = 0\\n        \\n\\t\\tfor day in range(1, N):\\n\\t\\t\\thaveNoStock[day] = max(haveNoStock[day - 1], haveStock[day - 1] + prices[day])\\n\\t\\t\\thaveStock[day] = max(haveStock[day - 1], haveNoStock[day - 1] - prices[day] - fee)\\n        \\n\\t\\treturn haveNoStock[N - 1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        IHadStockYesterday = -prices[0] - fee\\n        IHadNoStockYesterday = 0\\n\\n        IHaveStockToday = IHaveNoStockToday = 0\\n        for day in range(1, N):\\n            IHaveNoStockToday = max(IHadNoStockYesterday, IHadStockYesterday + prices[day])\\n            IHaveStockToday = max(IHadStockYesterday, IHadNoStockYesterday - prices[day] - fee)\\n            \\n            IHadStockYesterday, IHadNoStockYesterday = IHaveStockToday, IHaveNoStockToday\\n\\n        return IHaveNoStockToday\\n```\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    var n = prices.length;\\n        \\n    // rec + memo (top-down)\\n\\treturn maxProfit(prices, fee, 0, 0, new Integer[n][2]);\\n}\\n    \\nprivate int maxProfit(int[] nums, int fee, int day, Integer haveStock, Integer[][] memo) {\\n\\tif (day == nums.length) {\\n\\t\\treturn 0;\\n    }\\n        \\n\\tif (memo[day][haveStock] != null) {\\n\\t\\treturn memo[day][haveStock];\\n    }\\n\\n    var keepStockProfit = maxProfit(nums, fee, day + 1, haveStock, memo);\\n        \\n    var operationProfit = 0;\\n\\tif (haveStock == 1) {\\n        // sell\\n\\t\\toperationProfit = nums[day] + maxProfit(nums, fee, day + 1, 0, memo) - fee;\\n    }\\n\\telse {\\n\\t\\t// buy\\n\\t\\toperationProfit = maxProfit(nums, fee, day + 1, 1, memo) - nums[day];\\n\\t}\\n        \\n\\treturn memo[day][haveStock] = Math.max(keepStockProfit, operationProfit);\\n}\\n```\n```\\n// dp 2d bottom-up\\n\\nvar dp = new int[n][2];\\nvar maxProfit = 0;\\n        \\ndp[0][0] = -prices[0]; // this gets calculated first - day0, bought stock, thus negative balance\\nfor (int day = 1; day < n; day++) {\\n\\tfor (int haveStock = 0; haveStock < 2; haveStock++) {\\n\\t\\tvar keepStockProfit = dp[day - 1][haveStock];\\n\\n        var operationProfit = 0;\\n        if (haveStock == 1) {\\n\\t\\t\\t// sell\\n\\t\\t\\toperationProfit = prices[day] + dp[day - 1][0] - fee;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// buy\\n\\t\\t\\toperationProfit = dp[day - 1][1] - prices[day];\\n\\t\\t}\\n\\n\\t\\tmaxProfit = dp[day][haveStock] = Math.max(keepStockProfit, operationProfit);\\n\\t}\\n}\\n\\nreturn maxProfit;\\n```\n```\\nvar dp = new int[n][2];\\nvar maxProfit = 0;\\n        \\ndp[0][0] = -prices[0];\\nfor (int day = 1; day < n; day++) {\\n\\tvar keepStockProfit = dp[day - 1][0];\\n    var operationProfit = dp[day - 1][1] - prices[day];\\n            \\n    maxProfit = dp[day][0] = Math.max(keepStockProfit, operationProfit);\\n\\n    keepStockProfit = dp[day - 1][1];\\n\\toperationProfit = prices[day] + dp[day - 1][0] - fee;\\n            \\n\\tmaxProfit = dp[day][1] = Math.max(keepStockProfit, operationProfit);\\n}\\n\\nreturn maxProfit;\\n```\n```\\nvar dp = new int[n][2];\\nvar maxProfit = 0;\\n        \\ndp[0][0] = -prices[0];\\nfor (int day = 1; day < n; day++) {\\n\\tdp[day][0] = Math.max(dp[day - 1][0], dp[day - 1][1] - prices[day]);\\n    maxProfit = dp[day][1] = Math.max(dp[day - 1][1], prices[day] + dp[day - 1][0] - fee);\\n}\\n\\nreturn maxProfit;\\n```\n```\\n// dp[day][0] -> dayHaveStock profit\\n// dp[day][1] -> dayNoStock profit\\n\\nvar maxProfit = 0;\\n        \\nvar dayNoStock = 0;\\nvar dayHaveStock = -prices[0];\\nfor (int day = 1; day < n; day++) {\\n\\tdayHaveStock = Math.max(dayHaveStock, dayNoStock - prices[day]);\\n    maxProfit = dayNoStock = Math.max(dayNoStock, prices[day] + dayHaveStock - fee);\\n}\\n\\nreturn maxProfit;\\n```\n```\\nmaxProfit(int[] nums, int fee, int isCooldown, int transactionsLeft, int isItCloudyToday, int maxBudgetCapReached)\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        var n = prices.length;\\n        \\n        // dp 2d\\n//         var haveStock = new int[n][3];\\n//         var noStock = new int[n][3];\\n\\n//         // bought and sold on the 1st day\\n//         noStock[0][1] = 0;\\n//         // bought and sold on the 1st day\\n//         noStock[0][2] = 0;\\n        \\n//         // bought on the 1st day. T #1\\n//         haveStock[0][1] = -prices[0];\\n//         // bought, sold, bought on the 1st day. Thus T #2\\n//         haveStock[0][2] = -prices[0];\\n\\n//         for (int day = 1; day < n; day++) {\\n//             haveStock[day][1] = Math.max(haveStock[day - 1][1], noStock[day - 1][0] - prices[day]); \\n//             noStock[day][1] = Math.max(noStock[day - 1][1], haveStock[day - 1][1] + prices[day]);\\n//             haveStock[day][2] = Math.max(haveStock[day - 1][2], noStock[day - 1][1] - prices[day]);\\n//             noStock[day][2] = Math.max(noStock[day - 1][2], haveStock[day - 1][2] + prices[day]);\\n//         }\\n        \\n//         return noStock[n - 1][2];\\n\\n        // dp O(1)\\n        var noStockTodayT1 = 0;\\n        var noStockYesterdayT1 = 0;\\n        \\n        var noStockTodayT2 = 0;\\n        var noStockYesterdayT2 = 0;\\n        \\n        var haveStockTodayT1 = 0;\\n        var hadStockYesterdayT1 = -prices[0];\\n        \\n        var haveStockTodayT2 = 0;\\n        var hadStockYesterdayT2 = -prices[0];\\n\\n        for (int day = 1; day < n; day++) {\\n            haveStockTodayT1 = Math.max(hadStockYesterdayT1, -prices[day]); \\n            noStockTodayT1 = Math.max(noStockYesterdayT1, hadStockYesterdayT1 + prices[day]);\\n            haveStockTodayT2 = Math.max(hadStockYesterdayT2, noStockYesterdayT1 - prices[day]);\\n            noStockTodayT2 = Math.max(noStockYesterdayT2, hadStockYesterdayT2 + prices[day]);\\n            \\n            hadStockYesterdayT1 = haveStockTodayT1;\\n            hadStockYesterdayT2 = haveStockTodayT2;\\n            noStockYesterdayT1 = noStockTodayT1;\\n            noStockYesterdayT2 = noStockTodayT2;            \\n        }\\n        \\n        return noStockTodayT2;\\n\\n        // top-down + memo\\n        //return maxProfit(prices, 0, 0, k, new Integer[prices.length][2][k + 1]);\\n    }\\n    \\n    private int maxProfit(int[] nums, int day, int canSell, int transLeft, Integer[][][] memo) {\\n        if (day == nums.length || transLeft == 0) {\\n            return 0;\\n        }\\n        \\n        if (memo[day][canSell][transLeft] != null) {\\n            return memo[day][canSell][transLeft];\\n        }\\n        \\n        // do nothing - skip day\\n        var noActionsProfit = maxProfit(nums, day + 1, canSell, transLeft, memo);\\n        var actionProfit = 0;\\n        \\n        if (canSell == 1) {\\n            actionProfit = nums[day] + maxProfit(nums, day + 1, 0, transLeft - 1, memo);\\n        }\\n        else {\\n            actionProfit = maxProfit(nums, day + 1, 1, transLeft, memo) - nums[day];\\n        }\\n        \\n        return memo[day][canSell][transLeft] = Math.max(noActionsProfit, actionProfit);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        \\n        // !!!\\n        // for more details look at problem #3\\n        // !!!\\n        var n = prices.length;\\n\\n        if (k == 0 || n == 0) {\\n            return 0;\\n        }\\n\\n//         // dp 2 x 2d\\n//         var haveStock = new int[n][k + 1];\\n//         var noStock = new int[n][k + 1];\\n\\n//         for (int i = 1; i <= k; i++) {\\n//             // bought, sold, bought on the 1st day. Thus T #i\\n//             haveStock[0][i] = -prices[0];\\n//         }\\n\\n//         for (int day = 1; day < n; day++) {\\n//             for (int i = 1; i <= k; i++) {\\n//                 haveStock[day][i] = Math.max(haveStock[day - 1][i], noStock[day - 1][i - 1] - prices[day]); \\n//                 noStock[day][i] = Math.max(noStock[day - 1][i], haveStock[day - 1][i] + prices[day]);\\n//             }\\n//         }\\n        \\n//         return noStock[n - 1][k];\\n        \\n        // dp 2 x 1d\\n        var yesterdayHadStock = new int[k + 1];\\n        var yesterdayNoStock = new int[k + 1];\\n\\n        for (int i = 1; i <= k; i++) {\\n            // bought, sold, bought on the 1st day. Thus T #i\\n            yesterdayHadStock[i] = -prices[0];\\n        }\\n\\n        var todayHaveStock = new int[k + 1];\\n        var todayNoStock = new int[k + 1];\\n\\n        for (int day = 1; day < n; day++) {\\n            for (int i = 1; i <= k; i++) {\\n                todayHaveStock[i] = Math.max(yesterdayHadStock[i], yesterdayNoStock[i - 1] - prices[day]); \\n                todayNoStock[i] = Math.max(yesterdayNoStock[i], yesterdayHadStock[i] + prices[day]);\\n                // move today to yesterday\\n                yesterdayHadStock[i] = todayHaveStock[i];\\n                yesterdayNoStock[i] = todayNoStock[i];\\n            }\\n        }\\n        \\n        return yesterdayNoStock[k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //return maxProfit(prices, 0, 0, 0, new Integer[prices.length][2][2]);\\n        \\n        var n = prices.length;\\n        // 2d dp\\n//         var noStock = new int[n];\\n//         var haveStock = new int[n];\\n//         var justSold = new int[n];\\n        \\n//         noStock[0] = 0;\\n//         haveStock[0] = -prices[0];\\n//         justSold[0] = Integer.MIN_VALUE;\\n        \\n//         for (int day = 1; day < n; day++) {\\n//             noStock[day] = Math.max(noStock[day - 1], justSold[day - 1]);\\n//             haveStock[day] = Math.max(haveStock[day - 1], noStock[day - 1] - prices[day]);\\n//             justSold[day] = haveStock[day - 1] + prices[day];\\n//         }\\n        \\n//         return Math.max(justSold[n - 1], noStock[n - 1]);\\n        \\n        // 0d dp\\n\\n        var noStockYesterday = 0;\\n        var noStockToday = 0;\\n        var hadStockYesterday = -prices[0];\\n        var haveStockToday = 0;\\n        var justSoldYesterday = Integer.MIN_VALUE;\\n        var justSoldToday = 0;\\n\\n        for (int day = 1; day < n; day++) {\\n            noStockToday = Math.max(noStockYesterday, justSoldYesterday);\\n            haveStockToday = Math.max(hadStockYesterday, noStockYesterday - prices[day]);\\n            justSoldToday = hadStockYesterday + prices[day];\\n            \\n            noStockYesterday = noStockToday;\\n            hadStockYesterday = haveStockToday;\\n            justSoldYesterday = justSoldToday;\\n        }\\n        \\n        return Math.max(justSoldToday, noStockToday);\\n\\n    }\\n    \\n    private int maxProfit(int[] prices, int day, int isCooldown, int haveStock, Integer[][][] memo) {\\n        if (day == prices.length) {\\n            return 0;\\n        }\\n        \\n        if (memo[day][haveStock][isCooldown] != null) {\\n            return memo[day][haveStock][isCooldown];\\n        }\\n        \\n        var doNothingDay = maxProfit(prices, day + 1, 0, haveStock, memo);\\n        var operationDay = 0;\\n        if (haveStock == 1) {\\n            // sell\\n            operationDay = prices[day] + maxProfit(prices, day + 1, 1, 0, memo);\\n        }\\n        else {\\n            // buy\\n            if (isCooldown == 0) {\\n                operationDay = maxProfit(prices, day + 1, 0, 1, memo) - prices[day];\\n            }\\n        }    \\n        return memo[day][haveStock][isCooldown] = Math.max(doNothingDay, operationDay);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160964,
                "title": "java-using-state-machine-like-stock-iii",
                "content": "\\tI read an article about Best Time to Buy and Sell Stock III that used state machine, a very intuitive way.\\n\\n\\tThat inspires me to solve this problem with same idea.\\n\\n\\tSuppose we have a state machine:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/chriszzt/image_1534556190.png)\\n\\n\\tWe should maintain each state with maximum profit.\\n\\n\\tSo at S0, we could either do nothing, or we could buy a stock.\\n\\tAt s1, we cloud either do nothing, or we could sell current stock with fee.\\n\\n\\tTo update state:\\n\\tFor s0, the incoming arrows from s0 itself or s1. So s0 = Math.max(s0, s1 + sale_price - fee)\\n\\tFor s1, the incoming arrows from s0 and s1 itself, So s1 = Math.max(s1, s0 - buying_prices)\\n\\nHere is my Code:\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n      if (prices.length == 0) {\\n        return 0;\\n      }\\n      int s0 = 0;\\n      int s1 = -prices[0];\\n      for (int i = 1; i < prices.length; i++) {\\n        s1 = Math.max(s1, s0 - prices[i]);\\n        s0 = Math.max(s0, prices[i] + s1 - fee);\\n      }\\n      \\n      return s0;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n      if (prices.length == 0) {\\n        return 0;\\n      }\\n      int s0 = 0;\\n      int s1 = -prices[0];\\n      for (int i = 1; i < prices.length; i++) {\\n        s1 = Math.max(s1, s0 - prices[i]);\\n        s0 = Math.max(s0, prices[i] + s1 - fee);\\n      }\\n      \\n      return s0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108884,
                "title": "java-c-clean-code-dp-greedy",
                "content": "```\\nDefinition:\\nhold[i] - the maximum profit you can earn if you have to hold at day[i]\\nsold[i] - the maximum profit you can earn if you have to sold at day[i]\\n\\nFormula:\\nhold[i] = max(hold[i - 1], sold[i - 1] - p[i])       // if hold at [i-1], no op; if sold at [i-1], buy at [i] with cost of p[i];\\nsold[i] = max(sold[i - 1], hold[i - 1] + p[i] - fee) // if sold at [i-1], no op; if hold at [i-1], sell at [i] with gain of p[i] - fee;\\n\\nInitialization:\\nhold[0] = 0 - price[0];  // buy shares with cost of p[0];\\nsold[0] = 0;             // no op no cost;\\n```\\n**Java DP**\\n```\\nclass Solution {\\n    public int maxProfit(int[] p, int fee) {\\n        int n = p.length;\\n        if (n < 2) return 0;\\n        int[] hold = new int[n], sold = new int[n];\\n        hold[0] = -p[0];\\n        for (int i = 1; i < n; ++i) {\\n            hold[i] = Math.max(hold[i - 1], sold[i - 1] - p[i]);\\n            sold[i] = Math.max(sold[i - 1], hold[i - 1] + p[i] - fee);\\n        }\\n\\n        return sold[n - 1];\\n    }\\n}\\n```\\n**C++ DP**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int n = p.size();\\n        if (n < 2) return 0;\\n        vector<int> hold(n, 0), sold(n, 0);\\n        hold[0] = -p[0];\\n        for (int i = 1; i < n; i++) {\\n            hold[i] = max(hold[i - 1], sold[i - 1] - p[i]);\\n            sold[i] = max(sold[i - 1], hold[i - 1] - fee + p[i]);\\n        }\\n\\n        return sold[n - 1];\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        if (p.size() < 2) return 0;\\n        int sold = 0, hold = 0 - p[0];\\n        for (int i = 1; i < p.size(); i++) {\\n            hold = max(hold, sold - p[i]);\\n            sold = max(sold, hold + p[i] - fee);\\n        }\\n        return sold;\\n    }\\n};\\n```\\n**Java Greedy**\\n1.  buy in - when current price higher than previous lowest point by more than amount of transaction fee, and set current price as highest point;\\n2. sale out - when current price lower than prevous highest point by more than amount of transaction fee, and reset lowest, highest\\n3. update highest - only if highest is set;\\n4. update lowest - every day\\n```\\nclass Solution {\\n    public int maxProfit(int[] p, int fee) {\\n        int profit = 0;\\n        Integer lo = null, hi = null, n = p.length;\\n        for (int i = 0; i < n; i++) {\\n            if (lo != null && hi == null && p[i] - lo > fee) hi = p[i]; // buy in\\n            if (hi != null && p[i] > hi) hi = p[i]; // update highest\\n            if (hi != null && (hi - p[i] > fee || i == n - 1)) { // sale out\\n                profit += hi - lo - fee;\\n                hi = null;\\n                lo = null;\\n            }\\n\\n            lo = lo != null ? Math.min(lo, p[i]) : p[i]; // update lowest\\n        }\\n        return profit;      \\n    }\\n}\\n```\\n**C++ Greedy**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int profit = 0;\\n        int* lo = nullptr, *hi = nullptr, n = p.size();\\n        for (int i = 0; i < n; i++) {\\n            if (lo && !hi && p[i] - *lo > fee) hi = &p[i]; // buy in\\n            if (hi && p[i] > *hi) hi = &p[i]; // update highest\\n            if (hi && (*hi - p[i] > fee || i == n - 1)) { // sale out\\n                profit += *hi - *lo - fee;\\n                hi = nullptr;\\n                lo = nullptr;\\n            }\\n\\n            if (!lo || p[i] < *lo) lo = &p[i]; // update lowest\\n        }\\n        return profit;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nDefinition:\\nhold[i] - the maximum profit you can earn if you have to hold at day[i]\\nsold[i] - the maximum profit you can earn if you have to sold at day[i]\\n\\nFormula:\\nhold[i] = max(hold[i - 1], sold[i - 1] - p[i])       // if hold at [i-1], no op; if sold at [i-1], buy at [i] with cost of p[i];\\nsold[i] = max(sold[i - 1], hold[i - 1] + p[i] - fee) // if sold at [i-1], no op; if hold at [i-1], sell at [i] with gain of p[i] - fee;\\n\\nInitialization:\\nhold[0] = 0 - price[0];  // buy shares with cost of p[0];\\nsold[0] = 0;             // no op no cost;\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] p, int fee) {\\n        int n = p.length;\\n        if (n < 2) return 0;\\n        int[] hold = new int[n], sold = new int[n];\\n        hold[0] = -p[0];\\n        for (int i = 1; i < n; ++i) {\\n            hold[i] = Math.max(hold[i - 1], sold[i - 1] - p[i]);\\n            sold[i] = Math.max(sold[i - 1], hold[i - 1] + p[i] - fee);\\n        }\\n\\n        return sold[n - 1];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int n = p.size();\\n        if (n < 2) return 0;\\n        vector<int> hold(n, 0), sold(n, 0);\\n        hold[0] = -p[0];\\n        for (int i = 1; i < n; i++) {\\n            hold[i] = max(hold[i - 1], sold[i - 1] - p[i]);\\n            sold[i] = max(sold[i - 1], hold[i - 1] - fee + p[i]);\\n        }\\n\\n        return sold[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        if (p.size() < 2) return 0;\\n        int sold = 0, hold = 0 - p[0];\\n        for (int i = 1; i < p.size(); i++) {\\n            hold = max(hold, sold - p[i]);\\n            sold = max(sold, hold + p[i] - fee);\\n        }\\n        return sold;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] p, int fee) {\\n        int profit = 0;\\n        Integer lo = null, hi = null, n = p.length;\\n        for (int i = 0; i < n; i++) {\\n            if (lo != null && hi == null && p[i] - lo > fee) hi = p[i]; // buy in\\n            if (hi != null && p[i] > hi) hi = p[i]; // update highest\\n            if (hi != null && (hi - p[i] > fee || i == n - 1)) { // sale out\\n                profit += hi - lo - fee;\\n                hi = null;\\n                lo = null;\\n            }\\n\\n            lo = lo != null ? Math.min(lo, p[i]) : p[i]; // update lowest\\n        }\\n        return profit;      \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int profit = 0;\\n        int* lo = nullptr, *hi = nullptr, n = p.size();\\n        for (int i = 0; i < n; i++) {\\n            if (lo && !hi && p[i] - *lo > fee) hi = &p[i]; // buy in\\n            if (hi && p[i] > *hi) hi = &p[i]; // update highest\\n            if (hi && (*hi - p[i] > fee || i == n - 1)) { // sale out\\n                profit += *hi - *lo - fee;\\n                hi = nullptr;\\n                lo = nullptr;\\n            }\\n\\n            if (!lo || p[i] < *lo) lo = &p[i]; // update lowest\\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108892,
                "title": "java-dp-solution-o-n-to-o-1-space",
                "content": "Define dp array:\nhold[i] : The maximum profit of holding stock until day i;\nnotHold[i] : The maximum profit of not hold stock until day i;\n\ndp transition function:\nFor day i, we have two situations:\n1. Hold stock: \n    (1) We do nothing on day i: hold[i - 1];\n    (2) We buy stock on day i: notHold[i - 1] - prices[i];\n\n2. Not hold stock: \n    (1) We do nothing on day i: notHold[i - 1];\n    (2) We sell stock on day i: hold[i - 1] + prices[i] - fee;\n\n`O(n) space`\n```\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n        \n        int len = prices.length;\n        int[] hold = new int[len];     //Till day i, the max profit is hold[i] if I hold the stock.\n        int[] notHold = new int[len];  //Till day i, the max profit is notHold[i] if I do not hold the stock.\n        \n        hold[0] = -prices[0];\n        notHold[0] = 0;\n        \n        for (int i = 1; i < prices.length; i++) {\n            hold[i] = Math.max(hold[i - 1], notHold[i - 1] - prices[i]);\n            notHold[i] = Math.max(notHold[i - 1], hold[i - 1] - fee + prices[i]);\n        }\n        \n        return notHold[len - 1];\n    }\n}\n````\n`O(1) Space`\nFrom the dp transition function, we can see the i th state are only based on the i-1 th state. So we could optimize space to O(1) using two variables.\n```\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n        \n        int len = prices.length;\n        int hold = -prices[0];\n        int notHold = 0;\n        \n        for (int i = 1; i < prices.length; i++) {\n            hold = Math.max(hold, notHold - prices[i]);\n            notHold = Math.max(notHold, hold + prices[i] - fee);\n        }\n        \n        return notHold;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n        \n        int len = prices.length;\n        int[] hold = new int[len];     //Till day i, the max profit is hold[i] if I hold the stock.\n        int[] notHold = new int[len];  //Till day i, the max profit is notHold[i] if I do not hold the stock.\n        \n        hold[0] = -prices[0];\n        notHold[0] = 0;\n        \n        for (int i = 1; i < prices.length; i++) {\n            hold[i] = Math.max(hold[i - 1], notHold[i - 1] - prices[i]);\n            notHold[i] = Math.max(notHold[i - 1], hold[i - 1] - fee + prices[i]);\n        }\n        \n        return notHold[len - 1];\n    }\n}\n```\n```\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n        \n        int len = prices.length;\n        int hold = -prices[0];\n        int notHold = 0;\n        \n        for (int i = 1; i < prices.length; i++) {\n            hold = Math.max(hold, notHold - prices[i]);\n            notHold = Math.max(notHold, hold + prices[i] - fee);\n        }\n        \n        return notHold;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112134,
                "title": "c-simple-and-short-dp-solution-detailed-explanation-o-n-time-o-1-space",
                "content": "### **Explanation:**\\nSell_stock represents the max profit on day i if we don\\'t have a stock and don\\'t buy or have a stock and sell it.\\nKeep_stock represents the max profit on day i if we buy a  stock or have a stock and keep it.\\n**In iteration i:**\\n* **sell_stock** = maximum between: \\n*sellstock* - if in iteration i-1 we sold the stock or had none and now we don\\'t want to buy, \\nor *keepstock + prices[i] - fee* if we have a stock and want to sell it.\\n* **keep_stock** = maximum between: \\n*keepstock* if in iteration i-1 we had a stock or bought one and now we are keeping it, \\nor *sellstack - prices[i]* if we have no stock and want to buy one now.\\n\\nWe return sell_stock because it\\'s for sure better to sell the last stock than keep it.\\n\\n**If you like my solution and explanation - please upvote!**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell_stack = 0, keep_stock = -prices[0];\\n        for (int i = 1; i < prices.size(); i++) {\\n            sell_stack = max(sell_stack, keep_stock + prices[i] - fee);\\n            keep_stock = max(keep_stock, sell_stack - prices[i]);\\n        }\\n        return sell_stack;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell_stack = 0, keep_stock = -prices[0];\\n        for (int i = 1; i < prices.size(); i++) {\\n            sell_stack = max(sell_stack, keep_stock + prices[i] - fee);\\n            keep_stock = max(keep_stock, sell_stack - prices[i]);\\n        }\\n        return sell_stack;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283701,
                "title": "python-recursive-solution-memoization",
                "content": "I couldn\\'t really find the recusrive solution in the discussion which forms the crux of DP problems...So I decided to post it so that it may help someone to actually learn how the recursion is actually taking place rather than directly seeing the bottom up approach.\\n\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    dp = []\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        dp = defaultdict(lambda : -1)\\n        def cost(i,n,bought):\\n            if i >= n:\\n                return 0\\n            if (i, bought) in dp:\\n                return dp[(i, bought)]\\n            #if bought previously, we have 2 option:-\\n            # sell the prvious stock today or skip this day\\n            if bought:\\n                dp[(i,bought)] = max(cost(i+1,n,False) + prices[i] - fee, cost(i+1,n,bought))\\n            \\n            #else if we can buy a new stock, then we again have 2 option:-\\n            #buy the current stock or skip over it\\n            else:\\n                dp[(i,bought)] = max(cost(i+1,n,True) - prices[i], cost(i+1,n,bought))\\n                \\n            return dp[(i,bought)]\\n        \\n        return cost(0,len(prices),False)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "I couldn\\'t really find the recusrive solution in the discussion which forms the crux of DP problems...So I decided to post it so that it may help someone to actually learn how the recursion is actually taking place rather than directly seeing the bottom up approach.\\n\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    dp = []\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        dp = defaultdict(lambda : -1)\\n        def cost(i,n,bought):\\n            if i >= n:\\n                return 0\\n            if (i, bought) in dp:\\n                return dp[(i, bought)]\\n            #if bought previously, we have 2 option:-\\n            # sell the prvious stock today or skip this day\\n            if bought:\\n                dp[(i,bought)] = max(cost(i+1,n,False) + prices[i] - fee, cost(i+1,n,bought))\\n            \\n            #else if we can buy a new stock, then we again have 2 option:-\\n            #buy the current stock or skip over it\\n            else:\\n                dp[(i,bought)] = max(cost(i+1,n,True) - prices[i], cost(i+1,n,bought))\\n                \\n            return dp[(i,bought)]\\n        \\n        return cost(0,len(prices),False)",
                "codeTag": "Java"
            },
            {
                "id": 1112599,
                "title": "python-3-dp-with-detail-and-simple-explanation-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        # You initially have zero money in your hand\\n        cin_w_shares = -prices[0] # Cash in hand with shares if you bought it on first day\\n        cin_wo_shares = 0 # Cash in hand without shares if you do not buy any share on first day\\n        \\n        for i in range(1,len(prices)):\\n            # Maximum cash in hand with shares\\n            # Either \\n\\t\\t\\t# 1. withold prev share in which case your cash in hand will not change, \\n            # 2. or assume there was no currently bought share but you want to buy it today - \\n\\t\\t\\t#         In this case: your current cash in hand with shares will be your previous cash \\n\\t\\t\\t#         in hand without shares minus buying price of the share today.\\n            cin_w_shares = max(cin_w_shares, cin_wo_shares-prices[i]) \\n            \\n            # Maximum cash in hand without shares\\n            # Either \\n\\t\\t\\t# 1. withold money without shares in which case your cash in hand will not change, \\n            # 2. or assume you previously bought the share and you are going to sell that today -\\n\\t\\t\\t#         In this case : your current cash in hand without shares will be your previous cash \\n\\t\\t\\t#         in hand with shares plus the current selling price minus transaction fee\\n            cin_wo_shares = max(cin_wo_shares, cin_w_shares + prices[i]-fee)\\n            \\n        # Return cash in hand without shares, as cash in hand with share will always be lower\\n        return cin_wo_shares \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        # You initially have zero money in your hand\\n        cin_w_shares = -prices[0] # Cash in hand with shares if you bought it on first day\\n        cin_wo_shares = 0 # Cash in hand without shares if you do not buy any share on first day\\n        \\n        for i in range(1,len(prices)):\\n            # Maximum cash in hand with shares\\n            # Either \\n\\t\\t\\t# 1. withold prev share in which case your cash in hand will not change, \\n            # 2. or assume there was no currently bought share but you want to buy it today - \\n\\t\\t\\t#         In this case: your current cash in hand with shares will be your previous cash \\n\\t\\t\\t#         in hand without shares minus buying price of the share today.\\n            cin_w_shares = max(cin_w_shares, cin_wo_shares-prices[i]) \\n            \\n            # Maximum cash in hand without shares\\n            # Either \\n\\t\\t\\t# 1. withold money without shares in which case your cash in hand will not change, \\n            # 2. or assume you previously bought the share and you are going to sell that today -\\n\\t\\t\\t#         In this case : your current cash in hand without shares will be your previous cash \\n\\t\\t\\t#         in hand with shares plus the current selling price minus transaction fee\\n            cin_wo_shares = max(cin_wo_shares, cin_w_shares + prices[i]-fee)\\n            \\n        # Return cash in hand without shares, as cash in hand with share will always be lower\\n        return cin_wo_shares \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667390,
                "title": "c-accepted-recursion-memo-tabulation-space-optimization-easy-to-code-striver",
                "content": "# For better UnderStanding Go through striver Dp series (DP on Stocks)\\n\\n\\n# Approach 1:-Recursion(TLE)\\n```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n       \\n        int profit=0;\\n        \\n        if(buy)\\n        {\\n            \\n            int not_buy=stock(v,1,index+1,fee);\\n            int buy= -v[index]+stock(v,0,index+1,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n         \\n            int sell=v[index]-fee+stock(v,1,index+1,fee);\\n            int not_sell=stock(v,0,index+1,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n    \\n      return stock(prices,1,0,fee);\\n    }\\n};\\n\\n```\\n\\n# Approach 2-Memoisation(\\u2705\\u2705Accepted)\\n\\n```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,vector<vector<int>>&dp,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[index][buy]!=-1)\\n        {\\n            return dp[index][buy];\\n        }\\n        int profit=0;\\n       \\n        if(buy)\\n        {\\n          \\n            int not_buy=stock(v,1,index+1,dp,fee);\\n            int buy= -v[index]+stock(v,0,index+1,dp,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n          \\n            int sell=v[index]-fee+stock(v,1,index+1,dp,fee);\\n            int not_sell=stock(v,0,index+1,dp,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n      vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n      return stock(prices,1,0,dp,fee);\\n    }\\n};\\n\\n```\\n\\n# Approach 3:-\\u2705\\u2705 Tabulation(Accepted\\u2705)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n         //lest cobvert int memo\\n        vector<vector<int>>dp(prices.size()+1,vector<int>(2,0));\\n        int n=prices.size();\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            for(int buy=0;buy<2;buy++)\\n            {\\n         int profit=0;\\n        \\n        if(buy)\\n        {\\n           \\n            int not_buy= dp[index+1][1];\\n            int buy= -prices[index]+ dp[index+1][0];\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n            \\n            int sell=prices[index]-fee+dp[index+1][1];\\n            int not_sell=dp[index+1][0];\\n            profit=max(sell,not_sell);\\n        }\\n       dp[index][buy]=profit;\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n};\\n\\n```\\n\\n# Approach 4 : \\u2705\\u2705SPACE OPTIMIZATION (\\u2705Accepted)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n       \\n        \\n        int n=prices.size();\\n       \\n      vector<int>ahead(2,0);\\n      vector<int>curr(2,0);\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            curr[1]=max(-prices[index]+ ahead[0],ahead[1]);\\n      \\n          curr[0]=max(prices[index]-fee+ahead[1],ahead[0]);\\n          \\n        ahead=curr;\\n            }\\n        \\n\\n        return curr[1];\\n    }\\n};\\n\\n```\\n\\n# If you have any question, feel free to ask. If you like the explanations, please Upvote!\\n![478xve.jpg](https://assets.leetcode.com/users/images/e1f75642-1d16-47ea-8281-0a1696fa1607_1687394035.9172788.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n       \\n        int profit=0;\\n        \\n        if(buy)\\n        {\\n            \\n            int not_buy=stock(v,1,index+1,fee);\\n            int buy= -v[index]+stock(v,0,index+1,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n         \\n            int sell=v[index]-fee+stock(v,1,index+1,fee);\\n            int not_sell=stock(v,0,index+1,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n    \\n      return stock(prices,1,0,fee);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,vector<vector<int>>&dp,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[index][buy]!=-1)\\n        {\\n            return dp[index][buy];\\n        }\\n        int profit=0;\\n       \\n        if(buy)\\n        {\\n          \\n            int not_buy=stock(v,1,index+1,dp,fee);\\n            int buy= -v[index]+stock(v,0,index+1,dp,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n          \\n            int sell=v[index]-fee+stock(v,1,index+1,dp,fee);\\n            int not_sell=stock(v,0,index+1,dp,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n      vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n      return stock(prices,1,0,dp,fee);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n         //lest cobvert int memo\\n        vector<vector<int>>dp(prices.size()+1,vector<int>(2,0));\\n        int n=prices.size();\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            for(int buy=0;buy<2;buy++)\\n            {\\n         int profit=0;\\n        \\n        if(buy)\\n        {\\n           \\n            int not_buy= dp[index+1][1];\\n            int buy= -prices[index]+ dp[index+1][0];\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n            \\n            int sell=prices[index]-fee+dp[index+1][1];\\n            int not_sell=dp[index+1][0];\\n            profit=max(sell,not_sell);\\n        }\\n       dp[index][buy]=profit;\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n       \\n        \\n        int n=prices.size();\\n       \\n      vector<int>ahead(2,0);\\n      vector<int>curr(2,0);\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            curr[1]=max(-prices[index]+ ahead[0],ahead[1]);\\n      \\n          curr[0]=max(prices[index]-fee+ahead[1],ahead[0]);\\n          \\n        ahead=curr;\\n            }\\n        \\n\\n        return curr[1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112089,
                "title": "best-time-to-buy-sell-stock-w-fee-js-python-java-c-state-machine-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis proplem is an introduction to **state machine** logic. In order to solve it, we can consider the two possible distinct states of being: having no stock and being ready to buy (**buying**) and owning stock and being ready to sell (**selling**).\\n\\nWe just need to iterate through the prices (**P**) and keep track of the best possible value for these two states of being for each day. The difficulty is that the tracks of the two states cross over regulary.\\n\\nFor example, if we consider the state of being ready to buy stock after this iteration (**buying**), it can be reached from being ready to buy today and doing nothing, ***OR*** it can be reached by being ready to sell today and selling (with the additional fee [**F**]). We just need to pick whichever one yields the best value.\\n\\nThe same is true of the **selling** state. The new **selling** state is the better result between the previous **selling** state with no action and the previous **buying** state with a stock purchase today.\\n\\n![State Machine Visual](https://i.imgur.com/9hpSjmS.png)\\n\\nWe should manually set our initial values for **buying** and **selling** to account for the first day and iterate from there.\\n\\nSince the fee is only administered once per buy/sell pair, we can technically account for it on either side, as we\\'re always going to want to return the **buying** state, having no outstanding stock left to sell.\\n\\n***Question: Should we be worried about updating buying before using it in the second equation?***\\nMathematically, it\\'s only ever a good day to buy ***or*** sell; it cannot be both.\\n\\nConsider the possible situations: In the first equation, if the old **buying** is greater than **selling + P[i] - F**, then the new **buying** will be the same as the old **buying**, so there will be no change for the second equation.\\n\\nBut what if **buying** changes? Let\\'s take an example:\\n```\\n  if:  buying = 10, P[i] = 4, F = 0\\nthen:  newBuying = max(10, selling + 4 - 0)\\n       newSelling = max(selling, newBuying - 4)\\n\\n  if:  selling <= 6                               // For values of selling less than 7\\nthen:  newBuying = max(10, <=10)                  // the old buying will still be largest\\n       newBuying = buying                         // so there\\'s no problem\\n\\n  if:  selling > 6                                // If selling is greater than 6\\nthen:  newBuying = max(10, >6 + 4)                // then buying will change\\n       newBuying = selling + 4                    // so we might have a problem\\n\\n  if:  newBuying = selling + 4                    // But here we see that selling cannot\\nthen:  newSelling = max(selling, selling + 4 - 4) // possibly change when buying does\\n```\\nAny positive value for **F** would only lower the value of **newBuying**, which would only make it so that **newBuying - P[i]** couldn\\'t even tie **selling** but would always be lower.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe code for all four languages is almost identical.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 47.3MB** (beats 98% / 79%).\\n```javascript\\nvar maxProfit = function(P, F) {\\n    let len = P.length, buying = 0, selling = -P[0]\\n    for (let i = 1; i < len; i++) {\\n        buying = Math.max(buying, selling + P[i] - F)\\n        selling = Math.max(selling, buying - P[i])\\n    }\\n    return buying\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **672ms / 21.3MB** (beats 89% / 82%).\\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int], F: int) -> int:\\n        buying, selling = 0, -P[0]\\n        for i in range(1, len(P)):\\n            buying = max(buying, selling + P[i] - F)\\n            selling = max(selling, buying - P[i])\\n        return buying\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 47.8MB** (beats 94% / 99%).\\n```java\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **88ms / 54.9MB** (beats 92% / 98%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P, int F) {\\n        int len = P.size(), buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = max(buying, selling + P[i] - F);\\n            selling = max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  if:  buying = 10, P[i] = 4, F = 0\\nthen:  newBuying = max(10, selling + 4 - 0)\\n       newSelling = max(selling, newBuying - 4)\\n\\n  if:  selling <= 6                               // For values of selling less than 7\\nthen:  newBuying = max(10, <=10)                  // the old buying will still be largest\\n       newBuying = buying                         // so there\\'s no problem\\n\\n  if:  selling > 6                                // If selling is greater than 6\\nthen:  newBuying = max(10, >6 + 4)                // then buying will change\\n       newBuying = selling + 4                    // so we might have a problem\\n\\n  if:  newBuying = selling + 4                    // But here we see that selling cannot\\nthen:  newSelling = max(selling, selling + 4 - 4) // possibly change when buying does\\n```\n```javascript\\nvar maxProfit = function(P, F) {\\n    let len = P.length, buying = 0, selling = -P[0]\\n    for (let i = 1; i < len; i++) {\\n        buying = Math.max(buying, selling + P[i] - F)\\n        selling = Math.max(selling, buying - P[i])\\n    }\\n    return buying\\n};\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int], F: int) -> int:\\n        buying, selling = 0, -P[0]\\n        for i in range(1, len(P)):\\n            buying = max(buying, selling + P[i] - F)\\n            selling = max(selling, buying - P[i])\\n        return buying\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P, int F) {\\n        int len = P.size(), buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = max(buying, selling + P[i] - F);\\n            selling = max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203709,
                "title": "dp-c-solution-with-explaination",
                "content": "The question is to find the max profit on i-th day. If the i-th day is the last day, in order to get the maximum profit, you only have 2 choice: **(1) do nothing; (2) sell**. Because if you buy on the i-th day, you cannot sell it, and you are actually losing money.\\n\\n**(1) Do nothing**. Then the max profit you can earn is the same as the (i-1)-th day. dp[i] = d[i-1];\\n**(2) Sell**. Then you have a lot of choice to buy on j-th day (j<i) and sell on i-th day, and the corresponding profit is d[j] + prices[i] - prices[j] - fee.\\nAnd you can find the maximum of all those choices. However, I tried, I got a time limited exceeded.\\nThen we have to reduce the calculation during finding the maximum, which is the same as find the maximum of d[j] - prices[j] - fee, where j < i. It is easy to see that d[j] - prices[j] - fee is the money left after you buy on j-th. \\nSo the code is as follows:\\n\\n\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int dp[n] = {0}; //maximum profit\\n        int max_prof = dp[0] - prices[0] - fee;\\n        \\n        for(int i = 1; i<n; i++){\\n            dp[i] = max(dp[i-1], max_prof + prices[i]); //do nothing or sell\\n            max_prof = max(max_prof, dp[i] - prices[i] - fee);\\n        }\\n        \\n        return dp[n-1];\\n        \\n    }\\n};\\n\\n\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int dp[n] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 1430329,
                "title": "recursion-memoization-proper-intuition-well-commented-c",
                "content": "In the discussion section everyone has posted the bottom up solution , which i believe is not the good approach to go directly , we should understand the intuition make the recusive code and then go for bottom up.\\nso i decided to post my recursive + memoization solution\\n\\n```\\nclass Solution {\\npublic:\\n    //time:o(2*N) ==>o(N)\\n    //space:O(2*n) \\n    //this 2 in complexity is due to the state \\'BOUGHT\\' it can have two value true or false\\n    int maxans(vector<int> &prices,int fee,int day,bool bought,vector<vector<int>> &dp)\\n    {\\n        //basecase \\n        if(day>=prices.size())\\n            return 0;\\n        \\n        if(dp[day][bought]!=-1)\\n            return dp[day][bought];\\n        \\n        //##############   OPTION 1: do nothing on this day ########################\\n            //just simply increase the day number and do nothing\\n        int donothing = maxans(prices,fee,day+1,bought,dp);\\n        \\n        //################ OPTION 2: do something ############################\\n        int dosomething;\\n        //we can do only two thing either we can sell or buy\\n        //but for that we have condition of not involving in multiple transaction\\n        //so we will go according to that\\n        \\n        //if we are holding a stock==> then sell\\n        if(bought)\\n        {\\n            //           profit with fee deduct + profit from remaining\\n            dosomething = (prices[day]-fee) + maxans(prices,fee,day+1,false,dp);\\n        }\\n        //we are not holding any stock ==>then buy\\n        else\\n        {\\n            //           profit by buying + profit from remaining\\n            dosomething = -prices[day]+maxans(prices,fee,day+1,true,dp);\\n        }\\n        \\n        //finally the maximum of doing and notdoing\\n        return dp[day][bought] = max(donothing,dosomething);\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n        vector<vector<int>> dp(prices.size(),vector<int>(2,-1));\\n        //dp matrix is like N rows and two columns\\n        //calling the function from day 0\\n        return maxans(prices,fee,0,0,dp);\\n        \\n    }\\n};\\n```\\n**DO UPVOTE IF YOU FOUND THIS HELPFUL**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //time:o(2*N) ==>o(N)\\n    //space:O(2*n) \\n    //this 2 in complexity is due to the state \\'BOUGHT\\' it can have two value true or false\\n    int maxans(vector<int> &prices,int fee,int day,bool bought,vector<vector<int>> &dp)\\n    {\\n        //basecase \\n        if(day>=prices.size())\\n            return 0;\\n        \\n        if(dp[day][bought]!=-1)\\n            return dp[day][bought];\\n        \\n        //##############   OPTION 1: do nothing on this day ########################\\n            //just simply increase the day number and do nothing\\n        int donothing = maxans(prices,fee,day+1,bought,dp);\\n        \\n        //################ OPTION 2: do something ############################\\n        int dosomething;\\n        //we can do only two thing either we can sell or buy\\n        //but for that we have condition of not involving in multiple transaction\\n        //so we will go according to that\\n        \\n        //if we are holding a stock==> then sell\\n        if(bought)\\n        {\\n            //           profit with fee deduct + profit from remaining\\n            dosomething = (prices[day]-fee) + maxans(prices,fee,day+1,false,dp);\\n        }\\n        //we are not holding any stock ==>then buy\\n        else\\n        {\\n            //           profit by buying + profit from remaining\\n            dosomething = -prices[day]+maxans(prices,fee,day+1,true,dp);\\n        }\\n        \\n        //finally the maximum of doing and notdoing\\n        return dp[day][bought] = max(donothing,dosomething);\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n        vector<vector<int>> dp(prices.size(),vector<int>(2,-1));\\n        //dp matrix is like N rows and two columns\\n        //calling the function from day 0\\n        return maxans(prices,fee,0,0,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639789,
                "title": "intuitive-dp-solution-using-finite-state-machine",
                "content": "## Finite-State Machine Intuition\\n\\n![image](https://assets.leetcode.com/users/images/89ca4245-f21d-44c5-aa0c-38042ff08512_1640109778.9027212.jpeg)\\n\\nWe can represent this problem using only two states:\\n* **S0** : Can buy\\n* **S1** : Can sell\\n\\nWhere the transition between those states is based on the action taken on the current state:\\n* We can only **Buy** if we are on **S0**, and hence transition to **S1**\\n* We can only **Sell** if we are on **S1**, and hence transition to **S0**\\n* Or we simply **Wait**  (do nothing) to stay on the same state \\n\\n---\\n\\n## Calculating Profit\\nWe can calculate the maximum profit of a state at time **i** by:\\n* **S0** : (**Wait** at **S0**)  or (**Sell** from **S1**, *don\\'t forget to pay the fees*)\\n```\\ns0[i] = max(s0[i-1], s1[i-1] + prices[i] - fee) \\n```\\n* **S1** : (**Wait** at **S1**)  or (**Buy** from **S0**)\\n```\\n s1[i] = max(s1[i-1], s0[i-1] - prices[i]) \\n```\\n\\n### Maximum Profit\\nThen we can get the maximum profit from the last day at **S0**: `s0[-1]`, since we know that selling leaves us with more profit than buying, right?\\n\\n---\\n\\n## Defining the Base Case\\n\\nAt the beginning, we don\\'t have any stock to sell yet, so we initialize **S0** to zero:\\n```\\ns0[0] = 0\\n```\\nWe can buy from the first day `prices[0]`, and hence we initialize **S1** to:\\n```\\ns1[0] = -prices[0]\\n```\\n\\n---\\n\\n## The Code!\\n```\\ndef maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        s0 = [0 for i in range(len(prices))]\\n        s1 = [0 for i in range(len(prices))]\\n\\t\\t\\n\\t\\t# Set our base case\\n\\t\\ts0[0] = 0\\n\\t\\ts1[0] = -prices[0]\\n\\t\\t\\n        for i in range(1, len(prices)):\\n            s0[i] = max(s0[i-1], s1[i-1] + prices[i] - fee)\\n            s1[i] = max(s1[i-1], s0[i-1] - prices[i])\\n        return s0[-1]\\n```\\n\\n\\n## Optimizing Space, O(1)\\n\\n```\\ndef maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        s0 = 0\\n        s1 = -prices[0]\\n        for i in range(1, len(prices)):\\n            prev_s0 = s0\\n            s0 = max(s0, s1 + prices[i] - fee)\\n            s1 = max(s1, prev_s0 - prices[i])\\n        return s0\\n```\\n\\n---\\n\\n> Note: This solution was inspired by [@npvinhphat](https://leetcode.com/npvinhphat/)\\'s solution for problem: [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/) \\u2764\\uFE0F",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ns0[i] = max(s0[i-1], s1[i-1] + prices[i] - fee) \\n```\n```\\n s1[i] = max(s1[i-1], s0[i-1] - prices[i]) \\n```\n```\\ns0[0] = 0\\n```\n```\\ns1[0] = -prices[0]\\n```\n```\\ndef maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        s0 = [0 for i in range(len(prices))]\\n        s1 = [0 for i in range(len(prices))]\\n\\t\\t\\n\\t\\t# Set our base case\\n\\t\\ts0[0] = 0\\n\\t\\ts1[0] = -prices[0]\\n\\t\\t\\n        for i in range(1, len(prices)):\\n            s0[i] = max(s0[i-1], s1[i-1] + prices[i] - fee)\\n            s1[i] = max(s1[i-1], s0[i-1] - prices[i])\\n        return s0[-1]\\n```\n```\\ndef maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        s0 = 0\\n        s1 = -prices[0]\\n        for i in range(1, len(prices)):\\n            prev_s0 = s0\\n            s0 = max(s0, s1 + prices[i] - fee)\\n            s1 = max(s1, prev_s0 - prices[i])\\n        return s0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1112112,
                "title": "python-another-dp-solution-explained",
                "content": "Let us define `diff[i] = B[i+1] - B[i]`. Then we need to find maximum gain for several continuous subarrays, where we pay fee for each subarray. Let us consider it on example:\\n`[1, 3, 5, 4, 8, 7, 4]`, then differences will be `[2, 2, -1, 4, -1, -3]`. For example we can take two subarrays `[2, 2]` and `[4]`, it means we make two trancastions and we need to pay `2` fees. In original array it means we buy at price `1`, then sell at price `5`. Then buy at price `4` and sell at price `8`.\\n\\nUse dynamic programming, where `dp[i]` is maximum gain at `i`-th moment of time if we use `diff[i]` and `sp[i]` be maximum among `dp[0], ..., dp[i]`, that is running maximum, that is `sp[i]` is the gain we can get, using first `i` times.\\nThen we can have `2` options:\\n\\n1. We continue last subarray, so we get `diff[i] + dp[i-1]`.\\n2. We start new subarray, so we get `diff[i] + sp[i-2] - fee`: here we take `sp[i-2]`, because we need to skip one element, so subarrays are separated.\\n\\nLet us look at our example with differences `[2, 2, -1, 4, -1, -3]`:\\n\\n1.`dp[0]` is the maximum gain we can get using ony first difference, we can have `2` and we need to pay fee, so we have `1`.\\n2.`dp[1]` is maxumum gain we can get using `[2, 2]`. We can continue previous transaction, so we will gain `3`. Or we can try to start new transaction. However it is not possible, because we need to have a gap here.\\n3.`dp[2]` is maximum gain we can get using `[2, 2, -1]`. Note, that by definition of `dp[i]` we need to use last element here, so again we have two choices: if we continue first transaction, we have `3-1 = 2` gain. Or we start new transaction, and then we need to make gap and previous transaction will be for element `i-2` or smaller. Exaclty for this we use `sp`: running maximum of `dp`. In our case `sp[0] = 1`, so total gain if we start new transaction is `sp[0] - fee + -1 = -1`.\\n4.`dp[3]` is maximum gain we can get using `[2, 2, -1, 4]`. Again, we can have two choices: continue last transaction, in this case we have `dp[2] + 4 = 6`. If we start new transaction, we have `sp[1] - fee + 4 = 6` as well. So in this case does not matter, what option we choose and it makes sence: fee is equal to decrease of price.\\n5.`dp[4]` is maximum gain we can get using `[2, 2, -1, 4, -1]`. Again, we have choice between `dp[3] + -1 = 5` and `sp[2] - fee + -1 = 4`.\\n6.`dp[5]` is maximum gain we can get using `[2, 2, -1, 4, -1, -3]`. We have either `dp[4] + -3 = 2` or `sp[3] - fee + -3 = 2`.\\n\\nFinally, we have arrays like this:\\n\\n`dp = [1, 3, 2, 6, 5, 2, -inf]`\\n`sp = [1, 3, 3, 6, 6, 6, 0]`\\n\\n**Complexity**: time and space complexity is `O(n)`, where space complexity can be reduced to `O(1)`, because we use only `2` elements to the back.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, B, fee):\\n        if len(B) == 1: return 0\\n        n = len(B)\\n        \\n        dp, sp = [-float(inf)]*n, [0]*n\\n\\n        for i in range(n-1):\\n            dp[i] = B[i+1] - B[i] + max(dp[i-1], sp[i-2] - fee)\\n            sp[i] = max(sp[i-1], dp[i])\\n             \\n        return sp[-2] \\n```\\n\\nOther buy and sell stock problems with my explanations:\\n\\n**121: Best Time to Buy and Sell Stock**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/851941/Python-O(n)-dynamic-programming-solution-explained\\n\\n**123. Best Time to Buy and Sell Stock III**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/794633/Python-O(n)-solution-with-optimization-explained\\n\\n**188. Best Time to Buy and Sell Stock IV**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/900151/Python-O(nk)-dynamic-programming-explained\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, B, fee):\\n        if len(B) == 1: return 0\\n        n = len(B)\\n        \\n        dp, sp = [-float(inf)]*n, [0]*n\\n\\n        for i in range(n-1):\\n            dp[i] = B[i+1] - B[i] + max(dp[i-1], sp[i-2] - fee)\\n            sp[i] = max(sp[i-1], dp[i])\\n             \\n        return sp[-2] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 759089,
                "title": "c-top-down-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[50001][2];\\n    \\n    int ff(vector<int>& prices, int f, int i, bool bought) {\\n        if (i == prices.size()) return 0;\\n        \\n        /*\\n        Decisions :\\n        1. If bought -> then sell at price[i]\\n        2. If not bought -> then buy at price[i]\\n        3. Do nothing (neither buy or sell)\\n        */\\n        \\n        if ( dp[i][bought] != -1) return dp[i][bought];\\n        int profit = INT_MIN;\\n        if (bought) {\\n            // Sell, profit = +prices[i]\\n            profit = max(profit, ff(prices, f, i + 1, false) + prices[i]);\\n        }\\n        else {\\n            // Buy, profit = -prices[i] -fee\\n            profit = max(profit, ff(prices, f, i + 1, true) - prices[i] - f);\\n        }\\n        profit = max(profit, ff(prices, f, i + 1, bought));\\n        return dp[i][bought] = profit;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp, -1, sizeof dp);\\n        return ff(prices, fee, 0, false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[50001][2];\\n    \\n    int ff(vector<int>& prices, int f, int i, bool bought) {\\n        if (i == prices.size()) return 0;\\n        \\n        /*\\n        Decisions :\\n        1. If bought -> then sell at price[i]\\n        2. If not bought -> then buy at price[i]\\n        3. Do nothing (neither buy or sell)\\n        */\\n        \\n        if ( dp[i][bought] != -1) return dp[i][bought];\\n        int profit = INT_MIN;\\n        if (bought) {\\n            // Sell, profit = +prices[i]\\n            profit = max(profit, ff(prices, f, i + 1, false) + prices[i]);\\n        }\\n        else {\\n            // Buy, profit = -prices[i] -fee\\n            profit = max(profit, ff(prices, f, i + 1, true) - prices[i] - f);\\n        }\\n        profit = max(profit, ff(prices, f, i + 1, bought));\\n        return dp[i][bought] = profit;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp, -1, sizeof dp);\\n        return ff(prices, fee, 0, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652623,
                "title": "c-4-approach-recursion-memoisation-tabulation-space-optimsation",
                "content": "Approach 1:-Recursion(TLE)\\n```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n       \\n        int profit=0;\\n        \\n        if(buy)\\n        {\\n            \\n            int not_buy=stock(v,1,index+1,fee);\\n            int buy= -v[index]+stock(v,0,index+1,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n         \\n            int sell=v[index]-fee+stock(v,1,index+1,fee);\\n            int not_sell=stock(v,0,index+1,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n    \\n      return stock(prices,1,0,fee);\\n    }\\n};\\n```\\n\\n\\nApproach 2-Memoisation(\\u2705\\u2705Accepted)\\n```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,vector<vector<int>>&dp,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[index][buy]!=-1)\\n        {\\n            return dp[index][buy];\\n        }\\n        int profit=0;\\n       \\n        if(buy)\\n        {\\n          \\n            int not_buy=stock(v,1,index+1,dp,fee);\\n            int buy= -v[index]+stock(v,0,index+1,dp,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n          \\n            int sell=v[index]-fee+stock(v,1,index+1,dp,fee);\\n            int not_sell=stock(v,0,index+1,dp,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n      vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n      return stock(prices,1,0,dp,fee);\\n    }\\n};\\n```\\nApproach 3:-\\u2705\\u2705 Tabulation(Accepted\\u2705)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n         //lest cobvert int memo\\n        vector<vector<int>>dp(prices.size()+1,vector<int>(2,0));\\n        int n=prices.size();\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            for(int buy=0;buy<2;buy++)\\n            {\\n         int profit=0;\\n        \\n        if(buy)\\n        {\\n           \\n            int not_buy= dp[index+1][1];\\n            int buy= -prices[index]+ dp[index+1][0];\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n            \\n            int sell=prices[index]-fee+dp[index+1][1];\\n            int not_sell=dp[index+1][0];\\n            profit=max(sell,not_sell);\\n        }\\n       dp[index][buy]=profit;\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n};\\n```\\nApproach 4 :Tabulation neglecting for loop of buy conditions\\u2705Accepted)\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n         \\n        vector<vector<int>>dp(prices.size()+1,vector<int>(3,0));\\n        int n=prices.size();\\n       \\n      \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            dp[index][1]=max(-prices[index]+ dp[index+1][0],dp[index+1][1]);\\n      \\n           dp[index][0]=max(prices[index]-fee+dp[index+1][1],dp[index+1][0]);\\n            }\\n        \\n //    return stock(v,1,0,dp);\\n        return dp[0][1];\\n    }\\n};\\n```\\nApproach 5:\\u2705\\u2705space optimsisation using ahead and curr vector(\\u2705Accepted)\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n       \\n        \\n        int n=prices.size();\\n       \\n      vector<int>ahead(2,0);\\n      vector<int>curr(2,0);\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            curr[1]=max(-prices[index]+ ahead[0],ahead[1]);\\n      \\n          curr[0]=max(prices[index]-fee+ahead[1],ahead[0]);\\n          \\n        ahead=curr;\\n            }\\n        \\n\\n        return curr[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n       \\n        int profit=0;\\n        \\n        if(buy)\\n        {\\n            \\n            int not_buy=stock(v,1,index+1,fee);\\n            int buy= -v[index]+stock(v,0,index+1,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n         \\n            int sell=v[index]-fee+stock(v,1,index+1,fee);\\n            int not_sell=stock(v,0,index+1,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n    \\n      return stock(prices,1,0,fee);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     int stock(vector<int>&v,int buy,int index,vector<vector<int>>&dp,int fee)\\n    {\\n        if(index==v.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[index][buy]!=-1)\\n        {\\n            return dp[index][buy];\\n        }\\n        int profit=0;\\n       \\n        if(buy)\\n        {\\n          \\n            int not_buy=stock(v,1,index+1,dp,fee);\\n            int buy= -v[index]+stock(v,0,index+1,dp,fee);\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n          \\n            int sell=v[index]-fee+stock(v,1,index+1,dp,fee);\\n            int not_sell=stock(v,0,index+1,dp,fee);\\n            profit=max(sell,not_sell);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n      vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n      return stock(prices,1,0,dp,fee);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n         //lest cobvert int memo\\n        vector<vector<int>>dp(prices.size()+1,vector<int>(2,0));\\n        int n=prices.size();\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            for(int buy=0;buy<2;buy++)\\n            {\\n         int profit=0;\\n        \\n        if(buy)\\n        {\\n           \\n            int not_buy= dp[index+1][1];\\n            int buy= -prices[index]+ dp[index+1][0];\\n            profit=max(buy,not_buy);\\n        }\\n        else\\n        {\\n            \\n            int sell=prices[index]-fee+dp[index+1][1];\\n            int not_sell=dp[index+1][0];\\n            profit=max(sell,not_sell);\\n        }\\n       dp[index][buy]=profit;\\n            }\\n        }\\n\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n         \\n        vector<vector<int>>dp(prices.size()+1,vector<int>(3,0));\\n        int n=prices.size();\\n       \\n      \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            dp[index][1]=max(-prices[index]+ dp[index+1][0],dp[index+1][1]);\\n      \\n           dp[index][0]=max(prices[index]-fee+dp[index+1][1],dp[index+1][0]);\\n            }\\n        \\n //    return stock(v,1,0,dp);\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n       \\n        \\n        int n=prices.size();\\n       \\n      vector<int>ahead(2,0);\\n      vector<int>curr(2,0);\\n     \\n        for(int index=n-1;index>=0;index--)\\n        {\\n            curr[1]=max(-prices[index]+ ahead[0],ahead[1]);\\n      \\n          curr[0]=max(prices[index]-fee+ahead[1],ahead[0]);\\n          \\n        ahead=curr;\\n            }\\n        \\n\\n        return curr[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289870,
                "title": "dp-2-statuses-o-1-in-space-and-o-n-in-time-very-easy-to-understand",
                "content": "Let\\'s define ***your property = the profit you got in hand + the value of your share***\\ndp[0] is the most property you can have now, and you don\\'t hold any share on your hand\\ndp[1] is the most property you can have now, and you do hold share\\nBuying share doesn\\'t change your property because you are just transfering you money\\n**share growth = today\\'s price - yesterday\\'s price**\\n\\ndp[0] in current day is the max of\\n* **dp[0] in previous day** (if you didn\\'t hold share yesterday and nothing changes)\\n* **dp[1] in previous day + share growth - transaction fee** (if you sell out your share today)\\n\\ndp[1] in current day is the max of\\n* **dp[0] in previous day** (if you buy share today, nothing changes)\\n* **dp[1] in previous day + share growth**(if you held share yesterday and you just keep it in hand)\\n\\nNo matter you buy share or not in the first day, your total property is initialled as 0\\nThe result is dp[0] in the last day\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        dp=[0,0]\\n        for i in range(1,len(prices)):\\n            grow=prices[i]-prices[i-1]\\n            dp[0],dp[1]=max(dp[0],dp[1]+grow-fee),max(dp[0],dp[1]+grow)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        dp=[0,0]\\n        for i in range(1,len(prices)):\\n            grow=prices[i]-prices[i-1]\\n            dp[0],dp[1]=max(dp[0],dp[1]+grow-fee),max(dp[0],dp[1]+grow)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349447,
                "title": "greedy-o-n-one-pass-c-clean-code-with-description",
                "content": "Hi there, \\n\\nSolution is based on following observations.\\nAt each step we either can:\\n- Start range by bying at minimum price;\\n- Extend range by neither selling nor buying;\\n- End range by selling at maximum price;\\n\\nRange is sequence of prices that starts from the minimum, contains **max - min > fee** and ends when we reach next range or the end of array.\\n\\nEssential question is when to start new range and end previous.\\nIt is always profitable to start new range if a[i] - max > fee.\\n\\nSolutions is below:\\n\\n\\n```\\n    int maxProfit(vector<int>& a, int fee) \\n    {\\n        int profit = 0;\\n        int mn = a[0], mx = a[0];\\n        for(int i = 1; i < a.size(); ++i)\\n        {\\n            // End current range and start new one\\n            if( mx - a[i] > fee && mx - mn > fee)\\n            {\\n                p += mx - mn - fee;\\n                mx = mn = a[i];\\n                continue;\\n            }\\n\\n            // Start new range\\n            if(mn > a[i])\\n            {\\n                mn = a[i];\\n                mx = a[i];\\n            }\\n            else\\n            {\\n                // Extend range\\n                mx = max(mx, a[i]);\\n            }\\n            \\n        }\\n\\n        // Sell what is left\\n        if( mx - mn - fee > 0 )\\n            p += mx - mn - fee;\\n\\n        return p;\\n    }\\n```\\n\\nResults:\\n```\\n\\u221A Accepted\\n  \\u221A 44/44 cases passed (136 ms)\\n  \\u221A Your runtime beats 87.59 % of cpp submissions\\n  \\u221A Your memory usage beats 95.04 % of cpp submissions (14.9 MB)\\n```\\n  \\nHope description is easy to understand.\\nIf you find post useful, please upvote.\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    int maxProfit(vector<int>& a, int fee) \\n    {\\n        int profit = 0;\\n        int mn = a[0], mx = a[0];\\n        for(int i = 1; i < a.size(); ++i)\\n        {\\n            // End current range and start new one\\n            if( mx - a[i] > fee && mx - mn > fee)\\n            {\\n                p += mx - mn - fee;\\n                mx = mn = a[i];\\n                continue;\\n            }\\n\\n            // Start new range\\n            if(mn > a[i])\\n            {\\n                mn = a[i];\\n                mx = a[i];\\n            }\\n            else\\n            {\\n                // Extend range\\n                mx = max(mx, a[i]);\\n            }\\n            \\n        }\\n\\n        // Sell what is left\\n        if( mx - mn - fee > 0 )\\n            p += mx - mn - fee;\\n\\n        return p;\\n    }\\n```\n```\\n\\u221A Accepted\\n  \\u221A 44/44 cases passed (136 ms)\\n  \\u221A Your runtime beats 87.59 % of cpp submissions\\n  \\u221A Your memory usage beats 95.04 % of cpp submissions (14.9 MB)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447840,
                "title": "2-lines-elegant-precise-o-n-solution-o-1-space-no-dp-c",
                "content": "##  1. **EFFICIENT SOLUTION [But Not Intuitive]**\\n* **IT\\'S A TRICKY SOLUTION TO COME UP WITH AT FIRST ATTEMPT. So take a Pen-Paper and DRY Run this Code Step by Step.** \\n* **Runtime : 60ms**\\n\\n**C++ Code :-**\\n```\\n// Idea : We have to hold the CASH to buy the stocks and hold the maximum profit we could have  if we owned a share of stock\\n// Initially we have negative hold cash because we have to buy first before making any profit..\\nint maxProfit(vector<int>& prices, int fee) {\\n\\tint cash = 0, hold = -prices[0];                     // Buy here first stock initially\\n\\tfor(int i = 1; i < prices.size(); ++i){\\n\\t\\tcash = max(cash, hold + prices[i] - fee);        // Sell the stock(s)\\n\\t\\thold = max(hold, cash - prices[i]);             // Buy the stock(s) buy holding as much as profit\\n\\t}\\n\\treturn cash;\\n}\\n```\\n***TIME COMPLEXITY* : `O(N)`, Where, N : size of prices array** \\n***SPACE COMPLEXITY* :  `O(1) [Constant]`,**\\n```\\n```\\n##  2. **DP SOLUTION [MEMOIZATION (intuitive)]**\\n**In this question, we have to skip the next day after buying the stock.**\\n**We have three options or choices for every stock.**\\n\\n**1. Buy the stock**\\n**2. Sell the stock**\\n**3. Skip the stock**\\n\\n**`Note: But from option 1 & 2, only one is valid at a time!, it makes sense also. Either we can buy it Or sell it`**\\n**`However, the option 3 is always available  to us.`**\\n\\nWhere **`bag :`** we have took the stock or not! \\n`bag == 1`, we have taken the stock. \\n`bag == 0,` not taken right now.\\n**Note : Here we just subtract fee also after/with selling the stock.**\\n\\n**C++ Code :-**\\n```\\nclass Solution {\\nprivate: int N;\\nprivate:\\n    int dfs(vector<int> &prices, int idx, int bag, int fee, vector<vector<int>> &memo){\\n        if(idx >= N) return 0;\\n        if(memo[idx][bag] != -1) return memo[idx][bag];\\n        if(bag == 1){\\n            int sellIt = (prices[idx] - fee) + dfs(prices, idx + 1, 0, fee, memo);\\n            int skipIt = dfs(prices, idx + 1, 1, fee, memo);\\n            return memo[idx][bag] = max(sellIt, skipIt);\\n        }else{\\n            int buyIt = -prices[idx] + dfs(prices, idx + 1, 1, fee, memo);\\n            int skipIt = dfs(prices, idx + 1, 0, fee, memo);\\n            return memo[idx][bag] = max(buyIt, skipIt);\\n        }\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        N = prices.size();\\n        vector<vector<int>> memo(N + 1, vector<int>(2, -1));\\n        return dfs(prices, 0, 0, fee, memo);\\n    }\\n};\\n```\\n***TIME COMPLEXITY* : `O(N)`, Where N : size of prices array** \\n***SPACE COMPLEXITY* :  `O(N * 2) == O(N)`, for using memo**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense Pls **Upvote :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Idea : We have to hold the CASH to buy the stocks and hold the maximum profit we could have  if we owned a share of stock\\n// Initially we have negative hold cash because we have to buy first before making any profit..\\nint maxProfit(vector<int>& prices, int fee) {\\n\\tint cash = 0, hold = -prices[0];                     // Buy here first stock initially\\n\\tfor(int i = 1; i < prices.size(); ++i){\\n\\t\\tcash = max(cash, hold + prices[i] - fee);        // Sell the stock(s)\\n\\t\\thold = max(hold, cash - prices[i]);             // Buy the stock(s) buy holding as much as profit\\n\\t}\\n\\treturn cash;\\n}\\n```\n```\\n```\n```\\nclass Solution {\\nprivate: int N;\\nprivate:\\n    int dfs(vector<int> &prices, int idx, int bag, int fee, vector<vector<int>> &memo){\\n        if(idx >= N) return 0;\\n        if(memo[idx][bag] != -1) return memo[idx][bag];\\n        if(bag == 1){\\n            int sellIt = (prices[idx] - fee) + dfs(prices, idx + 1, 0, fee, memo);\\n            int skipIt = dfs(prices, idx + 1, 1, fee, memo);\\n            return memo[idx][bag] = max(sellIt, skipIt);\\n        }else{\\n            int buyIt = -prices[idx] + dfs(prices, idx + 1, 1, fee, memo);\\n            int skipIt = dfs(prices, idx + 1, 0, fee, memo);\\n            return memo[idx][bag] = max(buyIt, skipIt);\\n        }\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        N = prices.size();\\n        vector<vector<int>> memo(N + 1, vector<int>(2, -1));\\n        return dfs(prices, 0, 0, fee, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326821,
                "title": "complete-explanation-of-the-buy-and-sell-stock-problems-using-dp",
                "content": "I will be going over what I have learned while trying to solve these problems. I was initially using `Kadane\\'s algorithm` to do these problems. Infact, completed the first, second, and third **Buy and Sell Stock problems** using Kadane\\'s but the fourth problem gave me a concussion so, I embarked on a journey to learn a framework using which I can solve the complete set of these problems and handle any tweaks that an interviewer might throw at me in the future. I visited a number of resources, watched a number of videos and here is the culmination of everything I have picked so far.\\n\\nThese are all the problems we have in the Buy and Sell Stock set.\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n4. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n5. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n6. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n\\nFirst, we will see how we can come up with a framework which we can apply for all the above problems. A framework which is flexible enough to accomodate any tweaks an interviewer might throw at us in the future. *A framework which exhausts all the possible outcomes and then come up with the best solution*. A recursive solution would be exhaustive but we will use \"states\" for exhaustion in these problems. **We will consider each day and see how many possible \"states\" do we have for each day and then find \"choices\" corresponding to each state.**\\n\\n**Let\\'s talk about the constraints first.**\\n1. `Sell` must be after `Buy`.\\n2. `Buy` must be after `Sell`.\\n3.  Limit on the number of transaction(k), `k>0`.\\n\\n**For each day we have three choices.**\\n1. `Buy`.\\n2. `Sell`.\\n3. `Rest`. Which further has two states.\\n\\t a. `Rest after buy`. Here we are holding the stock. We are not selling or buying. We are just resting.\\n\\t b. `Rest after selling`. Here we are not holding any stocks. We are not selling or buying. We are just resting.\\n\\n**Let\\'s talk about the states now.**\\n1. The day we are on i.e `i`.\\n2. The maximum number of allowed transactions i.e `k`.\\n3. The holding state i.e the resting state we talked about before. This is either `1(holding stock)` or `0(not holding stock)`.\\n\\nNow, we can put all the combinations of these states in a 3D matrix like so :\\n\\n```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\\n\\n\\n***For every problem we have to find the `dp[n-1][k][0]`, which is the maximum profit for the maximum number of transactions allowed on the last day.***\\n\\nOne important observation. Why didn\\'t we say **`dp[n-1][k][1]`** instead of saying **`dp[n-1][k][0]`**? because if the resting state `S` is 1, it means we are still holding a stock and the profit cannot be maximum until and unless we are done selling all the stocks we have.\\n\\n\\n\\n\\nNow, let\\'s think about what choices do we have for each state and how we can update the \"state\". Let\\'s write our state transition equations. They will be something like this.\\n\\n`dp[i][k][0] = Max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // prices is the array of stocks`\\n\\n***This equation corresponds to when you are not holding a stock. You are not holding a stock today because perhaps you didn\\'t have any stocks yesterday which we could sell today or maybe you have stocks that you want to sell today, so at the end of the day we will not be holding any stocks.***\\n\\n`dp[i][k][1] = Max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`\\n\\n***This equation corresponds to when you are holding a stock. You are holding a stock today because perhaps you had stocks yesterday or maybe you want to buy stocks today, so at the end of the day we will be holding stocks.***\\n\\n***This explanation should be clear. If you buy, you need to subtract prices[i] from the profit, and if you sell, you need to increase prices[i] to the profit.***\\n\\n\\nNow, let\\'s talk about the base cases.\\n\\n1. `dp[-1][k][0]  = 0`     **// Because the day starts with 0 and here i is -1**\\n2. `dp[-1][k][1] = -Infinity`  **// Because we can\\'t hold any stocks before the first day**\\n3. `dp[i][0][0] = 0`  **// Because k = 0. There won\\'t be any transactions so the profit will be zero** \\n4. `dp[i][0][1] = -Infinity`  **// Because k = 0. We can\\'t hold any stocks without starting a transaction** \\n\\n\\nSo, to summarize the above base conditions and state transition equations\\n\\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\\n\\n\\nNow, let\\'s begin with the problems.\\n\\n1. ***When k = 1***\\n\\nWe will put k = 1 directly in the state transition equations and see for ourselves.\\n\\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\\n\\nWe can also see that the presence of k when it is 1 does not change the state in any way so, we can simply ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\\n\\nWe can write the solution for it like so:\\n\\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\\n\\n***We can reduce the Space complexity to 0(1) by not constructing the DP matrix as the new state is only related to an adjacent state. So, instead of the DP matrix we can store the states in a single variable. One variable for not holding and one for holding.***\\n\\nCode for that would look something like :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\\n\\n2. ***When k = + Infinity***\\n\\nWhen k is Infinity, k and k-1 are practically the same. We will use that in our state transition equations.\\n\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\\n\\nSince, the presence of k is not really impacting the states, we will ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\\n\\nAnd the solution would look like this : \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n3. ***When k = 2***\\n\\nNow, we need to exhaust the value of k as well. Before this we were ignoring k because it was not impacting our states. We need to hold the states for the second transaction as well along with the first transaction. \\n\\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\\n\\nThe solution would look like this :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\\n\\n\\n4. ***When k = + interger***\\n\\n**Important observation** : A transaction consists of buying and selling, which takes atleast 2 days. Therefore, the effective limit k should not exceed n/2( n is the number of days). If it exceeds, there is no contraint effect which makes k equivalent to +Infinity.\\n\\nThis is the only problem from this set which is a little difficult.\\n\\nSolution would look like this \\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\\n\\n5. ***When k = +Infinity with cooldown***\\n\\nWe must wait one day after selling a stock to continue trading. We can write the state transition equations as :\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\\n\\nCode would look like \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n\\n6. ***When k = +Infinity with transaction fee***\\n\\nSince now we need to pay some fee for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\\n\\nCode can we written as  :\\n\\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\nI hope you enjoyed this post.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802592,
                "title": "python-o-n-by-dp-w-visualization",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=QfpGxJohu2E)\\n\\nPython O(n) by DP + State machine\\n\\n---\\n\\n**Hint**:\\n\\nSimilar to [Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/), this time, we have to pay extra transaction fee for each pair of trade (i.e., one set of buy-hold-sell).\\n\\nWhen selling: \\nWe sell out stock, and get the money at sell price.\\n\\nWhen **buying**:\\nWe buy in stock, and **pay** the **money for stock** as well as the **money for transaction fee**.\\n\\n---\\n\\n**State machine diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/0a25bbd8-0a4c-45cf-aa38-e56eabde0a62_1597941209.8898816.png)\\n\\n\\n---\\n\\n**Complexity analysis**:\\n\\nTime complexity: O( n ) on for loop iteration\\n\\nSpace complexity: O( 1 ) we only need fixed size temp variables.\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        dp_hold, dp_not_hold = -float(\\'inf\\'), 0\\n        \\n        for stock_price in prices:\\n            \\n            prev_hold, prev_not_hold = dp_hold, dp_not_hold\\n            \\n            # either keep not hold, or sell out today at stock price\\n            dp_not_hold = max(prev_not_hold, prev_hold + stock_price)\\n            \\n            # either keep hold, or buy in today at stock price and pay transaction fee for this trade\\n            dp_hold = max(prev_hold, prev_not_hold - stock_price - fee)\\n        \\n        # maximum profit must be in not-hold state\\n        return dp_not_hold\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\nIt\\'s quite similar to this one,\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n\\n---\\n\\nStock-family\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        dp_hold, dp_not_hold = -float(\\'inf\\'), 0\\n        \\n        for stock_price in prices:\\n            \\n            prev_hold, prev_not_hold = dp_hold, dp_not_hold\\n            \\n            # either keep not hold, or sell out today at stock price\\n            dp_not_hold = max(prev_not_hold, prev_hold + stock_price)\\n            \\n            # either keep hold, or buy in today at stock price and pay transaction fee for this trade\\n            dp_hold = max(prev_hold, prev_not_hold - stock_price - fee)\\n        \\n        # maximum profit must be in not-hold state\\n        return dp_not_hold\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668139,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int c(int buy,vector<int>&price,int fee,int i,vector<vector<int>>&dp){\\n        if(i>=price.size())return 0;\\n        if(dp[i][buy]!=-1)return dp[i][buy];\\n        int not_take = c(buy,price,fee,i+1,dp);\\n        int take=0;\\n        if(buy){\\n            take = c(1-buy,price,fee,i+1,dp) - price[i] - fee;\\n        }\\n        else {\\n            take = price[i] + c(1-buy,price,fee,i+1,dp);\\n        }\\n       return dp[i][buy]= max(take,not_take);\\n    }\\n    int maxProfit(vector<int>& price, int fee) {\\n        vector<vector<int>>dp(price.size(),vector<int>(2,-1));\\n        return c(1,price,fee,0,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/10d9af68-d9eb-4026-a674-f9c9236add9d_1687413419.112083.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c(int buy,vector<int>&price,int fee,int i,vector<vector<int>>&dp){\\n        if(i>=price.size())return 0;\\n        if(dp[i][buy]!=-1)return dp[i][buy];\\n        int not_take = c(buy,price,fee,i+1,dp);\\n        int take=0;\\n        if(buy){\\n            take = c(1-buy,price,fee,i+1,dp) - price[i] - fee;\\n        }\\n        else {\\n            take = price[i] + c(1-buy,price,fee,i+1,dp);\\n        }\\n       return dp[i][buy]= max(take,not_take);\\n    }\\n    int maxProfit(vector<int>& price, int fee) {\\n        vector<vector<int>>dp(price.size(),vector<int>(2,-1));\\n        return c(1,price,fee,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667495,
                "title": "beats-100-video-java-c-python",
                "content": "# Intuition\\nThe 2 things required for a Dynamic Programming Problem i.e We have choices to make on any given day.\\n1. The 3 choices are buy, sell, do nothing.\\n2. The state/profits of any given day depends on what you did past/previous days.\\n\\nThese 2 things leads us in the direction of DP. The entire solution is explained in Video as it is difficult to write entire approach.\\n\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KE2fc0RJ4hU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int free = 0;\\n        int hold = -prices[0];\\n        for(int i:prices){\\n            int tmp = hold;\\n            hold = Math.max(hold, free-i);\\n            free = Math.max(free, tmp+i-fee);\\n        }\\n        return free;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(std::vector<int>& prices, int fee) {\\n        int free = 0;\\n        int hold = -prices[0];\\n        for (int i : prices) {\\n            int tmp = hold;\\n            hold = std::max(hold, free - i);\\n            free = std::max(free, tmp + i - fee);\\n        }\\n        return free;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices, fee):\\n        free = 0\\n        hold = -prices[0]\\n        for i in prices:\\n            tmp = hold\\n            hold = max(hold, free - i)\\n            free = max(free, tmp + i - fee)\\n        return free\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int free = 0;\\n        int hold = -prices[0];\\n        for(int i:prices){\\n            int tmp = hold;\\n            hold = Math.max(hold, free-i);\\n            free = Math.max(free, tmp+i-fee);\\n        }\\n        return free;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(std::vector<int>& prices, int fee) {\\n        int free = 0;\\n        int hold = -prices[0];\\n        for (int i : prices) {\\n            int tmp = hold;\\n            hold = std::max(hold, free - i);\\n            free = std::max(free, tmp + i - fee);\\n        }\\n        return free;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices, fee):\\n        free = 0\\n        hold = -prices[0]\\n        for i in prices:\\n            tmp = hold\\n            hold = max(hold, free - i)\\n            free = max(free, tmp + i - fee)\\n        return free\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112149,
                "title": "best-time-to-buy-and-sell-stock-with-fee-c-solution-simple-code-with-explanation",
                "content": "Here, we have two states,\\n\"**hold**\" state: represent the max profit when we hold a stock at time` i - 1`.\\n\"**sold**\" state: represent the max profit when we do not hold a stock at time `i - 1.`\\n\\nInitially for **hold** we hold one stock so `hold = -prices[0]`, for **sold**, we dont hold any stocks ,so `sold =0`\\nAnd for every iteration `i`, we check, the max profit of **hold** state is either we still hold the stock that we hold at the `i-1 `time or we buy new stock i,e, `hold = max(hold,sold - prices[i])`\\nand also,  the max profit of **sold** state is either we still keep our` profit =0`  or we sell the stock we already hold i.e, `sold = max(sold, hold + prices[i] - fee)`\\n\\nFinally,we return **sold**.\\n\\n\\n```\\nint maxProfit(vector<int>& prices, int fee) {\\n        if (prices.size() < 2) return 0;\\n        int sold = 0, hold = 0 - prices[0];\\n        for (int i = 1; i < prices.size(); i++) {\\n            hold = max(hold, sold - prices[i]);\\n            sold = max(sold, hold + prices[i] - fee);\\n        }\\n        return sold;\\n    }\\n```\\n**Please upvote**, if you like the code",
                "solutionTags": [],
                "code": "```\\nint maxProfit(vector<int>& prices, int fee) {\\n        if (prices.size() < 2) return 0;\\n        int sold = 0, hold = 0 - prices[0];\\n        for (int i = 1; i < prices.size(); i++) {\\n            hold = max(hold, sold - prices[i]);\\n            sold = max(sold, hold + prices[i] - fee);\\n        }\\n        return sold;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667733,
                "title": "python-3-4-lines-w-explanation-t-m-84-96",
                "content": "Here\\'s how the code works:\\n\\n- We initialize two variables, `ownShare` and `noShare`. `ownShare` represents the maximum profit that can be achieved if one currently owns a share of the stock, and `noShare` represents the maximum profit that can be achieved if one currently does not own shares of the stock.\\n\\n- The initial values of `ownShare` and`noShare`are based on the first element of the prices array. `ownShare` is set to `-prices[0]` because if one starts by buying a share at the initial price, the profit will be negative (considering the transaction fee). `noShare` is set to 0 because if one does not own any shares initially, the profit will be 0.\\n\\n- We iterate over each price in the prices array.\\n\\n- We update `ownShare` and `noShare` simultaneously using tuple unpacking and the `max` function.\\n\\n- The updated value of `ownShare` is calculated by taking the maximum of the current `ownShare` value and the difference between `noShare` and the current price `(noShare - price`). This represents the maximum profit if you currently own a share and either decide to keep it (no change in `ownShare`) or sell it `(noShare - price)`.\\n\\n- The updated value of `noShare` is calculated by taking the maximum of the current `noShare` value and the sum of `ownShare` and the current price minus the transaction fee `(ownShare + price - fee)`. This represents the maximum profit if one currently does not own any shares and either decide to keep it that way (no change in noShare) or buy a share `(ownShare + price - fee)`.\\n\\n- After the loop, the final value of `noShare`, which represents the maximum profit achievable, is returned as the result.\\n\\n- In summary, the code iterates over the prices of the stock and updates the `ownShare` and `noShare` variables based on whether it is more profitable to own or not own a share at each step, considering the transaction fee. The maximum profit achievable is determined by the final value of `noShare` and is returned as the result. *--ChatGPT*\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: list[int], fee: int) -> int:\\n\\n        ownShare, noShare = -prices[0], 0\\n\\n        for price in prices:\\n            ownShare, noShare = (max(ownShare, noShare-price       ),\\n                                 max( noShare, ownShare + price-fee))\\n\\n        return noShare\\n```\\n[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/976716834/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(prices)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: list[int], fee: int) -> int:\\n\\n        ownShare, noShare = -prices[0], 0\\n\\n        for price in prices:\\n            ownShare, noShare = (max(ownShare, noShare-price       ),\\n                                 max( noShare, ownShare + price-fee))\\n\\n        return noShare\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534868,
                "title": "detailed-explanation-of-all-the-6-problems-of-stock-buy-and-sell",
                "content": "**Please Upvote if you Liked the Post**\\n\\n```\\n/* This is Easy Enough, Just you have to find a lowest point and after that a \\nhighest point and make a transaction to get max profit. In this code we are \\nassuming every day to be a potential selling day and we are registering the max profit , \\nalso if current day stock\\'s price is lower than the price on which we bought the stock\\nthen we update the price to lower price\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int maxProfit = 0;\\n       int costPrice = prices[0];\\n        for(int i = 1;i<prices.length;i++){\\n            maxProfit = Math.max(maxProfit,prices[i] - costPrice);  //this is my potential selling day\\n            if(prices[i] < costPrice) costPrice = prices[i];\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n\\n/*\\nIn this question we can make any number of transaction as we want and we want\\nto collect maximum profit, so what we will do is collect all the upstrokes of the stock \\nprice zigzag graph, so our strategy is simple if prices go up just collect profit and if \\nprice go down then start counting continuos profit again. In this way we collect all the profit \\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        int continuosProfit = 0;\\n        for(int i = 1;i<prices.length;i++){\\n            //if prices go up, don\\'t sell but collect your continuos profit\\n            if(prices[i] > prices[i - 1]){\\n                continuosProfit += (prices[i] - prices[i - 1]);\\n            }else{ //if prices go down,sell previous stock and buy today \\n                maxProfit += continuosProfit; //collected the profit\\n                continuosProfit = 0;\\n            }\\n        }\\n        if(continuosProfit > 0) maxProfit += continuosProfit;\\n        return maxProfit;\\n    }\\n}\\n\\n\\n/*\\nHere two transaction are allowed so what we do is to traverse from left to right\\nand we will consider every day as selling day , so we first update our minimum stock value \\ntill day and then we calculate profit by selling stock today,and then we update our maximum profit \\ntill now and store it. \\n\\nSimilary we traverse from right to left and consider every day as buying day and also maintainig \\nthe maximum stock price from future till now , so we calculate our profit and update max \\nprofit till now ans store it.\\n\\nSo now at every point we have two transactions(non overlapping) one which indicates  \\nthat till now we have sold and gained profit and other signifies that we brought today or\\nlater and sold in future and gained profit, in this way at every point we have two non \\noverlapping transactions. so max of it is our ans.\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //while going form left to right\\n        \\n        int maxleft = 0;\\n        int [] leftMax  = new int[prices.length];\\n        int maxTillNow = 0;\\n        int minTillNow = prices[0];\\n        for(int i = 1;i<prices.length;i++){ //left to right\\n            minTillNow = Math.min(minTillNow,prices[i]);\\n            int profit = prices[i] - minTillNow;\\n            maxleft = Math.max(maxleft,profit);\\n            leftMax[i] = maxleft;\\n        }\\n        \\n        int maxright = 0;\\n        int [] rightMax = new int[prices.length];\\n        maxTillNow = prices[prices.length - 1];\\n        int maxProfitTillNow = 0;\\n        for(int i = prices.length - 2;i>=0;i--){\\n            //everyday is a potential buying day\\n            maxTillNow = Math.max(maxTillNow,prices[i]);\\n            int profit = maxTillNow - prices[i]; \\n            maxProfitTillNow = Math.max(maxProfitTillNow,profit);\\n            rightMax[i] = maxProfitTillNow;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i<prices.length;i++){\\n            ans = Math.max(ans,leftMax[i] + rightMax[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n/*\\nNow we are allowed to do at max k transactions and gain max profit. so we \\nuse dynamic progrraming and use a 2d dp, where the rows indicate number of \\ntransactions allowed and columns indicate the day. At any given cell in 2d dp we\\nhave to store the max profit we can gain by doing at most i transaction till jth day. \\nso at any given cell we have to choose between our options which are , either we\\ndo not do any transaction on ith day so we carry forward the result of i-1 th day where\\nwe have j - 1 transactions allowed.or we can do transaction on ith day. The max of these \\nresults is stored in dp[i][j]\\n*/\\n\\n\\nclass Solution {\\n    public int maxProfit(int l, int[] prices) {\\n        if(l == 0 || prices.length == 0) return 0;\\n        int [][] dp = new int[l + 1][prices.length];\\n        //i represent the number of transactions allowed and j is day\\n        \\n        for(int i = 1;i<dp.length;i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 1;j<dp[0].length;j++){\\n                //we don\\'t do any transaction on jth day or we did transaction on jth day(sold)\\n                max = Math.max(max,dp[i - 1][j - 1] - prices[j - 1]); //storing the max \\n                dp[i][j] = Math.max(max  + prices[j], dp[i][j - 1]);\\n            }\\n        }\\n        \\n        return dp[dp.length - 1][dp[0].length - 1];\\n        \\n    }\\n}\\n\\n/*\\nIn this Question we can do as many Transactions we want But for every Transaction \\nwe have to give transaction fee as well. So we take the strategy of either remain in \\nboughtState or in soldState, boughtState means the latest transaction should be \\nbuying of stock, we can remain in bought state by either carrying forward by last \\nboughtState or by buying share on after the last sell. Similary we can remain in\\nsoldStae either by carrying forward by last soldState or by selling the last bought share.\\n\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int len = prices.length;\\n        int boughtState [] = new int[len];\\n        int soldState [] = new int [len];\\n        \\n        boughtState[0] = -prices[0];\\n        \\n        for(int i = 1;i<len;i++){\\n            boughtState[i] = Math.max(boughtState[i - 1],soldState[i - 1] - prices[i]);\\n            soldState[i] = Math.max(soldState[i - 1],boughtState[i - 1] + prices[i] - fee);\\n        }\\n        \\n        return soldState[len - 1];\\n    }\\n}\\n\\n/*\\nWe use the Same concept in this Question as previous question , \\nonly difference here is that after selling we have to take rest of one day, \\nso we have to tweak the equation little bit in for loop\\n\\n*/\\n\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //after selling the next day should be  mandatory cooldown\\n        if(prices.length == 1) return 0;\\n        if(prices.length == 2) return Math.max(0,prices[1] - prices[0]);\\n        \\n        int [] boughtState = new int[prices.length];\\n        int [] sellState = new int[prices.length];\\n        \\n        boughtState[0] = -prices[0];\\n        sellState[0] = 0;\\n        boughtState[1] = Math.max(boughtState[0],sellState[0] - prices[1]);\\n        sellState[1] = Math.max(sellState[0],boughtState[0] + prices[1]);\\n        \\n        for(int i = 2;i<prices.length;i++){\\n            boughtState[i] = Math.max(boughtState[i - 1],sellState[i - 2] - prices[i]);\\n            sellState[i] = Math.max(boughtState[i - 1] + prices[i],sellState[i - 1]);\\n        }\\n        return sellState[prices.length - 1];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* This is Easy Enough, Just you have to find a lowest point and after that a \\nhighest point and make a transaction to get max profit. In this code we are \\nassuming every day to be a potential selling day and we are registering the max profit , \\nalso if current day stock\\'s price is lower than the price on which we bought the stock\\nthen we update the price to lower price\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int maxProfit = 0;\\n       int costPrice = prices[0];\\n        for(int i = 1;i<prices.length;i++){\\n            maxProfit = Math.max(maxProfit,prices[i] - costPrice);  //this is my potential selling day\\n            if(prices[i] < costPrice) costPrice = prices[i];\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n\\n/*\\nIn this question we can make any number of transaction as we want and we want\\nto collect maximum profit, so what we will do is collect all the upstrokes of the stock \\nprice zigzag graph, so our strategy is simple if prices go up just collect profit and if \\nprice go down then start counting continuos profit again. In this way we collect all the profit \\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        int continuosProfit = 0;\\n        for(int i = 1;i<prices.length;i++){\\n            //if prices go up, don\\'t sell but collect your continuos profit\\n            if(prices[i] > prices[i - 1]){\\n                continuosProfit += (prices[i] - prices[i - 1]);\\n            }else{ //if prices go down,sell previous stock and buy today \\n                maxProfit += continuosProfit; //collected the profit\\n                continuosProfit = 0;\\n            }\\n        }\\n        if(continuosProfit > 0) maxProfit += continuosProfit;\\n        return maxProfit;\\n    }\\n}\\n\\n\\n/*\\nHere two transaction are allowed so what we do is to traverse from left to right\\nand we will consider every day as selling day , so we first update our minimum stock value \\ntill day and then we calculate profit by selling stock today,and then we update our maximum profit \\ntill now and store it. \\n\\nSimilary we traverse from right to left and consider every day as buying day and also maintainig \\nthe maximum stock price from future till now , so we calculate our profit and update max \\nprofit till now ans store it.\\n\\nSo now at every point we have two transactions(non overlapping) one which indicates  \\nthat till now we have sold and gained profit and other signifies that we brought today or\\nlater and sold in future and gained profit, in this way at every point we have two non \\noverlapping transactions. so max of it is our ans.\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //while going form left to right\\n        \\n        int maxleft = 0;\\n        int [] leftMax  = new int[prices.length];\\n        int maxTillNow = 0;\\n        int minTillNow = prices[0];\\n        for(int i = 1;i<prices.length;i++){ //left to right\\n            minTillNow = Math.min(minTillNow,prices[i]);\\n            int profit = prices[i] - minTillNow;\\n            maxleft = Math.max(maxleft,profit);\\n            leftMax[i] = maxleft;\\n        }\\n        \\n        int maxright = 0;\\n        int [] rightMax = new int[prices.length];\\n        maxTillNow = prices[prices.length - 1];\\n        int maxProfitTillNow = 0;\\n        for(int i = prices.length - 2;i>=0;i--){\\n            //everyday is a potential buying day\\n            maxTillNow = Math.max(maxTillNow,prices[i]);\\n            int profit = maxTillNow - prices[i]; \\n            maxProfitTillNow = Math.max(maxProfitTillNow,profit);\\n            rightMax[i] = maxProfitTillNow;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0;i<prices.length;i++){\\n            ans = Math.max(ans,leftMax[i] + rightMax[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n/*\\nNow we are allowed to do at max k transactions and gain max profit. so we \\nuse dynamic progrraming and use a 2d dp, where the rows indicate number of \\ntransactions allowed and columns indicate the day. At any given cell in 2d dp we\\nhave to store the max profit we can gain by doing at most i transaction till jth day. \\nso at any given cell we have to choose between our options which are , either we\\ndo not do any transaction on ith day so we carry forward the result of i-1 th day where\\nwe have j - 1 transactions allowed.or we can do transaction on ith day. The max of these \\nresults is stored in dp[i][j]\\n*/\\n\\n\\nclass Solution {\\n    public int maxProfit(int l, int[] prices) {\\n        if(l == 0 || prices.length == 0) return 0;\\n        int [][] dp = new int[l + 1][prices.length];\\n        //i represent the number of transactions allowed and j is day\\n        \\n        for(int i = 1;i<dp.length;i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 1;j<dp[0].length;j++){\\n                //we don\\'t do any transaction on jth day or we did transaction on jth day(sold)\\n                max = Math.max(max,dp[i - 1][j - 1] - prices[j - 1]); //storing the max \\n                dp[i][j] = Math.max(max  + prices[j], dp[i][j - 1]);\\n            }\\n        }\\n        \\n        return dp[dp.length - 1][dp[0].length - 1];\\n        \\n    }\\n}\\n\\n/*\\nIn this Question we can do as many Transactions we want But for every Transaction \\nwe have to give transaction fee as well. So we take the strategy of either remain in \\nboughtState or in soldState, boughtState means the latest transaction should be \\nbuying of stock, we can remain in bought state by either carrying forward by last \\nboughtState or by buying share on after the last sell. Similary we can remain in\\nsoldStae either by carrying forward by last soldState or by selling the last bought share.\\n\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int len = prices.length;\\n        int boughtState [] = new int[len];\\n        int soldState [] = new int [len];\\n        \\n        boughtState[0] = -prices[0];\\n        \\n        for(int i = 1;i<len;i++){\\n            boughtState[i] = Math.max(boughtState[i - 1],soldState[i - 1] - prices[i]);\\n            soldState[i] = Math.max(soldState[i - 1],boughtState[i - 1] + prices[i] - fee);\\n        }\\n        \\n        return soldState[len - 1];\\n    }\\n}\\n\\n/*\\nWe use the Same concept in this Question as previous question , \\nonly difference here is that after selling we have to take rest of one day, \\nso we have to tweak the equation little bit in for loop\\n\\n*/\\n\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //after selling the next day should be  mandatory cooldown\\n        if(prices.length == 1) return 0;\\n        if(prices.length == 2) return Math.max(0,prices[1] - prices[0]);\\n        \\n        int [] boughtState = new int[prices.length];\\n        int [] sellState = new int[prices.length];\\n        \\n        boughtState[0] = -prices[0];\\n        sellState[0] = 0;\\n        boughtState[1] = Math.max(boughtState[0],sellState[0] - prices[1]);\\n        sellState[1] = Math.max(sellState[0],boughtState[0] + prices[1]);\\n        \\n        for(int i = 2;i<prices.length;i++){\\n            boughtState[i] = Math.max(boughtState[i - 1],sellState[i - 2] - prices[i]);\\n            sellState[i] = Math.max(boughtState[i - 1] + prices[i],sellState[i - 1]);\\n        }\\n        return sellState[prices.length - 1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178836,
                "title": "c-4-5-line-code-o-n-faster-than-100",
                "content": "\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int c=0;//cash \\n        int h=prices[0];//total amount bougth can be negative as well \\n        for(int i=1;i<prices.size();i++){\\n            c=max(c,prices[i]-h-fee);\\n            h=min(h,prices[i]-c);\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int c=0;//cash \\n        int h=prices[0];//total amount bougth can be negative as well \\n        for(int i=1;i<prices.size();i++){\\n            c=max(c,prices[i]-h-fee);\\n            h=min(h,prices[i]-c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1113471,
                "title": "golang-dp-solution-with-explanation",
                "content": "```\\nfunc maxProfit(prices []int, fee int) int {\\n    dp := make([][2]int, len(prices))\\n    dp[0][0] = 0 //0 stands for hold cash on day 0 \\n    dp[0][1] = -prices[0]//1 stands for hold stock on day 0\\n    \\n    for i := 1; i < len(prices); i++ {\\n        //if the decision is to hold cash on day i, there are 2 options\\n        //option 1: sell the stock held from previous day\\n        //option 2: do nothing, keep on holding cash like previous day\\n        //max profit of day i with cash is max(option1, option2)\\n        dp[i][0] = max(prices[i] + dp[i-1][1] - fee, dp[i-1][0])\\n        \\n        //if the decision is to hold stock on day i, there are also 2 options\\n        //option 1: buy stock, based on previous day\\'s cash profit\\n        //option 2: do nothing, keep on holding stock like previous day\\n        //max profit of day i with stock is max(option1, option2)\\n        dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1])\\n    }\\n    \\n    return dp[len(prices) - 1][0]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc maxProfit(prices []int, fee int) int {\\n    dp := make([][2]int, len(prices))\\n    dp[0][0] = 0 //0 stands for hold cash on day 0 \\n    dp[0][1] = -prices[0]//1 stands for hold stock on day 0\\n    \\n    for i := 1; i < len(prices); i++ {\\n        //if the decision is to hold cash on day i, there are 2 options\\n        //option 1: sell the stock held from previous day\\n        //option 2: do nothing, keep on holding cash like previous day\\n        //max profit of day i with cash is max(option1, option2)\\n        dp[i][0] = max(prices[i] + dp[i-1][1] - fee, dp[i-1][0])\\n        \\n        //if the decision is to hold stock on day i, there are also 2 options\\n        //option 1: buy stock, based on previous day\\'s cash profit\\n        //option 2: do nothing, keep on holding stock like previous day\\n        //max profit of day i with stock is max(option1, option2)\\n        dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1])\\n    }\\n    \\n    return dp[len(prices) - 1][0]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112623,
                "title": "c-recursion-memoization",
                "content": "Recursion is generally powerful and enable more readable code than DP, however this is not the most performant solution. For the context of an interview, I think this is a great approach as it takes only few minutes to write and just to express the constraints of the problem.\\n\\n**EDIT:** There is a [smarter approach](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/1112543/C%2B%2B-36ms-Greedy-DP-Solution-Explained-100-Time-100-Space) other than DP for this problem.\\n\\n```cpp\\nint maxProfit(vector<int>& prices, int fee) {\\n\\tvector<vector<int>> memo(2, vector<int>(prices.size(), -1));\\n\\treturn max_profit(prices, memo, fee);\\n}\\n\\nint max_profit(const vector<int>& prices, vector<vector<int>>& memo, int fee, int i=0, bool can_sell=false){\\n\\tif(i == prices.size()) return 0;\\n\\tauto& cache = memo[can_sell][i];\\n\\tif(cache == -1){\\n\\t\\tcache = can_sell?\\n\\t\\t\\tmax(max_profit(prices, memo, fee, i+1, false) + prices[i] - fee,   // sell now\\n\\t\\t\\t\\tmax_profit(prices, memo, fee, i+1, true))                // sell later\\n\\t\\t   :max(max_profit(prices, memo, fee, i+1, true) - prices[i],    // buy now\\n\\t\\t\\t\\tmax_profit(prices, memo, fee, i+1, false));              // buy later\\n\\t}\\n\\treturn cache;\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxProfit(vector<int>& prices, int fee) {\\n\\tvector<vector<int>> memo(2, vector<int>(prices.size(), -1));\\n\\treturn max_profit(prices, memo, fee);\\n}\\n\\nint max_profit(const vector<int>& prices, vector<vector<int>>& memo, int fee, int i=0, bool can_sell=false){\\n\\tif(i == prices.size()) return 0;\\n\\tauto& cache = memo[can_sell][i];\\n\\tif(cache == -1){\\n\\t\\tcache = can_sell?\\n\\t\\t\\tmax(max_profit(prices, memo, fee, i+1, false) + prices[i] - fee,   // sell now\\n\\t\\t\\t\\tmax_profit(prices, memo, fee, i+1, true))                // sell later\\n\\t\\t   :max(max_profit(prices, memo, fee, i+1, true) - prices[i],    // buy now\\n\\t\\t\\t\\tmax_profit(prices, memo, fee, i+1, false));              // buy later\\n\\t}\\n\\treturn cache;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 108873,
                "title": "faster-than-the-max-solution-and-very-clear-answer",
                "content": "```  python\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        state = profit = 0 \\n        last_price = prices[0] \\n        for price in prices[1:]:                  \\n            state += price - last_price\\n            if state > fee:\\n                profit += state - fee\\n                state = fee\\n            else:\\n                if state < 0: state = 0\\n            last_price = price\\n        return profit\\n```\\nExplanation:\\n. state is a switch variable\\n. when state >= fee, all incoming positive price movement will become profit\\n. when state <= 0, that, all incoming negative  price movement will be discarded\\n\\n[python] best run : 149 ms, beats 98.92% at this time,  35%+ faster than the \"max\" solution.\\n[java] best run: 13ms, beats 97.42% at this time,  20%+ faster than the \"max\"",
                "solutionTags": [],
                "code": "```  python\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        state = profit = 0 \\n        last_price = prices[0] \\n        for price in prices[1:]:                  \\n            state += price - last_price\\n            if state > fee:\\n                profit += state - fee\\n                state = fee\\n            else:\\n                if state < 0: state = 0\\n            last_price = price\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667895,
                "title": "easiest-python-solution-without-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to track the minimum price at which the stock should be bought and sell it whenever a profit can be made.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the minimum price (min_price) with the first stock price (prices[0]) plus the transaction fee (fee).\\n1. Initialize the maximum profit (max_profit) as 0.\\n1. Iterate over each stock price (price) in the prices list.\\n1. Inside the loop:\\n1. If the current price (price) is greater than the minimum price (min_price), a profit can be made by selling the stock. In this case, add the difference between the current price and the minimum price to the maximum profit (max_profit).\\n1. Update the minimum price (min_price) to the current price (price).\\n1. If the current price plus fee (price + fee) is less than the minimum price (min_price), update the minimum price to the current price plus fee. This ensures that the transaction fee is considered when determining the minimum price to buy the stock.\\n1. Return the maximum profit (max_profit).\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        # Initialize the minimum price with the first stock price plus fee\\n        min_price = prices[0] + fee\\n        # Initialize the maximum profit as 0\\n        max_profit = 0\\n        \\n        # Iterate over each stock price\\n        for price in prices:\\n            # If the current price is greater than the minimum price,\\n            # a profit can be made by selling the stock\\n            if min_price < price:\\n                # Add the difference between the current price and the minimum price\\n                # to the maximum profit\\n                max_profit += price - min_price\\n                # Update the minimum price to the current price\\n                min_price = price\\n            # If the current price plus fee is less than the minimum price,\\n            # update the minimum price to the current price plus fee\\n            elif price + fee < min_price:\\n                min_price = price + fee\\n        \\n        # Return the maximum profit\\n        return max_profit\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        # Initialize the minimum price with the first stock price plus fee\\n        min_price = prices[0] + fee\\n        # Initialize the maximum profit as 0\\n        max_profit = 0\\n        \\n        # Iterate over each stock price\\n        for price in prices:\\n            # If the current price is greater than the minimum price,\\n            # a profit can be made by selling the stock\\n            if min_price < price:\\n                # Add the difference between the current price and the minimum price\\n                # to the maximum profit\\n                max_profit += price - min_price\\n                # Update the minimum price to the current price\\n                min_price = price\\n            # If the current price plus fee is less than the minimum price,\\n            # update the minimum price to the current price plus fee\\n            elif price + fee < min_price:\\n                min_price = price + fee\\n        \\n        # Return the maximum profit\\n        return max_profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505953,
                "title": "java-with-explanation-dp-easy-to-understand",
                "content": "```\\n/*\\nat any point there are two possibilities:\\n\\n    1. you own a stock\\n        -> you sell it here and move forward\\n        -> you move forwrd without doing anything\\n        \\n    2.you don\\'t own a stock\\n        -> you buy a stock here and move forward\\n        -> you move forward without doing anything\\n        \\n    In all of these steps we try to maximize the profit\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        //dp array\\n        int dp[][]=new int[prices.length][2];\\n        for(int i=0;i<prices.length;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return solve(0,0,prices,fee,dp);\\n    }\\n    int solve(int index,int own,int prices[],int fee,int dp[][]){\\n        if(index==prices.length)\\n            return 0;\\n        \\n        if(dp[index][own]!=-1){\\n            return dp[index][own];\\n        }\\n        \\n        //don\\'t have any stock  \\n        if(own==0){//2 choices : 1.buy / 2. don\\'t buy\\n            \\n            //buy and move forward\\n            int a=-(prices[index]+fee)+solve(index+1,1,prices,fee,dp);\\n            \\n            //move forward without buying\\n            int b=solve(index+1,0,prices,fee,dp);\\n            \\n            return dp[index][own]=Math.max(a,b);\\n            \\n        //owning a stock\\n        }else{//2 choices : 1.sell / 2. don\\'t sell\\n            \\n            //sell and move forward\\n            int a=(prices[index])+solve(index+1,0,prices,fee,dp);\\n            \\n            //move forward without selling \\n            int b=solve(index+1,1,prices,fee,dp);\\n            \\n            return dp[index][own]=Math.max(a,b);\\n        }\\n        \\n    }\\n\\t//hey if you find this helpful please upvote\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nat any point there are two possibilities:\\n\\n    1. you own a stock\\n        -> you sell it here and move forward\\n        -> you move forwrd without doing anything\\n        \\n    2.you don\\'t own a stock\\n        -> you buy a stock here and move forward\\n        -> you move forward without doing anything\\n        \\n    In all of these steps we try to maximize the profit\\n*/\\n\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        //dp array\\n        int dp[][]=new int[prices.length][2];\\n        for(int i=0;i<prices.length;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return solve(0,0,prices,fee,dp);\\n    }\\n    int solve(int index,int own,int prices[],int fee,int dp[][]){\\n        if(index==prices.length)\\n            return 0;\\n        \\n        if(dp[index][own]!=-1){\\n            return dp[index][own];\\n        }\\n        \\n        //don\\'t have any stock  \\n        if(own==0){//2 choices : 1.buy / 2. don\\'t buy\\n            \\n            //buy and move forward\\n            int a=-(prices[index]+fee)+solve(index+1,1,prices,fee,dp);\\n            \\n            //move forward without buying\\n            int b=solve(index+1,0,prices,fee,dp);\\n            \\n            return dp[index][own]=Math.max(a,b);\\n            \\n        //owning a stock\\n        }else{//2 choices : 1.sell / 2. don\\'t sell\\n            \\n            //sell and move forward\\n            int a=(prices[index])+solve(index+1,0,prices,fee,dp);\\n            \\n            //move forward without selling \\n            int b=solve(index+1,1,prices,fee,dp);\\n            \\n            return dp[index][own]=Math.max(a,b);\\n        }\\n        \\n    }\\n\\t//hey if you find this helpful please upvote\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112543,
                "title": "c-36ms-greedy-dp-solution-explained-100-time-100-space",
                "content": "Variation of the [base problem](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) [[explained here](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/763649/C%2B%2B-O(n)-Time-O(1)-Space-Solution-Explained-100-Time-~95-Space-Respectively)] with a small twist, but still the same core logic: we need to build a state machine that will progress for each new available price and decide what to do accordingly.\\n\\nTo do so, we will declare 2 support variables:\\n* `buy` will denote a purchasing state, initially set to `0`;\\n* `sell` will mark a selling state, initially set to be below the mininum value we might get in the input.\\n\\nWe will then proceed looping with `price` through the input vector provided and for each one of them we will:\\n* update `buy` to be maximum between its current value (which means it is more convenient not to take action) or the `buy` state we might be in if we were to sell now, with a total gain of `sell + price - fee`;\\n* specularly update `sell` as the maximum between its current value or the `sell` state we might enter now reducing our budget (`buy`) by the current `price`.\\n\\nNote that we might subtract `fee` at the second step instead - it would not change things, as long as we keep track of it; it was a bit tricky to notice, since usually in the real stock market \"transactions\" are either selling or purchasing, but here it is considered more in the sense of \"completed trade\".\\n\\nAnyway, to make a bit more sense of our state machine, let\\'s look at the first example in the description - `prices == {1,3,2,8,4,9}` and `fee == 2` - , which would give us:\\n\\n```cpp\\nbuy: 0 sell: -1 // we start and consider buying at 1, so our balance is -1\\nbuy: 0 sell: -1 // nothing more convenient for now, we move on since even selling at 3 would still keep us at 0\\nbuy: 0 sell: -1 // even worse now\\nbuy: 5 sell: -1 // okay, now we can consider selling at 8, for a net profit of 8 - 1 - 2 == 5; we still keep track of the sell branch\\nbuy: 5 sell:  1 // if we were to buy now, our sell branch would be at 5 - 4 == 1\\nbuy: 8 sell:  1 // and since we sell now at 9, we add an extra profit to the previous: 9 - 5 - 2 + 1 == 3\\n```\\n\\nOnce done, we can return `buy` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        // support variables\\n        int buy = 0, sell = -100000;\\n        for (int price: prices) {\\n            // best buy state: current one of what we can achieve selling now\\n            buy = max(buy, sell + price - fee);\\n            // best sell state: current one or what we can achieve purchasing now\\n            sell = max(sell, buy - price);\\n        }\\n        return buy;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/e737768b-1078-47a1-b920-2b1ce9819315_1615907927.5753946.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```cpp\\nbuy: 0 sell: -1 // we start and consider buying at 1, so our balance is -1\\nbuy: 0 sell: -1 // nothing more convenient for now, we move on since even selling at 3 would still keep us at 0\\nbuy: 0 sell: -1 // even worse now\\nbuy: 5 sell: -1 // okay, now we can consider selling at 8, for a net profit of 8 - 1 - 2 == 5; we still keep track of the sell branch\\nbuy: 5 sell:  1 // if we were to buy now, our sell branch would be at 5 - 4 == 1\\nbuy: 8 sell:  1 // and since we sell now at 9, we add an extra profit to the previous: 9 - 5 - 2 + 1 == 3\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        // support variables\\n        int buy = 0, sell = -100000;\\n        for (int price: prices) {\\n            // best buy state: current one of what we can achieve selling now\\n            buy = max(buy, sell + price - fee);\\n            // best sell state: current one or what we can achieve purchasing now\\n            sell = max(sell, buy - price);\\n        }\\n        return buy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112529,
                "title": "java-intuitive-o-n-solution-greedy",
                "content": "**714. Best Time to Buy and Sell Stock with Transaction Fee**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int cash = 0;\\n        int min = prices[0];\\n        for(int i: prices){\\n            if(i < min) min = i; // keep track of minimum\\n            else if(i > min + fee){ // if can make a profit, take it\\n                cash += i - min - fee; // add profit W/ fee\\n                min = i - fee; // do not incur the fee multiple times, since we incurred it for this price already\\n            }\\n        }\\n        return cash;\\n    }\\n}\\n```\\n\\n**PROBLEM OVERVIEW**\\nGiven an array of stock prices, return the max profit if you must pay a transaction fee when selling stock.\\n\\n**SOLUTION ANALYSIS**\\nGiven the problem statement, it\\'s clear that we want to minimize transaction fees and maximize profits\\n\\n**From the previous \"Buy and Sell Stock\" problems, we know that for unlimited transactions, the maximum profit we can attain is by keeping track of the minimum and greedily selling when we reach a profitable state:**\\n\\n* If prices[i] < min, then it\\'s optimal to update min, since less profit can be made by buying a more expensive stock\\n\\n\\n* In this case, when prices[i] - fee > min, then we can make a profit even with the transaction fee, then update the minimum to theh current price\\n\\nBut how can we overcome the transaction fee in examples like [1,8,9] and k=2, where this current logic will give us profit = ((8-1)-2) = 5 profit, although the answer should be 6? We should simply **avoid incurring the transaction fee multiple times**. We do this by setting min = prices[i] - fee, thereby saying **we paid the fee once, and we\\'ll utilize that payment until our next profitable transaction**.\\n\\n[1,8,9], k=2\\nProfit = ((8-1)-2) + ((9-6)-2) = (5+1) = 6\\n\\n**TIME COMPLEXITY**\\nO(n)",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int cash = 0;\\n        int min = prices[0];\\n        for(int i: prices){\\n            if(i < min) min = i; // keep track of minimum\\n            else if(i > min + fee){ // if can make a profit, take it\\n                cash += i - min - fee; // add profit W/ fee\\n                min = i - fee; // do not incur the fee multiple times, since we incurred it for this price already\\n            }\\n        }\\n        return cash;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112110,
                "title": "c-greedy-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) \\n    {\\n        if (prices.size() < 2)\\n            return 0;\\n\\t\\t\\t\\n        int profit = 0, min = prices[0];\\n        \\n        for (size_t i = 0; i < prices.size(); i++)\\n        {\\n            if (prices[i] < min)\\n                min = prices[i];\\n            else if (prices[i] - fee > min)\\n            {\\n                profit += prices[i] - fee - min;\\n                min = prices[i] - fee;\\n            }\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) \\n    {\\n        if (prices.size() < 2)\\n            return 0;\\n\\t\\t\\t\\n        int profit = 0, min = prices[0];\\n        \\n        for (size_t i = 0; i < prices.size(); i++)\\n        {\\n            if (prices[i] < min)\\n                min = prices[i];\\n            else if (prices[i] - fee > min)\\n            {\\n                profit += prices[i] - fee - min;\\n                min = prices[i] - fee;\\n            }\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858347,
                "title": "c-state-machine-dp-solution-o-n",
                "content": "Runtime: 228 ms, faster than 86.85% of C++ online submissions for Best Time to Buy and Sell Stock with Transaction Fee.\\nMemory Usage: 55.2 MB, less than 60.06% of C++ online submissions for Best Time to Buy and Sell Stock with Transaction Fee.\\n.\\n.\\n![image](https://assets.leetcode.com/users/images/cf7ce8ea-a57d-4ca5-bfa1-dba5c770115e_1600733059.5530665.png)\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n        int n = prices.size();\\n        if(n<2) return 0;\\n        \\n        // Stock state machine has 2 states: buy stock, sell stock\\n        // We can arrive in to buy state from previous buy or sell state\\n            // From sell state to buy state we loose money to buy the stock and so profit = sell - prices[i]\\n            // From buy state to buy state we just take the previous buy profit forward\\n        // We can arrive in to sell state from previous buy or sell state\\n            // From buy state to sell state we gain money by selling the stock  with negative fee and so profit = buy + prices[i] - fee\\n            // From sell state to sell state we just take the previous sell profit forward\\n        \\n        // To achive max profit we always want to maximize sell and buy profit\\n\\n\\t\\t// Intially we have no previous stock and so our sell profit = 0 and buy profit = -prices[0]\\n        int sell = 0;\\n        int buy = -prices[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            // We must sell the stock before buying again \\n            sell = max(sell, buy + prices[i] - fee);\\n            buy = max(buy, sell-prices[i]);\\n        }\\n        \\n        // final maximum profit after selling the last stock\\n        return sell;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        \\n        int n = prices.size();\\n        if(n<2) return 0;\\n        \\n        // Stock state machine has 2 states: buy stock, sell stock\\n        // We can arrive in to buy state from previous buy or sell state\\n            // From sell state to buy state we loose money to buy the stock and so profit = sell - prices[i]\\n            // From buy state to buy state we just take the previous buy profit forward\\n        // We can arrive in to sell state from previous buy or sell state\\n            // From buy state to sell state we gain money by selling the stock  with negative fee and so profit = buy + prices[i] - fee\\n            // From sell state to sell state we just take the previous sell profit forward\\n        \\n        // To achive max profit we always want to maximize sell and buy profit\\n\\n\\t\\t// Intially we have no previous stock and so our sell profit = 0 and buy profit = -prices[0]\\n        int sell = 0;\\n        int buy = -prices[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            // We must sell the stock before buying again \\n            sell = max(sell, buy + prices[i] - fee);\\n            buy = max(buy, sell-prices[i]);\\n        }\\n        \\n        // final maximum profit after selling the last stock\\n        return sell;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603000,
                "title": "detailed-explanation-o-n-time-and-o-1-space-from-o-n-2-time-and-o-n-space",
                "content": "\\nThe basic dp solution : \\nFor each position i, we find the a prevAns which is the maximum profit collected from 0th to (j - 1)th position, inclusive. Then we check if we buy at jth position and sell at ith position, will this give me a better profit than the current profit ? \\nIf yes, update the dp[i] with the profit + prevAns. Deduct the fee.\\n\\n\\n    public int maxProfit(int[] prices, int fee) {       \\n        int n = prices.length;\\n        if(n <= 1)\\n            return 0;\\n        int dp[] = new int[n + 1];\\n        for(int i = 1; i <= n; ++i){\\n            int prevAns = 0;  // It stores the max answer from 0 to j - 1. \\n            for(int j = 1; j < i; ++j){\\n                prevAns = Math.max(prevAns, dp[j - 1]);\\n                dp[i] = Math.max(dp[i], prices[i - 1] - prices[j - 1] - fee + prevAns);\\n            }\\n        }\\n        int ans = 0;\\n        for(int a : dp)\\n            ans = Math.max(ans, a);\\n        return ans;        \\n    }\\n    \\nThe above solution is cool, a basic one. It costs O(n^2) time and O(n) space. \\n*Not good enough*\\nFails for *[this](https://leetcode.com/submissions/detail/331317320/testcase/)* testcase\\n\\nWhat is the problem ? The inner loop ! \\nWhy do we need it ? To calculate the min price to buy the share at to be sold at ith position and also the prevAns.\\nCan we do without it ?\\n       \\n    dp[i] = Math.max(dp[i], prices[i - 1] - prices[j - 1] - fee + prevAns);\\n    \\nLets write it like this :\\n\\n    dp[i] = Math.max(dp[i], (prices[i - 1] - fee) + ( prevAns - prices[j - 1]));\\n    \\nIn this expression, ```(prices[i - 1] -  fee)``` is constant for index i.\\nSo, let\\'s attempt to calculate ```prevAns - prices[j - 1] ``` on the fly.\\n\\nTo get the maximum profit at ith position, ```(prevAns - prices[j - 1]) ``` term has to be maximized\\n\\nApproach :\\n\\n ```maxProfit``` : maximum profit till (i - 1)th position.\\n ```prevAns``` : maxProfit before the index of current minPrice\\n ```minPrice``` :  The best price to buy at to be sold at prices[i]\\n\\nWhy can\\'t we have ```maxProfit  ==  prevAns``` always ?\\nMight happen that, maxProfit is found at position (j - 1), and the prices[j] is a very large number.\\nSo it not profitable to but at prices[j] even though the previous profit for it would have been high.\\nprevAns is updated only when minPrice is shifted right. prevAns has to be one the answers left of minPrice\\'s index !\\n\\n\\nCode :\\n\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        if(n <= 1)\\n            return 0;\\n        int dp[] = new int[n];\\n        int maxProfit = 0;\\n        int prevAns = 0;\\n        int minPrice = prices[0];\\n        for(int i = 1; i < n; ++i){\\n            dp[i] = prices[i] - fee - minPrice + prevAns;\\n            if(prevAns - minPrice < maxProfit - prices[i]){\\n                prevAns = maxProfit;\\n                minPrice = prices[i];\\n            }\\n            maxProfit = Math.max(maxProfit, dp[i]);                \\n        }\\n        return maxProfit;\\n    }  \\n\\n\\n\\nIt costs O(n) time and space.\\nCan we do better ? Yes !\\nWhy don\\'t need the dp[] ! We can calculate the value on the fly.\\n\\n\\n     public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        if(n <= 1)\\n            return 0;\\n        int maxProfit = 0, prevAns = 0, minPrice = prices[0];\\n        for(int i = 1; i < n; ++i){            \\n            int currentProfit = prices[i] - fee - minPrice + prevAns;\\n            if(prevAns - minPrice < maxProfit - prices[i]){\\n                prevAns = maxProfit;\\n                minPrice = prices[i];\\n            }\\n            maxProfit = Math.max(maxProfit, currentProfit);                  \\n        }\\n        return maxProfit;\\n    }  \\n    \\n    \\nThe above solution costs O(n) time and O(1) space. \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```(prices[i - 1] -  fee)```\n```prevAns - prices[j - 1] ```\n```(prevAns - prices[j - 1]) ```\n```maxProfit```\n```prevAns```\n```minPrice```\n```maxProfit  ==  prevAns```",
                "codeTag": "Unknown"
            },
            {
                "id": 444413,
                "title": "different-python-dp-solutions-with-thinking-process-to-solve-the-series-stock-problems",
                "content": "Please see and vote for my different solutions with thinking process.\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/306438/Python-O(n)-solution-with-thinking-process)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/306427/Different-O(n)-Python-solutions-with-thinking-process)\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/306235/Different-DP-Python-solutions-with-thinking-process)\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/306282/Different-DP-Python-solutions-with-thinking-process)\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/444413/Different-Python-solutions-with-thinking-process-to-solve-the-series-of-stock-problems)\\n\\n**Method 1: DP algorithm with O(n^2) time and O(n) space**\\nTime Limit Exceeded, 34 / 44 test cases passed.\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j]  - fee + dp[j-1] for j from 0 to i-1)\\n```\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] - fee\\n                tmp += dp[j-1] if j > 1 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\\n\\n\\n\\n**Method 2: DP algorithm with O(n) time and O(n) space (852ms, beat 34.68%)**\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j]  - fee + dp[j-1] for j from 0 to i-1)\\n**We can further use DP to get local_max = - prices[j] - fee + dp[j-1] for j from 0 to i-1.**\\n```\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0] - fee\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-1] - prices[i] - fee)\\n        return dp[n-1]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] - fee\\n                tmp += dp[j-1] if j > 1 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\n```\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0] - fee\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-1] - prices[i] - fee)\\n        return dp[n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 263732,
                "title": "java-dp-detailed-comments",
                "content": "Runtime - O(N)\\nSpace - O(N) which can be optimized since we are only accessing data from previous index\\n\\n```java\\nclass Solution {\\n    \\n    // Assume we know max profit on each day i\\n    // Answer is the max profit on day N-1\\n    // Between each day, the decision is to buy (if not owned), do nothing, to sell (if owned)\\n    \\n    // Let F(i, isOwned) be the max profix on day i\\n    // Base case\\n    // F(0, isOwned=true) = -prices[0]\\n    // F(0, isOwned=false) = 0\\n    \\n    // General case\\n    // F(i, isOwned=true) = max(F(i - 1, true), F(i - 1, false) - prices[i])\\n    // F(i, isOwned=false) = max(F(i - 1, false), F(i - 1, true) + prices[i] - fee)\\n    \\n    public int maxProfit(int[] prices, int fee) {\\n        int N = prices.length;\\n        int[] owned = new int[N];\\n        int[] clear = new int[N];\\n        owned[0] = -prices[0];\\n        \\n        for (int i = 1; i < N; i++) {\\n            owned[i] = Math.max(owned[i - 1], clear[i - 1] - prices[i]);\\n            clear[i] = Math.max(clear[i - 1], owned[i - 1] + prices[i] - fee);\\n        }\\n        \\n        return clear[N - 1];\\n    } \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    // Assume we know max profit on each day i\\n    // Answer is the max profit on day N-1\\n    // Between each day, the decision is to buy (if not owned), do nothing, to sell (if owned)\\n    \\n    // Let F(i, isOwned) be the max profix on day i\\n    // Base case\\n    // F(0, isOwned=true) = -prices[0]\\n    // F(0, isOwned=false) = 0\\n    \\n    // General case\\n    // F(i, isOwned=true) = max(F(i - 1, true), F(i - 1, false) - prices[i])\\n    // F(i, isOwned=false) = max(F(i - 1, false), F(i - 1, true) + prices[i] - fee)\\n    \\n    public int maxProfit(int[] prices, int fee) {\\n        int N = prices.length;\\n        int[] owned = new int[N];\\n        int[] clear = new int[N];\\n        owned[0] = -prices[0];\\n        \\n        for (int i = 1; i < N; i++) {\\n            owned[i] = Math.max(owned[i - 1], clear[i - 1] - prices[i]);\\n            clear[i] = Math.max(clear[i - 1], owned[i - 1] + prices[i] - fee);\\n        }\\n        \\n        return clear[N - 1];\\n    } \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136388,
                "title": "easiest-solution-python-o-n-complexity-with-explanation",
                "content": "dp[i][0]: arrive i, no shares at hand.\\ndp[i][1]: arrive i, shares at hand.\\n\\ndp[i][1] = max(dp[i-1][0] - nums[i], dp[i-1][1]): buy at nums[i] or do nothing.\\ndp[i][0] = max(dp[i-1][1] + nums[i] - fee, dp[i-1][0]): sell at nums[i] or do nothing.\\n\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0 for _ in xrange(2)] for _ in xrange(len(prices))]\\n        dp[0][0] = 0\\n        dp[0][1] = -prices[0]\\n        for i in xrange(1, len(prices)):\\n            dp[i][1] = max([dp[i - 1][0] - prices[i], dp[i - 1][1]])\\n            dp[i][0] = max([dp[i - 1][1] + prices[i] - fee, dp[i - 1][0]])\\n\\n        return dp[-1][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0 for _ in xrange(2)] for _ in xrange(len(prices))]\\n        dp[0][0] = 0\\n        dp[0][1] = -prices[0]\\n        for i in xrange(1, len(prices)):\\n            dp[i][1] = max([dp[i - 1][0] - prices[i], dp[i - 1][1]])\\n            dp[i][0] = max([dp[i - 1][1] + prices[i] - fee, dp[i - 1][0]])\\n\\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108878,
                "title": "finally-understood-this-type-of-problem",
                "content": "# Lets start with the basics - trade once only.\\nThe idea is similar to maximum sub array problem. \\nTo express the problem in math terms: \\n0) Let's call ```[] A``` for maximum profit and ```A[i] ```represent obtainable profit up to ith index\\n1) Given ```[] p``` for prices\\n2) Find ```max{i,j} p[i] - p[j] ```for ```0<=j<=i```\\n3) Given index i, largest possible obtainable profit at ith position is either ```A[i-1]``` (doing nothing) or  ```p[i] (known) - min{j} p[j] ```for``` 0<=j<=i``` (trade once - buy at j and sell at i)\\n4) Thus DP recurring solution is: ```A[i] = max( A[i-1], p[i] - current_min)``` , where ```current_min ``` is ```min(current_min, p[i])```\\n\\nCode to one trade is as follows\\n\\n```\\npublic int maxProfit(int[] prices) \\n{\\n    if(prices.length< 2)return 0;\\n    int[] re = new int[prices.length];\\n    int minPrice = prices[0];\\n    for(int i = 1; i < prices.length; i++)\\n    {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] - minPrice);\\n    }\\n    \\n    return re[n-1];        \\n}\\n```\\n# For two trades. \\nI thought pretty hard on this, how do you do two trades, like the one above?\\nI first came up with a recursion fashion to deal with this problem, too slow.\\nNow come to think about it, the DP structure is like this.\\nLets call```[] A``` maximum profit obtainable for one trade, and ```[]B``` maximum profit obtainable for two trades.\\nFor ```A``` it will be exactly as above, what about ```B```?\\nSame as before, the profit is always obtained in two ways: \\n1) Doing nothing, thus profit stays same - ```B[i-1]```\\n2) Do something, thus make a profit - ```A[j-1] + p[i] - p[j]```\\nThus DP recurring formula is ```B[i] = max(B[i-1], A[k-1] + p[i] - p[k]) for 1<=k<=i```\\nThis basically says best profit obtainable at second trade is either 1) same as before (doing 2 trades) or 2) trade once (result in A), and trade again buy at ```p[k]``` and sell at ```p[i]```\\n\\nCode for two trades is as follows\\n```\\npublic int maxProfit(int[] prices) \\n{\\n    int n = prices.length;\\n    if(n<2) return 0;\\n    int[] profit = new int[n];\\n    profit = newProfit(profit, prices); // trade once\\n    profit = newProfit(profit, prices); // trade twice\\n    return profit[n-1];        \\n}\\n\\nint[] newProfit(int[] prevProfit, int[] prices)\\n{\\n    int n = prices.length, curMax = -prices[0];\\n    int[] re = new int[n];\\n    for(int i = 1; i < n; i++)\\n    {\\n        curMax = Math.max(curMax, prevProfit[i-1]-prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] + curMax);\\n    }\\n    return re;\\n}\\n```\\n\\n\\n# For ```K``` number of trades\\nThis question is basically the extension to two trades.\\nFor  ```K``` number of trades, the max profit will be:\\n```K[i] = max(K[i-1], J[m] + p[i] - p[m]) for 0<=m<=i```, where ```J``` is max obtainable profit for the ```K-1 ```number of trades.\\nThe trick to this question is to realize that if number_of_trades > p.length/2, you can do unlimited number of trades, and you should use or else you will get TLE\\nAnd if you can loop up to K trades, need to check if an early exit can be done, by checking if profit stays the same.\\n\\n\\n\\n# For unlimited number of trades\\nEssentially this is asking for the \"MAX\" available profit obtainable.\\nWith similar set up as before,\\n```A[i] = max(A[i-1], A[k-1] + p[i] - p[k]) for 1<=k<=i```\\nHere A[i] represents max profit obtainable at ith point with unlimited number of trades.\\nthe central part in ```int[] newProfit``` function is as follows:\\n```\\nint curMax = -prices[0];\\nfor(int i = 1; i < n; i++)\\n{\\n        curMax = Math.max(curMax, re[i-1] - prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] + curMax);\\n}\\n```\\n\\n\\n\\n# For trades with cool down\\nBasically same set up as unlimited number of trades \\n```A[i] = max(A[i-1], A[k-2] + p[i] - p[k]) for 2<=k<=i```\\n```\\nint curMax = Math.max(-prices[0],-prices[1]);\\nre[1] = Math.max(0, prices[1] - prices[0]);\\nfor(int i = 2; i < n; i++)\\n{\\n        curMax = Math.max(curMax, re[i-2] - prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] + curMax);\\n}\\n```\\n\\n\\n# For this question\\nSame as above set up, but with each trade, a fee is built in.\\n```A[i] = max(A[i-1], A[k] + p[i] - p[k] - fee ) for 0<=k<=i```\\n\\nCode I used for this question:\\n```\\npublic int maxProfit(int[] prices, int fee) \\n{\\n    int n = prices.length;\\n    if(n<2) return 0;\\n    int[] re = new int[n];\\n    int curMax = -prices[0];\\n    for(int i = 1; i < n; i++)\\n    {\\n    curMax = Math.max(curMax, re[i-1] - prices[i]);\\n    re[i] = Math.max(re[i-1], prices[i] + curMax - fee);\\n    }\\n    return re[n-1];       \\n}\\n```",
                "solutionTags": [],
                "code": "```[] A```\n```A[i] ```\n```[] p```\n```max{i,j} p[i] - p[j] ```\n```0<=j<=i```\n```A[i-1]```\n```p[i] (known) - min{j} p[j] ```\n``` 0<=j<=i```\n```A[i] = max( A[i-1], p[i] - current_min)```\n```current_min ```\n```min(current_min, p[i])```\n```\\npublic int maxProfit(int[] prices) \\n{\\n    if(prices.length< 2)return 0;\\n    int[] re = new int[prices.length];\\n    int minPrice = prices[0];\\n    for(int i = 1; i < prices.length; i++)\\n    {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] - minPrice);\\n    }\\n    \\n    return re[n-1];        \\n}\\n```\n```[] A```\n```[]B```\n```A```\n```B```\n```B[i-1]```\n```A[j-1] + p[i] - p[j]```\n```B[i] = max(B[i-1], A[k-1] + p[i] - p[k]) for 1<=k<=i```\n```p[k]```\n```p[i]```\n```\\npublic int maxProfit(int[] prices) \\n{\\n    int n = prices.length;\\n    if(n<2) return 0;\\n    int[] profit = new int[n];\\n    profit = newProfit(profit, prices); // trade once\\n    profit = newProfit(profit, prices); // trade twice\\n    return profit[n-1];        \\n}\\n\\nint[] newProfit(int[] prevProfit, int[] prices)\\n{\\n    int n = prices.length, curMax = -prices[0];\\n    int[] re = new int[n];\\n    for(int i = 1; i < n; i++)\\n    {\\n        curMax = Math.max(curMax, prevProfit[i-1]-prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] + curMax);\\n    }\\n    return re;\\n}\\n```\n```K```\n```K```\n```K[i] = max(K[i-1], J[m] + p[i] - p[m]) for 0<=m<=i```\n```J```\n```K-1 ```\n```A[i] = max(A[i-1], A[k-1] + p[i] - p[k]) for 1<=k<=i```\n```int[] newProfit```\n```\\nint curMax = -prices[0];\\nfor(int i = 1; i < n; i++)\\n{\\n        curMax = Math.max(curMax, re[i-1] - prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] + curMax);\\n}\\n```\n```A[i] = max(A[i-1], A[k-2] + p[i] - p[k]) for 2<=k<=i```\n```\\nint curMax = Math.max(-prices[0],-prices[1]);\\nre[1] = Math.max(0, prices[1] - prices[0]);\\nfor(int i = 2; i < n; i++)\\n{\\n        curMax = Math.max(curMax, re[i-2] - prices[i]);\\n        re[i] = Math.max(re[i-1], prices[i] + curMax);\\n}\\n```\n```A[i] = max(A[i-1], A[k] + p[i] - p[k] - fee ) for 0<=k<=i```\n```\\npublic int maxProfit(int[] prices, int fee) \\n{\\n    int n = prices.length;\\n    if(n<2) return 0;\\n    int[] re = new int[n];\\n    int curMax = -prices[0];\\n    for(int i = 1; i < n; i++)\\n    {\\n    curMax = Math.max(curMax, re[i-1] - prices[i]);\\n    re[i] = Math.max(re[i-1], prices[i] + curMax - fee);\\n    }\\n    return re[n-1];       \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669432,
                "title": "python-short-1-liner-2-solutions-functional-programming",
                "content": "# Approach 1: Recursive DP\\nSimilar to [Editorial solution](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/editorial/) but with recursion.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$,\\n\\nwhere, `n is length of prices`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int], fee: int) -> int:\\n        @cache\\n        def max_profit(i: int) -> int:\\n            if i < 0: return (-inf, 0)\\n            hold, free = max_profit(i - 1)\\n            return max(hold, free - prices[i]), max(free, hold + prices[i] - fee)\\n        \\n        return max_profit(len(prices) - 1)[1]\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: Functional 1-liner.\\nSame as the recursive solution above, but in a space optimized and functional approach.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$,\\n\\nwhere, `n is length of prices`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int], fee: int) -> int:\\n        return reduce(lambda a, p: (max(a[0], a[1] - p), max(a[1], a[0] + p - fee)), prices, (-inf, 0))[1] # (hold, free)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int], fee: int) -> int:\\n        @cache\\n        def max_profit(i: int) -> int:\\n            if i < 0: return (-inf, 0)\\n            hold, free = max_profit(i - 1)\\n            return max(hold, free - prices[i]), max(free, hold + prices[i] - fee)\\n        \\n        return max_profit(len(prices) - 1)[1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int], fee: int) -> int:\\n        return reduce(lambda a, p: (max(a[0], a[1] - p), max(a[1], a[0] + p - fee)), prices, (-inf, 0))[1] # (hold, free)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668834,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nThe goal is to calculate the maximum profit that can be earned by completing as many transactions as we like.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo we use dynamic programming.\\nFor each price in the prices vector, we calculate the maximum potential profit by considering two scenarios:\\n\\n1) Buying the stock at the current price minus the transaction fee (currSell - prices[i] - fee).\\n2) Selling the stock at the current price after buying it at a previous price (currBuy + prices[i] - fee).\\n\\nWe update the variables currBuy and currSell with the maximum of these two scenarios, ensuring that the profit is maximized. At the end of the loop, the value of currSell represents the maximum profit that can be obtained.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int currBuy=INT_MIN,currSell=0;\\n        for(int i=0;i<prices.size();i++){\\n            currBuy=max(currBuy,currSell-prices[i]);\\n            currSell=max(currSell,currBuy+prices[i]-fee);\\n        }\\n        return currSell;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int currBuy=INT_MIN,currSell=0;\\n        for(int i=0;i<prices.size();i++){\\n            currBuy=max(currBuy,currSell-prices[i]);\\n            currSell=max(currSell,currBuy+prices[i]-fee);\\n        }\\n        return currSell;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667708,
                "title": "java-solution-for-best-time-to-buy-and-sell-stock-with-transaction-fee-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use dynamic programming to find the maximum profit that can be achieved by buying and selling stocks, taking into account the transaction fee.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used is based on maintaining a 2D array dp to store the maximum profit at each day with two states: 0 stocks (no stock) and 1 stock (one stock). The array dp is updated iteratively, considering two cases at each day:\\n\\nCase 1: Sell the stock - We compare the maximum profit on the previous day without stock (dp[i-1][0]) and the profit obtained by selling the stock on the current day (dp[i-1][1] + prices[i] - fee). We choose the maximum of these two values.\\n\\nCase 2: Buy the stock - We compare the maximum profit on the previous day with one stock (dp[i-1][1]) and the profit obtained by buying the stock on the current day (dp[i-1][0] - prices[i]). We choose the maximum of these two values.\\n\\nThe initial values of dp[0][0] and dp[0][1] are set based on the first day\\'s stock price, representing the profit with no stock and one stock, respectively.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the length of the prices array, as we iterate through the array once. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) as well, since we use a 2D array dp of size n by 2 to store the intermediate results, where n is the length of the prices array.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maxProfit(int[] prices, int fee) \\n    {\\n        int n = prices.length;\\n        int[][] dp = new int[n][2];\\n\\n        dp[0][0] = 0; // profit on day 0 with no stock\\n        dp[0][1] = -prices[0]; // profit on day 0 with one stock\\n\\n        for (int i = 1; i < n; i++) \\n        {\\n            // Case 1: Sell the stock\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);\\n            \\n            // Case 2: Buy the stock\\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\\n        }\\n\\n        return dp[n - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maxProfit(int[] prices, int fee) \\n    {\\n        int n = prices.length;\\n        int[][] dp = new int[n][2];\\n\\n        dp[0][0] = 0; // profit on day 0 with no stock\\n        dp[0][1] = -prices[0]; // profit on day 0 with one stock\\n\\n        for (int i = 1; i < n; i++) \\n        {\\n            // Case 1: Sell the stock\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);\\n            \\n            // Case 2: Buy the stock\\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\\n        }\\n\\n        return dp[n - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667350,
                "title": "easy-c-python-c-solutions-buy-sell",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy to solve several stock problems.\\nUse buy and sell!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSeveral stock profit problems are solved in the similar manner.\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/zWS6E0ntTkM](https://youtu.be/zWS6E0ntTkM)\\n\\nGreedy greedy calculus solution LeetCode714, 121, 122 has the largest profit in the stock market with transaction fees (the main question is Best Time to Buy and Sell Stock with Transaction Fee, and the other two questions can be solved in the same way). These three problems seek local optimal solutions, and greed can solve the overall situation (the real stock market does not seem to be the case, this method is feasible because the stock price is known), greedy calculus is not a panacea, but it is easy to implement, and it is more than enough to solve such problems. Simple and fast O(n) time.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int s=prices.size();\\n        if (s <= 1) return 0;\\n        int buy = -prices[0], sell=0;\\n        for (int i = 1; i < s; i++) {\\n            buy = max(buy, sell-prices[i]);\\n            sell = max(sell, prices[i] - fee + buy);\\n        //    cout<<buy<<\"|\"<<sell<<endl;          \\n        }\\n        return sell;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        s=len(prices)\\n        if s<=1: return 0\\n        buy=-prices[0]\\n        sell=0\\n        for price in prices[1:]:\\n            buy=max(buy, sell-price)\\n            sell=max(sell, price-fee+buy)\\n        return sell\\n```\\n```C []\\nint maxProfit(int* prices, int n, int fee){\\n    int buy=INT_MAX, sell=0;\\n    for (int i=0; i<n; i++){\\n        if (buy>prices[i]-sell) buy=prices[i]-sell;\\n        if (sell<prices[i]-fee-buy) sell=prices[i]-fee-buy;\\n    }\\n    return sell;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int s=prices.size();\\n        if (s <= 1) return 0;\\n        int buy = -prices[0], sell=0;\\n        for (int i = 1; i < s; i++) {\\n            buy = max(buy, sell-prices[i]);\\n            sell = max(sell, prices[i] - fee + buy);\\n        //    cout<<buy<<\"|\"<<sell<<endl;          \\n        }\\n        return sell;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        s=len(prices)\\n        if s<=1: return 0\\n        buy=-prices[0]\\n        sell=0\\n        for price in prices[1:]:\\n            buy=max(buy, sell-price)\\n            sell=max(sell, price-fee+buy)\\n        return sell\\n```\n```C []\\nint maxProfit(int* prices, int n, int fee){\\n    int buy=INT_MAX, sell=0;\\n    for (int i=0; i<n; i++){\\n        if (buy>prices[i]-sell) buy=prices[i]-sell;\\n        if (sell<prices[i]-fee-buy) sell=prices[i]-fee-buy;\\n    }\\n    return sell;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3430524,
                "title": "c-top-down-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        dp[1][1]=-1*p[0];\\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<2;j++){\\n                if(j){\\n                    dp[i][j]= max(-1*p[i-1] + dp[i-1][0] , dp[i-1][1]);\\n                }\\n                else {\\n                    dp[i][j]=max(p[i-1] + dp[i-1][1]- fee , dp[i-1][0]);\\n                }\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        dp[1][1]=-1*p[0];\\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<2;j++){\\n                if(j){\\n                    dp[i][j]= max(-1*p[i-1] + dp[i-1][0] , dp[i-1][1]);\\n                }\\n                else {\\n                    dp[i][j]=max(p[i-1] + dp[i-1][1]- fee , dp[i-1][0]);\\n                }\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942852,
                "title": "100-faster-java-soln-with-video-solution-dp",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetailed video solution link : https://youtu.be/pTQB9wbIpfU\\nWe traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maxProfit(int[] prices,int fee) {\\n        int obsp=-prices[0];//obsp->Old buying state profit\\n        int ossp=0;//->Old selling state profit\\n        for (int i = 1; i <prices.length ; i++) {\\n            int nbsp=0;//->new buying state profit\\n            int nssp=0;//->new selling state profit\\n            if(obsp>ossp-prices[i])\\n            { \\n                nbsp= obsp;\\n            }\\n            else\\n                nbsp=ossp-prices[i];\\n\\n            if(obsp+prices[i]-fee>ossp)\\n            {\\n                nssp= obsp+prices[i]-fee;\\n            }\\n            else {\\n                nssp = ossp ;\\n\\n            }\\n            obsp=nbsp;\\n            ossp=nssp;\\n        }\\n        return ossp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public static int maxProfit(int[] prices,int fee) {\\n        int obsp=-prices[0];//obsp->Old buying state profit\\n        int ossp=0;//->Old selling state profit\\n        for (int i = 1; i <prices.length ; i++) {\\n            int nbsp=0;//->new buying state profit\\n            int nssp=0;//->new selling state profit\\n            if(obsp>ossp-prices[i])\\n            { \\n                nbsp= obsp;\\n            }\\n            else\\n                nbsp=ossp-prices[i];\\n\\n            if(obsp+prices[i]-fee>ossp)\\n            {\\n                nssp= obsp+prices[i]-fee;\\n            }\\n            else {\\n                nssp = ossp ;\\n\\n            }\\n            obsp=nbsp;\\n            ossp=nssp;\\n        }\\n        return ossp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293869,
                "title": "c-recursion-memoization-01knapsack-simple-solution",
                "content": "The deciding factor is the variable b,\\nif we buy at a stage, then at the next stage we will sell or continue.\\nif we don\\'t buy, we can buy or wait to buy at next stage.\\nif we sell, then we can buy at next stage or continue.\\n\\nPLEASE UPVOTE IF FOUND HELPFUL.\\n```\\nint solve(vector<int>&price,int fee,int i,int n,int buy,vector<vector<int>>&dp){\\n        if(i==n)\\n            return 0;\\n        int x=0,y=0;\\n        if(dp[i][buy]!=INT_MIN)\\n            return dp[i][buy];\\n        if(buy==0){\\n            x=solve(price,fee,i+1,n,buy,dp);\\n            y=-price[i]+solve(price,fee,i+1,n,1,dp);\\n        }else{\\n            x=solve(price,fee,i+1,n,buy,dp);\\n            y=solve(price,fee,i+1,n,0,dp)+price[i]-fee;\\n        }\\n        return dp[i][buy]=max(x,y);\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        vector<vector<int>> out(prices.size()+1,vector<int>(2,INT_MIN));\\n        return solve(prices,fee,0,prices.size(),0,out);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(vector<int>&price,int fee,int i,int n,int buy,vector<vector<int>>&dp){\\n        if(i==n)\\n            return 0;\\n        int x=0,y=0;\\n        if(dp[i][buy]!=INT_MIN)\\n            return dp[i][buy];\\n        if(buy==0){\\n            x=solve(price,fee,i+1,n,buy,dp);\\n            y=-price[i]+solve(price,fee,i+1,n,1,dp);\\n        }else{\\n            x=solve(price,fee,i+1,n,buy,dp);\\n            y=solve(price,fee,i+1,n,0,dp)+price[i]-fee;\\n        }\\n        return dp[i][buy]=max(x,y);\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        vector<vector<int>> out(prices.size()+1,vector<int>(2,INT_MIN));\\n        return solve(prices,fee,0,prices.size(),0,out);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110600,
                "title": "simple-recursion-c-and-memoization",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint dp[50001][2];\\n\\tint rec(vector<int> &pr, int i, int bos, int fee)\\n\\t{\\n\\n\\t\\tif (i >= pr.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i][bos] != -1)\\n\\t\\t\\treturn dp[i][bos];\\n\\t\\tint profit = 0;\\n\\t\\tif (bos == 1) // buy\\n\\t\\t{\\n\\t\\t\\tint buy = rec(pr, i + 1, 0, fee) - pr[i] - fee;\\n\\t\\t\\tint notbuy = rec(pr, i + 1, 1, fee);\\n\\t\\t\\tprofit = max(buy, notbuy);\\n\\t\\t}\\n\\t\\tif (bos == 0) // sell\\n\\t\\t{\\n\\t\\t\\tint sell = rec(pr, i + 1, 1, fee) + pr[i];\\n\\t\\t\\tint notsell = rec(pr, i + 1, 0, fee);\\n\\t\\t\\tprofit = max(sell, notsell);\\n\\t\\t}\\n\\t\\treturn dp[i][bos] = profit;\\n\\t}\\n\\tint maxProfit(vector<int> &prices, int fee)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn rec(prices, 0, 1, fee);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint dp[50001][2];\\n\\tint rec(vector<int> &pr, int i, int bos, int fee)\\n\\t{\\n\\n\\t\\tif (i >= pr.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i][bos] != -1)\\n\\t\\t\\treturn dp[i][bos];\\n\\t\\tint profit = 0;\\n\\t\\tif (bos == 1) // buy\\n\\t\\t{\\n\\t\\t\\tint buy = rec(pr, i + 1, 0, fee) - pr[i] - fee;\\n\\t\\t\\tint notbuy = rec(pr, i + 1, 1, fee);\\n\\t\\t\\tprofit = max(buy, notbuy);\\n\\t\\t}\\n\\t\\tif (bos == 0) // sell\\n\\t\\t{\\n\\t\\t\\tint sell = rec(pr, i + 1, 1, fee) + pr[i];\\n\\t\\t\\tint notsell = rec(pr, i + 1, 0, fee);\\n\\t\\t\\tprofit = max(sell, notsell);\\n\\t\\t}\\n\\t\\treturn dp[i][bos] = profit;\\n\\t}\\n\\tint maxProfit(vector<int> &prices, int fee)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn rec(prices, 0, 1, fee);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532323,
                "title": "python3-dp",
                "content": "The \"buy low & sell high\"\" approach could be used to solve all problems in this series. \\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/695515/Python3-two-approaches)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices:\\n            buy = min(buy, x)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/565654/Python3-greedy-and-dp)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\\n[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/702602/Python3-two-approaches)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/702612/Python3-two-approaches)\\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        buy, sell = [inf]*k, [0]*k\\n        for x in prices:\\n            for i in range(k):\\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[-1] if k and prices else 0\\n```\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/762801/Python3-dp)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, cooldown, sell = inf, 0, 0\\n        for x in prices: \\n            buy = min(buy, x - cooldown)\\n            cooldown = sell \\n            sell = max(sell, x - buy)\\n        return sell\\n```\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/1532323/Python3-dp)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy - fee)\\n        return sell \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices:\\n            buy = min(buy, x)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy)\\n        return sell\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\\n        buy, sell = [inf]*k, [0]*k\\n        for x in prices:\\n            for i in range(k):\\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[-1] if k and prices else 0\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, cooldown, sell = inf, 0, 0\\n        for x in prices: \\n            buy = min(buy, x - cooldown)\\n            cooldown = sell \\n            sell = max(sell, x - buy)\\n        return sell\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        buy, sell = inf, 0\\n        for x in prices: \\n            buy = min(buy, x - sell)\\n            sell = max(sell, x - buy - fee)\\n        return sell \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562621,
                "title": "an-interesting-solution-not-dp-o-n-in-time-beats-98-63-with-explanation",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: list, fee: int) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        profit = 0\\n        buy = sold = prices[0]\\n        for price in prices[1:]:\\n            # if current price is higher than sold, then we will consider this new price as sold price\\n            if price >= sold:\\n                sold = price\\n\\n            # if current price is lower than sold, then we may think sold the stock at \"sold price\"\\n            else:\\n                gain = sold - buy - fee\\n                # we will perform a transmission only if\\n                # 1. we can earn money, and\\n                # 2. gain is large enough to pay \\u201Copportunity cost\\u201D, because\\n                #       if we perform transmission, the new buying price may be higher than\\n                #       current buying price, and the difference is the opportunity cost. eg.\\n                #       prices are [1, 5, 4, 10] with fee = 3,\\n                #       if we sold the stock at 5, then we cannot\\n                #       get a higher profit with \"buy at 1 sold at 10\"\\n                if gain > 0 and gain > price - buy:\\n                    profit += gain\\n                    buy = sold = price\\n                # if we cannot earn any profit, then we should rethink changing the buying price\\n                elif price < buy:\\n                    buy = sold = price\\n        if sold - buy > fee:\\n            profit += sold - buy - fee\\n        return profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: list, fee: int) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        profit = 0\\n        buy = sold = prices[0]\\n        for price in prices[1:]:\\n            # if current price is higher than sold, then we will consider this new price as sold price\\n            if price >= sold:\\n                sold = price\\n\\n            # if current price is lower than sold, then we may think sold the stock at \"sold price\"\\n            else:\\n                gain = sold - buy - fee\\n                # we will perform a transmission only if\\n                # 1. we can earn money, and\\n                # 2. gain is large enough to pay \\u201Copportunity cost\\u201D, because\\n                #       if we perform transmission, the new buying price may be higher than\\n                #       current buying price, and the difference is the opportunity cost. eg.\\n                #       prices are [1, 5, 4, 10] with fee = 3,\\n                #       if we sold the stock at 5, then we cannot\\n                #       get a higher profit with \"buy at 1 sold at 10\"\\n                if gain > 0 and gain > price - buy:\\n                    profit += gain\\n                    buy = sold = price\\n                # if we cannot earn any profit, then we should rethink changing the buying price\\n                elif price < buy:\\n                    buy = sold = price\\n        if sold - buy > fee:\\n            profit += sold - buy - fee\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108881,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Best Time to Buy and Sell Stock with Transaction Fee** https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/\\n\\n**DP solution building on two choices**\\n* dp[i] gives the maximum profit possible after day i.\\n* On day i, we have two choices. Either we can hold the stock or we can make a transaction on day i.\\n* If we decide to hold, then the maximum profit on day i is same as dp[i-1].\\n* If we do a transaction, then we are selling at prices[i]. Now for the stock we are selling, say we bought at day j (ranging from 0 to i-1). Then the profit at day i is: max(prices[i]-fee-prices[j]+dp[j-1])\\n* dp[i] = max(hold, transact) = max(dp[i-1], prices[i]-fee + max(dp[j-1]-prices[j])) j in [0, i-1]\\n* Note, we can maintain a running maximum for (dp[j-1]-prices[j]). This makes the algorithm O(N) and O(1).\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        profit, max_diff = 0, float('-inf')\\n        for i in range(len(prices)):\\n            hold = profit\\n            transact = prices[i] - fee + max_diff if i > 0 else 0\\n            max_diff = max(max_diff, profit-prices[i])\\n            profit = max(hold, transact)\\n        return profit\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        profit, max_diff = 0, float('-inf')\\n        for i in range(len(prices)):\\n            hold = profit\\n            transact = prices[i] - fee + max_diff if i > 0 else 0\\n            max_diff = max(max_diff, profit-prices[i])\\n            profit = max(hold, transact)\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669057,
                "title": "c-day-22-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(1)\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        if(n < 2)\\n            return 0;\\n        int buy = -prices[0];\\n        int sell = 0;\\n        for(int i = 1; i < n; i++) {\\n            int new_buy = max(buy, sell - prices[i]);    \\n            int new_sell = max(sell, buy + prices[i] - fee);\\n         \\n            buy = new_buy;\\n            sell = new_sell;\\n        }\\n        return sell;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(1)\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        if(n < 2)\\n            return 0;\\n        int buy = -prices[0];\\n        int sell = 0;\\n        for(int i = 1; i < n; i++) {\\n            int new_buy = max(buy, sell - prices[i]);    \\n            int new_sell = max(sell, buy + prices[i] - fee);\\n         \\n            buy = new_buy;\\n            sell = new_sell;\\n        }\\n        return sell;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668406,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->When approaching this problem, my initial thoughts would be to use a dynamic programming approach due to its ability to efficiently handle overlapping subproblems. The problem involves making decisions at each step (whether to hold or sell/buy the stock) while considering the transaction fees.\\n\\nTo begin, I would define a state that represents the current position and whether the stock is held or not. Then, I would consider the possible actions at each state and evaluate the maximum profit based on those actions. This can be done recursively, where the maximum profit at the current state depends on the maximum profits of the subsequent states.\\n\\nI would also consider using memoization to store the results of subproblems to avoid recomputation. By storing the maximum profit for each state, we can retrieve the result in constant time if it has already been computed.\\n\\nOverall, my initial thoughts would revolve around breaking down the problem into smaller subproblems, recursively evaluating the maximum profit for each state, and utilizing memoization to optimize the solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The given code implements a dynamic programming approach to solve a stock trading problem with transaction fees. Here\\'s the high-level approach for better understanding:\\n\\n1. Create a 2D `dp` array with dimensions `[50005][2]` to store the maximum profits for each state (iterator and stock hold status). Initialize all values in the `dp` array to -1.\\n\\n2. Define a recursive function `solve` that takes the following parameters: the vector of stock prices (`prices`), the transaction fee (`fee`), the iterator position (`itr`), and the stock hold status (`hold`).\\n\\n3. Inside the `solve` function:\\n   - Check if the iterator position `itr` is beyond the size of the `prices` vector. If so, return 0 indicating that there are no more prices to process.\\n   - Check if the maximum profit for the current state (`itr` and `hold`) has already been computed and stored in the `dp` array. If so, return the precomputed value.\\n   - Initialize a variable `ans` to store the maximum profit for the current state.\\n\\n4. Determine the maximum profit for the current state by considering two scenarios:\\n   - If the stock is currently on hold (`hold` is true):\\n     - Recursively call the `solve` function to calculate the maximum profit without selling the stock (continuing to hold).\\n     - Recursively call the `solve` function to calculate the maximum profit by selling the stock and paying the transaction fee (`fee`), and adding the profit from selling (`prices[itr] - fee`) to the total.\\n     - Take the maximum of these two values and update `ans` accordingly.\\n   - If the stock is not on hold (`hold` is false):\\n     - Recursively call the `solve` function to calculate the maximum profit without buying the stock (continuing not to hold).\\n     - Recursively call the `solve` function to calculate the maximum profit by buying the stock and subtracting its price (`prices[itr]`) from the total profit.\\n     - Take the maximum of these two values and update `ans` accordingly.\\n\\n5. Store the computed maximum profit `ans` for the current state (`itr` and `hold`) in the `dp` array.\\n\\n6. Finally, outside the `solve` function, initialize the `dp` array using `memset` to -1.\\n\\n7. Call the `solve` function from the `maxProfit` function, passing the vector of stock prices (`prices`), the transaction fee (`fee`), the initial iterator position (0), and the initial stock hold status (0). This will calculate the maximum profit for the given stock prices and return the result.\\n\\n8. Return the maximum profit obtained from the `maxProfit` function.\\n\\nThis approach utilizes dynamic programming and memoization to avoid redundant calculations, significantly improving the efficiency of the solution. By storing and reusing the computed results in the `dp` array, the recursive calls are minimized, leading to a faster solution for the stock trading problem with transaction fees.\\n\\n# Complexity\\n- Time complexity:   O(n * 2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:   O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[99999][2];\\n\\n    // Function to solve the problem recursively\\n    int solve(vector<int> &prices, int fee, int itr, int hold) {\\n        if (itr >= prices.size()) return 0;\\n        if (dp[itr][hold] != -1) return dp[itr][hold];\\n        int ans = 0;\\n\\n        // Checking if current stock is on hold or not\\n        if (hold)\\n            ans = max({ans, solve(prices, fee, itr + 1, hold), solve(prices, fee, itr + 1, 0) + prices[itr] - fee});\\n        else\\n            ans = max({ans, solve(prices, fee, itr + 1, hold), solve(prices, fee, itr + 1, 1) - prices[itr]});\\n        return dp[itr][hold] = ans;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solve(prices, fee, 0, 0);\\n        return ans;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/dc448808-bb03-4df4-ac35-1ae6496eae09_1687417047.8743799.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[99999][2];\\n\\n    // Function to solve the problem recursively\\n    int solve(vector<int> &prices, int fee, int itr, int hold) {\\n        if (itr >= prices.size()) return 0;\\n        if (dp[itr][hold] != -1) return dp[itr][hold];\\n        int ans = 0;\\n\\n        // Checking if current stock is on hold or not\\n        if (hold)\\n            ans = max({ans, solve(prices, fee, itr + 1, hold), solve(prices, fee, itr + 1, 0) + prices[itr] - fee});\\n        else\\n            ans = max({ans, solve(prices, fee, itr + 1, hold), solve(prices, fee, itr + 1, 1) - prices[itr]});\\n        return dp[itr][hold] = ans;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solve(prices, fee, 0, 0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667576,
                "title": "c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int &k,vector<vector<int>> &dp,int x){\\n        if(i>=n)return 0;\\n        if(dp[i][x]!=-1)return dp[i][x];\\n        int ans1 = solve(i+1,n,v,k,dp,x);\\n        int ans2 = 0;\\n        if(x){\\n            ans2 = -v[i]-k+solve(i+1,n,v,k,dp,0);\\n        }else{\\n            ans2 =  v[i]+solve(i+1,n,v,k,dp,1);\\n        }\\n        return dp[i][x] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v, int fee) {\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        return solve(0,n,v,fee,dp,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int &k,vector<vector<int>> &dp,int x){\\n        if(i>=n)return 0;\\n        if(dp[i][x]!=-1)return dp[i][x];\\n        int ans1 = solve(i+1,n,v,k,dp,x);\\n        int ans2 = 0;\\n        if(x){\\n            ans2 = -v[i]-k+solve(i+1,n,v,k,dp,0);\\n        }else{\\n            ans2 =  v[i]+solve(i+1,n,v,k,dp,1);\\n        }\\n        return dp[i][x] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v, int fee) {\\n        int n = v.size();\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        return solve(0,n,v,fee,dp,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667480,
                "title": "c-simple-approach-dp-beginner-friendly",
                "content": "### \\uD83D\\uDD25 Donn forget to Upvote if you liked the Approach. \\uD83D\\uDD25\\n\\n# Approach\\nApproach to the problem is very straight.\\nConsider a function which will buy a stock if there if no current stock on hold which is check by the hold iterator and stock will be sold if the value of **hold ==1**. Similarly calling a recursive function for checking buy and sell at every index and picking out the profit with max value.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[50005][2];\\n\\n    int solve(vector<int> &prices, int fee,int itr,int hold)\\n    {\\n        if(itr>=prices.size()) return 0;\\n        if(dp[itr][hold]!=-1) return dp[itr][hold];\\n        int ans=0;\\n// Checking if current stock is on hold or not\\n        if(hold)\\n        ans=max({ans,solve(prices,fee,itr+1,hold),solve(prices,fee,itr+1,0)+prices[itr]-fee});\\n        else\\n        ans=max({ans,solve(prices,fee,itr+1,hold),solve(prices,fee,itr+1,1)-prices[itr]});\\n        return dp[itr][hold]=ans;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(prices,fee,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[50005][2];\\n\\n    int solve(vector<int> &prices, int fee,int itr,int hold)\\n    {\\n        if(itr>=prices.size()) return 0;\\n        if(dp[itr][hold]!=-1) return dp[itr][hold];\\n        int ans=0;\\n// Checking if current stock is on hold or not\\n        if(hold)\\n        ans=max({ans,solve(prices,fee,itr+1,hold),solve(prices,fee,itr+1,0)+prices[itr]-fee});\\n        else\\n        ans=max({ans,solve(prices,fee,itr+1,hold),solve(prices,fee,itr+1,1)-prices[itr]});\\n        return dp[itr][hold]=ans;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(prices,fee,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437995,
                "title": "solution",
                "content": "```C++ []\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\nclass Solution {\\npublic:\\n\\tint maxProfit(std::vector<int>& prices, int fee)\\n\\t{\\n\\t\\tauto buy_state = -1 * prices[0];\\n\\t\\tauto sell_state = 0;\\n\\t\\tfor (auto i = 1; i != static_cast<int>(std::size(prices)); ++i)\\n\\t\\t{\\n\\t\\t\\tbuy_state = std::max(buy_state, sell_state - prices[i]);\\n\\t\\t\\tsell_state = std::max(sell_state, prices[i] + buy_state - fee);\\n\\t\\t}\\n\\t\\treturn sell_state;\\n\\t}\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        min_p = prices[0] + fee\\n        res = 0\\n        \\n        for p in prices:\\n            if min_p < p:\\n                res += p-min_p\\n                min_p = p\\n            elif p+fee < min_p:\\n                min_p = p + fee\\n        \\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\nclass Solution {\\npublic:\\n\\tint maxProfit(std::vector<int>& prices, int fee)\\n\\t{\\n\\t\\tauto buy_state = -1 * prices[0];\\n\\t\\tauto sell_state = 0;\\n\\t\\tfor (auto i = 1; i != static_cast<int>(std::size(prices)); ++i)\\n\\t\\t{\\n\\t\\t\\tbuy_state = std::max(buy_state, sell_state - prices[i]);\\n\\t\\t\\tsell_state = std::max(sell_state, prices[i] + buy_state - fee);\\n\\t\\t}\\n\\t\\treturn sell_state;\\n\\t}\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        min_p = prices[0] + fee\\n        res = 0\\n        \\n        for p in prices:\\n            if min_p < p:\\n                res += p-min_p\\n                min_p = p\\n            elif p+fee < min_p:\\n                min_p = p + fee\\n        \\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3370791,
                "title": "best-o-n-solution",
                "content": "# Approach\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Profit(int index, int buy, int fee, vector<int>& prices, vector<vector<int>> &dp) {\\n        if (index >= prices.size())\\n            return 0;\\n        if (dp[index][buy] != -1)\\n            return dp[index][buy];\\n        int maxProfit = 0;\\n        if (buy) {\\n            maxProfit = max(-prices[index] + Profit(index+1, 0, fee, prices, dp),\\n                                         0 + Profit(index+1, 1, fee, prices, dp));\\n        } else {\\n            maxProfit = max(prices[index] - fee + Profit(index+1, 1, fee, prices, dp),\\n                                              0 + Profit(index+1, 0, fee, prices, dp));\\n        }\\n        return dp[index][buy] = maxProfit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return Profit(0, 1, fee, prices, dp);\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Profit(int index, int buy, int fee, vector<int>& prices, vector<vector<int>> &dp) {\\n        if (index >= prices.size())\\n            return 0;\\n        if (dp[index][buy] != -1)\\n            return dp[index][buy];\\n        int maxProfit = 0;\\n        if (buy) {\\n            maxProfit = max(-prices[index] + Profit(index+1, 0, fee, prices, dp),\\n                                         0 + Profit(index+1, 1, fee, prices, dp));\\n        } else {\\n            maxProfit = max(prices[index] - fee + Profit(index+1, 1, fee, prices, dp),\\n                                              0 + Profit(index+1, 0, fee, prices, dp));\\n        }\\n        return dp[index][buy] = maxProfit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return Profit(0, 1, fee, prices, dp);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218938,
                "title": "kotlin-explained-from-bruteforce-to-dp-o-n-time-o-1-space",
                "content": "# Approach\\n1. State a brute force approach\\n\\nSimplest way is to do this recursively: we\\'ve got 2 states we can be in: either we are holding a stock or we aren\\'t. \\n\\nIf we are holding a stock, we can either:\\n1. wait and do nothing\\n2. sell it\\n\\nIf we are not holding a stock, we can:\\n1. wait and do nothing\\n2. buy it\\n\\nSo we have 2 actions we can make at each iteration, which doubles it each time we increase index. This is $$O(2^n)$$:\\n\\n```kotlin\\nclass Solution {\\n    private val NON_HOLD = 0\\n    private val HOLD = 1\\n\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        return dfs(prices, fee, 0, NON_HOLD)\\n    }\\n\\n    private fun dfs(prices: IntArray, fee: Int, i: Int, status: Int): Int {\\n        if (i >= prices.size) return 0\\n\\n        if (status == NON_HOLD) {\\n            return maxOf(\\n                dfs(prices, fee, i+1, HOLD) - prices[i] - fee,\\n                dfs(prices, fee, i+1, NON_HOLD)\\n            )\\n        }\\n\\n        return maxOf(\\n            dfs(prices, fee, i+1, NON_HOLD) + prices[i],\\n            dfs(prices, fee, i+1, HOLD),\\n        )\\n    }\\n}\\n```\\n2. Identify repeating subproblems and memoize them\\n\\nNow we have to think about our approach. If we try to compute i=0 for each state, it requires us to recompute 0 -> n-1, then 1 -> n-1, then 2 -> n-1 and so on. But what if we already computed 1 -> n-1 ? Then we can memoize it and return our optimal profit at index i and state s:\\n\\n```kotlin\\nclass Solution {\\n    private val NON_HOLD = 0\\n    private val HOLD = 1\\n\\n    private lateinit var memo: Array<IntArray>\\n\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        val n = prices.size\\n        memo = Array(n) { IntArray(2) {-1} }\\n        return dfs(prices, fee, 0, NON_HOLD)\\n    }\\n\\n    private fun dfs(prices: IntArray, fee: Int, i: Int, status: Int): Int {\\n        if (i >= prices.size) return 0\\n        if (memo[i][status] != -1) return memo[i][status]\\n\\n        memo[i][status] =\\n            if (status == NON_HOLD) maxOf(\\n                dfs(prices, fee, i+1, HOLD) - prices[i] - fee,\\n                dfs(prices, fee, i+1, NON_HOLD)\\n            )\\n            else maxOf(\\n                dfs(prices, fee, i+1, NON_HOLD) + prices[i],\\n                dfs(prices, fee, i+1, HOLD),\\n            )\\n        return memo[i][status]\\n    }\\n}\\n```\\n3. try if it cannot be refactored to iterative solution\\n\\nIf we\\'ll think about this problem, then can do it from beginning to end (previously we did it top-down, so basically from the end). If we\\'ll decide to go with the for loop, then the logic might be like this: \\n1. current optimal hold would be the maximum of: previous optimal hold or previous optimal non-hold + buying current stock\\n2. current optimal non-hold would be maximum of: previous optimal non-hold or previous \\n\\nThen the answer lies in the last non hold, because finally, we can\\'t be holding a stock.\\n\\n```kotlin\\nclass Solution {\\n    private val NON_HOLD = 0\\n    private val HOLD = 1\\n\\n    private lateinit var memo: Array<IntArray>\\n\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        val n = prices.size\\n        memo = Array(n) { IntArray(2) {-1} }\\n        memo[0][NON_HOLD] = 0\\n        memo[0][HOLD] = -prices[0]-fee\\n\\n        for (i in 1 until n) {\\n            memo[i][HOLD] = maxOf(\\n                memo[i-1][HOLD], \\n                memo[i-1][NON_HOLD] - prices[i] - fee)\\n            memo[i][NON_HOLD] = maxOf(\\n                memo[i-1][NON_HOLD], \\n                memo[i-1][HOLD] + prices[i])\\n        }\\n\\n        return memo[n-1][NON_HOLD]\\n    }\\n}\\n```\\n4. optimize even more\\nThere is an obvious optimization we can make space-wise:\\n\\nNotice the approach in previous implementation - each time we just have to remember previous state. Then we just need to know the previous state which we can store in a single variable. This makes the algo O(n) time and O(1) space which can\\'t be optimized further.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        val n = prices.size\\n        var nonHold = 0\\n        var hold = -prices[0]-fee\\n\\n        for (i in 1 until n) {\\n            val tmpHold = hold\\n            hold = maxOf(hold, nonHold - prices[i] - fee)\\n            nonHold = maxOf(tmpHold + prices[i], nonHold)\\n        }\\n\\n        return nonHold\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```kotlin\\nclass Solution {\\n    private val NON_HOLD = 0\\n    private val HOLD = 1\\n\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        return dfs(prices, fee, 0, NON_HOLD)\\n    }\\n\\n    private fun dfs(prices: IntArray, fee: Int, i: Int, status: Int): Int {\\n        if (i >= prices.size) return 0\\n\\n        if (status == NON_HOLD) {\\n            return maxOf(\\n                dfs(prices, fee, i+1, HOLD) - prices[i] - fee,\\n                dfs(prices, fee, i+1, NON_HOLD)\\n            )\\n        }\\n\\n        return maxOf(\\n            dfs(prices, fee, i+1, NON_HOLD) + prices[i],\\n            dfs(prices, fee, i+1, HOLD),\\n        )\\n    }\\n}\\n```\n```kotlin\\nclass Solution {\\n    private val NON_HOLD = 0\\n    private val HOLD = 1\\n\\n    private lateinit var memo: Array<IntArray>\\n\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        val n = prices.size\\n        memo = Array(n) { IntArray(2) {-1} }\\n        return dfs(prices, fee, 0, NON_HOLD)\\n    }\\n\\n    private fun dfs(prices: IntArray, fee: Int, i: Int, status: Int): Int {\\n        if (i >= prices.size) return 0\\n        if (memo[i][status] != -1) return memo[i][status]\\n\\n        memo[i][status] =\\n            if (status == NON_HOLD) maxOf(\\n                dfs(prices, fee, i+1, HOLD) - prices[i] - fee,\\n                dfs(prices, fee, i+1, NON_HOLD)\\n            )\\n            else maxOf(\\n                dfs(prices, fee, i+1, NON_HOLD) + prices[i],\\n                dfs(prices, fee, i+1, HOLD),\\n            )\\n        return memo[i][status]\\n    }\\n}\\n```\n```kotlin\\nclass Solution {\\n    private val NON_HOLD = 0\\n    private val HOLD = 1\\n\\n    private lateinit var memo: Array<IntArray>\\n\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        val n = prices.size\\n        memo = Array(n) { IntArray(2) {-1} }\\n        memo[0][NON_HOLD] = 0\\n        memo[0][HOLD] = -prices[0]-fee\\n\\n        for (i in 1 until n) {\\n            memo[i][HOLD] = maxOf(\\n                memo[i-1][HOLD], \\n                memo[i-1][NON_HOLD] - prices[i] - fee)\\n            memo[i][NON_HOLD] = maxOf(\\n                memo[i-1][NON_HOLD], \\n                memo[i-1][HOLD] + prices[i])\\n        }\\n\\n        return memo[n-1][NON_HOLD]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxProfit(prices: IntArray, fee: Int): Int {\\n        val n = prices.size\\n        var nonHold = 0\\n        var hold = -prices[0]-fee\\n\\n        for (i in 1 until n) {\\n            val tmpHold = hold\\n            hold = maxOf(hold, nonHold - prices[i] - fee)\\n            nonHold = maxOf(tmpHold + prices[i], nonHold)\\n        }\\n\\n        return nonHold\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530531,
                "title": "python-beats-99-easy-accurate-solution-documented",
                "content": "Simple rule is to buy at least price and sell at higher price before the price goes down.\\n```\\nclass Solution:\\n    # Time O(n) Space O(1)    \\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        profit = 0                              # profit so far\\n        buy = prices[0] + fee                   # buy price\\n        for i in range(1, len(prices)):\\n            if prices[i] > buy:                 # can have profit if we sell today\\n                profit += prices[i] - buy       # - add the profit\\n                buy = prices[i]                 # - set new buy price\\n            elif prices[i] + fee < buy:         # last buy was a mistake, could have bought at this lower price today\\n                buy = prices[i] + fee           # - set new buy price\\n        return profit\\n```\\nPlease UPVOTE\\uD83D\\uDC4D if you love\\u2764\\uFE0F this solution or learned something new.\\nIf you have any question, feel free to ask.",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    # Time O(n) Space O(1)    \\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        profit = 0                              # profit so far\\n        buy = prices[0] + fee                   # buy price\\n        for i in range(1, len(prices)):\\n            if prices[i] > buy:                 # can have profit if we sell today\\n                profit += prices[i] - buy       # - add the profit\\n                buy = prices[i]                 # - set new buy price\\n            elif prices[i] + fee < buy:         # last buy was a mistake, could have bought at this lower price today\\n                buy = prices[i] + fee           # - set new buy price\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498633,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/edd44455-57d4-472d-bb6b-2497c39816c5_1661753457.7447906.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int tra,int fee,vector<int>& p,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tint profit;\\n\\t\\t\\tif(tra%2==0){\\n\\t\\t\\t\\tint buy= -p[i]+f(i+1,tra+1,fee,p,n);\\n\\t\\t\\t\\tint notbuy= f(i+1,tra,fee,p,n);\\n\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint sell= p[i]-fee+f(i+1,tra+1,fee,p,n);\\n\\t\\t\\t\\tint notsell= f(i+1,tra,fee,p,n);\\n\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t}\\n\\t\\t\\treturn profit;\\n\\t\\t}\\n\\n\\t\\tint maxProfit(vector<int>& p, int fee) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\treturn f(0,0,fee,p,n);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 2 [Memoization] \\t\\n![image](https://assets.leetcode.com/users/images/38365170-1048-42c4-8f20-428be54863e9_1661753315.007294.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int b,int fee,vector<int>& p,int n,vector<vector<int>>& dp){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(dp[i][b]!=-1) return dp[i][b];\\n\\t\\t\\tint profit;\\n\\t\\t\\tif(b){\\n\\t\\t\\t\\tint buy= -p[i]+f(i+1,0,fee,p,n,dp);\\n\\t\\t\\t\\tint notbuy= f(i+1,1,fee,p,n,dp);\\n\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint sell= p[i]-fee+f(i+1,1,fee,p,n,dp);\\n\\t\\t\\t\\tint notsell= f(i+1,0,fee,p,n,dp);\\n\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][b]=profit;\\n\\t\\t}\\n\\n\\t\\tint maxProfit(vector<int>& p, int fee) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(2,-1));\\n\\t\\t\\treturn f(0,1,fee,p,n,dp);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -3 [Tabulation] \\n\\n![image](https://assets.leetcode.com/users/images/fdb56aa3-77a9-4d23-8cb5-63aa1f398fab_1661753852.1692991.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p, int fee) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(2,0));\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int b=0;b<=1;b++){\\n\\t\\t\\t\\t\\tint profit;\\n\\t\\t\\t\\t\\tif(b){\\n\\t\\t\\t\\t\\t\\tint buy= -p[i]+dp[i+1][0];\\n\\t\\t\\t\\t\\t\\tint notbuy= dp[i+1][1];\\n\\t\\t\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint sell= p[i]-fee+dp[i+1][1];\\n\\t\\t\\t\\t\\t\\tint notsell= dp[i+1][0];\\n\\t\\t\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][b]=profit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][1];\\n\\t\\t}\\n\\t};\\n\\n# Method - 4 [SpaceOptimization]\\n![image](https://assets.leetcode.com/users/images/caa26cb1-65a5-466d-ac8d-5987ec8d8085_1661754402.7549605.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p, int fee) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<int> prev(2,0), curr(2,0);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int b=0;b<=1;b++){\\n\\t\\t\\t\\t\\tint profit;\\n\\t\\t\\t\\t\\tif(b){\\n\\t\\t\\t\\t\\t\\tint buy= -p[i]+prev[0];\\n\\t\\t\\t\\t\\t\\tint notbuy= prev[1];\\n\\t\\t\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint sell= p[i]-fee+prev[1];\\n\\t\\t\\t\\t\\t\\tint notsell= prev[0];\\n\\t\\t\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr[b]=profit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[1];\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int tra,int fee,vector<int>& p,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tint profit;\\n\\t\\t\\tif(tra%2==0){\\n\\t\\t\\t\\tint buy= -p[i]+f(i+1,tra+1,fee,p,n);\\n\\t\\t\\t\\tint notbuy= f(i+1,tra,fee,p,n);\\n\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2179215,
                "title": "python-4-approaches-entire-dp",
                "content": "**Recursion -> TLE\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N)**\\n\\n```\\ndef f(ind,buy,prices,fee):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,fee), 0 + f(ind+1,1,prices,fee))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind]-fee + f(ind+1,1,prices,fee), 0 + f(ind+1,0,prices,fee))\\n\\t\\t\\n    return profit \\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        return f(0,1,prices,fee)\\n```\\n\\n**Memoization**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N*2) + O(N)**\\n\\n```\\ndef f(ind,buy,prices,fee,dp):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,fee,dp), 0 + f(ind+1,1,prices,fee,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind]- fee + f(ind+1,1,prices,fee,dp), 0 + f(ind+1,0,prices,fee,dp))\\n        \\n    dp[ind][buy] = profit\\t\\n    return dp[ind][buy]\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        n = len(prices)\\n        dp =[[-1 for i in range(2)] for i in range(n)]\\n        \\n        return f(0,1,prices,fee,dp)\\n```\\n\\n**Tabulation**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N*2)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n+1)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind]-fee + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+1][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]      \\n```\\n\\n**Tabulation with SPACE OPTIMIZED\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        \\n        ahead = [0 for i in range(2)]\\n        curr = [0 for i in range(2)]\\n        \\n        ahead[0] = ahead[1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind]-fee + ahead[0], 0 + ahead[1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + ahead[1], 0 + ahead[0])\\n                    \\n                curr[buy] = profit\\n\\t\\t\\t\\t\\n            ahead = [x for x in curr]    \\n            ind -= 1    \\n\\t\\t\\t\\n        return ahead[1]\\n```\\n\\n**Please upvote if you find it useful !!!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef f(ind,buy,prices,fee):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,fee), 0 + f(ind+1,1,prices,fee))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind]-fee + f(ind+1,1,prices,fee), 0 + f(ind+1,0,prices,fee))\\n\\t\\t\\n    return profit \\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        return f(0,1,prices,fee)\\n```\n```\\ndef f(ind,buy,prices,fee,dp):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,fee,dp), 0 + f(ind+1,1,prices,fee,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind]- fee + f(ind+1,1,prices,fee,dp), 0 + f(ind+1,0,prices,fee,dp))\\n        \\n    dp[ind][buy] = profit\\t\\n    return dp[ind][buy]\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        n = len(prices)\\n        dp =[[-1 for i in range(2)] for i in range(n)]\\n        \\n        return f(0,1,prices,fee,dp)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n+1)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind]-fee + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+1][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]      \\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        \\n        ahead = [0 for i in range(2)]\\n        curr = [0 for i in range(2)]\\n        \\n        ahead[0] = ahead[1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind]-fee + ahead[0], 0 + ahead[1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + ahead[1], 0 + ahead[0])\\n                    \\n                curr[buy] = profit\\n\\t\\t\\t\\t\\n            ahead = [x for x in curr]    \\n            ind -= 1    \\n\\t\\t\\t\\n        return ahead[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586813,
                "title": "java-easy-and-clean-dp-solution-with-handwritten-explanation",
                "content": "Time Complexity - O(N)\\nSpace Complexity - O(1)\\nRuntime - 4ms - Faster than 60.21%\\n.\\n **CODE**\\n```\\nclass Solution {\\n    public int maxProfit(int[] arr, int fees) {\\n        int n = arr.length;\\n        int bsp = -arr[0];\\n    \\tint ssp = 0;\\n    \\tfor(int i=1; i<n; i++){\\n    \\t\\tint bd = (bsp > ssp-arr[i]) ? bsp : ssp-arr[i];\\n    \\t\\tint sd = (ssp > bsp + arr[i] - fees) ? ssp : bsp + arr[i] - fees;\\n    \\t\\tbsp = bd;\\n    \\t\\tssp = sd;\\n    \\t}\\n    \\treturn ssp;\\n    }\\n}\\n```\\n# **Handwritten Explanation**\\n![image](https://assets.leetcode.com/users/images/d343b686-c27b-4e4b-a7cb-6c4d87d8d8e2_1637343894.1586857.jpeg)\\n.\\n![image](https://assets.leetcode.com/users/images/4351d591-c398-45d9-a10e-af100d8cb672_1637343944.0810592.jpeg)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] arr, int fees) {\\n        int n = arr.length;\\n        int bsp = -arr[0];\\n    \\tint ssp = 0;\\n    \\tfor(int i=1; i<n; i++){\\n    \\t\\tint bd = (bsp > ssp-arr[i]) ? bsp : ssp-arr[i];\\n    \\t\\tint sd = (ssp > bsp + arr[i] - fees) ? ssp : bsp + arr[i] - fees;\\n    \\t\\tbsp = bd;\\n    \\t\\tssp = sd;\\n    \\t}\\n    \\treturn ssp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586778,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimization from O(N) to O(1)\\n\\n---\\n\\n**Top-Down:**\\n\\nThere are 3 cases to consider, optimally choose the maximal:\\n\\n1. if we do *not* `have` stock, then we can `buy` at price `A[i]`\\n2. if we do `have` stock, then we can `sell` what we `have` at price `A[i]`\\n3. we can `hold` onto what we `have`\\n\\n**Bottom-Up:** similar to [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/1566910/The-ART-of-Dynamic-Programming), this problem is difficult to turn the top-down solution upside-down to create the bottom-up solution, since we are *not* directly following the recursive stack unwinding.  Instead we use the following base cases and recurrence relation with a state machine.\\n\\n**Base cases:**\\n\\nWhen `i = 0` there are 2 considerations: buy or don\\'t buy at price `A[0]`\\n\\n1. `none[0]` represents do *not* buy `A[0]`\\n2. `have[0]` represents buy (ie. it cost `-A[0]` to buy and have `A[0]`)\\n\\n**Recurrence relation:**\\n\\nWe optimally choose the maximum of 4 choices within 2 states, ie. we iteratively build each current optimal `i`<sup>th</sup> solution upon previous optimal `i - 1`<sup>th</sup> solutions for `i = 1..N - 1` where `N` is the cardinality of the input array `A` of stock prices:\\n\\n![image](https://assets.leetcode.com/users/images/bbe1b0fd-9685-4c77-921c-74399027a0e9_1637342383.5602803.png)\\n\\n\\n**`none[i]` means we currently have *no* stock, so we can either:**\\n1. hold onto *no* stock\\n2. buy at price `A[i]` for a cost of `-A[i]`\\n\\n**`have[i]` means we currently have stock, so we can either:**\\n1. hold onto the stock we have\\n2. sell at price `A[i]` with `fee`\\n    \\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int, NONE: Int = -1): Int {\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (i == A.size)\\n                return 0\\n            var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n            var sell = if (have != NONE) go(i + 1, NONE) +  A[i] - have - fee else 0\\n            var hold = go(i + 1, have)\\n            return listOf(buy, sell, hold).max()!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int, NONE: Int = -1): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (i == A.size)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n                var sell = if (have != NONE) go(i + 1, NONE) +  A[i] - have - fee else 0\\n                var hold = go(i + 1, have)\\n                m[k] = listOf(buy, sell, hold).max()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int): Int {\\n        var N = A.size\\n        var none = IntArray(N) { 0 }\\n        var have = IntArray(N) { 0 }\\n        have[0] = -A[0]                                                 // it costs -A[0] to buy & have A[0]\\n        for (i in 1 until N) {\\n            none[i] = Math.max(none[i - 1], have[i - 1] + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have[i] = Math.max(have[i - 1], none[i - 1] - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none[N - 1]\\n    }\\n}\\n```\\n\\n4. Memory optimization from O(N) to O(1)\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int): Int {\\n        var N = A.size\\n        var (none, have) = listOf(0, -A[0])                      // it costs -A[0] to buy & have A[0]\\n        for (i in 1 until N) {\\n            var (last_none, last_have) = listOf(none, have)\\n            none = Math.max(last_none, last_have + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have = Math.max(last_have, last_none - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet maxProfit = (A, fee, NONE = -1) => {\\n    let go = (i = 0, have = NONE) => {\\n        if (i == A.length)\\n            return 0;\\n        let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n            sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee: 0,\\n            hold = go(i + 1, have);\\n        return Math.max(buy, sell, hold);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet maxProfit = (A, fee, m = new Map(), NONE = -1) => {\\n    let go = (i = 0, have = NONE) => {\\n        if (i == A.length)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee: 0,\\n                hold = go(i + 1, have);\\n            m.set(k, Math.max(buy, sell, hold));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet maxProfit = (A, fee) => {\\n    let N = A.length;\\n    let none = Array(N).fill(0),\\n        have = Array(N).fill(0);\\n    have[0] = -A[0];                                                // it costs -A[0] to buy & have A[0]\\n    for (let i = 1; i < N; ++i) {\\n        none[i] = Math.max(none[i - 1], have[i - 1] + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n        have[i] = Math.max(have[i - 1], none[i - 1] - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n    }\\n    return none[N - 1];\\n};\\n```\\n\\n4. Memory optimization from O(N) to O(1)\\n```\\nlet maxProfit = (A, fee) => {\\n    let [none, have] = [0, -A[0]];                           // it costs -A[0] to buy & have A[0]\\n    for (let i = 1; i < A.length; ++i) {\\n        let [last_none, last_have] = [none, have];\\n        none = Math.max(last_none, last_have + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n        have = Math.max(last_have, last_none - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n    }\\n    return none;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int, NONE: int = -1) -> int:\\n        def go(i = 0, have = NONE):\\n            if i == len(A):\\n                return 0\\n            a = go(i + 1, A[i]) if have == NONE else 0\\n            b = go(i + 1, NONE) + A[i] - have - fee if have != NONE else 0\\n            c = go(i + 1, have)\\n            return max(a, b, c)\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int, NONE: int = -1) -> int:\\n        @cache\\n        def go(i = 0, have = NONE):\\n            if i == len(A):\\n                return 0\\n            a = go(i + 1, A[i]) if have == NONE else 0\\n            b = go(i + 1, NONE) + A[i] - have - fee if have != NONE else 0\\n            c = go(i + 1, have)\\n            return max(a, b, c)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int) -> int:\\n        N = len(A)\\n        none = [0] * N\\n        have = [0] * N\\n        have[0] = -A[0]                                           # it costs -A[0] to buy & have A[0]\\n        for i in range(1, N):\\n            none[i] = max(none[i - 1], have[i - 1] + A[i] - fee)  # implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have[i] = max(have[i - 1], none[i - 1] - A[i])        # implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        return none[N - 1]\\n```\\n\\n4. Memory optimization from O(N) to O(1)\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int) -> int:\\n        none, have = 0, -A[0]                                                  # it costs -A[0] to buy & have A[0]\\n        for i in range(1, len(A)):\\n            none, have = max(none, have + A[i] - fee), max(have, none - A[i])  # none = max(implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee), have = max(implicit hold when have[i] = have[i - 1] or buy at price A[i])\\n        return none\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int maxProfit(VI& A, int fee, int NONE = -1) {\\n        fun go = [&](auto i, auto have) {\\n            if (i == A.size())\\n                return 0;\\n            auto buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                 sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee : 0,\\n                 hold = go(i + 1, have);\\n            return max({ buy, sell, hold });\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxProfit(VI& A, int fee, Map m = {}, int NONE = -1) {\\n        auto key = [](auto i, auto have) {\\n            stringstream ss; ss << i << \",\" << have;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (i == A.size())\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                     sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee : 0,\\n                     hold = go(i + 1, have);\\n                m[k] = max({ buy, sell, hold });\\n            }\\n            return m[k];\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int fee) {\\n        int N = A.size();\\n        VI none(N),\\n           have(N);\\n        have[0] = -A[0];                                           // it costs -A[0] to buy & have A[0]\\n        for (auto i{ 1 }; i < N; ++i) {\\n            none[i] = max(none[i - 1], have[i - 1] + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have[i] = max(have[i - 1], none[i - 1] - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none[N - 1];\\n    }\\n};\\n```\\n\\n4. Memory optimization from O(N) to O(1)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int fee) {\\n        auto [none, have] = make_tuple(0, -A[0]);           // it costs -A[0] to buy & have A[0]\\n        for (auto i{ 1 }; i < A.size(); ++i) {\\n            auto [last_none, last_have] = make_tuple(none, have);\\n            none = max(last_none, last_have + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have = max(last_have, last_none - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int, NONE: Int = -1): Int {\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (i == A.size)\\n                return 0\\n            var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n            var sell = if (have != NONE) go(i + 1, NONE) +  A[i] - have - fee else 0\\n            var hold = go(i + 1, have)\\n            return listOf(buy, sell, hold).max()!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int, NONE: Int = -1): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = NONE): Int {\\n            if (i == A.size)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var buy  = if (have == NONE) go(i + 1, A[i]) else 0\\n                var sell = if (have != NONE) go(i + 1, NONE) +  A[i] - have - fee else 0\\n                var hold = go(i + 1, have)\\n                m[k] = listOf(buy, sell, hold).max()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int): Int {\\n        var N = A.size\\n        var none = IntArray(N) { 0 }\\n        var have = IntArray(N) { 0 }\\n        have[0] = -A[0]                                                 // it costs -A[0] to buy & have A[0]\\n        for (i in 1 until N) {\\n            none[i] = Math.max(none[i - 1], have[i - 1] + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have[i] = Math.max(have[i - 1], none[i - 1] - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none[N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray, fee: Int): Int {\\n        var N = A.size\\n        var (none, have) = listOf(0, -A[0])                      // it costs -A[0] to buy & have A[0]\\n        for (i in 1 until N) {\\n            var (last_none, last_have) = listOf(none, have)\\n            none = Math.max(last_none, last_have + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have = Math.max(last_have, last_none - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none\\n    }\\n}\\n```\n```\\nlet maxProfit = (A, fee, NONE = -1) => {\\n    let go = (i = 0, have = NONE) => {\\n        if (i == A.length)\\n            return 0;\\n        let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n            sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee: 0,\\n            hold = go(i + 1, have);\\n        return Math.max(buy, sell, hold);\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxProfit = (A, fee, m = new Map(), NONE = -1) => {\\n    let go = (i = 0, have = NONE) => {\\n        if (i == A.length)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee: 0,\\n                hold = go(i + 1, have);\\n            m.set(k, Math.max(buy, sell, hold));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxProfit = (A, fee) => {\\n    let N = A.length;\\n    let none = Array(N).fill(0),\\n        have = Array(N).fill(0);\\n    have[0] = -A[0];                                                // it costs -A[0] to buy & have A[0]\\n    for (let i = 1; i < N; ++i) {\\n        none[i] = Math.max(none[i - 1], have[i - 1] + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n        have[i] = Math.max(have[i - 1], none[i - 1] - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n    }\\n    return none[N - 1];\\n};\\n```\n```\\nlet maxProfit = (A, fee) => {\\n    let [none, have] = [0, -A[0]];                           // it costs -A[0] to buy & have A[0]\\n    for (let i = 1; i < A.length; ++i) {\\n        let [last_none, last_have] = [none, have];\\n        none = Math.max(last_none, last_have + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n        have = Math.max(last_have, last_none - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n    }\\n    return none;\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int, NONE: int = -1) -> int:\\n        def go(i = 0, have = NONE):\\n            if i == len(A):\\n                return 0\\n            a = go(i + 1, A[i]) if have == NONE else 0\\n            b = go(i + 1, NONE) + A[i] - have - fee if have != NONE else 0\\n            c = go(i + 1, have)\\n            return max(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int, NONE: int = -1) -> int:\\n        @cache\\n        def go(i = 0, have = NONE):\\n            if i == len(A):\\n                return 0\\n            a = go(i + 1, A[i]) if have == NONE else 0\\n            b = go(i + 1, NONE) + A[i] - have - fee if have != NONE else 0\\n            c = go(i + 1, have)\\n            return max(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int) -> int:\\n        N = len(A)\\n        none = [0] * N\\n        have = [0] * N\\n        have[0] = -A[0]                                           # it costs -A[0] to buy & have A[0]\\n        for i in range(1, N):\\n            none[i] = max(none[i - 1], have[i - 1] + A[i] - fee)  # implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have[i] = max(have[i - 1], none[i - 1] - A[i])        # implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        return none[N - 1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], fee: int) -> int:\\n        none, have = 0, -A[0]                                                  # it costs -A[0] to buy & have A[0]\\n        for i in range(1, len(A)):\\n            none, have = max(none, have + A[i] - fee), max(have, none - A[i])  # none = max(implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee), have = max(implicit hold when have[i] = have[i - 1] or buy at price A[i])\\n        return none\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int maxProfit(VI& A, int fee, int NONE = -1) {\\n        fun go = [&](auto i, auto have) {\\n            if (i == A.size())\\n                return 0;\\n            auto buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                 sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee : 0,\\n                 hold = go(i + 1, have);\\n            return max({ buy, sell, hold });\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxProfit(VI& A, int fee, Map m = {}, int NONE = -1) {\\n        auto key = [](auto i, auto have) {\\n            stringstream ss; ss << i << \",\" << have;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (i == A.size())\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto buy  = have == NONE ? go(i + 1, A[i]) : 0,\\n                     sell = have != NONE ? go(i + 1, NONE) + A[i] - have - fee : 0,\\n                     hold = go(i + 1, have);\\n                m[k] = max({ buy, sell, hold });\\n            }\\n            return m[k];\\n        };\\n        return go(0, NONE);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int fee) {\\n        int N = A.size();\\n        VI none(N),\\n           have(N);\\n        have[0] = -A[0];                                           // it costs -A[0] to buy & have A[0]\\n        for (auto i{ 1 }; i < N; ++i) {\\n            none[i] = max(none[i - 1], have[i - 1] + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have[i] = max(have[i - 1], none[i - 1] - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none[N - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int fee) {\\n        auto [none, have] = make_tuple(0, -A[0]);           // it costs -A[0] to buy & have A[0]\\n        for (auto i{ 1 }; i < A.size(); ++i) {\\n            auto [last_none, last_have] = make_tuple(none, have);\\n            none = max(last_none, last_have + A[i] - fee);  // implicit hold when none[i] = none[i - 1] or sell what we have at price A[i] w/ fee\\n            have = max(last_have, last_none - A[i]);        // implicit hold when have[i] = have[i - 1] or buy at price A[i]\\n        }\\n        return none;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523408,
                "title": "c-recursive-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[50001][2];\\n    int solve(vector<int>& prices, int &fee, int pos, bool hold){\\n        if(pos==prices.size()) return 0;\\n        if(dp[pos][hold]!=-1) return dp[pos][hold];\\n        int buy=0,notbuy=0,sell=0,notsell=0;\\n        if(!hold) buy = solve(prices,fee,pos+1,!hold) - prices[pos];\\n        notbuy = solve(prices,fee,pos+1,hold);\\n        if(hold) sell = solve(prices,fee,pos+1,!hold) + prices[pos] - fee;\\n        notsell = solve(prices,fee,pos+1,hold);\\n        return dp[pos][hold] = max({buy,notbuy,sell,notsell});\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,fee,0,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[50001][2];\\n    int solve(vector<int>& prices, int &fee, int pos, bool hold){\\n        if(pos==prices.size()) return 0;\\n        if(dp[pos][hold]!=-1) return dp[pos][hold];\\n        int buy=0,notbuy=0,sell=0,notsell=0;\\n        if(!hold) buy = solve(prices,fee,pos+1,!hold) - prices[pos];\\n        notbuy = solve(prices,fee,pos+1,hold);\\n        if(hold) sell = solve(prices,fee,pos+1,!hold) + prices[pos] - fee;\\n        notsell = solve(prices,fee,pos+1,hold);\\n        return dp[pos][hold] = max({buy,notbuy,sell,notsell});\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,fee,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353024,
                "title": "easy-c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve (vector<int>& prices, int i, int fee, int bought) {\\n        if (i >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[i][bought] != -1) {\\n            return dp[i][bought];\\n        }\\n        \\n        // Skip\\n        int result = solve(prices, i+1, fee, bought);\\n\\n        if (bought == 1) {\\n            // Sell\\n            result = max(result, solve(prices, i+1, fee, 0) + prices[i] - fee);\\n        } else {\\n            // Buy\\n            result = max(result, solve(prices, i+1, fee, 1) - prices[i]);\\n        }\\n        dp[i][bought] = result;\\n        return result;\\n        \\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        dp.resize(n, vector<int> (2, -1));\\n        return solve(prices, 0, fee, 0);    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve (vector<int>& prices, int i, int fee, int bought) {\\n        if (i >= prices.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[i][bought] != -1) {\\n            return dp[i][bought];\\n        }\\n        \\n        // Skip\\n        int result = solve(prices, i+1, fee, bought);\\n\\n        if (bought == 1) {\\n            // Sell\\n            result = max(result, solve(prices, i+1, fee, 0) + prices[i] - fee);\\n        } else {\\n            // Buy\\n            result = max(result, solve(prices, i+1, fee, 1) - prices[i]);\\n        }\\n        dp[i][bought] = result;\\n        return result;\\n        \\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        dp.resize(n, vector<int> (2, -1));\\n        return solve(prices, 0, fee, 0);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344347,
                "title": "2-lines-elegant-precise-o-n-solution-with-o-1-space-no-dp-c",
                "content": "* **IT\\'S A TRICKY SOLUTION TO COME UP WITH AT FIRST ATTEMPT. So take a Pen-Paper and DRY Run this Code Step by Step.** \\n* **Runtime : 60ms**\\n```\\n// Idea : We have to hold the CASH to buy the stocks and hold themaximum profit we could have  if we owned a share of stock\\n// Initially we have negative hold cash because we have to buy first before making any profit..\\nint maxProfit(vector<int>& prices, int fee) {\\n\\tint cash = 0, hold = -prices[0];                     // Buy here first stock initially\\n\\tfor(int i = 1; i < prices.size(); ++i){\\n\\t\\tcash = max(cash, hold + prices[i] - fee);        // Sell the stock(s)\\n\\t\\thold = max(hold, cash - prices[i]);             // Buy the stock(s) buy holding as much as profit\\n\\t}\\n\\treturn cash;\\n}\\n```\\n**TIME COMPLEXITY : `O(n)`, Where, n : size of prices array** \\n**SPACE COMPLEXITY :  `O(1) [Constant]`,**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense Pls **Upvote :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Idea : We have to hold the CASH to buy the stocks and hold themaximum profit we could have  if we owned a share of stock\\n// Initially we have negative hold cash because we have to buy first before making any profit..\\nint maxProfit(vector<int>& prices, int fee) {\\n\\tint cash = 0, hold = -prices[0];                     // Buy here first stock initially\\n\\tfor(int i = 1; i < prices.size(); ++i){\\n\\t\\tcash = max(cash, hold + prices[i] - fee);        // Sell the stock(s)\\n\\t\\thold = max(hold, cash - prices[i]);             // Buy the stock(s) buy holding as much as profit\\n\\t}\\n\\treturn cash;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310304,
                "title": "c-recursive-memoization",
                "content": "```\\n int v[100001][2];\\n    int find(vector<int> &prices, int i,bool buy,int fee)\\n    {\\n        if(i>=prices.size()) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  \\n        {\\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,!buy,fee),find(prices,i+1,buy,fee)); \\n        }\\n        else   \\n        {      \\n           return v[i][buy]=max( (prices[i]-fee)+find(prices,i+1,!buy,fee),find(prices,i+1,buy,fee)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices,int fee) {\\n        memset(v,-1,sizeof(v));\\n        int n=prices.size(); \\n        return find(prices,0,1,fee);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int v[100001][2];\\n    int find(vector<int> &prices, int i,bool buy,int fee)\\n    {\\n        if(i>=prices.size()) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  \\n        {\\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,!buy,fee),find(prices,i+1,buy,fee)); \\n        }\\n        else   \\n        {      \\n           return v[i][buy]=max( (prices[i]-fee)+find(prices,i+1,!buy,fee),find(prices,i+1,buy,fee)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices,int fee) {\\n        memset(v,-1,sizeof(v));\\n        int n=prices.size(); \\n        return find(prices,0,1,fee);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262762,
                "title": "c-solution-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size(), buying = 0, selling = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            buying = max(buying, selling + prices[i] - fee);\\n            selling = max(selling, buying - prices[i]);\\n        }\\n        return buying;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size(), buying = 0, selling = -prices[0];\\n        for (int i = 1; i < n; i++) {\\n            buying = max(buying, selling + prices[i] - fee);\\n            selling = max(selling, buying - prices[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1113484,
                "title": "c-dp-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices, int fee) {\\n        \\n        if(prices == null || prices.Length == 0)\\n            return 0;\\n        \\n        // buy[i]: max profit if we buy the stock on ith day \\n        int[] buy = new int[prices.Length];\\n        // sell[i]: max profit if we sell the stock on ith day \\n        int[] sell = new int[prices.Length];\\n        // On 0th day, we pay prices[0] to buy the stock\\n        buy[0] = -prices[0];\\n        // on 0th day, since we buy & sell the stock at the same day at the same prices, so the profit is 0.\\n        sell[0] = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            // On ith day, we have 3 options: buy stock, sell stock, do nothing\\n            \\n            // If we buy stock on ith day\\n            buy[i] = Math.Max(buy[i - 1], sell[i - 1] - prices[i]);\\n            \\n            // If we sell stock on ith day\\n            sell[i] = Math.Max(sell[i - 1], buy[i - 1] + prices[i] - fee);\\n        }\\n        \\n        return sell[prices.Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices, int fee) {\\n        \\n        if(prices == null || prices.Length == 0)\\n            return 0;\\n        \\n        // buy[i]: max profit if we buy the stock on ith day \\n        int[] buy = new int[prices.Length];\\n        // sell[i]: max profit if we sell the stock on ith day \\n        int[] sell = new int[prices.Length];\\n        // On 0th day, we pay prices[0] to buy the stock\\n        buy[0] = -prices[0];\\n        // on 0th day, since we buy & sell the stock at the same day at the same prices, so the profit is 0.\\n        sell[0] = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            // On ith day, we have 3 options: buy stock, sell stock, do nothing\\n            \\n            // If we buy stock on ith day\\n            buy[i] = Math.Max(buy[i - 1], sell[i - 1] - prices[i]);\\n            \\n            // If we sell stock on ith day\\n            sell[i] = Math.Max(sell[i - 1], buy[i - 1] + prices[i] - fee);\\n        }\\n        \\n        return sell[prices.Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702760,
                "title": "explanation-same-logic-for-other-time-series-stock-problems",
                "content": "On a day i you can be in the following states:\\n1. You don\\'t have a stock denoted by dp[i][0]\\n2. You have a stock denoted by dp[i][1]\\n\\nhere dp[i][0] and dp[i][1] denotes profit till ith day in two states, our goal is to maximize this.\\n\\nNow the magic formula:\\ncase 1: if you don\\'t have a stock, it means \\n\\ta) either you didn\\'t have it on the previous day and doing no transactions today or\\n\\tb) had a stock from previous day and selling it today plus paying the fees for the transaction\\n\\tthe above can be written as below ::\\n\\t dp[i][0] = max ( dp[i-1][0], dp[i-1][1] + prices[i] - fee)\\n\\t since our goal is to have maximum profit, we take max\\n\\ncase 2: if you have a stock, it means \\n\\ta) either you had it on the previous day and doing no transactions today or\\n\\tb) had no stock on previous day and buying it today \\n\\tthe above can be written as below ::\\n\\tdp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n\\t since our goal is to have maximum profit, we take max\\n\\nFinally we want the last days profit for the state where we are holding no stocks , hence return dp[-1][0]\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:  \\n        dp = [[0 for _ in range(2)] for _ in range(len(prices))]\\n        dp[0][0] = 0\\n        dp[0][1] =  - prices[0]\\n        \\n        for i in range(1,len(prices)):\\n            dp[i][0] = max ( dp[i-1][0], dp[i-1][1] + prices[i] - fee)\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n          \\n        return dp[-1][0]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "On a day i you can be in the following states:\\n1. You don\\'t have a stock denoted by dp[i][0]\\n2. You have a stock denoted by dp[i][1]\\n\\nhere dp[i][0] and dp[i][1] denotes profit till ith day in two states, our goal is to maximize this.\\n\\nNow the magic formula:\\ncase 1: if you don\\'t have a stock, it means \\n\\ta) either you didn\\'t have it on the previous day and doing no transactions today or\\n\\tb) had a stock from previous day and selling it today plus paying the fees for the transaction\\n\\tthe above can be written as below ::\\n\\t dp[i][0] = max ( dp[i-1][0], dp[i-1][1] + prices[i] - fee)\\n\\t since our goal is to have maximum profit, we take max\\n\\ncase 2: if you have a stock, it means \\n\\ta) either you had it on the previous day and doing no transactions today or\\n\\tb) had no stock on previous day and buying it today \\n\\tthe above can be written as below ::\\n\\tdp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n\\t since our goal is to have maximum profit, we take max\\n\\nFinally we want the last days profit for the state where we are holding no stocks , hence return dp[-1][0]\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:  \\n        dp = [[0 for _ in range(2)] for _ in range(len(prices))]\\n        dp[0][0] = 0\\n        dp[0][1] =  - prices[0]\\n        \\n        for i in range(1,len(prices)):\\n            dp[i][0] = max ( dp[i-1][0], dp[i-1][1] + prices[i] - fee)\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n          \\n        return dp[-1][0]",
                "codeTag": "Java"
            },
            {
                "id": 609298,
                "title": "c-greedy-solution",
                "content": "\\n\\tint maxProfit(vector<int>& prices, int fee) {\\n         int profit = 0;\\n         int n = prices.size();\\n         int lowest = prices[0];\\n         for(int i=1;i<n;i++) {\\n             if(prices[i]<lowest) {\\n                lowest = prices[i];\\n             }\\n             int diff = prices[i] - lowest;\\n             if(diff > 0 && diff > fee) {\\n                 profit += prices[i] - lowest - fee;\\n                 lowest = prices[i] - fee;\\n             }\\n         }\\n         return profit;\\n     }",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "\\n\\tint maxProfit(vector<int>& prices, int fee) {\\n         int profit = 0;\\n         int n = prices.size();\\n         int lowest = prices[0];\\n         for(int i=1;i<n;i++) {\\n             if(prices[i]<lowest) {\\n                lowest = prices[i];\\n             }\\n             int diff = prices[i] - lowest;\\n             if(diff > 0 && diff > fee) {\\n                 profit += prices[i] - lowest - fee;\\n                 lowest = prices[i] - fee;\\n             }\\n         }\\n         return profit;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 556577,
                "title": "easy-to-understand-dp-solution-works-on-every-kind-of-stock-buy-and-sell-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        vector<vector<int> > dp(n+1,vector<int>(4,0));\\n        //4 states 1=> buy stock on ith day\\n        //         2=>sell stock on ith day\\n        //         3=>did nothing, i just have a stock on ith day\\n        //         4=>did nothing and i dont stock on ith day\\n        if(n<=1) return 0;\\n        dp[0][0]=-prices[0];\\n        dp[0][1]=INT_MIN;   // intially not possible to sell stock\\n        dp[0][2]=INT_MIN; // initially condition not possible\\n        for(int i=1;i<n;i++){\\n            dp[i][0]=max(dp[i-1][1],dp[i-1][3])-prices[i];// can buy only if i sold last day or did nothing last day\\n            dp[i][1]=max(dp[i-1][0],dp[i-1][2])+prices[i]-fee;// sell only if i brought last day or i was holding a stock\\n            dp[i][2]=max(dp[i-1][2],dp[i-1][0]); // i have stock because i was already having stock on (i-1)th day or i bought stock prev day\\n            dp[i][3]=max(dp[i-1][3],dp[i-1][1]); // i did nothing and  have nothing because i had nothing earlier day too or i sold in the last day \\n        }\\n        return *max_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        vector<vector<int> > dp(n+1,vector<int>(4,0));\\n        //4 states 1=> buy stock on ith day\\n        //         2=>sell stock on ith day\\n        //         3=>did nothing, i just have a stock on ith day\\n        //         4=>did nothing and i dont stock on ith day\\n        if(n<=1) return 0;\\n        dp[0][0]=-prices[0];\\n        dp[0][1]=INT_MIN;   // intially not possible to sell stock\\n        dp[0][2]=INT_MIN; // initially condition not possible\\n        for(int i=1;i<n;i++){\\n            dp[i][0]=max(dp[i-1][1],dp[i-1][3])-prices[i];// can buy only if i sold last day or did nothing last day\\n            dp[i][1]=max(dp[i-1][0],dp[i-1][2])+prices[i]-fee;// sell only if i brought last day or i was holding a stock\\n            dp[i][2]=max(dp[i-1][2],dp[i-1][0]); // i have stock because i was already having stock on (i-1)th day or i bought stock prev day\\n            dp[i][3]=max(dp[i-1][3],dp[i-1][1]); // i did nothing and  have nothing because i had nothing earlier day too or i sold in the last day \\n        }\\n        return *max_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242075,
                "title": "intuitive-dp-python",
                "content": "on jth day , what do I do?\\n1. I keep my money\\n2. I decide to sell, meaning I bought before \\n\\n```\\ndp[j] = maximum money i can make with nums[:j + 1] (j th day is included)\\n         = max(dp[j-1],              max(profit by buying on ith day and selling on jth + dp[i-1] for all i ) )\\n\\t\\t      I dont sell                      I sell\\n```\\ncode\\n\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        dp = [0] * len(prices)\\n        for j in range(len(dp)):\\n            dp[j] = dp[j -1]\\n            for i in range(j):\\n                dp[j] = max(dp[j], +prices[j] - prices[i] - fee + (dp[i - 1] if i - 1 >=0 else 0))\\n        return dp[-1]\\n```\\n\\nmore formal analysis\\n\\n1. **subproblem definition**: dp[j]  = max money i can make with nums[:j + 1]\\n2. **number of subproblems**, |nums|= O(n)\\n3. **time per subproblem** = O(n)\\n4. **recurrence** dp[j] = max(dp[j-1], max(+prices[j] - prices[i] - fee + dp[i - 1] for i in range(j)))\\n5. **total time** = time per subproblem * number of subproblems = O(n^2)\\n6. **top down or bottom up**: bottom up \\n7. **final answer** = dp[-1]  \\n\\nwhen computing \\n```\\ndp[j] = max(dp[j-1], +prices[j] - prices[i] - fee + dp[i - 1])\\n```\\nI be taking the prices[j] out and leaving everything else in \\n```\\ndp[j] = max(dp[j-1], +prices[j] + max( - prices[i] - fee + dp[i - 1]))\\n```\\nmakes it O(1) per subproblem \\ntotal time linear\\n\\ncode  changed to \\n\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        dp = [0] * len(prices)\\n        m = - prices[0] - fee\\n        for j in range(1,len(dp)):\\n            dp[j] = max(dp[j-1] if j - 1 >= 0 else 0, prices[j] + m)\\n            m = max(m, -prices[j] -fee + dp[j-1])\\n        return dp[-1]\\n```\\n\\n\\nthen one more change to have free memory usage , I only need dp[j] and dp[j-1] every time so I only keep these 2 \\n\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        u,v = 0,0\\n        m = - prices[0] - fee\\n        for j in range(1,len(prices)):\\n            v = max(u, prices[j] + m)\\n            m = max(m, -prices[j] - fee + u)\\n            u = v\\n        return v\\n```\\n\\nthat makes it faster for some reason \\n\\n",
                "solutionTags": [],
                "code": "```\\ndp[j] = maximum money i can make with nums[:j + 1] (j th day is included)\\n         = max(dp[j-1],              max(profit by buying on ith day and selling on jth + dp[i-1] for all i ) )\\n\\t\\t      I dont sell                      I sell\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        dp = [0] * len(prices)\\n        for j in range(len(dp)):\\n            dp[j] = dp[j -1]\\n            for i in range(j):\\n                dp[j] = max(dp[j], +prices[j] - prices[i] - fee + (dp[i - 1] if i - 1 >=0 else 0))\\n        return dp[-1]\\n```\n```\\ndp[j] = max(dp[j-1], +prices[j] - prices[i] - fee + dp[i - 1])\\n```\n```\\ndp[j] = max(dp[j-1], +prices[j] + max( - prices[i] - fee + dp[i - 1]))\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        dp = [0] * len(prices)\\n        m = - prices[0] - fee\\n        for j in range(1,len(dp)):\\n            dp[j] = max(dp[j-1] if j - 1 >= 0 else 0, prices[j] + m)\\n            m = max(m, -prices[j] -fee + dp[j-1])\\n        return dp[-1]\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        u,v = 0,0\\n        m = - prices[0] - fee\\n        for j in range(1,len(prices)):\\n            v = max(u, prices[j] + m)\\n            m = max(m, -prices[j] - fee + u)\\n            u = v\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176265,
                "title": "python-dp-state-value-transition-approach-for-all-this-type-of-questions",
                "content": "For this question you have nothing more than 2 states - `hold` and `sell`\\nNote for initialization, `hold` has to be negative infinity because you cannot hold any stock before you iterate through stock prices (for each stage). Then it\\'s DP like everyone said, the code in for loop defines state transition and how to get optimal values. We don\\'t need O(n) space since we only need the optimal values for each state (but not stage).\\n```\\nclass Solution:\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        hold, sell = -float(\\'inf\\'), 0\\n        for p in prices:\\n            hold = max(hold, sell - p - fee)\\n            sell = max(sell, hold + p)\\n        return sell\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices, fee):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \"\"\"\\n        hold, sell = -float(\\'inf\\'), 0\\n        for p in prices:\\n            hold = max(hold, sell - p - fee)\\n            sell = max(sell, hold + p)\\n        return sell\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932948,
                "title": "python-dp-recursion-space-optimization",
                "content": "```\\n#Recursion \\n#Time Complexity: O(2^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def solve(ind,buy):\\n            if ind==n:\\n                return 0\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else: # sell a stock\\n                take=prices[ind]-fee+solve(ind+1,0)\\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            return profit\\n        n=len(prices)\\n        return solve(0,0)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2) + O(n)\\nclass Solution2:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def solve(ind,buy):\\n            if ind==n:\\n                return 0\\n            if dp[ind][buy]!=-1:\\n                return dp[ind][buy]\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]-fee+solve(ind+1,0) \\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            dp[ind][buy]=profit\\n            return dp[ind][buy]\\n        n=len(prices)\\n        dp=[[-1,-1] for i in range(n)]\\n        return solve(0,0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2)\\nclass Solution3:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n=len(prices)\\n        dp=[[0,0] for i in range(n+1)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+dp[ind+1][1] \\n                    not_take=0+dp[ind+1][0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]-fee+dp[ind+1][0] \\n                    not_take=0+dp[ind+1][1]\\n                    profit=max(take,not_take)\\n                dp[ind][buy]=profit\\n        return dp[0][0]\\n    \\n#Space Optimization\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n=len(prices)\\n        ahead=[0]*2\\n        curr=[0]*2\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+ahead[1] \\n                    not_take=0+ahead[0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]-fee+ahead[0] # +2 for cooldown\\n                    not_take=0+ahead[1]\\n                    profit=max(take,not_take)\\n                curr[buy]=profit\\n            ahead=curr[:]\\n        return curr[0]\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(2^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def solve(ind,buy):\\n            if ind==n:\\n                return 0\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else: # sell a stock\\n                take=prices[ind]-fee+solve(ind+1,0)\\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            return profit\\n        n=len(prices)\\n        return solve(0,0)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2) + O(n)\\nclass Solution2:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def solve(ind,buy):\\n            if ind==n:\\n                return 0\\n            if dp[ind][buy]!=-1:\\n                return dp[ind][buy]\\n            profit=0\\n            if buy==0: #buy a stock\\n                take=-prices[ind]+solve(ind+1,1) \\n                not_take=0+solve(ind+1,0)\\n                profit=max(take,not_take)\\n            else:\\n                take=prices[ind]-fee+solve(ind+1,0) \\n                not_take=0+solve(ind+1,1)\\n                profit=max(take,not_take)\\n            dp[ind][buy]=profit\\n            return dp[ind][buy]\\n        n=len(prices)\\n        dp=[[-1,-1] for i in range(n)]\\n        return solve(0,0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(n*2)\\nclass Solution3:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n=len(prices)\\n        dp=[[0,0] for i in range(n+1)]\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+dp[ind+1][1] \\n                    not_take=0+dp[ind+1][0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]-fee+dp[ind+1][0] \\n                    not_take=0+dp[ind+1][1]\\n                    profit=max(take,not_take)\\n                dp[ind][buy]=profit\\n        return dp[0][0]\\n    \\n#Space Optimization\\n#Time Complexity: O(n*2)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n=len(prices)\\n        ahead=[0]*2\\n        curr=[0]*2\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                profit=0\\n                if buy==0: #buy a stock\\n                    take=-prices[ind]+ahead[1] \\n                    not_take=0+ahead[0]\\n                    profit=max(take,not_take)\\n                else:\\n                    take=prices[ind]-fee+ahead[0] # +2 for cooldown\\n                    not_take=0+ahead[1]\\n                    profit=max(take,not_take)\\n                curr[buy]=profit\\n            ahead=curr[:]\\n        return curr[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671383,
                "title": "hey-can-u-do-in-o-n-time-and-o-1-space-complexity-if-not-then-please-refer-my-solution",
                "content": "# Intuition\\nif we think dp approch then what will be our ans for i\\'th index\\ndp[i]=max(dp[i],arr[i]-arr[j]+dp[j-1]-fee); till j<i and dp[i] will be maximum profit till that day.\\nso for i\\'th day we have to maximize the value of -arr[j]+dp[j-1] and both value we have already so we will keep pre value that will be store the val of maximum val of -arr[j]+dp[j-1];.\\nso no need of dp , we can do in o(1) space.because we have to simply store the max val of -arr[j]+dp[j-1];\\n# Approach\\ninitially for i=0 ans will be 0;pre will be pre=-arr[0],ans=0;\\ni=1; ans=max(ans,arr[1]+pre-fee); pre=max(pre,-arr[1]+ans)\\nso on.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr, int fee) {\\n        int n=arr.size();\\n        int ans=0;\\n        int pre=-arr[0];\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,arr[i]+pre-fee);\\n            pre=max(pre,ans-arr[i]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr, int fee) {\\n        int n=arr.size();\\n        int ans=0;\\n        int pre=-arr[0];\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,arr[i]+pre-fee);\\n            pre=max(pre,ans-arr[i]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667583,
                "title": "optimized-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int c = 0;  // cash\\n        int h = prices[0];  // total amount bought, can be negative as well\\n        \\n        for (int i = 1; i < prices.size(); i++) {\\n            // Calculate the maximum profit if we sell the stock on the current day\\n            // The profit is the difference between the current price and the amount bought,\\n            // minus the transaction fee\\n            int profit = prices[i] - h - fee;\\n            \\n            // Update the cash value to be the maximum of the current cash and the profit\\n            c = max(c, profit);\\n            \\n            // Update the total amount bought to be the minimum of the current amount bought\\n            // and the current price minus the cash value\\n            h = min(h, prices[i] - c);\\n        }\\n        \\n        return c;  // Return the maximum profit\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int c = 0;  // cash\\n        int h = prices[0];  // total amount bought, can be negative as well\\n        \\n        for (int i = 1; i < prices.size(); i++) {\\n            // Calculate the maximum profit if we sell the stock on the current day\\n            // The profit is the difference between the current price and the amount bought,\\n            // minus the transaction fee\\n            int profit = prices[i] - h - fee;\\n            \\n            // Update the cash value to be the maximum of the current cash and the profit\\n            c = max(c, profit);\\n            \\n            // Update the total amount bought to be the minimum of the current amount bought\\n            // and the current price minus the cash value\\n            h = min(h, prices[i] - c);\\n        }\\n        \\n        return c;  // Return the maximum profit\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667536,
                "title": "recursion-top-down-dp-memoisation-bottom-up-dp-tabulation",
                "content": "# Recursion\\n# Complexity\\n- Time complexity : $$Exponential$$ ~ $$O(2^N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$ (for auxilliary stack space)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        return f(0,1,prices,fee);\\n    }\\n\\n    int f(int i, int buy, vector<int> &prices, int fee) {\\n        if(i == prices.size()) return 0;\\n\\n        int pick = 0;\\n        int notPick = 0;\\n        if(buy) {\\n            pick = -prices[i] + f(i+1,0,prices,fee);\\n            notPick = f(i+1,1,prices,fee); \\n        }\\n\\n        else {\\n            pick = prices[i] - fee + f(i+1,1,prices,fee);\\n            notPick = f(i+1,0,prices,fee);\\n        }\\n        return dp[i][buy] = max(pick,notPick);\\n    }\\n};\\n```\\n\\n# Top Down DP - Memoisation\\n# Complexity\\n- Time complexity : $$O(n*2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n*2)$$ $$+$$ $$O(n)$$(auxilliary stack space)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        return f(0,1,prices,fee,dp);\\n    }\\n\\n    int f(int i, int buy, vector<int> &prices, int fee, vector<vector<int>> &dp) {\\n        if(i == prices.size()) return 0;\\n        \\n        if(dp[i][buy] != -1) return dp[i][buy];\\n\\n        int pick = 0;\\n        int notPick = 0;\\n        if(buy) {\\n            pick = -prices[i] + f(i+1,0,prices,fee,dp);\\n            notPick = f(i+1,1,prices,fee,dp); \\n        }\\n\\n        else {\\n            pick = prices[i] - fee + f(i+1,1,prices,fee,dp);\\n            notPick = f(i+1,0,prices,fee,dp);\\n        }\\n        return dp[i][buy] = max(pick,notPick);\\n    }\\n};\\n```\\n\\n# Bottom Up DP - Tabulation\\n# Complexity\\n- Time complexity : $$O(n*2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n*2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n\\n        for(int i=n-1 ; i>=0 ; i--) {\\n            for(int buy=0 ; buy<=1 ; buy++) {\\n                int pick = 0;\\n                int notPick = 0;\\n                if(buy) {\\n                    pick = -prices[i] + dp[i+1][0];\\n                    notPick = dp[i+1][1]; \\n                }\\n\\n                else {\\n                    pick = prices[i] - fee + dp[i+1][1];\\n                    notPick = dp[i+1][0];\\n                }\\n                dp[i][buy] = max(pick,notPick);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\nPlease upvote if you liked the solution\\n![upvote LC.jfif](https://assets.leetcode.com/users/images/e690378f-d576-4698-9af3-38a23f358fd7_1687400313.4077866.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        return f(0,1,prices,fee);\\n    }\\n\\n    int f(int i, int buy, vector<int> &prices, int fee) {\\n        if(i == prices.size()) return 0;\\n\\n        int pick = 0;\\n        int notPick = 0;\\n        if(buy) {\\n            pick = -prices[i] + f(i+1,0,prices,fee);\\n            notPick = f(i+1,1,prices,fee); \\n        }\\n\\n        else {\\n            pick = prices[i] - fee + f(i+1,1,prices,fee);\\n            notPick = f(i+1,0,prices,fee);\\n        }\\n        return dp[i][buy] = max(pick,notPick);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        return f(0,1,prices,fee,dp);\\n    }\\n\\n    int f(int i, int buy, vector<int> &prices, int fee, vector<vector<int>> &dp) {\\n        if(i == prices.size()) return 0;\\n        \\n        if(dp[i][buy] != -1) return dp[i][buy];\\n\\n        int pick = 0;\\n        int notPick = 0;\\n        if(buy) {\\n            pick = -prices[i] + f(i+1,0,prices,fee,dp);\\n            notPick = f(i+1,1,prices,fee,dp); \\n        }\\n\\n        else {\\n            pick = prices[i] - fee + f(i+1,1,prices,fee,dp);\\n            notPick = f(i+1,0,prices,fee,dp);\\n        }\\n        return dp[i][buy] = max(pick,notPick);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n\\n        for(int i=n-1 ; i>=0 ; i--) {\\n            for(int buy=0 ; buy<=1 ; buy++) {\\n                int pick = 0;\\n                int notPick = 0;\\n                if(buy) {\\n                    pick = -prices[i] + dp[i+1][0];\\n                    notPick = dp[i+1][1]; \\n                }\\n\\n                else {\\n                    pick = prices[i] - fee + dp[i+1][1];\\n                    notPick = dp[i+1][0];\\n                }\\n                dp[i][buy] = max(pick,notPick);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478518,
                "title": "python-simple-clean-solution-step-by-step-dp-improvisation",
                "content": "# Code\\n\\n#### Using lru_cache\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        @lru_cache(None)\\n        def helper(i, buy):\\n            if i == n: return 0\\n\\n            ans = helper(i + 1, buy)\\n            if buy:\\n                ans = max(ans, helper(i + 1, False) - prices[i])\\n            else:\\n                ans = max(ans, helper(i + 1, True) + prices[i] - fee)\\n            return ans\\n        return helper(0, True)\\n```\\n\\n#### Using DP\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[0] * 2 for _ in range(n+1)]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][0] - prices[i])\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][1] + prices[i] - fee)\\n                \\n        return dp[0][1]\\n```\\n\\n#### Space Optimization\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp, dpPrev = [0, 0], [0, 0]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[j] = max(dpPrev[j], dpPrev[0] - prices[i])\\n                else:\\n                    dp[j] = max(dpPrev[j], dpPrev[1] + prices[i] - fee)\\n            dpPrev = dp\\n                \\n        return dpPrev[1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        @lru_cache(None)\\n        def helper(i, buy):\\n            if i == n: return 0\\n\\n            ans = helper(i + 1, buy)\\n            if buy:\\n                ans = max(ans, helper(i + 1, False) - prices[i])\\n            else:\\n                ans = max(ans, helper(i + 1, True) + prices[i] - fee)\\n            return ans\\n        return helper(0, True)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[0] * 2 for _ in range(n+1)]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][0] - prices[i])\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i+1][1] + prices[i] - fee)\\n                \\n        return dp[0][1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp, dpPrev = [0, 0], [0, 0]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(2):\\n                if j == 1:\\n                    dp[j] = max(dpPrev[j], dpPrev[0] - prices[i])\\n                else:\\n                    dp[j] = max(dpPrev[j], dpPrev[1] + prices[i] - fee)\\n            dpPrev = dp\\n                \\n        return dpPrev[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966787,
                "title": "dp-solution",
                "content": "\\n# Code\\n```\\nfunction maxProfit(prices: number[], fee: number): number {\\n    const m = prices.length\\n    const firstDay = 0, hold = 0;\\n    //memoization\\n    const dp = new Array(m)\\n\\n    for(let i=0;i<m;i++){\\n        dp[i] = new Array(2).fill(-1)\\n    }\\n\\n    return manageStocks(firstDay, hold, fee, prices, dp)\\n};\\n\\nconst manageStocks = (ind:number, hold:number, fee:number, prices:number[], dp:number[][]) => {\\n\\n    if(ind >= prices.length)  return 0\\n\\n    if(dp[ind][hold] !== -1)  return dp[ind][hold]\\n\\n    let buyStock = 0, sellStock = 0, skipDay = 0;\\n    // purchase stock;\\n    if(hold === 0){\\n        buyStock = -prices[ind] + manageStocks(ind+1, 1, fee, prices, dp)\\n    }else if(hold === 1){ //sell stock\\n        sellStock = prices[ind] - fee + manageStocks(ind+1, 0, fee, prices, dp)\\n    }\\n    //skip current day \\n    skipDay = manageStocks(ind+1, hold, fee, prices, dp)\\n\\n    return dp[ind][hold] = Math.max(buyStock, sellStock, skipDay)\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction maxProfit(prices: number[], fee: number): number {\\n    const m = prices.length\\n    const firstDay = 0, hold = 0;\\n    //memoization\\n    const dp = new Array(m)\\n\\n    for(let i=0;i<m;i++){\\n        dp[i] = new Array(2).fill(-1)\\n    }\\n\\n    return manageStocks(firstDay, hold, fee, prices, dp)\\n};\\n\\nconst manageStocks = (ind:number, hold:number, fee:number, prices:number[], dp:number[][]) => {\\n\\n    if(ind >= prices.length)  return 0\\n\\n    if(dp[ind][hold] !== -1)  return dp[ind][hold]\\n\\n    let buyStock = 0, sellStock = 0, skipDay = 0;\\n    // purchase stock;\\n    if(hold === 0){\\n        buyStock = -prices[ind] + manageStocks(ind+1, 1, fee, prices, dp)\\n    }else if(hold === 1){ //sell stock\\n        sellStock = prices[ind] - fee + manageStocks(ind+1, 0, fee, prices, dp)\\n    }\\n    //skip current day \\n    skipDay = manageStocks(ind+1, hold, fee, prices, dp)\\n\\n    return dp[ind][hold] = Math.max(buyStock, sellStock, skipDay)\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756091,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P, int F) {\\n        int len = P.size(), buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = max(buying, selling + P[i] - F);\\n            selling = max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P, int F) {\\n        int len = P.size(), buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = max(buying, selling + P[i] - F);\\n            selling = max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660525,
                "title": "short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n        for(int i=n-1;i>=0;i--){\\n            dp[i][1] = max(-prices[i] + dp[i+1][0],dp[i+1][1]);  // if buy = 1 means you can buy\\n            dp[i][0] = max(prices[i] - fee + dp[i+1][1],dp[i+1][0]);  // you can sell\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n        for(int i=n-1;i>=0;i--){\\n            dp[i][1] = max(-prices[i] + dp[i+1][0],dp[i+1][1]);  // if buy = 1 means you can buy\\n            dp[i][0] = max(prices[i] - fee + dp[i+1][1],dp[i+1][0]);  // you can sell\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578069,
                "title": "golang-solution-state-machine-t-o-n-s-o-1",
                "content": "```\\nfunc maxProfit(prices []int, fee int) int {\\n\\tlength := len(prices)\\n\\tif length == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\twithShare := -1 * prices[0]\\n\\tnoShare := 0\\n\\tfor i := 1; i < length; i++ {\\n\\t\\tnoShare = int(math.Max(float64(noShare), float64(withShare+prices[i]-fee)))\\n\\t\\twithShare = int(math.Max(float64(withShare), float64(noShare-prices[i])))\\n\\t}\\n\\n\\treturn noShare\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxProfit(prices []int, fee int) int {\\n\\tlength := len(prices)\\n\\tif length == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\twithShare := -1 * prices[0]\\n\\tnoShare := 0\\n\\tfor i := 1; i < length; i++ {\\n\\t\\tnoShare = int(math.Max(float64(noShare), float64(withShare+prices[i]-fee)))\\n\\t\\twithShare = int(math.Max(float64(withShare), float64(noShare-prices[i])))\\n\\t}\\n\\n\\treturn noShare\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509831,
                "title": "java-top-down",
                "content": "I think it is really necessary to understand the top down approach before trying to solve it bottom up.\\nThis solution is based on the video by neetcode: https://www.youtube.com/watch?v=I7j0F7AHpb8\\n\\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    return dp(prices, fee, 0, 0, new Integer[prices.length][2]);\\n}\\n\\nprivate int dp(int[] prices, int fee, int index, int buying, Integer[][] memo) {\\n    if (index == prices.length) {\\n        return 0;\\n    }\\n    if (memo[index][buying] != null) {\\n        return memo[index][buying];\\n    }\\n    if (buying == 0) { // buying acts as a flag\\n        int buy = dp(prices, fee, index + 1, buying + 1, memo) - prices[index];\\n        int doNothing = dp(prices, fee, index + 1, buying, memo);\\n        memo[index][buying] = Math.max(buy, doNothing);\\n    } else {\\n        int sell = dp(prices, fee, index + 1, buying - 1, memo) + prices[index] - fee;\\n        int doNothing = dp(prices, fee, index + 1, buying, memo);\\n        memo[index][buying] = Math.max(sell, doNothing);\\n    }\\n    return memo[index][buying];\\n}\\n```\\n\\t\\n\\nThis same framework can be easily modified for these other problems (try in this order):\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic int maxProfit(int[] prices, int fee) {\\n    return dp(prices, fee, 0, 0, new Integer[prices.length][2]);\\n}\\n\\nprivate int dp(int[] prices, int fee, int index, int buying, Integer[][] memo) {\\n    if (index == prices.length) {\\n        return 0;\\n    }\\n    if (memo[index][buying] != null) {\\n        return memo[index][buying];\\n    }\\n    if (buying == 0) { // buying acts as a flag\\n        int buy = dp(prices, fee, index + 1, buying + 1, memo) - prices[index];\\n        int doNothing = dp(prices, fee, index + 1, buying, memo);\\n        memo[index][buying] = Math.max(buy, doNothing);\\n    } else {\\n        int sell = dp(prices, fee, index + 1, buying - 1, memo) + prices[index] - fee;\\n        int doNothing = dp(prices, fee, index + 1, buying, memo);\\n        memo[index][buying] = Math.max(sell, doNothing);\\n    }\\n    return memo[index][buying];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219064,
                "title": "java-in-depth-explanation",
                "content": "I think the naming convention on LeetCode needs to be improve. It\\'s so confused to me that what does `hold` mean? After having headache for a while, I kinda figure out. `hold` represents the max profit if we buy the current stock. You can see it clearly in my solution below.\\n\\n```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices, int fee) \\n    {\\n        if(prices == null || prices.length <= 1)    return 0;\\n        \\n        // hold represents profit_so_far_if_we_buy\\n        int cash = 0;\\n        int hold = cash - prices[0];\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            cash = Math.max(cash, hold + prices[i] - fee);\\n            \\n            // can we make more profit, if we sell the previous stock somewhere before this point and buy the new stock now\\n            hold = Math.max(hold, cash - prices[i]);\\n        }\\n        return cash;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices, int fee) \\n    {\\n        if(prices == null || prices.length <= 1)    return 0;\\n        \\n        // hold represents profit_so_far_if_we_buy\\n        int cash = 0;\\n        int hold = cash - prices[0];\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            cash = Math.max(cash, hold + prices[i] - fee);\\n            \\n            // can we make more profit, if we sell the previous stock somewhere before this point and buy the new stock now\\n            hold = Math.max(hold, cash - prices[i]);\\n        }\\n        return cash;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075024,
                "title": "99-64-in-java-solution",
                "content": "class Solution {\\n    public int maxProfit(int[] prices, int fee) {    \\n\\t\\n        int len = prices.length, profit = 0, buy = prices[0];\\n        for (int i = 1; i < len; i++) {\\n            profit = Math.max(profit,  prices[i]- buy - fee);\\n            buy = Math.min(buy, prices[i]-profit);\\n        }\\n        return profit;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxProfit(int[] prices, int fee) {    \\n\\t\\n        int len = prices.length, profit = 0, buy = prices[0];\\n        for (int i = 1; i < len; i++) {\\n            profit = Math.max(profit,  prices[i]- buy - fee);\\n            buy = Math.min(buy, prices[i]-profit);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1758614,
                "title": "proper-top-down-dp-c",
                "content": "**ind** `current position`, **use**  `if we are currently holding any stock (1) or not (0)`\\n\\n**Case 1**: If we are not holding any stock (hold == 0) then we can either:\\n**1.1** *Assume we\\'re holding some stock and we sold it on this step thus also subtracting the fee*  `arr[ind] - fee + solve(arr, ind-1, 1, fee)`\\n**1.2** *Were not including this stock in any operations* `solve(arr, ind-1, 0, fee)`\\n\\n\\n**Case 2**: If were holding stock currently (hold == 1) the we can either:\\n**2.1** *Assume we bought stock from this step, thus subtract the price and similarly find answer for previous index* `solve(arr, ind-1, 0, fee)-arr[ind]`\\n**2.2**  *We didn\\'t bought stock from this step* `solve(arr, ind-1, 1, fee)` \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp[2];\\n    int solve(vector<int> &arr, int ind, int hold, int fee)\\n    {\\n        if(ind == 0)\\n        {\\n            if(hold == 1) return -arr[ind];\\n            else return 0;\\n        }\\n        \\n        if(dp[hold][ind]!=INT_MIN) return dp[hold][ind];\\n        \\n        if(!hold)\\n        {\\n            dp[hold][ind] = max(arr[ind] - fee + solve(arr, ind-1, 1, fee), solve(arr, ind-1, 0, fee));\\n        }\\n        else\\n        {\\n            dp[hold][ind] = max(solve(arr, ind-1, 0, fee)-arr[ind], solve(arr, ind-1, 1, fee));\\n        }\\n        return dp[hold][ind];\\n    }\\n    int maxProfit(vector<int>& nums, int fee) {\\n        int n = nums.size();\\n        for(int i=0;i<2;++i) dp[i].resize(n, INT_MIN);\\n        return solve(nums, n-1, 0, fee);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp[2];\\n    int solve(vector<int> &arr, int ind, int hold, int fee)\\n    {\\n        if(ind == 0)\\n        {\\n            if(hold == 1) return -arr[ind];\\n            else return 0;\\n        }\\n        \\n        if(dp[hold][ind]!=INT_MIN) return dp[hold][ind];\\n        \\n        if(!hold)\\n        {\\n            dp[hold][ind] = max(arr[ind] - fee + solve(arr, ind-1, 1, fee), solve(arr, ind-1, 0, fee));\\n        }\\n        else\\n        {\\n            dp[hold][ind] = max(solve(arr, ind-1, 0, fee)-arr[ind], solve(arr, ind-1, 1, fee));\\n        }\\n        return dp[hold][ind];\\n    }\\n    int maxProfit(vector<int>& nums, int fee) {\\n        int n = nums.size();\\n        for(int i=0;i<2;++i) dp[i].resize(n, INT_MIN);\\n        return solve(nums, n-1, 0, fee);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690075,
                "title": "",
                "content": "1\\uFF0C \\u5982\\u679C\\u67D0\\u5929\\u76F8\\u5BF9\\u4E8E\\u524D\\u4E00\\u5929\\u4EF7\\u683C\\u4E0D\\u53D8\\uFF0C\\u5219\\u4ECA\\u65E5\\u7684\\u4E70\\u5356\\u7B49\\u6548\\u4E8E\\u524D\\u4E00\\u5929\\u7684\\u4E70\\u5356\\u3002\\n\\n\\u56E0\\u6B64\\u53EF\\u4EE5\\u5047\\u8BBE\\u6BCF\\u4E00\\u5929\\u7684\\u4EF7\\u683C\\u90FD\\u4F1A\\u53D8\\u5316\\u3002\\n\\n\\n2\\uFF0C\\u5982\\u679C\\u7B2C\\u4E8C\\u5929\\u76F8\\u5BF9\\u4ECA\\u5929\\u4E0A\\u6DA8\\u4E14\\u4ECA\\u5929\\u76F8\\u5BF9\\u524D\\u4E00\\u5929\\u4E0A\\u6DA8\\uFF0C\\u90A3\\u4E48\\u524D\\u4E00\\u5929\\u4E70\\u5165\\u6BD4\\u4ECA\\u5929\\u66F4\\u4F18\\uFF0C\\u5E76\\u4E14\\u540E\\u4E00\\u5929\\u5356\\u51FA\\u6BD4\\u4ECA\\u5929\\u5356\\u51FA\\u66F4\\u4F18\\u3002\\n\\u5982\\u679C\\u7B2C\\u4E8C\\u5929\\u76F8\\u5BF9\\u4ECA\\u5929\\u4E0B\\u8DCC\\u4E14\\u4ECA\\u5929\\u76F8\\u5BF9\\u524D\\u4E00\\u5929\\u4E0B\\u8DCC\\uFF0C\\u90A3\\u4E48\\u524D\\u4E00\\u5929\\u5356\\u51FA\\u6BD4\\u4ECA\\u5929\\u5356\\u51FA\\u66F4\\u4F18\\uFF0C\\u5E76\\u4E14\\u540E\\u4E00\\u5929\\u5356\\u51FA\\u6BD4\\u4ECA\\u5929\\u5356\\u51FA\\u66F4\\u4F18\\u3002\\n\\n\\u56E0\\u6B64\\u53EF\\u4EE5\\u5047\\u8BBE\\u4EF7\\u683C\\u53EA\\u4F1A\\u51FA\\u73B0\\u4EA4\\u66FF\\u4E0A\\u6DA8\\u4E0B\\u8DCC\\u3002\\n\\n3\\uFF0C\\u6BCF\\u5929\\u53EA\\u6709 \\u4E70\\u5165 \\u5356\\u51FA \\u4E0D\\u64CD\\u4F5C\\u4E09\\u79CD\\u9009\\u62E9\\u3002\\u603B\\u5929\\u6570\\u6709\\u9650\\uFF0C\\u56E0\\u800C\\u4E0D\\u540C\\u7684\\u64CD\\u4F5C\\u65B9\\u5F0F\\u6570\\u91CF\\u6709\\u9650\\u3002\\u4E8E\\u662F\\u5FC5\\u5B9A\\u5B58\\u5728\\u67D0\\u4E00\\u79CD\\u64CD\\u4F5C\\u65B9\\u5F0F\\u5229\\u6DA6\\u6700\\u5927\\u3002\\n\\n4\\uFF0C\\u8003\\u8651\\u4E00\\u79CD\\u6700\\u5927\\u5229\\u6DA6\\u7684\\u64CD\\u4F5C\\u65B9\\u5F0F\\u3002\\u8003\\u8651\\u7B2C\\u4E00\\u6B21\\u4E70\\u5165\\u7684\\u65F6\\u95F4\\u70B9\\u3002\\u4ECE\\u5DE6\\u5230\\u4F9D\\u6B21\\u8003\\u8651\\u5C40\\u90E8\\u6700\\u4F4E\\u70B9\\u3002\\u5148\\u8003\\u8651d0\\uFF0C\\n\\nA \\u82E5\\u5C40\\u90E8\\u6700\\u9AD8\\u70B9u0\\u4E0Ed0\\u5DEE\\u503C\\u5927\\u4E8Efee\\uFF0C\\u5219d0\\u7684\\u786E\\u4E3A\\u7B2C\\u4E00\\u6B21\\u4E70\\u5165\\u7684\\u65F6\\u95F4\\u70B9\\u3002\\n\\u63A5\\u4E0B\\u6765\\u6709\\u4E24\\u79CD\\u9009\\u62E9\\uFF0C1\\uFF0C\\u7EE7\\u7EED\\u6301\\u6709\\uFF0C2\\uFF0C\\u76F4\\u63A5\\u5356\\u51FA\\n\\u5982\\u679C\\u51FA\\u73B0\\u4E00\\u6B21\\u4F4E\\u70B9\\u5C0F\\u4E8E \\u524D\\u65B9\\u6700\\u9AD8\\u7684\\u9AD8\\u70B9-fee\\uFF0C\\u5219\\u5E94\\u5728\\u524D\\u65B9\\u6700\\u9AD8\\u7684\\u9AD8\\u70B9\\u5356\\u51FA\\u3002\\n\\u5982\\u679C\\u4F4E\\u70B9\\u59CB\\u7EC8\\u5927\\u4E8E\\u524D\\u65B9\\u6700\\u9AD8\\u7684\\u9AD8\\u70B9-fee\\uFF0C\\u5219\\u5E94\\u5728\\u540E\\u65B9\\u7684\\u6700\\u9AD8\\u70B9\\u5356\\u51FA \\u5E76\\u7ED3\\u675F\\u4E70\\u5356\\u3002\\n\\nB\\u82E5\\u5C40\\u90E8\\u6700\\u9AD8\\u70B9u0\\u4E0Ed0\\u5DEE\\u503C\\u5C0F\\u4E8Efee\\uFF0C\\u9700\\u8981\\u8003\\u8651\\u540E\\u7EED\\u624D\\u80FD\\u5224\\u65AD\\u80FD\\u5426\\u4F5C\\u4E3A\\u4E70\\u5165\\u70B9\\u3002\\u5982\\u679C\\u4E0B\\u4E00\\u4E2A\\u4F4E\\u70B9\\u5C0F\\u4E8Eu0\\uFF0C\\u5219\\u5E94\\u8BE5\\u5C06\\u5176\\u66F4\\u65B0\\u4E3A\\u53EF\\u80FD\\u7684\\u4E70\\u5165\\u70B9\\uFF0C\\u7EE7\\u7EED\\u8003\\u8651\\u662F\\u5426\\u5B58\\u5728\\u9AD8\\u70B9\\u5927\\u4E8E\\u4F4E\\u70B9\\u8D85\\u8FC7fee\\u3002\\u5982\\u679C\\u5B58\\u5728\\uFF0C\\u5219\\u8FDB\\u5165A \\u3002\\u5982\\u679C\\u59CB\\u7EC8\\u4E0D\\u5B58\\u5728\\uFF0C\\u5219\\u65E0\\u9700\\u7EE7\\u7EED\\u64CD\\u4F5C\\u3002\\n\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices, int fee)\\n    {\\n        if (prices.size() == 1)\\n            return 0;\\n        int buy = prices[0];\\n        bool bpf = false; //buy\\u70B9\\u662F\\u5426\\u5DF2\\u7ECF\\u9501\\u5B9A\\n        int high = prices[0];\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); i++)\\n        {\\n            if (!bpf)\\n            {\\n                if (!bpf && prices[i] <= buy)\\n                {\\n                    buy = prices[i];\\n                    high = buy;\\n                }\\n                else if (prices[i] - buy >= fee)\\n                {\\n                    bpf = true;\\n                    //}else{\\n                    //    continue;\\n                }\\n            }\\n            else\\n            {\\n                if (high - prices[i] >= fee)\\n                {\\n                    profit += high - buy - fee;\\n                    buy = prices[i];\\n                    high = buy;\\n                    bpf = false;\\n                    //}else{\\n                }\\n            }\\n            high = max(prices[i], high);\\n        }\\n        profit += max(0, high - buy - fee);\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices, int fee)\\n    {\\n        if (prices.size() == 1)\\n            return 0;\\n        int buy = prices[0];\\n        bool bpf = false; //buy\\u70B9\\u662F\\u5426\\u5DF2\\u7ECF\\u9501\\u5B9A\\n        int high = prices[0];\\n        int profit = 0;\\n        for (int i = 1; i < prices.size(); i++)\\n        {\\n            if (!bpf)\\n            {\\n                if (!bpf && prices[i] <= buy)\\n                {\\n                    buy = prices[i];\\n                    high = buy;\\n                }\\n                else if (prices[i] - buy >= fee)\\n                {\\n                    bpf = true;\\n                    //}else{\\n                    //    continue;\\n                }\\n            }\\n            else\\n            {\\n                if (high - prices[i] >= fee)\\n                {\\n                    profit += high - buy - fee;\\n                    buy = prices[i];\\n                    high = buy;\\n                    bpf = false;\\n                    //}else{\\n                }\\n            }\\n            high = max(prices[i], high);\\n        }\\n        profit += max(0, high - buy - fee);\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684685,
                "title": "python-greedy-and-dp",
                "content": "## Greedy : O(n) time, O(1) space\\n![](https://github.com/wf9a5m75/leetcode/blob/c2a15ef00f0550b1b0b40a822eb541cbb5644c53/best-time-to-buy-and-sell-stock-with-transaction-fee/whiteboard_for_solution1.jpg?raw=true)\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        #\\n        # Greedy\\n        #   O(n) time\\n        #   O(1) space\\n        #\\n        N = len(prices)\\n        if (N <= 1):\\n            return 0\\n        ans = 0\\n        lowest = prices[0]\\n        for i in range(1, N):\\n            if lowest > prices[i]:\\n                lowest = prices[i]\\n            elif lowest + fee < prices[i]:\\n                ans += prices[i] - fee - lowest\\n                lowest = prices[i] - fee\\n        return ans\\n```\\n\\n-----\\n\\n## DP : O(n) time, O(N) space\\n\\nBase idea : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking)\\n\\n![](https://github.com/wf9a5m75/leetcode/blob/c2a15ef00f0550b1b0b40a822eb541cbb5644c53/best-time-to-buy-and-sell-stock-with-transaction-fee/whiteboard_for_solution0.jpg?raw=true)\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        #\\n        # DP\\n        #   O(n) time\\n        #   O(n) space\\n        #\\n        N = len(prices)\\n        if (N <= 1):\\n            return 0\\n\\n        wallet = [0] * N\\n        cost = [0] * N\\n        sell = [0] * N\\n\\n        cost[0] = -prices[0] - fee\\n        sell[0] = 0\\n        # print(*wallet)\\n        # print(*cost)\\n        # print(*sell)\\n        for i in range(1, N):\\n            wallet[i] = max(wallet[i - 1], sell[i - 1])\\n            cost[i] = max(cost[i - 1], wallet[i] -prices[i] - fee)\\n            sell[i] =  prices[i] + cost[i]\\n            # print(\"-------\")\\n            # print(*wallet)\\n            # print(*cost)\\n            # print(*sell)\\n        return max(wallet[-1], sell[-1])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        #\\n        # Greedy\\n        #   O(n) time\\n        #   O(1) space\\n        #\\n        N = len(prices)\\n        if (N <= 1):\\n            return 0\\n        ans = 0\\n        lowest = prices[0]\\n        for i in range(1, N):\\n            if lowest > prices[i]:\\n                lowest = prices[i]\\n            elif lowest + fee < prices[i]:\\n                ans += prices[i] - fee - lowest\\n                lowest = prices[i] - fee\\n        return ans\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        #\\n        # DP\\n        #   O(n) time\\n        #   O(n) space\\n        #\\n        N = len(prices)\\n        if (N <= 1):\\n            return 0\\n\\n        wallet = [0] * N\\n        cost = [0] * N\\n        sell = [0] * N\\n\\n        cost[0] = -prices[0] - fee\\n        sell[0] = 0\\n        # print(*wallet)\\n        # print(*cost)\\n        # print(*sell)\\n        for i in range(1, N):\\n            wallet[i] = max(wallet[i - 1], sell[i - 1])\\n            cost[i] = max(cost[i - 1], wallet[i] -prices[i] - fee)\\n            sell[i] =  prices[i] + cost[i]\\n            # print(\"-------\")\\n            # print(*wallet)\\n            # print(*cost)\\n            # print(*sell)\\n        return max(wallet[-1], sell[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669952,
                "title": "fully-explained-solution",
                "content": "*One of the best questions in DP*\\n  \\n\\tNote: There is transaction fees only if you sell it.\\n Lets assume on a particular day you can be in two states: \\n1.  You have a stock in hand ** `hold`**\\n2. You do not have a stock in hand  **`cash`**\\n\\nState 1 i.e you have a stock in hand if you held a stock yesterday and did not do any transactions today or you did not have a stock yesterday and bought a stock today.\\nState 2 i.e you donot have a stock in hand today. This can be achieved if you sold yesterdays stock or continued to remain without a stock.\\n\\nLets describe the states in code: \\n```\\nhold[i] = Math.max(hold[i-1],cash[i-1]-price[i])\\ncash[i] = Math.max(cash[i-1], hold[i-1]+price[i]-fee)\\n```\\n\\nLets consider an example    `prices = {1,3,2,8,4,9}`\\n\\n**Day 1**\\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0}\\nhold = {-1,0,0,0,0,0}  // hold[0] = -prices[0]\\n```\\nOn day1 we start with no profit and no cash in hand. Here hold[0] = -prices[0] is used because without any cash in hand previous to day1 we bought a stock on day1 so our net amount will be negative of prices[0].\\n\\n**Day 2**\\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,0,0,0,0}\\n```\\n```\\ncash[1] = max(\\'no transactions\\'-> 0, \\'selling of yesterdays stock\\'-> -1+3-2)\\nhold[1] = max(\\'no transactions\\'-> -1, \\'buying a stock today\\'->0-3)\\n```\\n\\n**Day 3**\\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,-1,0,0,0}\\n```\\n```\\ncash[2] = max(0,-1+2-2)\\nhold[2] = max(-1,0-2)\\n```\\n\\n**Day 4**\\n```\\nprofit = 5\\ncash = {0,0,0,5,0,0}\\nhold = {-1,-1,-1,-1,0,0}\\n```\\n```\\ncash[3] = max(0,-1+8-2)\\nhold[3] = max(-1,0-8)\\n```\\n\\n**Day 5**\\n```\\nprofit = 5\\ncash = {0,0,0,5,5,0}\\nhold = {-1,-1,-1,-1,1,0}\\n```\\n```\\ncash[4] = max(5,-1+4-2)\\nhold[4] = max(-1,5-4)\\n```\\n\\n**Day 6**\\n```\\nprofit = 8\\ncash = {0,0,0,5,5,8}\\nhold = {-1,-1,-1,-1,1,1}\\n```\\n```\\ncash[4] = max(5,1+9-2)\\nhold[4] = max(1,5-9)\\n```\\n\\nCode\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        int[] cash = new int[n];\\n        int[] hold = new int[n];\\n        cash[0] = 0;\\n        int profit = 0;\\n        hold[0] = -prices[0];\\n        for(int i=1;i<n;i++){\\n            cash[i] = Math.max(cash[i-1],hold[i-1]+prices[i]-fee);\\n            hold[i] = Math.max(hold[i-1],cash[i-1]-prices[i]);\\n        }\\n        return cash[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nhold[i] = Math.max(hold[i-1],cash[i-1]-price[i])\\ncash[i] = Math.max(cash[i-1], hold[i-1]+price[i]-fee)\\n```\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0}\\nhold = {-1,0,0,0,0,0}  // hold[0] = -prices[0]\\n```\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,0,0,0,0}\\n```\n```\\ncash[1] = max(\\'no transactions\\'-> 0, \\'selling of yesterdays stock\\'-> -1+3-2)\\nhold[1] = max(\\'no transactions\\'-> -1, \\'buying a stock today\\'->0-3)\\n```\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,-1,0,0,0}\\n```\n```\\ncash[2] = max(0,-1+2-2)\\nhold[2] = max(-1,0-2)\\n```\n```\\nprofit = 5\\ncash = {0,0,0,5,0,0}\\nhold = {-1,-1,-1,-1,0,0}\\n```\n```\\ncash[3] = max(0,-1+8-2)\\nhold[3] = max(-1,0-8)\\n```\n```\\nprofit = 5\\ncash = {0,0,0,5,5,0}\\nhold = {-1,-1,-1,-1,1,0}\\n```\n```\\ncash[4] = max(5,-1+4-2)\\nhold[4] = max(-1,5-4)\\n```\n```\\nprofit = 8\\ncash = {0,0,0,5,5,8}\\nhold = {-1,-1,-1,-1,1,1}\\n```\n```\\ncash[4] = max(5,1+9-2)\\nhold[4] = max(1,5-9)\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        int[] cash = new int[n];\\n        int[] hold = new int[n];\\n        cash[0] = 0;\\n        int profit = 0;\\n        hold[0] = -prices[0];\\n        for(int i=1;i<n;i++){\\n            cash[i] = Math.max(cash[i-1],hold[i-1]+prices[i]-fee);\\n            hold[i] = Math.max(hold[i-1],cash[i-1]-prices[i]);\\n        }\\n        return cash[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507618,
                "title": "help-you-problem-constraint-elaboration-no-spoilers",
                "content": "The problem is not well defined... There are non-obvious constraints that are implied in this problem, it took me some submissions to figure these out, hopefully it can help you:\\n\\n1. **You can only buy/sell 1 at a time!**\\n2. `fee` is only assessed on sale (i.e., it is free to buy)\\n2. Must buy before selling / Must sell before buying another\\n\\t* Cannot sell if you don\\'t have, cannot buy if you already have\\n    * e.g., no call/put options\\n3. Cannot buy from the \"future\"  / Cannot sell in the \"past\"\\n\\t* Futures are not possible here\\n\\n\\n\\n\\n<details>\\n<summary>\\u2190 More in-depth help...  #Minor SPOILER Alert!</summary>\\n\\n* Buying and Selling on the same day will not give you profit\\n* Max profit will always happen after a sale (e.g., if you buy on the last day, you are \"down\")\\n* Knowing the future does not benefit you (because you can only hold 1 at a time)\\n\\t* e.g., it is not a combinatorial problem\\n* On any given \"day\", there are only 2 things to do: buy or sell.\\n\\t* However you must observe Rule #1 and Rule #3 above\\n\\t* You cannot sell if you haven\\'t bought (and you cannot buy if you already have).\\n\\t<details>\\n\\t<summary>\\u2190 DEFINITE SPOILER Alert!</summary>\\n\\t\\n\\t* So there are \"4\" actions on any given day:\\n\\t\\t* Buy\\n\\t\\t* Sell\\n\\t\\t* Buy later (wait for lowest price)\\n\\t\\t* Sell later (wait for highest price)\\n\\t\\n</details>\\n</details>\\n\\nOkay i hope this helps!\\n",
                "solutionTags": [],
                "code": "The problem is not well defined... There are non-obvious constraints that are implied in this problem, it took me some submissions to figure these out, hopefully it can help you:\\n\\n1. **You can only buy/sell 1 at a time!**\\n2. `fee` is only assessed on sale (i.e., it is free to buy)\\n2. Must buy before selling / Must sell before buying another\\n\\t* Cannot sell if you don\\'t have, cannot buy if you already have\\n    * e.g., no call/put options\\n3. Cannot buy from the \"future\"  / Cannot sell in the \"past\"\\n\\t* Futures are not possible here\\n\\n\\n\\n\\n<details>\\n<summary>\\u2190 More in-depth help...  #Minor SPOILER Alert!</summary>\\n\\n* Buying and Selling on the same day will not give you profit\\n* Max profit will always happen after a sale (e.g., if you buy on the last day, you are \"down\")\\n* Knowing the future does not benefit you (because you can only hold 1 at a time)\\n\\t* e.g., it is not a combinatorial problem\\n* On any given \"day\", there are only 2 things to do: buy or sell.\\n\\t* However you must observe Rule #1 and Rule #3 above\\n\\t* You cannot sell if you haven\\'t bought (and you cannot buy if you already have).\\n\\t<details>\\n\\t<summary>\\u2190 DEFINITE SPOILER Alert!</summary>\\n\\t\\n\\t* So there are \"4\" actions on any given day:\\n\\t\\t* Buy\\n\\t\\t* Sell\\n\\t\\t* Buy later (wait for lowest price)\\n\\t\\t* Sell later (wait for highest price)\\n\\t\\n</details>\\n</details>\\n\\nOkay i hope this helps!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1246650,
                "title": "greedy-better-than-dp-python",
                "content": "**Dynamic programming approach**\\n\\nMy first intuition was to use DP in the following format:\\n\\t\\n\\t(1) dp[i][0] indicates the profit until day i having zero stock in the end,\\n\\t(2) dp[i][1] indicates the profit until day i having one stock in the end,\\n\\nSo, intuitively, the recursive equation was as follows (for j < i):\\n\\n\\t(1) dp[i][0] = max([dp[i][0] , dp[j][0], dp[j][1] - fee + prices[i]])\\n\\t(2) dp[i][1] = max([dp[i][1] , dp[j][1],  dp[j][0] - prices[i]])\\n\\nSince the algorithm was O(n^2), unsurprisingly, it returned TLE.\\n\\n**Greedy approach**\\n\\nAt any point of time, I can have either one stock or zero stocks. To maximize the profit at a later point of time, I need maximum profit possible with zero stocks as well as one stock until that point. **We are not concerned when was the stock bought or sold earlier.**\\nSo, basically if I have two variables **one** and **zero** indicating maximum profit with one and zero stock respectively until day i, at day i,\\nmaximum profit with one and zero stock respectively would be :\\n\\t\\n\\tone = max(one, zero - prices[i])\\n\\tzero = max(zero , one + prices[i] - fee)\\n\\nTime complexity is O(N).\\n\\nHere is the code :\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        one = -prices[0]\\n        zero = 0\\n        \\n        for i in range(1 , len(prices)):\\n            \\n            one = max(one, zero - prices[i])\\n            zero = max(zero , one + prices[i] - fee)\\n            \\n        return zero\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \\n        one = -prices[0]\\n        zero = 0\\n        \\n        for i in range(1 , len(prices)):\\n            \\n            one = max(one, zero - prices[i])\\n            zero = max(zero , one + prices[i] - fee)\\n            \\n        return zero\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153706,
                "title": "c-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int size = prices.size();\\n        if (size < 2) {\\n            return 0;\\n        }\\n        vector<int> buy(size, 0), sell(size, 0);\\n        buy[0] = -prices[0]; // Buy prices[0]\\n        for (int i = 1; i < prices.size(); i++) {\\n            // Either do nothing, or buy\\n            buy[i] = max(buy[i - 1], sell[i - 1] - prices[i]);\\n            // Either do nothing, or sell\\n            sell[i] = max(sell[i - 1], prices[i] + buy[i - 1] - fee);\\n        }\\n        return sell.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int size = prices.size();\\n        if (size < 2) {\\n            return 0;\\n        }\\n        vector<int> buy(size, 0), sell(size, 0);\\n        buy[0] = -prices[0]; // Buy prices[0]\\n        for (int i = 1; i < prices.size(); i++) {\\n            // Either do nothing, or buy\\n            buy[i] = max(buy[i - 1], sell[i - 1] - prices[i]);\\n            // Either do nothing, or sell\\n            sell[i] = max(sell[i - 1], prices[i] + buy[i - 1] - fee);\\n        }\\n        return sell.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112187,
                "title": "rust-one-liner-dp-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_profit(prices: Vec<i32>, fee: i32) -> i32 {\\n        prices\\n            .iter()\\n            .fold((None, 0), |(hold, cash): (Option<i32>, _), &price| {\\n                (\\n                    Some(hold.unwrap_or(-price).max(cash - price)),\\n                    hold.map_or(0, |h| cash.max(h + price - fee)),\\n                )\\n            })\\n            .1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_profit(prices: Vec<i32>, fee: i32) -> i32 {\\n        prices\\n            .iter()\\n            .fold((None, 0), |(hold, cash): (Option<i32>, _), &price| {\\n                (\\n                    Some(hold.unwrap_or(-price).max(cash - price)),\\n                    hold.map_or(0, |h| cash.max(h + price - fee)),\\n                )\\n            })\\n            .1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908131,
                "title": "state-machine",
                "content": "If we are in S0, it means we had no stock in past or we had a stock in past and we just sold it.\\nIf we are in S1, it means we had one stock in past or we had no stock in past and we just bought it.\\n\\nAt beginning, only way to be in S0 is to buy no stock at that time.\\nAt beginning, only way to be in S1 is to buy a stock at that time.\\n\\n![image](https://assets.leetcode.com/users/images/b01fef91-3237-42fe-824a-877c854c01ce_1603539461.492912.png)\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2) {\\n            return 0;\\n        }\\n        int n = prices.size();\\n        vector<vector<int>> dp(2, vector<int> (n));\\n        dp[0][0] = 0, dp[1][0] = -prices[0];\\n        int res = 0;\\n        for(int i = 1; i < n; ++i) {\\n            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] + prices[i] - fee);\\n            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] - prices[i]);\\n            res = max(res, dp[0][i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nO(1) space can be achieved by utilizing the fact that only the previous state is required to construct current state.\\n\\nInspired by this [post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/908061/State-Machine-(beats-100))",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2) {\\n            return 0;\\n        }\\n        int n = prices.size();\\n        vector<vector<int>> dp(2, vector<int> (n));\\n        dp[0][0] = 0, dp[1][0] = -prices[0];\\n        int res = 0;\\n        for(int i = 1; i < n; ++i) {\\n            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] + prices[i] - fee);\\n            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] - prices[i]);\\n            res = max(res, dp[0][i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780119,
                "title": "c-o-1-space-o-n-time-explained",
                "content": "```\\nclass Solution {\\npublic:\\n//     infinite transaction\\n// 3 choices -> buy, sell, do nothing\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int Buy = -prices[0]; // (one bought) (keep minimum) (max of -ve) buy or do nothing - [take prev buy]\\n        int Sell = 0; // Sell at this or do nothing\\n        \\n        for(int i=1; i<prices.size(); i++){\\n            int nbuy=max(Buy, Sell-prices[i]);\\n            int nsell=max(Sell, Buy +prices[i]-fee);\\n            \\n            Buy = nbuy; \\n            Sell = nsell;\\n        }\\n        return Sell;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n//     infinite transaction\\n// 3 choices -> buy, sell, do nothing\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int Buy = -prices[0]; // (one bought) (keep minimum) (max of -ve) buy or do nothing - [take prev buy]\\n        int Sell = 0; // Sell at this or do nothing\\n        \\n        for(int i=1; i<prices.size(); i++){\\n            int nbuy=max(Buy, Sell-prices[i]);\\n            int nsell=max(Sell, Buy +prices[i]-fee);\\n            \\n            Buy = nbuy; \\n            Sell = nsell;\\n        }\\n        return Sell;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683067,
                "title": "brute-force-with-memoization",
                "content": "```\\nclass Solution \\n{\\npublic:\\n       int dp[50001][2];\\n    int maxselling(vector<int>&prices,int i,int share,int fee )\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        int ans=0;\\n        if(dp[i][share]!=-1)\\n            return dp[i][share];\\n        if(share)\\n            ans+=max(prices[i]-fee+maxselling(prices,i+1,!share,fee),maxselling(prices,i+1,share,fee));\\n        else\\n            ans+=max(-prices[i]+maxselling(prices,i+1,!share,fee),maxselling(prices,i+1,share,fee));\\n        return dp[i][share]=ans;  \\n    }\\n    int maxProfit(vector<int>& prices, int fee) \\n    {\\n        int n=prices.size();\\n        for(int i=0;i<50001;i++)\\n        {\\n            dp[i][0]=-1,dp[i][1]=-1;\\n        }\\n        return maxselling(prices,0,0,fee);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n       int dp[50001][2];\\n    int maxselling(vector<int>&prices,int i,int share,int fee )\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        int ans=0;\\n        if(dp[i][share]!=-1)\\n            return dp[i][share];\\n        if(share)\\n            ans+=max(prices[i]-fee+maxselling(prices,i+1,!share,fee),maxselling(prices,i+1,share,fee));\\n        else\\n            ans+=max(-prices[i]+maxselling(prices,i+1,!share,fee),maxselling(prices,i+1,share,fee));\\n        return dp[i][share]=ans;  \\n    }\\n    int maxProfit(vector<int>& prices, int fee) \\n    {\\n        int n=prices.size();\\n        for(int i=0;i<50001;i++)\\n        {\\n            dp[i][0]=-1,dp[i][1]=-1;\\n        }\\n        return maxselling(prices,0,0,fee);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653811,
                "title": "c-dp-o-n-2-states",
                "content": "Thanks to great post by @Joy4fun\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108871/2-solutions-2-states-DP-solutions-clear-explanation!\\n\\nbuy[i] represents the max profit at day i in buy status, given that the last action you took is a buy action at day K, where K<=i. And you have the right to sell at day i+1, or do nothing.\\n\\nsell[i] represents the max profit at day i in sell status, given that the last action you took is a sell action at day K, where K<=i. And you have the right to buy at day i+1, or do nothing.\\n\\nTransaction fee is applied during buying.\\n```\\nint maxProfit( vector<int>& prices, int fee ) {\\n\\tint n = prices.size();\\n\\tif( n <= 1 ) return 0;\\n\\n\\tvector<int> buy( n, 0 ), sell( n, 0 );\\n\\tbuy[0] = prices[0]*-1 - fee;\\n\\tsell[0] = 0;\\n\\tfor( int i=1; i<n; i++ ) {\\n\\t\\tbuy[i] = max( buy[i-1], sell[i-1] - prices[i] - fee );\\n\\t\\tsell[i] = max( sell[i-1], buy[i-1] + prices[i] ); \\n\\t}\\n\\treturn sell[n-1];\\n}\\n```\\n\\nTransaction Fee is applied at selling.\\n```\\n    int maxProfit( vector<int>& prices, int fee ) {\\n        int n = prices.size();\\n        if( n <= 1 ) return 0;\\n\\n        vector<int> buy( n, 0 ), sell( n, 0 );\\n        buy[0] = prices[0]*-1;\\n        sell[0] = 0;\\n        for( int i=1; i<n; i++ ) {\\n            buy[i] = max( buy[i-1], sell[i-1] - prices[i] );\\n            sell[i] = max( sell[i-1], buy[i-1] + prices[i] - fee); \\n        }\\n        return sell[n-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfit( vector<int>& prices, int fee ) {\\n\\tint n = prices.size();\\n\\tif( n <= 1 ) return 0;\\n\\n\\tvector<int> buy( n, 0 ), sell( n, 0 );\\n\\tbuy[0] = prices[0]*-1 - fee;\\n\\tsell[0] = 0;\\n\\tfor( int i=1; i<n; i++ ) {\\n\\t\\tbuy[i] = max( buy[i-1], sell[i-1] - prices[i] - fee );\\n\\t\\tsell[i] = max( sell[i-1], buy[i-1] + prices[i] ); \\n\\t}\\n\\treturn sell[n-1];\\n}\\n```\n```\\n    int maxProfit( vector<int>& prices, int fee ) {\\n        int n = prices.size();\\n        if( n <= 1 ) return 0;\\n\\n        vector<int> buy( n, 0 ), sell( n, 0 );\\n        buy[0] = prices[0]*-1;\\n        sell[0] = 0;\\n        for( int i=1; i<n; i++ ) {\\n            buy[i] = max( buy[i-1], sell[i-1] - prices[i] );\\n            sell[i] = max( sell[i-1], buy[i-1] + prices[i] - fee); \\n        }\\n        return sell[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 403671,
                "title": "java-greedy-o-n-time-o-1-space",
                "content": "```\\n    public int maxProfit(int[] prices, int fee) {\\n        int sum = 0;\\n        int min = prices[0];\\n        int max = prices[0];\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < min || prices[i] + fee < max) {\\n                if (max - min - fee > 0) {\\n                    sum += max - min - fee;\\n                }\\n                min = prices[i];\\n                max = prices[i];\\n            } else if (prices[i] > max) {\\n                max = prices[i];\\n            }\\n        }\\n        sum += Math.max(0, max - min - fee);\\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public int maxProfit(int[] prices, int fee) {\\n        int sum = 0;\\n        int min = prices[0];\\n        int max = prices[0];\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < min || prices[i] + fee < max) {\\n                if (max - min - fee > 0) {\\n                    sum += max - min - fee;\\n                }\\n                min = prices[i];\\n                max = prices[i];\\n            } else if (prices[i] > max) {\\n                max = prices[i];\\n            }\\n        }\\n        sum += Math.max(0, max - min - fee);\\n        return sum;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 108889,
                "title": "clear-java-dp-solution-o-n-time-o-1-space",
                "content": "You might either have sold your stock or not, we can get the best profit (by day i) on each case according to the relationship:\\n\\na. If you're holding your stock, the best profit you can get on day i is either the same with the previous day (if you didn't sell it) or you buy the stock on the price of day i.\\n\\n```\\nhold = max(preSold - prices[i], preHold);\\n```` \\n\\nb. If you have no stock, the best you can get is either the same with yesterday (you've already sold it) or you sell it on today's price.\\n\\n```\\nsold = max(preHold + prices[i] - fee, preSold);\\n````\\n\\nSince we have 0 profit at the very beginning and can't sell, the initial value is -prices[0], and 0. Finally, we have to end on \"sold\" to get the maximum profit.\\n\\n```\\n    public int maxProfit(int[] prices, int fee) {       \\n        int preHold= -prices[0];\\n        int preSold = 0;\\n        \\n        for(int i = 1; i < prices.length; i++) {\\n            int hold = Math.max(preSold- prices[i], preHold);\\n            int sold = Math.max(preHold+ prices[i] - fee, preSold);\\n            preHold = hold ;\\n            preSold = sold ;\\n        }\\n        return preSold;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nhold = max(preSold - prices[i], preHold);\\n```\n```\\nsold = max(preHold + prices[i] - fee, preSold);\\n```\n```\\n    public int maxProfit(int[] prices, int fee) {       \\n        int preHold= -prices[0];\\n        int preSold = 0;\\n        \\n        for(int i = 1; i < prices.length; i++) {\\n            int hold = Math.max(preSold- prices[i], preHold);\\n            int sold = Math.max(preHold+ prices[i] - fee, preSold);\\n            preHold = hold ;\\n            preSold = sold ;\\n        }\\n        return preSold;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 108901,
                "title": "c-o-n-time-o-1-space",
                "content": "b is maximum value after  a series of alternating buy-sell actions, starting with a buy and ending with a buy.\\nc is maximum value after  a series of alternating buy-sell actions, starting with a buy and ending with a sell.\\nc is the answer to the problem.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a, int f) {\\n        int n = a.size();\\n        int b = -a[0],c = 0;\\n        for (int i = 1; i < a.size(); ++i) {\\n            int nb = max(b, -a[i] + c);\\n            c = max(c, a[i] - f + b);\\n            b = nb;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a, int f) {\\n        int n = a.size();\\n        int b = -a[0],c = 0;\\n        for (int i = 1; i < a.size(); ++i) {\\n            int nb = max(b, -a[i] + c);\\n            c = max(c, a[i] - f + b);\\n            b = nb;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108902,
                "title": "o-n-using-two-stacks",
                "content": "The idea is to have two stacks. One for holding the buying prices and one for holding the selling prices. One price in the buy queue corresponds to a sell prices in the sell queue of the transaction is complete.\\n\\nWe have the following cases:\\n- If we did not do anything yet (i.e., the buy stack is empty), buy it.\\n- If we have no unsold stock. That is, `buyQueue.size() == sellQueue.size()`, we have the option to regret a low sell if current price is higher than the price we sold the last share.\\n   - If current price is higher than the price we sold the last share, regret the last sell and sell today.\\n   - If current price is lower than the price we sold the last share - fee, buy it. Buying a share with price higher than the last sold price - fee is not optimal as we will need a price that is at least greater than the last sold price to make profit for this purchase in the future. If that is the case, why not sell the previous share on that day? Doing that, we save the fee.\\n- If we have unsold stock, that is `buyQueue.size() > sellQueue.size()`:\\n   - If current price is lower than the price we bought for the last share, we regret that purchase and instead buy today.\\n   - If selling the unsold share at current price have profit, sell it.\\n\\nFinally, we will end up either each buy has a corresponding sell OR we have an unsold share, which should simply be discarded. Then the profit is the difference - fee for each transaction.  \\n\\n```java\\npublic int maxProfit(int[] prices, int fee) {\\n        Stack<Integer> buy = new Stack<>();\\n        Stack<Integer> sell = new Stack<>();\\n        for (int p : prices) {\\n            if (buy.isEmpty()) {  //have nothing, buy it\\n                buy.push(p);\\n            } else if (buy.size() == sell.size()) {  //no unsold stock\\n                if (p < sell.peek() - fee) {  //current price needs a price lower than the previous sold price to sell in the future, buy it.\\n                    buy.push(p);\\n                } else if (p > sell.peek()) {  //selling at current price for the last transaction can have higher profit, regret the last sell.\\n                    sell.pop();\\n                    sell.push(p);\\n                }\\n            } else {  // have an unsold share\\n                if (p > buy.peek() + fee) {  //if selling at current price have profit, do it.\\n                    sell.push(p);\\n                } else if (p < buy.peek()) {  //if current price is lower than the most recent purchase, regret it and buy today.\\n                    buy.pop();\\n                    buy.push(p);\\n                }\\n            }\\n        }\\n        if (buy.size() > sell.size()) {  //discard the unsold buy attempt\\n            buy.pop();\\n        }\\n        int amount = 0;\\n        while (!buy.isEmpty()) {\\n            amount += sell.pop() - buy.pop() - fee;\\n        }\\n        return amount;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int maxProfit(int[] prices, int fee) {\\n        Stack<Integer> buy = new Stack<>();\\n        Stack<Integer> sell = new Stack<>();\\n        for (int p : prices) {\\n            if (buy.isEmpty()) {  //have nothing, buy it\\n                buy.push(p);\\n            } else if (buy.size() == sell.size()) {  //no unsold stock\\n                if (p < sell.peek() - fee) {  //current price needs a price lower than the previous sold price to sell in the future, buy it.\\n                    buy.push(p);\\n                } else if (p > sell.peek()) {  //selling at current price for the last transaction can have higher profit, regret the last sell.\\n                    sell.pop();\\n                    sell.push(p);\\n                }\\n            } else {  // have an unsold share\\n                if (p > buy.peek() + fee) {  //if selling at current price have profit, do it.\\n                    sell.push(p);\\n                } else if (p < buy.peek()) {  //if current price is lower than the most recent purchase, regret it and buy today.\\n                    buy.pop();\\n                    buy.push(p);\\n                }\\n            }\\n        }\\n        if (buy.size() > sell.size()) {  //discard the unsold buy attempt\\n            buy.pop();\\n        }\\n        int amount = 0;\\n        while (!buy.isEmpty()) {\\n            amount += sell.pop() - buy.pop() - fee;\\n        }\\n        return amount;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809755,
                "title": "0-1-space-optimized-solution",
                "content": "# PLS UPVOTE IF YOU LIKE MY SOLUTION AND FEEL FREE TO ASK IN COMMENTS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#  CODE WITH SPACE OPTIMIZATION\\n# Approach\\nLoop through the prices in reverse:\\nThe outer loop iterates through the prices vector in reverse order, starting from the last element and going backwards.\\n\\nTwo states for each price:\\nFor each price at index index, there are two possible states: holding a stock (buy = 1) or not holding a stock (buy = 0).\\n\\nCalculate the maximum profit for each state:\\nInside the loop, there is a nested loop to calculate the maximum profit for both states, i.e., holding a stock and not holding a stock.\\n\\nUpdate the curr vector:\\nThe maximum profit for both states (holding and not holding a stock) is calculated for the current index and stored in the curr vector.\\n\\nUpdate the next vector:\\nOnce the maximum profit is calculated for the current index, the next vector is updated with the values from the curr vector.\\n\\nReturn the maximum profit:\\nAfter the loop completes, the function returns the maximum profit when not holding a stock, i.e., next[1].\\n\\nThe dynamic programming approach used here efficiently calculates the maximum profit for each state by considering the previous state\\'s maximum profit. It takes into account the fee for each transaction and maximizes the overall profit based on the given stock prices.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nint solvetab(vector<int>& prices,int fee)\\n{\\n    int n = prices.size();\\n    vector<int>curr(2,0);\\n    vector<int>next(2,0);\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ next[0]-fee , 0 + next[1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1] , 0 + next[0]); \\n            }\\n            curr[buy]=profit;\\n        }\\n        next=curr;\\n    }\\n    return next[1];\\n}\\n\\n\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        return solvetab(prices ,fee);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nint solvetab(vector<int>& prices,int fee)\\n{\\n    int n = prices.size();\\n    vector<int>curr(2,0);\\n    vector<int>next(2,0);\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ next[0]-fee , 0 + next[1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1] , 0 + next[0]); \\n            }\\n            curr[buy]=profit;\\n        }\\n        next=curr;\\n    }\\n    return next[1];\\n}\\n\\n\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        return solvetab(prices ,fee);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671658,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func maxProfit(_ prices: [Int], _ fee: Int) -> Int {\\n        let numberOfDays = prices.count\\n        // edge case\\n        if numberOfDays == 1 { return 0 }\\n\\n        // initalize two arrays, one for the maximium profit on the ith day while holding a stock. The other is for maximum profit on the ith day while currently not holding a stock. \\n        var dpHolding = Array(repeating: 0, count: numberOfDays)\\n        var dpNotHolding = Array(repeating: 0, count: numberOfDays)\\n\\n        // in order to hold a stock on the first day, we need to be in net negative.\\n        dpHolding[0] = -prices[0]\\n\\n        for i in 1..<numberOfDays {\\n            // there are three scenarios on any given day - buy, sell, do nothing. Note that only when we hold a stock can we sell, and only when we are not holding can we buy.\\n            dpHolding[i] = max(dpHolding[i - 1], dpNotHolding[i - 1] - prices[i])\\n            dpNotHolding[i] = max(dpNotHolding[i - 1], dpHolding[i - 1] + prices[i] - fee)\\n        }\\n        // selling on the last day is always more profitable than holding Lol.\\n        return dpNotHolding[numberOfDays - 1]\\n    }\\n    // Time Complexity - O(N)\\n    // Space Complexity - O(N)\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxProfit(_ prices: [Int], _ fee: Int) -> Int {\\n        let numberOfDays = prices.count\\n        // edge case\\n        if numberOfDays == 1 { return 0 }\\n\\n        // initalize two arrays, one for the maximium profit on the ith day while holding a stock. The other is for maximum profit on the ith day while currently not holding a stock. \\n        var dpHolding = Array(repeating: 0, count: numberOfDays)\\n        var dpNotHolding = Array(repeating: 0, count: numberOfDays)\\n\\n        // in order to hold a stock on the first day, we need to be in net negative.\\n        dpHolding[0] = -prices[0]\\n\\n        for i in 1..<numberOfDays {\\n            // there are three scenarios on any given day - buy, sell, do nothing. Note that only when we hold a stock can we sell, and only when we are not holding can we buy.\\n            dpHolding[i] = max(dpHolding[i - 1], dpNotHolding[i - 1] - prices[i])\\n            dpNotHolding[i] = max(dpNotHolding[i - 1], dpHolding[i - 1] + prices[i] - fee)\\n        }\\n        // selling on the last day is always more profitable than holding Lol.\\n        return dpNotHolding[numberOfDays - 1]\\n    }\\n    // Time Complexity - O(N)\\n    // Space Complexity - O(N)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671304,
                "title": "c-easy-and-readable-solution-faster-than-89",
                "content": "![image.png](https://assets.leetcode.com/users/images/f2babf1a-d935-45b8-82aa-86af915acc40_1687466439.4967916.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices, int fee) {\\n        int profit = 0;\\n        int minPrice = prices[0];\\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            if (prices[i] < minPrice)\\n                minPrice = prices[i];\\n            else if (prices[i] > minPrice + fee)\\n            {\\n                profit += prices[i] - minPrice - fee;\\n                minPrice = prices[i] - fee;\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices, int fee) {\\n        int profit = 0;\\n        int minPrice = prices[0];\\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            if (prices[i] < minPrice)\\n                minPrice = prices[i];\\n            else if (prices[i] > minPrice + fee)\\n            {\\n                profit += prices[i] - minPrice - fee;\\n                minPrice = prices[i] - fee;\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670895,
                "title": "c-4-lines-solution-beats-100-full-optmized",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int buy = INT_MIN;\\n        int sell = 0;\\n\\n        for (int price : prices) {\\n            buy = max(buy, sell - price);\\n            sell = max(sell, buy + price - fee);\\n        }\\n\\n        return sell;\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/dd556495-5bbd-495a-bdf8-92dddfeac9a7_1687457567.8676705.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int buy = INT_MIN;\\n        int sell = 0;\\n\\n        for (int price : prices) {\\n            buy = max(buy, sell - price);\\n            sell = max(sell, buy + price - fee);\\n        }\\n\\n        return sell;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670740,
                "title": "c-best-interview-selection-approach-simplest-logic",
                "content": "# Intuition\\nThink of it like this way you can either buy or sell at any point in time at most! \\nBe careful I said we may or may not do any transaction at a given point\\nIts very important as an intution building\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nApproach is simple you just need to traverse through the price array and maintain a bool data type variable which tells you whether or whether not you can buy or sell at a point \\nWhen one buys an additional fee is subtracted from it \\nAnd our profit is measured by the best option we explored\\nsame goes with selling\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumProfit(vector<int>& prices,int ind,bool canBuy,vector<vector<int>>& strg,int fee){\\n        if(ind==prices.size()) return 0;\\n        if(strg[ind][canBuy]!=-1) return strg[ind][canBuy];\\n        int profit=0;\\n        if(canBuy){\\n            int Bought=maximumProfit(prices,ind+1,!canBuy,strg,fee)-prices[ind]-fee;\\n            int notBought=maximumProfit(prices,ind+1,canBuy,strg,fee);\\n            profit=max(Bought,notBought);\\n        }else{\\n            int Sold=maximumProfit(prices,ind+1,!canBuy,strg,fee)+prices[ind];\\n            int notSold=maximumProfit(prices,ind+1,canBuy,strg,fee);\\n            profit=max(Sold,notSold);\\n        }\\n        return strg[ind][canBuy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int ind=0;\\n        bool canBuy=true;\\n        vector<vector<int>> strg(prices.size()+1,vector<int>(2,-1));\\n        return maximumProfit(prices,ind,canBuy,strg,fee);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumProfit(vector<int>& prices,int ind,bool canBuy,vector<vector<int>>& strg,int fee){\\n        if(ind==prices.size()) return 0;\\n        if(strg[ind][canBuy]!=-1) return strg[ind][canBuy];\\n        int profit=0;\\n        if(canBuy){\\n            int Bought=maximumProfit(prices,ind+1,!canBuy,strg,fee)-prices[ind]-fee;\\n            int notBought=maximumProfit(prices,ind+1,canBuy,strg,fee);\\n            profit=max(Bought,notBought);\\n        }else{\\n            int Sold=maximumProfit(prices,ind+1,!canBuy,strg,fee)+prices[ind];\\n            int notSold=maximumProfit(prices,ind+1,canBuy,strg,fee);\\n            profit=max(Sold,notSold);\\n        }\\n        return strg[ind][canBuy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int ind=0;\\n        bool canBuy=true;\\n        vector<vector<int>> strg(prices.size()+1,vector<int>(2,-1));\\n        return maximumProfit(prices,ind,canBuy,strg,fee);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670678,
                "title": "simpler-version-of-answer",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        hold, free = -prices[0], 0\\n        \\n        for i in range(1, n):\\n            hold = max(hold, free - prices[i])\\n            free = max(free, hold + prices[i] - fee)\\n        \\n        return free\\n\\n```\\n##### *Kindly Upvote\\u270C\\uD83C\\uDFFC*\\n\\n# Explanation \\n\\n1. The function `maxProfit` takes two parameters: `prices` (a list of integers representing the stock prices) and `fee` (an integer representing the transaction fee).\\n\\n2. We initialize the variables `hold` and `free`. `hold` represents the maximum profit we can have when we have a stock in hand, and `free` represents the maximum profit we can have when we don\\'t have any stock.\\n\\n3. We set the initial value of `hold` to the negative of the first element in the `prices` list. This means we buy the stock on the first day.\\n\\n4. We iterate over the remaining prices starting from index 1 to `n-1`, where `n` is the length of the `prices` list.\\n\\n5. At each step, we update the values of `hold` and `fre**Bold**e` based on the following conditions:\\n   - If we continue holding the stock on the current day, the maximum profit is either the same as the previous day\\'s `hold` value or the profit from selling the stock on the previous day and buying it again on the current day at the lower price.\\n   - If we sell the stock on the current day, the maximum profit is either the same as the previous day\\'s `free` value or the profit from buying the stock on the previous day and selling it on the current day minus the transaction fee.\\n\\n6. Finally, we return the value of `free`, which represents the maximum profit we can have at the end of all the transactions.\\n\\n***The simplified code achieves the same functionality as the Editorial code but with fewer lines and a clearer representation of the logic.***\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        hold, free = -prices[0], 0\\n        \\n        for i in range(1, n):\\n            hold = max(hold, free - prices[i])\\n            free = max(free, hold + prices[i] - fee)\\n        \\n        return free\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669702,
                "title": "c-5-approaches",
                "content": "# 1 Code -> Recursion\\n```\\nclass Solution {\\npublic:\\n    // 1 Recursion\\n    int Recursion(vector<int>& prices, int index, bool buy, int fee){\\n        if(index == prices.size())\\n            return 0;\\n\\n        //Buy = True means we can buy\\n        int profit = 0;\\n        if(buy){\\n            int buykaro = -prices[index] +  Recursion(prices, index+1, false, fee);\\n            int skipkaro =  Recursion(prices, index+1, true, fee);\\n            profit = max(buykaro, skipkaro);\\n        }else{\\n            int sellkaro = prices[index] - fee +  Recursion(prices, index+1, true, fee);\\n            int skipkaro =  Recursion(prices, index+1, false, fee);\\n            profit = max(sellkaro, skipkaro);\\n        }\\n\\n        return profit;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n     \\n        // 1 Recursion\\n        return Recursion(prices, 0, true, fee);\\n    }\\n};\\n```\\n\\n# 2 Code -> Recursion with Memoizatoin\\n```\\nclass Solution {\\npublic:\\n     // 2 Recursion With Memoization\\n    int Memoization(vector<int>& prices, int index, bool buy, vector<vector<int>>& dp, int fee){\\n        if(index == prices.size())\\n            return 0;\\n\\n        if(dp[index][buy] != -1){\\n            return dp[index][buy];\\n        }\\n\\n        //Buy = True means we can buy\\n        int profit = 0;\\n        if(buy){\\n            int buykaro = -prices[index] +  Memoization(prices, index+1, false, dp, fee);\\n            int skipkaro =  Memoization(prices, index+1, true, dp, fee);\\n            profit = max(buykaro, skipkaro);\\n        }else{\\n            int sellkaro = prices[index] - fee +  Memoization(prices, index+1, true, dp, fee);\\n            int skipkaro =  Memoization(prices, index+1, false, dp, fee);\\n            profit = max(sellkaro, skipkaro);\\n        }\\n\\n        return dp[index][buy] = profit;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        \\n        // 2 Recursion With Memoization\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return Memoization(prices, 0, true, dp, fee);\\n    }\\n};\\n```\\n\\n# 3 Code -> Tabulation\\n```\\nclass Solution {\\npublic:\\n    // 3 Tabulation\\n    int Tabulation(vector<int>& prices, int fee){\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+2, vector<int>(2, 0));\\n\\n        for(int index=n-1; index>=0; index--){\\n            for(int buy=0; buy<=1; buy++){\\n                int profit = 0;\\n                if(buy){\\n                    int buykaro = -prices[index] +  dp[index+1][false];\\n                    int skipkaro = dp[index+1][true];\\n                    profit = max(buykaro, skipkaro);\\n                }else{\\n                    int sellkaro = prices[index]  - fee + dp[index+1][true];\\n                    int skipkaro = dp[index+1][false];\\n                    profit = max(sellkaro, skipkaro);\\n                }\\n                dp[index][buy] = profit;\\n            }   \\n        }\\n        return dp[0][true];\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n   \\n        // 3 Tabulation\\n        return Tabulation(prices, fee);\\n    }\\n};\\n```\\n\\n# 4 Code -> Space Optimization\\n```\\nclass Solution {\\npublic:\\n    // 4 Space Optimization\\n    int SpaceOptimization(vector<int>& prices, int fee){\\n        int n = prices.size();\\n        vector<int> curr(2, 0), next(2, 0);\\n\\n        for(int index=n-1; index>=0; index--){\\n            for(int buy=0; buy<=1; buy++){\\n                int profit = 0;\\n                if(buy){\\n                    int buykaro = -prices[index] +  next[false];\\n                    int skipkaro = next[true];\\n                    profit = max(buykaro, skipkaro);\\n                }else{\\n                    int sellkaro = prices[index] - fee + next[true];\\n                    int skipkaro = next[false];\\n                    profit = max(sellkaro, skipkaro);\\n                }\\n                curr[buy] = profit;\\n            }\\n            next = curr;   \\n        }\\n        return curr[true];\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n   \\n        // 4 Space Optimization\\n        return SpaceOptimization(prices, fee);\\n    }\\n};\\n```\\n\\n# 5 Code -> Most Space Optimization / Optimal Approach\\n```\\nclass Solution {\\npublic:\\n    // 5 Most Optimize approach\\n    int final(vector<int>& prices, int fee){\\n        int n = prices.size();\\n        int cash = 0, hold = -prices[0];\\n        for(int i=1; i<n; i++){\\n            cash = max(cash, hold + prices[i] - fee);\\n            hold = max(hold, cash - prices[i]);\\n        }\\n        return cash;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n     \\n        // 5 Most Optimize approach\\n        return final(prices, fee);\\n    }\\n};\\n```\\n\\n# Upvote if it\\'s helpful for you \\uD83D\\uDE04\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1 Recursion\\n    int Recursion(vector<int>& prices, int index, bool buy, int fee){\\n        if(index == prices.size())\\n            return 0;\\n\\n        //Buy = True means we can buy\\n        int profit = 0;\\n        if(buy){\\n            int buykaro = -prices[index] +  Recursion(prices, index+1, false, fee);\\n            int skipkaro =  Recursion(prices, index+1, true, fee);\\n            profit = max(buykaro, skipkaro);\\n        }else{\\n            int sellkaro = prices[index] - fee +  Recursion(prices, index+1, true, fee);\\n            int skipkaro =  Recursion(prices, index+1, false, fee);\\n            profit = max(sellkaro, skipkaro);\\n        }\\n\\n        return profit;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n     \\n        // 1 Recursion\\n        return Recursion(prices, 0, true, fee);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     // 2 Recursion With Memoization\\n    int Memoization(vector<int>& prices, int index, bool buy, vector<vector<int>>& dp, int fee){\\n        if(index == prices.size())\\n            return 0;\\n\\n        if(dp[index][buy] != -1){\\n            return dp[index][buy];\\n        }\\n\\n        //Buy = True means we can buy\\n        int profit = 0;\\n        if(buy){\\n            int buykaro = -prices[index] +  Memoization(prices, index+1, false, dp, fee);\\n            int skipkaro =  Memoization(prices, index+1, true, dp, fee);\\n            profit = max(buykaro, skipkaro);\\n        }else{\\n            int sellkaro = prices[index] - fee +  Memoization(prices, index+1, true, dp, fee);\\n            int skipkaro =  Memoization(prices, index+1, false, dp, fee);\\n            profit = max(sellkaro, skipkaro);\\n        }\\n\\n        return dp[index][buy] = profit;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        \\n        // 2 Recursion With Memoization\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return Memoization(prices, 0, true, dp, fee);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // 3 Tabulation\\n    int Tabulation(vector<int>& prices, int fee){\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+2, vector<int>(2, 0));\\n\\n        for(int index=n-1; index>=0; index--){\\n            for(int buy=0; buy<=1; buy++){\\n                int profit = 0;\\n                if(buy){\\n                    int buykaro = -prices[index] +  dp[index+1][false];\\n                    int skipkaro = dp[index+1][true];\\n                    profit = max(buykaro, skipkaro);\\n                }else{\\n                    int sellkaro = prices[index]  - fee + dp[index+1][true];\\n                    int skipkaro = dp[index+1][false];\\n                    profit = max(sellkaro, skipkaro);\\n                }\\n                dp[index][buy] = profit;\\n            }   \\n        }\\n        return dp[0][true];\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n   \\n        // 3 Tabulation\\n        return Tabulation(prices, fee);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // 4 Space Optimization\\n    int SpaceOptimization(vector<int>& prices, int fee){\\n        int n = prices.size();\\n        vector<int> curr(2, 0), next(2, 0);\\n\\n        for(int index=n-1; index>=0; index--){\\n            for(int buy=0; buy<=1; buy++){\\n                int profit = 0;\\n                if(buy){\\n                    int buykaro = -prices[index] +  next[false];\\n                    int skipkaro = next[true];\\n                    profit = max(buykaro, skipkaro);\\n                }else{\\n                    int sellkaro = prices[index] - fee + next[true];\\n                    int skipkaro = next[false];\\n                    profit = max(sellkaro, skipkaro);\\n                }\\n                curr[buy] = profit;\\n            }\\n            next = curr;   \\n        }\\n        return curr[true];\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n   \\n        // 4 Space Optimization\\n        return SpaceOptimization(prices, fee);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // 5 Most Optimize approach\\n    int final(vector<int>& prices, int fee){\\n        int n = prices.size();\\n        int cash = 0, hold = -prices[0];\\n        for(int i=1; i<n; i++){\\n            cash = max(cash, hold + prices[i] - fee);\\n            hold = max(hold, cash - prices[i]);\\n        }\\n        return cash;\\n    }\\n\\n    int maxProfit(vector<int>& prices, int fee) {\\n     \\n        // 5 Most Optimize approach\\n        return final(prices, fee);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668786,
                "title": "optimized-and-well-explained-solution",
                "content": "# Intuition\\nTo solve this problem, we can use a dynamic programming approach. \\n\\n# Approach\\nThe idea is to maintain two variables, buy and sell, which represent the maximum profit you can achieve if you have bought or sold the stock, respectively. Initially, buy is set to the negative of the first price, assuming we buy the stock on the first day. sell is set to zero because we haven\\'t sold any stock yet.\\n\\nThen, for each day starting from the second day, we update buy and sell as follows:\\n\\n- Update buy by taking the maximum value between the previous buy and the difference between sell and the current price (representing the profit we would make if we bought the stock on this day).\\n- Update sell by taking the maximum value between the previous sell and the sum of the previous buy and the current price minus the transaction fee (representing the profit we would make if we sold the stock on this day).\\n\\nFinally, the maximum profit we can achieve is stored in the sell variable, so we return its value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        if (n <= 1) return 0;\\n        int buy = -prices[0];\\n        int sell = 0;\\n        for (int i = 1; i < n; i++) {\\n            int prevBuy = buy;\\n            buy = max(buy, sell - prices[i]);\\n            sell = max(sell, prevBuy + prices[i] - fee);\\n        }\\n        return sell;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        if (n <= 1) return 0;\\n        int buy = -prices[0];\\n        int sell = 0;\\n        for (int i = 1; i < n; i++) {\\n            int prevBuy = buy;\\n            buy = max(buy, sell - prices[i]);\\n            sell = max(sell, prevBuy + prices[i] - fee);\\n        }\\n        return sell;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668381,
                "title": "o-n-beats-100-java-solution-beginner-friendly-easy-to-understand-clean-clear-code",
                "content": "# Without Dynamic Programming\\n\\n# Greedy Approach Used\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int buy = prices[0];\\n        int profit = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] < buy) {\\n                buy = prices[i];\\n            } else if (prices[i] > buy + fee) {\\n                profit += prices[i] - buy - fee;\\n                buy = prices[i] - fee;\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int buy = prices[0];\\n        int profit = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] < buy) {\\n                buy = prices[i];\\n            } else if (prices[i] > buy + fee) {\\n                profit += prices[i] - buy - fee;\\n                buy = prices[i] - fee;\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668340,
                "title": "5-approaches-recursive-memo-tabulation-single-loop-solution-space-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTransaction fee is applicable only when you complete a trasaction \\nand according to definition,, a process of buy and sell is called transaction. only buying does not cause any fee.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# Recursive\\n(TLE - exponential TC)\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int index, int buy, int fee){\\n        if(index==prices.size()){\\n            return 0;\\n        }\\n        \\n        int profit =0;\\n        if(buy){\\n            int buyKaro = -prices[index] + solve(prices, index+1, 0,DP, fee);\\n            int skipKaro = solve(prices, index+1, 1, DP, fee);\\n            \\n            profit = max(buyKaro, skipKaro);\\n        }\\n        else{\\n            int sellKaro = prices[index] + solve(prices, index+1, 1, DP, fee) - fee;\\n            int skipKaro = solve(prices, index+1, 0, DP, fee);\\n            \\n            profit = max(sellKaro, skipKaro);\\n        }\\n        return profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int profit = solve(prices, 0, 1, fee);\\n        \\n        return profit;\\n    }\\n};\\n```\\n\\n# Recursion + memoization \\n# Complexity\\n- Time complexity: O(2 * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*N) + O(N)(recursive stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int index, int buy,vector<vector<int>>&DP, int fee){\\n        if(index==prices.size()){\\n            return 0;\\n        }\\n        if(DP[index][buy] != -1){\\n            return DP[index][buy];\\n            \\n        }\\n        \\n        int profit =0;\\n        if(buy){\\n            int buyKaro = -prices[index] + solve(prices, index+1, 0,DP, fee);\\n            int skipKaro = solve(prices, index+1, 1, DP, fee);\\n            \\n            profit = max(buyKaro, skipKaro);\\n        }\\n        else{\\n            int sellKaro = prices[index] + solve(prices, index+1, 1, DP, fee) - fee;\\n            int skipKaro = solve(prices, index+1, 0, DP, fee);\\n            \\n            profit = max(sellKaro, skipKaro);\\n        }\\n        return DP[index][buy]= profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>>DP(n+1, vector<int>(2 , -1));\\n        int profit = solve(prices, 0, 1, DP, fee);\\n        \\n        return profit;\\n    }\\n};\\n```\\n# Tablulation \\n# Complexity\\n- Time complexity: O(2 * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1, vector<int>(2 , 0));\\n\\n        for(int index = n-1; index >= 0; index--){\\n            for(int buy = 0; buy <= 1; buy ++){\\n                if(buy){\\n                    int buyKaro = -prices[index] + dp[index+1][0];\\n                    int skipKaro = dp[index+1][1];\\n                    \\n                    dp[index][buy] = max(buyKaro, skipKaro);\\n                }\\n                else{\\n                    int sellKaro = prices[index] + dp[index+1][1] - fee;\\n                    int skipKaro = dp[index+1][0];\\n                    \\n                    dp[index][buy] = max(sellKaro, skipKaro);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n# Single loop Tabulation \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1, vector<int>(2 , 0));\\n\\n        // No need of 2nd loop as it has only two values,, you can just put the values in dp[][]\\n        for(int index = n-1; index >= 0; index--){\\n            // buy\\n            dp[index][1] = max(-prices[index] + dp[index+1][0], dp[index+1][1]);\\n            // sell\\n            dp[index][0] = max(prices[index] + dp[index+1][1] - fee, dp[index+1][0]);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n\\n# Single loop Space Optimization \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<int>next(2, 0), curr(2,0);\\n\\n        // No need of 2nd loop as it has only two values,, you can just put the values in dp[][]\\n        for(int index = n-1; index >= 0; index--){\\n            // buy\\n            curr[1] = max(-prices[index] + next[0], next[1]);\\n            // sell\\n            curr[0] = max(prices[index] + next[1] - fee, next[0]);\\n            next = curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```\\n# Please upvote if it helped you",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int index, int buy, int fee){\\n        if(index==prices.size()){\\n            return 0;\\n        }\\n        \\n        int profit =0;\\n        if(buy){\\n            int buyKaro = -prices[index] + solve(prices, index+1, 0,DP, fee);\\n            int skipKaro = solve(prices, index+1, 1, DP, fee);\\n            \\n            profit = max(buyKaro, skipKaro);\\n        }\\n        else{\\n            int sellKaro = prices[index] + solve(prices, index+1, 1, DP, fee) - fee;\\n            int skipKaro = solve(prices, index+1, 0, DP, fee);\\n            \\n            profit = max(sellKaro, skipKaro);\\n        }\\n        return profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        int profit = solve(prices, 0, 1, fee);\\n        \\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int index, int buy,vector<vector<int>>&DP, int fee){\\n        if(index==prices.size()){\\n            return 0;\\n        }\\n        if(DP[index][buy] != -1){\\n            return DP[index][buy];\\n            \\n        }\\n        \\n        int profit =0;\\n        if(buy){\\n            int buyKaro = -prices[index] + solve(prices, index+1, 0,DP, fee);\\n            int skipKaro = solve(prices, index+1, 1, DP, fee);\\n            \\n            profit = max(buyKaro, skipKaro);\\n        }\\n        else{\\n            int sellKaro = prices[index] + solve(prices, index+1, 1, DP, fee) - fee;\\n            int skipKaro = solve(prices, index+1, 0, DP, fee);\\n            \\n            profit = max(sellKaro, skipKaro);\\n        }\\n        return DP[index][buy]= profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>>DP(n+1, vector<int>(2 , -1));\\n        int profit = solve(prices, 0, 1, DP, fee);\\n        \\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1, vector<int>(2 , 0));\\n\\n        for(int index = n-1; index >= 0; index--){\\n            for(int buy = 0; buy <= 1; buy ++){\\n                if(buy){\\n                    int buyKaro = -prices[index] + dp[index+1][0];\\n                    int skipKaro = dp[index+1][1];\\n                    \\n                    dp[index][buy] = max(buyKaro, skipKaro);\\n                }\\n                else{\\n                    int sellKaro = prices[index] + dp[index+1][1] - fee;\\n                    int skipKaro = dp[index+1][0];\\n                    \\n                    dp[index][buy] = max(sellKaro, skipKaro);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1, vector<int>(2 , 0));\\n\\n        // No need of 2nd loop as it has only two values,, you can just put the values in dp[][]\\n        for(int index = n-1; index >= 0; index--){\\n            // buy\\n            dp[index][1] = max(-prices[index] + dp[index+1][0], dp[index+1][1]);\\n            // sell\\n            dp[index][0] = max(prices[index] + dp[index+1][1] - fee, dp[index+1][0]);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        vector<int>next(2, 0), curr(2,0);\\n\\n        // No need of 2nd loop as it has only two values,, you can just put the values in dp[][]\\n        for(int index = n-1; index >= 0; index--){\\n            // buy\\n            curr[1] = max(-prices[index] + next[0], next[1]);\\n            // sell\\n            curr[0] = max(prices[index] + next[1] - fee, next[0]);\\n            next = curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667655,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        pos=-prices[0]\\n        profit=0\\n        n=len(prices)\\n        for i in range(1,n):\\n            pos=max(pos,profit-prices[i])\\n            profit=max(profit,pos+prices[i]-fee)\\n\\n        return profit    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        pos=-prices[0]\\n        profit=0\\n        n=len(prices)\\n        for i in range(1,n):\\n            pos=max(pos,profit-prices[i])\\n            profit=max(profit,pos+prices[i]-fee)\\n\\n        return profit    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667617,
                "title": "js-recursion-memoization-tabulation-space-optimization",
                "content": "# Approach\\nExpress in terms of index: i is index of prices array, j is buy or sell state (0 or 1)\\n\\nBase case: Reach end of prices array (i === n)\\n\\nRecurrence relation: \\n- Buy: Either purchase a stock by paying it\\'s price, in which case we move to the next index and set state to sell. Or we skip the current stock, move to next index, and leave state at buy.\\n- Sell: Either sell a stock for it\\'s price, subtract fee for completing a transaction, move to next index and set state to buy so we can start another transaction. Or skip current stock, move to next index, and leave state at sell.\\n\\n# Complexity\\nUnder each solution\\n\\n# Code\\n```\\n // Recursion [TLE]\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n\\n    function dp(i, j) {\\n        if (i === n) return 0;\\n\\n        if (j === 0) {\\n            return Math.max(-prices[i] + dp(i + 1, 1), dp(i + 1, 0));\\n        } else {\\n            return Math.max(prices[i] - fee + dp(i + 1, 0), dp(i + 1, 1));\\n        }\\n    }\\n    return dp(0, 0);\\n};\\n// TC: Exponential\\n// SC: O(n)\\n\\n // Recursion + Memoization\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n    const memo = [...new Array(n)].map(() => new Array(2).fill(-1));\\n\\n    function dp(i, j) {\\n        if (i === n) return 0;\\n\\n        if (memo[i][j] !== -1) return memo[i][j];\\n\\n        if (j === 0) {\\n            return memo[i][j] = Math.max(-prices[i] + dp(i + 1, 1), dp(i + 1, 0));\\n        } else {\\n            return memo[i][j] = Math.max(prices[i] - fee + dp(i + 1, 0), dp(i + 1, 1));\\n        }\\n    }\\n    return dp(0, 0);\\n};\\n// TC: O(n)\\n// SC: O(n)\\n\\n// Tabulation\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n    const dp = [...new Array(n + 1)].map(() => new Array(2).fill(0));\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        dp[i][0] = Math.max(-prices[i] + dp[i + 1][1], dp[i + 1][0]);\\n        dp[i][1] = Math.max(prices[i] + dp[i + 1][0] - fee, dp[i + 1][1]);\\n    }\\n    return dp[0][0];\\n};\\n// TC: O(n)\\n// SC: O(n)\\n\\n// Tabulation - Space optimized\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n    let dp = new Array(2).fill(0);\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        let temp = new Array(2).fill(0);\\n        temp[0] = Math.max(-prices[i] + dp[1], dp[0]);\\n        temp[1] = Math.max(prices[i] + dp[0] - fee, dp[1]);\\n        dp = temp;\\n    }\\n    return dp[0];\\n};\\n// TC: O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n // Recursion [TLE]\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n\\n    function dp(i, j) {\\n        if (i === n) return 0;\\n\\n        if (j === 0) {\\n            return Math.max(-prices[i] + dp(i + 1, 1), dp(i + 1, 0));\\n        } else {\\n            return Math.max(prices[i] - fee + dp(i + 1, 0), dp(i + 1, 1));\\n        }\\n    }\\n    return dp(0, 0);\\n};\\n// TC: Exponential\\n// SC: O(n)\\n\\n // Recursion + Memoization\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n    const memo = [...new Array(n)].map(() => new Array(2).fill(-1));\\n\\n    function dp(i, j) {\\n        if (i === n) return 0;\\n\\n        if (memo[i][j] !== -1) return memo[i][j];\\n\\n        if (j === 0) {\\n            return memo[i][j] = Math.max(-prices[i] + dp(i + 1, 1), dp(i + 1, 0));\\n        } else {\\n            return memo[i][j] = Math.max(prices[i] - fee + dp(i + 1, 0), dp(i + 1, 1));\\n        }\\n    }\\n    return dp(0, 0);\\n};\\n// TC: O(n)\\n// SC: O(n)\\n\\n// Tabulation\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n    const dp = [...new Array(n + 1)].map(() => new Array(2).fill(0));\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        dp[i][0] = Math.max(-prices[i] + dp[i + 1][1], dp[i + 1][0]);\\n        dp[i][1] = Math.max(prices[i] + dp[i + 1][0] - fee, dp[i + 1][1]);\\n    }\\n    return dp[0][0];\\n};\\n// TC: O(n)\\n// SC: O(n)\\n\\n// Tabulation - Space optimized\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length;\\n    let dp = new Array(2).fill(0);\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        let temp = new Array(2).fill(0);\\n        temp[0] = Math.max(-prices[i] + dp[1], dp[0]);\\n        temp[1] = Math.max(prices[i] + dp[0] - fee, dp[1]);\\n        dp = temp;\\n    }\\n    return dp[0];\\n};\\n// TC: O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667381,
                "title": "clear-explanation-with-simple-dynamic-programming-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe maximize our total profit, we need to maximize our profit without considering fees and therefore we need to figure out how we can do that. Like other stock questions, the profit on the ```i\\'th``` day depends on what we do on the ```i\\'th``` day and what we have done until this point. This leads to a dynammic programming solution.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOn a given day, we can either buy the stock, sell the stock, or do nothing. However, we must be a bit careful. We are not allowed to own two shares at the same time and we are also not allowed to sell the stock if we didn\\'t previously buy it. This refines our choices to the following. We can either buy a stock if we don\\'t currently hold it, we can sell the stock if we currently hold it, or we can do nothing. \\n\\nNotice the change in state when we decide to purchase or sell the stock; we go from being free to holding and vice versa. We are free to make as many trades as we want and this model allows us to do so. \\n\\nAs mentioned before, we will use dynamic programming to solve this question. Why? Because the maximum profit we can make on any given day is decided by what we choose to do on that particular day and the maximum profit that we have made uptil that point. \\n\\nTo capture the two states that we can be in (in posession or free), we create two arrays ```free``` and ```hold``` of length ```len(prices)``` where ```free[i]``` and ```hold[i]``` represent the maximum profit that can be earned on the ```i\\'th``` day whether we are holding a stock or not. \\n\\nTo come of with the relationship between ```free[i]``` and ```free[i-1]```, we can do two things. We can either do nothing, in which case ```free[i] = free[i-1]```. Or, we can sell a stock with yesterday\\'s holding profit in which case ```free[i] = hold[i-1] + prices[i] - fee```. We take ```free[i] = max(free[i-1], hold[i-1] + prices[i] - fee)```. Similarly, if we are holding a stock, then we can either do nothing in which case ```hold[i] = hold[i-1]``` or we can buy a stock with yesterday\\'s free profit in which case ```hold[i] = free[i-1] - prices[i]```\\n\\nOnce we have filled out both of these arrays, we can return the maximum of ```free[-1]``` and ```hold[-1]```, although it doesn\\'t make sense to not sell the stock on the last day since that is just declining money and therefore we can just return ```free[-1]```\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \"\"\"\\n        Returns the maximum profit that can be made by trading a stock\\n\\n        Args:\\n            prices: List[int] = the price data of the stock across several days\\n            fee: int = the fees payable when making a round trade i.e. buy and sell\\n        \\n        Returns: \\n            maxProfit: int = the maximum profit to be made\\n        \"\"\"\\n\\n        # Initialize two arrays which represent the maximum profit that can be made\\n        # on the i\\'th day. The two arrays respresent the possibility of either holding\\n        # a stock or not holding a stock.\\n        free = [0] * len(prices)\\n        hold = [0] * len(prices)\\n\\n        # Since we start off buy holding a stock, we have to pay the price of the stock\\n        # on the first day and therefore hold[0] will reflect that \\n        hold[0] = -prices[0]\\n    \\n        # We iterate for each day that we have a price for\\n        for i in range(1, len(prices)):\\n            # We can either sell a stock we are currently holding, buy a stock\\n            # if we don\\'t currently own one, or do nothing. \\n\\n            # if we sell a stock on the i\\'th day and are free, we will make the \\n            # yesterday\\'s profit (from holding) plus the price of the stock today.\\n            free[i] = max(free[i-1], hold[i-1]+prices[i]-fee)\\n\\n\\n            # if we buy a stock on the i\\'th day, then our current profit will be the\\n            # price we paid for the stock today subtracted from the profit we made \\n            # yesterday when no stock was held.\\n            hold[i] = max(hold[i-1], free[i-1] - prices[i])\\n        \\n        # It does not make sense to hold a stock on the last day so we take the \\n        # profit that can be earned after selling in on the last day and return \\n        # that as the result. \\n        maxProfit = free[-1]\\n        return maxProfit\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```i\\'th```\n```i\\'th```\n```free```\n```hold```\n```len(prices)```\n```free[i]```\n```hold[i]```\n```i\\'th```\n```free[i]```\n```free[i-1]```\n```free[i] = free[i-1]```\n```free[i] = hold[i-1] + prices[i] - fee```\n```free[i] = max(free[i-1], hold[i-1] + prices[i] - fee)```\n```hold[i] = hold[i-1]```\n```hold[i] = free[i-1] - prices[i]```\n```free[-1]```\n```hold[-1]```\n```free[-1]```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        \"\"\"\\n        Returns the maximum profit that can be made by trading a stock\\n\\n        Args:\\n            prices: List[int] = the price data of the stock across several days\\n            fee: int = the fees payable when making a round trade i.e. buy and sell\\n        \\n        Returns: \\n            maxProfit: int = the maximum profit to be made\\n        \"\"\"\\n\\n        # Initialize two arrays which represent the maximum profit that can be made\\n        # on the i\\'th day. The two arrays respresent the possibility of either holding\\n        # a stock or not holding a stock.\\n        free = [0] * len(prices)\\n        hold = [0] * len(prices)\\n\\n        # Since we start off buy holding a stock, we have to pay the price of the stock\\n        # on the first day and therefore hold[0] will reflect that \\n        hold[0] = -prices[0]\\n    \\n        # We iterate for each day that we have a price for\\n        for i in range(1, len(prices)):\\n            # We can either sell a stock we are currently holding, buy a stock\\n            # if we don\\'t currently own one, or do nothing. \\n\\n            # if we sell a stock on the i\\'th day and are free, we will make the \\n            # yesterday\\'s profit (from holding) plus the price of the stock today.\\n            free[i] = max(free[i-1], hold[i-1]+prices[i]-fee)\\n\\n\\n            # if we buy a stock on the i\\'th day, then our current profit will be the\\n            # price we paid for the stock today subtracted from the profit we made \\n            # yesterday when no stock was held.\\n            hold[i] = max(hold[i-1], free[i-1] - prices[i])\\n        \\n        # It does not make sense to hold a stock on the last day so we take the \\n        # profit that can be earned after selling in on the last day and return \\n        # that as the result. \\n        maxProfit = free[-1]\\n        return maxProfit\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667359,
                "title": "rust-dp",
                "content": "```\\nimpl Solution {\\n    pub fn max_profit(prices: Vec<i32>, fee: i32) -> i32 {\\n        let mut s0 = -prices[0]; // after buy state\\n        let mut s1 = 0; // after sell state\\n        for i in 1..prices.len() {\\n            let old_s0 = s0;\\n            s0 = s0.max(s1 - prices[i]);\\n            s1 = s1.max(old_s0 + prices[i] - fee);\\n        }\\n        s0.max(s1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_profit(prices: Vec<i32>, fee: i32) -> i32 {\\n        let mut s0 = -prices[0]; // after buy state\\n        let mut s1 = 0; // after sell state\\n        for i in 1..prices.len() {\\n            let old_s0 = s0;\\n            s0 = s0.max(s1 - prices[i]);\\n            s1 = s1.max(old_s0 + prices[i] - fee);\\n        }\\n        s0.max(s1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3170167,
                "title": "5-solutions-recursion-tabulation-greedy",
                "content": "\\n# Recursion With Loop\\n```\\nclass RecursionWithLoop {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,prices.length-1);\\n    }\\n\\n    private int help(int[] prices,int fee, int index){\\n\\n        if(index == 0)return 0;\\n\\n        int max = 0;\\n        for(int j=index-1; j>=0; j--){\\n            int selected = (prices[index]-prices[j]-fee)+help(prices,fee,j-1);\\n            int notSelected = help(prices,fee,index-1);\\n            max = Math.max(max,Math.max(selected,notSelected));\\n        }\\n        return max;\\n    }\\n\\n}\\n\\n```\\n\\n# Recursion To DP\\n\\nThis Solution is Optimized way of above recursive solution\\n```\\nclass RecursionToDP {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,prices.length-1);\\n    }\\n\\n    private int help(int[] prices,int fee, int index){\\n\\n        int[] dp = new int[prices.length];\\n\\n        for(int i=1; i<prices.length; i++){\\n            for(int j=i-1; j>=0; j--){\\n                int selected = 0;\\n                if(j-1>=0)selected = (prices[i]-prices[j]-fee)+dp[j-1];\\n                if(j - 1 < 0)selected = (prices[i]-prices[j]-fee);\\n                int notSelected = dp[i-1];\\n                dp[i] = Math.max(dp[i],Math.max(selected,notSelected));\\n            }\\n        }\\n\\n        return dp[prices.length-1];\\n    }\\n\\n}\\n```\\n\\n# Recursion With Extra Variable (isBuy)\\n\\nThis Solution is Another way to write a recursion Solution\\n```\\nclass BruteForce2 {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,0,true);\\n    }\\n\\n    private int help(int[] prices,int fee, int index, boolean isBuy){\\n\\n        if(index == prices.length)return 0;\\n\\n        int max = 0;\\n\\n        if(isBuy){\\n            int val = help(prices,fee,index+1,!isBuy) - prices[index];\\n            int val2 = help(prices,fee,index+1,isBuy);\\n            max = Math.max(val,val2);\\n        }else{\\n            int val = help(prices,fee,index+1,!isBuy) + prices[index]-fee;\\n            int val2 = help(prices,fee,index+1,isBuy);\\n            max = Math.max(val,val2);\\n        }\\n\\n        return max;\\n    }\\n\\n}\\n```\\n\\n# Recursion TO DP (Optimized) \\n\\nThis Solution is Optimization of the above recursive Solution\\n```\\nclass RecursionToDPOptimized {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,0,true);\\n    }\\n\\n    private int help(int[] prices,int fee, int index, boolean isBuy){\\n\\n        int[][] dp= new int[prices.length+1][2];\\n        dp[prices.length][0] = 0; \\n        \\n\\n        for(int i=prices.length-1; i>=0; i--){\\n\\n            for(int j=0; j<2; j++){\\n                if(j == 0 || i == 0){\\n                    int val = dp[i+1][1] - prices[i];\\n                    int val2 = dp[i+1][0];\\n                    dp[i][j] = Math.max(val,val2);\\n                }else{\\n                    int val = dp[i+1][0] + prices[i] - fee;\\n                    int val2 = dp[i+1][1];\\n                    dp[i][j] = Math.max(val,val2);\\n                }\\n            }\\n\\n        }\\n\\n        return Math.max(dp[0][0],dp[0][1]);\\n    }\\n\\n}\\n```\\n\\n# DP to Space Optimized (Greedy)\\n\\nThis Solution is Optimization of the above DP Solution which In the end results in a Greedy Solution\\n```\\nclass DPToSpaceOptimized {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,0,true);\\n    }\\n\\n    private int help(int[] prices,int fee, int index, boolean isBuy){\\n\\n        int buy = 0,sell=0;\\n        \\n\\n        for(int i=prices.length-1; i>=0; i--){\\n\\n            int val = sell - prices[i];\\n            int val2 = buy;\\n            buy = Math.max(val,val2);\\n\\n            if(i != 0){\\n                int val3 = buy + prices[i] - fee;\\n                int val4 = sell;\\n                sell = Math.max(val3,val4);\\n            }\\n            \\n\\n        }\\n\\n        return  buy;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass RecursionWithLoop {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,prices.length-1);\\n    }\\n\\n    private int help(int[] prices,int fee, int index){\\n\\n        if(index == 0)return 0;\\n\\n        int max = 0;\\n        for(int j=index-1; j>=0; j--){\\n            int selected = (prices[index]-prices[j]-fee)+help(prices,fee,j-1);\\n            int notSelected = help(prices,fee,index-1);\\n            max = Math.max(max,Math.max(selected,notSelected));\\n        }\\n        return max;\\n    }\\n\\n}\\n\\n```\n```\\nclass RecursionToDP {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,prices.length-1);\\n    }\\n\\n    private int help(int[] prices,int fee, int index){\\n\\n        int[] dp = new int[prices.length];\\n\\n        for(int i=1; i<prices.length; i++){\\n            for(int j=i-1; j>=0; j--){\\n                int selected = 0;\\n                if(j-1>=0)selected = (prices[i]-prices[j]-fee)+dp[j-1];\\n                if(j - 1 < 0)selected = (prices[i]-prices[j]-fee);\\n                int notSelected = dp[i-1];\\n                dp[i] = Math.max(dp[i],Math.max(selected,notSelected));\\n            }\\n        }\\n\\n        return dp[prices.length-1];\\n    }\\n\\n}\\n```\n```\\nclass BruteForce2 {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,0,true);\\n    }\\n\\n    private int help(int[] prices,int fee, int index, boolean isBuy){\\n\\n        if(index == prices.length)return 0;\\n\\n        int max = 0;\\n\\n        if(isBuy){\\n            int val = help(prices,fee,index+1,!isBuy) - prices[index];\\n            int val2 = help(prices,fee,index+1,isBuy);\\n            max = Math.max(val,val2);\\n        }else{\\n            int val = help(prices,fee,index+1,!isBuy) + prices[index]-fee;\\n            int val2 = help(prices,fee,index+1,isBuy);\\n            max = Math.max(val,val2);\\n        }\\n\\n        return max;\\n    }\\n\\n}\\n```\n```\\nclass RecursionToDPOptimized {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,0,true);\\n    }\\n\\n    private int help(int[] prices,int fee, int index, boolean isBuy){\\n\\n        int[][] dp= new int[prices.length+1][2];\\n        dp[prices.length][0] = 0; \\n        \\n\\n        for(int i=prices.length-1; i>=0; i--){\\n\\n            for(int j=0; j<2; j++){\\n                if(j == 0 || i == 0){\\n                    int val = dp[i+1][1] - prices[i];\\n                    int val2 = dp[i+1][0];\\n                    dp[i][j] = Math.max(val,val2);\\n                }else{\\n                    int val = dp[i+1][0] + prices[i] - fee;\\n                    int val2 = dp[i+1][1];\\n                    dp[i][j] = Math.max(val,val2);\\n                }\\n            }\\n\\n        }\\n\\n        return Math.max(dp[0][0],dp[0][1]);\\n    }\\n\\n}\\n```\n```\\nclass DPToSpaceOptimized {\\n    public int maxProfit(int[] prices, int fee) {\\n        return help(prices,fee,0,true);\\n    }\\n\\n    private int help(int[] prices,int fee, int index, boolean isBuy){\\n\\n        int buy = 0,sell=0;\\n        \\n\\n        for(int i=prices.length-1; i>=0; i--){\\n\\n            int val = sell - prices[i];\\n            int val2 = buy;\\n            buy = Math.max(val,val2);\\n\\n            if(i != 0){\\n                int val3 = buy + prices[i] - fee;\\n                int val4 = sell;\\n                sell = Math.max(val3,val4);\\n            }\\n            \\n\\n        }\\n\\n        return  buy;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168835,
                "title": "easy-java-memoization-commented-code",
                "content": "# Complexity\\n- Time complexity:\\nO(N) -> where N = number of prices. \\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    int[][] memo;\\n    public int maxProfit(int[] prices, int fee) {\\n        // Keeps track of results of buying or selling on each day\\n        memo = new int[prices.length][2];\\n        for (int i = 0; i < prices.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return dp(prices, fee,0, 0);\\n    }\\n\\n    // Returns max profit on day=day based on if you\\'re holding the stock or not\\n    private int dp(int[] prices, int fee, int holding, int day) {\\n        if (day == prices.length) return 0;\\n        if (memo[day][holding]!=-1) return memo[day][holding];\\n        \\n        // Irrespectiv of whether you\\'re holding a stock or not, \\n        // you can choose to skip doing any transactions on current day\\n        int ans = dp(prices, fee, holding, day+1);\\n        \\n        if (holding == 0) {\\n            // If you\\'re not holding the stock, take max of if you \\n            // skipped, or if you purchased at current day\\n            ans = Math.max(ans, dp(prices, fee, 1, day+1) - prices[day]);\\n        } else {\\n            // If you\\'re holding the stock, take max of if you skipped, or \\n            // if you sold at current day. \\n            // Fees only applies on selling stock.            \\n            ans = Math.max(ans, dp(prices, fee, 0, day+1) + prices[day] - fee);\\n        }\\n        memo[day][holding] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    public int maxProfit(int[] prices, int fee) {\\n        // Keeps track of results of buying or selling on each day\\n        memo = new int[prices.length][2];\\n        for (int i = 0; i < prices.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return dp(prices, fee,0, 0);\\n    }\\n\\n    // Returns max profit on day=day based on if you\\'re holding the stock or not\\n    private int dp(int[] prices, int fee, int holding, int day) {\\n        if (day == prices.length) return 0;\\n        if (memo[day][holding]!=-1) return memo[day][holding];\\n        \\n        // Irrespectiv of whether you\\'re holding a stock or not, \\n        // you can choose to skip doing any transactions on current day\\n        int ans = dp(prices, fee, holding, day+1);\\n        \\n        if (holding == 0) {\\n            // If you\\'re not holding the stock, take max of if you \\n            // skipped, or if you purchased at current day\\n            ans = Math.max(ans, dp(prices, fee, 1, day+1) - prices[day]);\\n        } else {\\n            // If you\\'re holding the stock, take max of if you skipped, or \\n            // if you sold at current day. \\n            // Fees only applies on selling stock.            \\n            ans = Math.max(ans, dp(prices, fee, 0, day+1) + prices[day] - fee);\\n        }\\n        memo[day][holding] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137657,
                "title": "java-solution-3-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }\\n        return buying;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121832,
                "title": "beats-100-both-memoization-and-tabulation-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/////////////  MEMOIZATION\\n    // int f(int ind,int buy,int n, int fee,vector<int>&v,vector<vector<int>> &dp){\\n    //     long long pick , notpick;\\n    //     if(ind == n) return 0;\\n    //     if(dp[ind][buy] != -1 ) return dp[ind][buy];\\n    //     if(buy == 1){  //// buy == 1 mtlb mai ab kharidunga\\n    //         notpick = 0 + f(ind+1,1,n,fee,v,dp);\\n    //         pick = -v[ind] + f(ind+1,0,n,fee,v,dp);\\n    //     }\\n    //     else{\\n    //         notpick = 0 + f(ind+1,0,n,fee,v,dp);\\n    //         pick = v[ind]-fee + f(ind+1,1,n,fee,v,dp);\\n    //     }\\n    //     return dp[ind][buy] = max(pick,notpick);\\n    // }\\n    // int maxProfit(vector<int>& v, int fee) {\\n    //     int n = v.size();\\n    //     vector<vector<int>> dp(n,vector<int>(2,-1));\\n    //     return f(0,1,n,fee,v,dp);\\n    // }\\n////////   TABULATION\\n    int maxProfit(vector<int>& v, int fee) {\\n        int n = v.size();\\n        int pick , notpick;\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=1;j++){\\n                if(j == 1){  //// buy == 1 mtlb mai ab kharidunga\\n                    notpick = 0 + dp[i+1][1];\\n                    pick = -v[i] + dp[i+1][0];\\n                }\\n                else{\\n                    notpick = 0 + dp[i+1][0];\\n                    pick = v[i]-fee + dp[i+1][1];\\n                }\\n                dp[i][j] = max(pick,notpick);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/////////////  MEMOIZATION\\n    // int f(int ind,int buy,int n, int fee,vector<int>&v,vector<vector<int>> &dp){\\n    //     long long pick , notpick;\\n    //     if(ind == n) return 0;\\n    //     if(dp[ind][buy] != -1 ) return dp[ind][buy];\\n    //     if(buy == 1){  //// buy == 1 mtlb mai ab kharidunga\\n    //         notpick = 0 + f(ind+1,1,n,fee,v,dp);\\n    //         pick = -v[ind] + f(ind+1,0,n,fee,v,dp);\\n    //     }\\n    //     else{\\n    //         notpick = 0 + f(ind+1,0,n,fee,v,dp);\\n    //         pick = v[ind]-fee + f(ind+1,1,n,fee,v,dp);\\n    //     }\\n    //     return dp[ind][buy] = max(pick,notpick);\\n    // }\\n    // int maxProfit(vector<int>& v, int fee) {\\n    //     int n = v.size();\\n    //     vector<vector<int>> dp(n,vector<int>(2,-1));\\n    //     return f(0,1,n,fee,v,dp);\\n    // }\\n////////   TABULATION\\n    int maxProfit(vector<int>& v, int fee) {\\n        int n = v.size();\\n        int pick , notpick;\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=1;j++){\\n                if(j == 1){  //// buy == 1 mtlb mai ab kharidunga\\n                    notpick = 0 + dp[i+1][1];\\n                    pick = -v[i] + dp[i+1][0];\\n                }\\n                else{\\n                    notpick = 0 + dp[i+1][0];\\n                    pick = v[i]-fee + dp[i+1][1];\\n                }\\n                dp[i][j] = max(pick,notpick);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103611,
                "title": "js-dp-bottom-up-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} fee\\n * @return {number}\\n */\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length\\n    let notHold = 0\\n    let hold = -prices[0]\\n    \\n    for (let i = 1; i < n; i++) {\\n        const temp = notHold\\n        notHold = Math.max(prices[i] - fee + hold, notHold)\\n        hold = Math.max(-prices[i] + temp, hold)\\n    }\\n    \\n    return Math.max(notHold, hold)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} fee\\n * @return {number}\\n */\\nvar maxProfit = function(prices, fee) {\\n    const n = prices.length\\n    let notHold = 0\\n    let hold = -prices[0]\\n    \\n    for (let i = 1; i < n; i++) {\\n        const temp = notHold\\n        notHold = Math.max(prices[i] - fee + hold, notHold)\\n        hold = Math.max(-prices[i] + temp, hold)\\n    }\\n    \\n    return Math.max(notHold, hold)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3051221,
                "title": "most-optimized-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O((N+1)*2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O((N+1)*2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    # def dp(self,i,buy,prices,fee,n,dct):\\n    #     if i==n:\\n    #         return 0\\n    #     if (i,buy) in dct:\\n    #         return dct[(i,buy)]\\n    #     if buy:\\n    #         x=max(self.dp(i+1,buy,prices,fee,n,dct),self.dp(i+1,0,prices,fee,n,dct)-prices[i])\\n    #     else:\\n    #         x=max(self.dp(i+1,buy,prices,fee,n,dct),self.dp(i+1,1,prices,fee,n,dct)+prices[i]-fee)\\n    #     dct[(i,buy)]=x\\n    #     return x\\n\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n=len(prices)\\n        # dp=[[0]*2 for _ in range(n+1)]\\n        ahd=[0]*2\\n        for i in range(n-1,-1,-1):\\n            curr=[0]*2\\n            for buy in range(2):\\n                if buy:\\n                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])\\n                else:\\n                    curr[buy]=max(ahd[buy],ahd[1]+prices[i]-fee)\\n            ahd=curr\\n        return ahd[1]\\n\\n        # return self.dp(0,1,prices,fee,n,{})\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # def dp(self,i,buy,prices,fee,n,dct):\\n    #     if i==n:\\n    #         return 0\\n    #     if (i,buy) in dct:\\n    #         return dct[(i,buy)]\\n    #     if buy:\\n    #         x=max(self.dp(i+1,buy,prices,fee,n,dct),self.dp(i+1,0,prices,fee,n,dct)-prices[i])\\n    #     else:\\n    #         x=max(self.dp(i+1,buy,prices,fee,n,dct),self.dp(i+1,1,prices,fee,n,dct)+prices[i]-fee)\\n    #     dct[(i,buy)]=x\\n    #     return x\\n\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n=len(prices)\\n        # dp=[[0]*2 for _ in range(n+1)]\\n        ahd=[0]*2\\n        for i in range(n-1,-1,-1):\\n            curr=[0]*2\\n            for buy in range(2):\\n                if buy:\\n                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])\\n                else:\\n                    curr[buy]=max(ahd[buy],ahd[1]+prices[i]-fee)\\n            ahd=curr\\n        return ahd[1]\\n\\n        # return self.dp(0,1,prices,fee,n,{})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999306,
                "title": "python-easy-o-n-explanation-for-fellow-low-iq-ppl",
                "content": "# Approach\\n*Using a state diagram, we can generalize this problem to the other problems in the stock questions*.\\n\\nEssentially, we are taking the \"best\" choice available for each state in every iteration. Then, at the end, we take the maximum of all states (although note that in this problem, `x0` will always be greater than `x1`at the end).\\n\\nUsing the diagram, we see that the transition functions are\\n`x0 = max(x0, x1 + prices[i])`\\n`x1 = max(x1, x0 - prices[i] - fee)`\\n\\n![image.png](https://assets.leetcode.com/users/images/d92c0fdf-e47d-4fdc-8088-b2fc125f4630_1672853510.9251232.png)\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        x0 = 0\\n        x1 = float(\\'-inf\\')\\n\\n        for i in range(N):\\n            x0 = max(x0, x1 + prices[i])\\n            x1 = max(x1, x0 - prices[i] - fee)\\n        return max(x0, x1)\\n\\n\\n```\\nIf you liked the solution, please leave a like :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        x0 = 0\\n        x1 = float(\\'-inf\\')\\n\\n        for i in range(N):\\n            x0 = max(x0, x1 + prices[i])\\n            x1 = max(x1, x0 - prices[i] - fee)\\n        return max(x0, x1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435763,
                "title": "c-striver-approach-recursive-memoization",
                "content": "```\\nint function(int i,int buy,vector<int>& prices,vector<vector<int>>& dp,int fee)\\n    {\\n        if(i==prices.size())\\n            return 0;\\n        \\n        if(dp[i][buy]!=-1)\\n            return dp[i][buy];\\n        \\n        int profit=0;\\n        \\n        if(buy)\\n        {\\n            profit=max(-prices[i]+function(i+1,0,prices,dp,fee),0+function(i+1,1,prices,dp,fee));\\n        }\\n        else\\n        {\\n            profit=max(prices[i]+function(i+1,1,prices,dp,fee)-fee,0+function(i+1,0,prices,dp,fee));\\n        }\\n        \\n        return dp[i][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) \\n    {\\n        int n=prices.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(2,-1)); \\n        \\n        return function(0,1,prices,dp,fee);\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint function(int i,int buy,vector<int>& prices,vector<vector<int>>& dp,int fee)\\n    {\\n        if(i==prices.size())\\n            return 0;\\n        \\n        if(dp[i][buy]!=-1)\\n            return dp[i][buy];\\n        \\n        int profit=0;\\n        \\n        if(buy)\\n        {\\n            profit=max(-prices[i]+function(i+1,0,prices,dp,fee),0+function(i+1,1,prices,dp,fee));\\n        }\\n        else\\n        {\\n            profit=max(prices[i]+function(i+1,1,prices,dp,fee)-fee,0+function(i+1,0,prices,dp,fee));\\n        }\\n        \\n        return dp[i][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices, int fee) \\n    {\\n        int n=prices.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(2,-1)); \\n        \\n        return function(0,1,prices,dp,fee);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2307919,
                "title": "c-dp-solution-explained-in-detail",
                "content": "**Approach:**\\n\\n* ```dp[i] = max profit on the ith day```\\n* at the ith day, we have three choices\\n    * 1. buy\\n    * 2. sell\\n    * 3. rest\\n* we will try each of these option and see in which case we get the max profit\\n* we can\\'t perform multiple transaction at a same time\\n* which means\\n    * if we decide to buy on the i-th day, there should be 0 stock held in our hand before we buy\\n    * if we decide to sell on the i-th day, there should be exactly 1 stock held in our hand before we sell.\\n* So, we can divide our problem in two subparts\\n    * ```dp[i][0] = the maximum profit at the end of the i-th day and with 0 stock in our hand AFTER taking the action```\\n    * ```dp[i][1] = the maximum profit at the end of the i-th day and with 1 stock in our hand AFTER taking the action```\\n* **for dp[i][0]:**\\n    * the actions taken on the i-th day can only be rest and sell, since we have 0 stock in our hand at the end of the day.\\n    * if we choose to rest\\n        * profit at ith day = profit at (i-1)day when we have 0 stocks in our hand after taking the action\\n        * ```dp[i][0] = dp[i-1][0]```\\n    * if we choose to sell\\n        * profit at ith day = profit at (i-1)day when we have 1 stocks in our hand after taking the action + prices[i]\\n        * ```dp[i][0] = dp[i-1][1]+prices[i]```\\n    * so final profit\\n        * ```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])```\\n* **for dp[i][1]:**\\n    * the actions taken on the i-th day can only be rest and buy, since we have 1 stock in our hand at the end of the day.\\n    * if we choose to rest\\n        * profit at ith day = profit at (i-1)day when we have 1 stocks in our hand after taking the action\\n        * ```dp[i][1] = dp[i-1][1]```\\n    * if we choose to sell\\n        * profit at ith day = profit at (i-1)day when we have 0 stocks in our hand after taking the action - prices[i]\\n        * ```dp[i][1] = dp[i-1][0]-prices[i]```\\n    * so final profit\\n        * ```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i])```\\n* **The final equations are:**\\n    * **```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])```**\\n    * **```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i])```**\\n* Now, we have to pay the fee at each transaction\\n* the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either\\n    * **```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])```**\\n    * **```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i]-fee)```**\\n    * or\\n    * **```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]-fee)```**\\n    * **```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i])```**\\n* Note we have two options as for when to subtract the fee.\\n    * This is because each transaction is characterized by two actions coming as a pair\\n        * buy and sell.\\n* The fee can be paid either when we buy the stock (corresponds to the first set of equations) or when we sell it (corresponds to the second set of equations)\\n* **```ans = dp[n-1][0]```**\\n    * we always have larger profit if we end up with 0 stock in hand\\n\\n\\n**Code:**\\n\\n**Solution 1** -- pay the fee when buying the stock:\\n```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices, int fee)\\n    {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, 0));\\n        dp[0][1] = -prices[0] - fee;\\n        for (int i = 1; i < n; i++)\\n        {\\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);\\n        }\\n        return dp[n - 1][0];\\n    }\\n};\\n```\\n**Solution 2** -- pay the fee when selling the stock:\\n```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices, int fee)\\n    {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, 0));\\n        dp[0][1] = -prices[0]; \\n        for (int i = 1; i < n; i++)\\n        {\\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);\\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\\n        }\\n        return dp[n - 1][0];\\n    }\\n};\\n```\\n\\n**Note that we can optimize the above codes for O(1) space**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```dp[i] = max profit on the ith day```\n```dp[i][0] = the maximum profit at the end of the i-th day and with 0 stock in our hand AFTER taking the action```\n```dp[i][1] = the maximum profit at the end of the i-th day and with 1 stock in our hand AFTER taking the action```\n```dp[i][0] = dp[i-1][0]```\n```dp[i][0] = dp[i-1][1]+prices[i]```\n```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])```\n```dp[i][1] = dp[i-1][1]```\n```dp[i][1] = dp[i-1][0]-prices[i]```\n```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i])```\n```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])```\n```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i])```\n```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])```\n```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i]-fee)```\n```dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]-fee)```\n```dp[i][0] = max(dp[i-1][1],dp[i-1][0]-prices[i])```\n```ans = dp[n-1][0]```\n```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices, int fee)\\n    {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, 0));\\n        dp[0][1] = -prices[0] - fee;\\n        for (int i = 1; i < n; i++)\\n        {\\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);\\n        }\\n        return dp[n - 1][0];\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices, int fee)\\n    {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, 0));\\n        dp[0][1] = -prices[0]; \\n        for (int i = 1; i < n; i++)\\n        {\\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);\\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\\n        }\\n        return dp[n - 1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929977,
                "title": "top-down-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    int[][] dp;\\n    \\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        dp = new int[n+1][2];\\n        \\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<2; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        return helper(0,1,prices,fee);\\n    }\\n    public int helper(int i, int buy, int[] prices, int fee){\\n        if(i >= prices.length)\\n            return 0;\\n        \\n        int buyStock = Integer.MIN_VALUE;\\n        int sellStock = Integer.MIN_VALUE;\\n        \\n        if(dp[i][buy] != -1)\\n            return dp[i][buy];\\n        \\n        if(buy == 1){\\n            buyStock = Math.max(-prices[i]+helper(i+1,0,prices,fee),\\n                               helper(i+1,1,prices,fee));\\n        }\\n        else{\\n            sellStock = Math.max(prices[i]+helper(i+1,1,prices,fee)-fee,\\n                                helper(i+1,0,prices,fee));\\n        }\\n        \\n        return dp[i][buy] = Math.max(buyStock,sellStock);\\n    }\\n}\\n```\\n\\nPlease upvote if found helpful!",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dp;\\n    \\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        dp = new int[n+1][2];\\n        \\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<2; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        return helper(0,1,prices,fee);\\n    }\\n    public int helper(int i, int buy, int[] prices, int fee){\\n        if(i >= prices.length)\\n            return 0;\\n        \\n        int buyStock = Integer.MIN_VALUE;\\n        int sellStock = Integer.MIN_VALUE;\\n        \\n        if(dp[i][buy] != -1)\\n            return dp[i][buy];\\n        \\n        if(buy == 1){\\n            buyStock = Math.max(-prices[i]+helper(i+1,0,prices,fee),\\n                               helper(i+1,1,prices,fee));\\n        }\\n        else{\\n            sellStock = Math.max(prices[i]+helper(i+1,1,prices,fee)-fee,\\n                                helper(i+1,0,prices,fee));\\n        }\\n        \\n        return dp[i][buy] = Math.max(buyStock,sellStock);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929694,
                "title": "fully-explained",
                "content": "*One of the best questions in DP*\\n  \\n\\tNote: There is transaction fees only if you sell it.\\n Lets assume on a particular day you can be in two states: \\n1.  You have a stock in hand ** `hold`**\\n2. You do not have a stock in hand  **`cash`**\\n\\nState 1 i.e you have a stock in hand if you held a stock yesterday and did not do any transactions today or you did not have a stock yesterday and bought a stock today.\\nState 2 i.e you donot have a stock in hand today. This can be achieved if you sold yesterdays stock or continued to remain without a stock.\\n\\nLets describe the states in code: \\n```\\nhold[i] = Math.max(hold[i-1],cash[i-1]-price[i])\\ncash[i] = Math.max(cash[i-1], hold[i-1]+price[i]-fee)\\n```\\n\\nLets consider an example    `prices = {1,3,2,8,4,9}`\\n\\n**Day 1**\\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0}\\nhold = {-1,0,0,0,0,0}  // hold[0] = -prices[0]\\n```\\nOn day1 we start with no profit and no cash in hand. Here hold[0] = -prices[0] is used because without any cash in hand previous to day1 we bought a stock on day1 so our net amount will be negative of prices[0].\\n\\n**Day 2**\\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,0,0,0,0}\\n```\\n```\\ncash[1] = max(\\'no transactions\\'-> 0, \\'selling of yesterdays stock\\'-> -1+3-2)\\nhold[1] = max(\\'no transactions\\'-> -1, \\'buying a stock today\\'->0-3)\\n```\\n\\n**Day 3**\\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,-1,0,0,0}\\n```\\n```\\ncash[2] = max(0,-1+2-2)\\nhold[2] = max(-1,0-2)\\n```\\n\\n**Day 4**\\n```\\nprofit = 5\\ncash = {0,0,0,5,0,0}\\nhold = {-1,-1,-1,-1,0,0}\\n```\\n```\\ncash[3] = max(0,-1+8-2)\\nhold[3] = max(-1,0-8)\\n```\\n\\n**Day 5**\\n```\\nprofit = 5\\ncash = {0,0,0,5,5,0}\\nhold = {-1,-1,-1,-1,1,0}\\n```\\n```\\ncash[4] = max(5,-1+4-2)\\nhold[4] = max(-1,5-4)\\n```\\n\\n**Day 6**\\n```\\nprofit = 8\\ncash = {0,0,0,5,5,8}\\nhold = {-1,-1,-1,-1,1,1}\\n```\\n```\\ncash[4] = max(5,1+9-2)\\nhold[4] = max(1,5-9)\\n```\\n\\n```\\nCode\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        int[] cash = new int[n];\\n        int[] hold = new int[n];\\n        cash[0] = 0;\\n        int profit = 0;\\n        hold[0] = -prices[0];\\n        for(int i=1;i<n;i++){\\n            cash[i] = Math.max(cash[i-1],hold[i-1]+prices[i]-fee);\\n            hold[i] = Math.max(hold[i-1],cash[i-1]-prices[i]);\\n        }\\n        return cash[n-1];\\n    }\\n```\\n\\n\\n**Up vote if you like the solution**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nhold[i] = Math.max(hold[i-1],cash[i-1]-price[i])\\ncash[i] = Math.max(cash[i-1], hold[i-1]+price[i]-fee)\\n```\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0}\\nhold = {-1,0,0,0,0,0}  // hold[0] = -prices[0]\\n```\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,0,0,0,0}\\n```\n```\\ncash[1] = max(\\'no transactions\\'-> 0, \\'selling of yesterdays stock\\'-> -1+3-2)\\nhold[1] = max(\\'no transactions\\'-> -1, \\'buying a stock today\\'->0-3)\\n```\n```\\nprofit = 0\\ncash = {0,0,0,0,0,0,}\\nhold = {-1,-1,-1,0,0,0}\\n```\n```\\ncash[2] = max(0,-1+2-2)\\nhold[2] = max(-1,0-2)\\n```\n```\\nprofit = 5\\ncash = {0,0,0,5,0,0}\\nhold = {-1,-1,-1,-1,0,0}\\n```\n```\\ncash[3] = max(0,-1+8-2)\\nhold[3] = max(-1,0-8)\\n```\n```\\nprofit = 5\\ncash = {0,0,0,5,5,0}\\nhold = {-1,-1,-1,-1,1,0}\\n```\n```\\ncash[4] = max(5,-1+4-2)\\nhold[4] = max(-1,5-4)\\n```\n```\\nprofit = 8\\ncash = {0,0,0,5,5,8}\\nhold = {-1,-1,-1,-1,1,1}\\n```\n```\\ncash[4] = max(5,1+9-2)\\nhold[4] = max(1,5-9)\\n```\n```\\nCode\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        int[] cash = new int[n];\\n        int[] hold = new int[n];\\n        cash[0] = 0;\\n        int profit = 0;\\n        hold[0] = -prices[0];\\n        for(int i=1;i<n;i++){\\n            cash[i] = Math.max(cash[i-1],hold[i-1]+prices[i]-fee);\\n            hold[i] = Math.max(hold[i-1],cash[i-1]-prices[i]);\\n        }\\n        return cash[n-1];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911652,
                "title": "java-dp-automata-comments-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    /**\\n    Automata:\\n    Q = { Hold, Sold } \\n    \\u2211 = { buy, sell, rest }\\n    q0 = { Sold }\\n    F = { Sold } \\n    \\u03B4 = {\\n        Sold x rest -> Sold\\n        Sold x buy -> Hold\\n        Hold x sell -> Sold\\n        Hold x rest -> Hold\\n    }\\n    */\\n    public int maxProfit(int[] prices, int fee) {\\n        int hold = -50000;\\n        int sold = 0;\\n        for (int price: prices) {\\n            int preHold = hold;\\n            int preSold = sold;\\n            hold = Math.max(preHold, preSold - price);\\n            sold = Math.max(preSold, preHold + price - fee);      \\n        }\\n        return sold;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n    Automata:\\n    Q = { Hold, Sold } \\n    \\u2211 = { buy, sell, rest }\\n    q0 = { Sold }\\n    F = { Sold } \\n    \\u03B4 = {\\n        Sold x rest -> Sold\\n        Sold x buy -> Hold\\n        Hold x sell -> Sold\\n        Hold x rest -> Hold\\n    }\\n    */\\n    public int maxProfit(int[] prices, int fee) {\\n        int hold = -50000;\\n        int sold = 0;\\n        for (int price: prices) {\\n            int preHold = hold;\\n            int preSold = sold;\\n            hold = Math.max(preHold, preSold - price);\\n            sold = Math.max(preSold, preHold + price - fee);      \\n        }\\n        return sold;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789615,
                "title": "dp-python-solution-using-list-with-explanation",
                "content": "With DP questions it\\'s almost always a good start to consider simpler cases of input sizes and observe the relationship from some input index i to i -1. Using inductive reasoning, the analysis of the smaller input sizes can uncover a pattern that generalizes for larger inputs.\\n\\nConsider storing the max profit up until some day i.  This can be represented with a list called dp with the number of days given by len(prices). \\n```\\ndp = [0] * len(prices)\\n```\\nThe max profit on day 1 is 0 since we can only buy on that first day giving negative profit or do nothing on that day and we want the larger of the two which is always 0. On the second day, we can either have the max profit as the day before on day 1 or we can sell on this day and pay a fee.\\n```\\ndp[0] = max(0, -prices[0])\\ndp[1] = max(dp[0], prices[1] - prices[0] - fee)\\n```\\nOverall, on any given day we can either choose to do nothing / sell/ buy.\\nWhat we notice here from the small input case is that the max profit on a day is either the max profit from the previous day since we can choose to do nothing / buy on this day or we can sell on the this day giving a new profit. In the simple case there is only one possible day you could have buy which is the first day. But on larger inputs there can be many days before which you can choose to buy the stock on.\\n\\nNow to generalize this simple case to larger cases, on any day i, we can have the same max profit as the day before on i - 1 by either doing nothing/buying or choosing to sell on day i with some buy day j. When we choose some day j as the buy day then we also carry over the max profit from the day before it. We want to select a day j that maximizes our profit.\\n```\\ndp[i] = max(dp[i-1], dp[j-1] - prices[j] + prices[i] - fee) for some j < i where j is a buy day\\n```\\nOur base conditions and this relation allows us to build a solution up in O(n^2) time but it will TLE.\\n\\nInstead we can notice that in the relation above\\n```\\ndp[j-1] - prices[j] - fee\\n```\\nprecedes every day i and that this value can be tracked instead of continually looping over per day i to form it. We want the maximum dp[j-1] - prices[j] - fee everytime to use with prices[i]. This can be stored in a variable max_prev_profit that is intially buying on the first day.\\n\\nThese steps reduce the problem to a single linear loop as given below.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        if len(prices) == 1:\\n            return 0\\n        dp = [0] * len(prices)\\n        dp[0] = 0\\n        dp[1] = max(0, prices[1] - prices[0] - fee)\\n        max_prev_profit = -prices[0] - fee\\n        for i in range(1, len(prices)):\\n            dp[i] = max(dp[i-1], max_prev_profit + prices[i])\\n            max_prev_profit = max(max_prev_profit, dp[i-1] - prices[i] - fee)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp = [0] * len(prices)\\n```\n```\\ndp[0] = max(0, -prices[0])\\ndp[1] = max(dp[0], prices[1] - prices[0] - fee)\\n```\n```\\ndp[i] = max(dp[i-1], dp[j-1] - prices[j] + prices[i] - fee) for some j < i where j is a buy day\\n```\n```\\ndp[j-1] - prices[j] - fee\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        if len(prices) == 1:\\n            return 0\\n        dp = [0] * len(prices)\\n        dp[0] = 0\\n        dp[1] = max(0, prices[1] - prices[0] - fee)\\n        max_prev_profit = -prices[0] - fee\\n        for i in range(1, len(prices)):\\n            dp[i] = max(dp[i-1], max_prev_profit + prices[i])\\n            max_prev_profit = max(max_prev_profit, dp[i-1] - prices[i] - fee)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772301,
                "title": "java-python3-simple-dp-solution-top-down-bottom-up",
                "content": "Hello everyone, I hope you all are doing great!\\n\\n**NOTE: If you found this post helpful, then please do upvote it!**\\n\\n#### Python (Top-Down)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n\\n        @lru_cache(None)\\n        def dp(i: int, holding: int):\\n            if i == n:\\n                return 0\\n            do_nothing = dp(i+1, holding)\\n            do_something = 0\\n            if holding:\\n                # sell stock\\n                do_something = prices[i]-fee + dp(i+1, 0)\\n            else:\\n                # buy stock\\n                do_something = -prices[i] + dp(i+1, 1)\\n            return max(do_nothing, do_something)\\n        return dp(0, 0)\\n```\\n\\n#### Java (Top-Down)\\n```\\nclass Solution {\\n    private int n, fee;\\n    private int[] prices;\\n    private int[][] memo;\\n\\n    private int dp(int i, int holding) {\\n        if (i == n)\\n            return 0;\\n        if (memo[i][holding] == 0) {\\n            int do_nothing = dp(i + 1, holding);\\n            int do_something = 0;\\n            if (holding == 1) {\\n                // sell stock today\\n                do_something = prices[i] - fee + dp(i + 1, 0);\\n            } else {\\n                // buy stock today\\n                do_something = -prices[i] + dp(i + 1, 1);\\n            }\\n            memo[i][holding] = Math.max(do_nothing, do_something);\\n        }\\n        return memo[i][holding];\\n    }\\n\\n    public int maxProfit(int[] prices, int fee) {\\n        this.prices = prices;\\n        this.fee = fee;\\n        this.n = prices.length;\\n        this.memo = new int[n][2];\\n        return dp(0, 0);\\n    }\\n}\\n```\\n\\n#### Python (Bottom-Up)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[0]*2 for _ in range(n+1)]\\n\\n        for i in range(n-1, -1, -1):\\n            for holding in range(2):\\n                do_nothing = dp[i+1][holding]\\n                if holding:\\n                    # sell stock\\n                    do_something = prices[i]-fee+dp[i+1][0]\\n                else:\\n                    do_something = -prices[i] + dp[i+1][1]\\n                dp[i][holding] = max(do_nothing, do_something)\\n        return dp[0][0]\\n```\\n\\n\\n#### Java (Bottom-Up)\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        int[][] dp = new int[n + 1][2];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int holding = 0; holding < 2; holding++) {\\n                int do_nothing = dp[i + 1][holding];\\n                int do_something = 0;\\n                if (holding == 1) {\\n                    // sell stock today\\n                    do_something = prices[i] - fee + dp[i + 1][0];\\n                } else {\\n                    // buy stock today\\n                    do_something = -prices[i] + dp[i + 1][1];\\n                }\\n                dp[i][holding] = Math.max(do_nothing, do_something);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\n\\nCheck my other solutions: https://blog.jawadnoor.vercel.app",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n\\n        @lru_cache(None)\\n        def dp(i: int, holding: int):\\n            if i == n:\\n                return 0\\n            do_nothing = dp(i+1, holding)\\n            do_something = 0\\n            if holding:\\n                # sell stock\\n                do_something = prices[i]-fee + dp(i+1, 0)\\n            else:\\n                # buy stock\\n                do_something = -prices[i] + dp(i+1, 1)\\n            return max(do_nothing, do_something)\\n        return dp(0, 0)\\n```\n```\\nclass Solution {\\n    private int n, fee;\\n    private int[] prices;\\n    private int[][] memo;\\n\\n    private int dp(int i, int holding) {\\n        if (i == n)\\n            return 0;\\n        if (memo[i][holding] == 0) {\\n            int do_nothing = dp(i + 1, holding);\\n            int do_something = 0;\\n            if (holding == 1) {\\n                // sell stock today\\n                do_something = prices[i] - fee + dp(i + 1, 0);\\n            } else {\\n                // buy stock today\\n                do_something = -prices[i] + dp(i + 1, 1);\\n            }\\n            memo[i][holding] = Math.max(do_nothing, do_something);\\n        }\\n        return memo[i][holding];\\n    }\\n\\n    public int maxProfit(int[] prices, int fee) {\\n        this.prices = prices;\\n        this.fee = fee;\\n        this.n = prices.length;\\n        this.memo = new int[n][2];\\n        return dp(0, 0);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[0]*2 for _ in range(n+1)]\\n\\n        for i in range(n-1, -1, -1):\\n            for holding in range(2):\\n                do_nothing = dp[i+1][holding]\\n                if holding:\\n                    # sell stock\\n                    do_something = prices[i]-fee+dp[i+1][0]\\n                else:\\n                    do_something = -prices[i] + dp[i+1][1]\\n                dp[i][holding] = max(do_nothing, do_something)\\n        return dp[0][0]\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        int[][] dp = new int[n + 1][2];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int holding = 0; holding < 2; holding++) {\\n                int do_nothing = dp[i + 1][holding];\\n                int do_something = 0;\\n                if (holding == 1) {\\n                    // sell stock today\\n                    do_something = prices[i] - fee + dp[i + 1][0];\\n                } else {\\n                    // buy stock today\\n                    do_something = -prices[i] + dp[i + 1][1];\\n                }\\n                dp[i][holding] = Math.max(do_nothing, do_something);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767572,
                "title": "best-time-to-buy-and-sell-stock-with-transaction-fee-solution-java",
                "content": "class Solution {\\n  public int maxProfit(int[] prices, int fee) {\\n    int sell = 0;\\n    int hold = Integer.MIN_VALUE;\\n\\n    for (final int price : prices) {\\n      sell = Math.max(sell, hold + price);\\n      hold = Math.max(hold, sell - price - fee);\\n    }\\n\\n    return sell;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n  public int maxProfit(int[] prices, int fee) {\\n    int sell = 0;\\n    int hold = Integer.MIN_VALUE;\\n\\n    for (final int price : prices) {\\n      sell = Math.max(sell, hold + price);\\n      hold = Math.max(hold, sell - price - fee);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1764839,
                "title": "java-dp-solution-explained",
                "content": "At every Day we would consider 2 States.\\n1. The Minimum Loan we are Holding after buying a Stock.\\n2. The Max profit that we would make if we sell the Minimum amount of loan we have kept till now along with the *Transaction fee* included.\\n\\nFor eg: [10,15,20,16,20,22]  ; fee = 3\\nDay 0: Assume we bought `prices[0]` which will be `bought = 10` & our `profit = 0`. \\n\\nDay 1: We either decide to keep the previous stock bought or Sell it, this leads to `bought = min(10, 15-2)` which means better to keep the previous bought stock. Other state to calculate the profit **IF** we decide to sell the previous Bought stock today on Day 1, which would mean `profit = Math.max(0, 15 - 10 - 3);` which gives us a new Profit of 2 which is ceretainly better than the previous result,.\\n\\nWe would likely solve the States for all remaining days.\\n\\nDay 2: `bought = Math.min(10, 20 - 2);` which means better to keep the previous min stock to sell.\\n`profit = Math.max(2, 20 - 10 - 3);` which will mean buy on Day 0 & Sell on Day 2 to get profit of 7.\\n\\nDay 3: `bought = Math.min(10, 16 - 7);` which means we can afford to Buy a new Stock with an assumtion that the previous bought Stock can be Selled before the current day.\\n`profit = Math.max(7, 16 - 9 - 3);` which means the previous Profit gained was better instead of selling the Profit today and reap a lower Profit.\\n\\nDay 4 : `bought = Math.min(9, 20 - 7);` ; `bought = 9`\\n`profit = Math.max(7, 20 - 9 - 3);` new `profit = 8`\\n\\nDay 5 : `bought = Math.min(9, 22 - 7);` ; `bought = 9`\\n`profit = Math.max(8, 22 - 9 - 3);` new `profit = 10`\\n\\nOur final `profit = 10` which we got by buying on Day 0 & Selling on Day 2, followed by buying on Day 3 & Selling on Day 5.\\n\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int bought = prices[0];\\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            bought = Math.min(bought, prices[i] - profit);\\n            profit = Math.max(profit,prices[i] - bought - fee);\\n        }\\n        \\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int bought = prices[0];\\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            bought = Math.min(bought, prices[i] - profit);\\n            profit = Math.max(profit,prices[i] - bought - fee);\\n        }\\n        \\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763745,
                "title": "c-recursion-memoization-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[50005][2];\\n    int solve(vector<int>& prices, int fee, int idx, int buy){\\n        if(idx >= prices.size()) return 0;\\n        \\n        // if i know the result of this state i will simply use that\\n        if(dp[idx][buy] != -1) return dp[idx][buy];\\n        \\n        // i will have two options either to do nothing or to do something(buy/sell)\\n        \\n        int op1 = INT_MIN, op2 = INT_MIN;\\n        \\n        //option 1 -> to do nothing\\n        \\n        op1 = solve(prices, fee, idx + 1, buy);\\n        \\n        //option 2 -> to buy or sell\\n        \\n        // if i already bought some stock than i have to sell this\\n        // because we cannot engage in multiple transactions\\n        if(buy){\\n            op2 = prices[idx] - fee + solve(prices, fee, idx + 1, 0);\\n        }\\n        \\n        // else we haven\\'t bought anything so we can buy a stock \\n        else{\\n              op2 = -prices[idx] + solve(prices, fee, idx + 1, 1);\\n        }\\n        \\n        return dp[idx][buy] = max(op1, op2);\\n    \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(prices, fee, 0, 0);   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[50005][2];\\n    int solve(vector<int>& prices, int fee, int idx, int buy){\\n        if(idx >= prices.size()) return 0;\\n        \\n        // if i know the result of this state i will simply use that\\n        if(dp[idx][buy] != -1) return dp[idx][buy];\\n        \\n        // i will have two options either to do nothing or to do something(buy/sell)\\n        \\n        int op1 = INT_MIN, op2 = INT_MIN;\\n        \\n        //option 1 -> to do nothing\\n        \\n        op1 = solve(prices, fee, idx + 1, buy);\\n        \\n        //option 2 -> to buy or sell\\n        \\n        // if i already bought some stock than i have to sell this\\n        // because we cannot engage in multiple transactions\\n        if(buy){\\n            op2 = prices[idx] - fee + solve(prices, fee, idx + 1, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1761029,
                "title": "simple-code",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int>& prices,bool canbuy, vector<vector<int>>&dp,int fee){\\n \\n         if(ind>=prices.size())\\n             return 0;\\n\\n         if(dp[ind][canbuy]!=-1)return dp[ind][canbuy];\\n    \\n         if(canbuy){\\n           int buy=f(ind+1,prices,!canbuy,dp,fee)-prices[ind];//like we buy so subtract the price from proft and make canbuy false\\n           int hold=f(ind+1,prices,canbuy,dp,fee);\\n           dp[ind][canbuy]=max(buy,hold);\\n         }\\n        else{\\n          int sell=f(ind+1,prices,!canbuy,dp,fee)+prices[ind]-fee;\\n          int hold=f(ind+1,prices,canbuy,dp,fee);\\n           dp[ind][canbuy]=max(sell,hold);\\n        }\\n     return dp[ind][canbuy];\\n}\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        return f(0,prices,1,dp,fee);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int f(int ind,vector<int>& prices,bool canbuy, vector<vector<int>>&dp,int fee){\\n \\n         if(ind>=prices.size())\\n             return 0;\\n\\n         if(dp[ind][canbuy]!=-1)return dp[ind][canbuy];\\n    \\n         if(canbuy){\\n           int buy=f(ind+1,prices,!canbuy,dp,fee)-prices[ind];//like we buy so subtract the price from proft and make canbuy false\\n           int hold=f(ind+1,prices,canbuy,dp,fee);\\n           dp[ind][canbuy]=max(buy,hold);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1718727,
                "title": "easy-most-simple-4-line-answer-c",
                "content": "if we want to buy on a particular day then we will have to pay prices[i] so our balance would be sell that we have done on last day - price of stock on current day.\\nThus to decide wether to buy today or not we check wether our balance will increase if we buy today. \\nThus we are doing => **max(buy, sell-nums[i]);**\\n\\nif we want to sell today we would like to sell such that our balance will increase.\\nThus we are doing **max(sell, buy+x-fee);**\\nHere **sell** is previous days selling profit and **buy+nums[i]-fee** is profit if we sell today.\\n\\n```\\nint maxProfit(vector<int>& prices, int fee) {\\n        int buy = -prices[0], sell = 0;\\n        for(auto x: prices) {\\n            buy = max(buy, sell-x);\\n            sell = max(sell, buy+x-fee);\\n        }\\n        return sell;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices, int fee) {\\n        int buy = -prices[0], sell = 0;\\n        for(auto x: prices) {\\n            buy = max(buy, sell-x);\\n            sell = max(sell, buy+x-fee);\\n        }\\n        return sell;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713859,
                "title": "c-o-n-time-and-o-1-space-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int buy=-prices[0]-fee,sell=0;\\n        for(int i=1;i<prices.size();i++){\\n            int temp=buy;\\n            buy=max(buy,sell-fee-prices[i]);\\n            sell=max(temp+prices[i],sell);\\n        }\\n        return sell;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int buy=-prices[0]-fee,sell=0;\\n        for(int i=1;i<prices.size();i++){\\n            int temp=buy;\\n            buy=max(buy,sell-fee-prices[i]);\\n            sell=max(temp+prices[i],sell);\\n        }\\n        return sell;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685834,
                "title": "kotlin-easy-fast-solution",
                "content": "```\\nfun maxProfit(prices: IntArray, fee: Int): Int {\\n        var buy = Int.MIN_VALUE\\n        var sell = 0\\n        for (price in prices) {\\n            buy = maxOf(buy, sell - price)\\n            sell = maxOf(sell, price + buy - fee)\\n        }\\n\\n        return sell\\n    }",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nfun maxProfit(prices: IntArray, fee: Int): Int {\\n        var buy = Int.MIN_VALUE\\n        var sell = 0\\n        for (price in prices) {\\n            buy = maxOf(buy, sell - price)\\n            sell = maxOf(sell, price + buy - fee)\\n        }\\n\\n        return sell\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1670483,
                "title": "c-top-down-dp-memoization",
                "content": "The idea is simple basically\\nIf we buy at a index then we can sell or skip on the next index if we sell we bear transation fee but we skip we can still sell and skip int next to next index\\nIf we sell at a index then we can only buy or skip on the next index so on and so forth \\n\\n![image](https://assets.leetcode.com/users/images/2d168532-e6eb-49c9-a6f6-2849551621f1_1641463311.8270044.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[50001][2];\\n    int solve(vector<int> &prices , int i , bool buy , int &fee){\\n        \\n        if(i == prices.size()) return 0;\\n        if(dp[i][buy] != -1) return dp[i][buy];\\n        if(buy){\\n            return dp[i][buy] = max(solve(prices , i+1 , false , fee)-prices[i] , solve(prices , i+1 , buy , fee));\\n        }\\n        else{\\n            return dp[i][buy] = max(solve(prices , i+1 , true , fee)+prices[i]-fee , solve(prices , i+1 , buy ,fee));\\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(prices , 0 , true , fee);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[50001][2];\\n    int solve(vector<int> &prices , int i , bool buy , int &fee){\\n        \\n        if(i == prices.size()) return 0;\\n        if(dp[i][buy] != -1) return dp[i][buy];\\n        if(buy){\\n            return dp[i][buy] = max(solve(prices , i+1 , false , fee)-prices[i] , solve(prices , i+1 , buy , fee));\\n        }\\n        else{\\n            return dp[i][buy] = max(solve(prices , i+1 , true , fee)+prices[i]-fee , solve(prices , i+1 , buy ,fee));\\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices, int fee) {\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(prices , 0 , true , fee);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669018,
                "title": "simple-o-n-one-pass-approach-using-state-machine",
                "content": "Inspired from: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking)\\n\\nIt\\'s very unique way to think about problems like this. If we are able to make state machine like this, it becomes very easy to implement in code and we can visualise it as well.\\n\\n![image](https://assets.leetcode.com/users/images/58bacba9-592e-4a35-8e59-db52e4b80157_1641402467.333787.png)\\n\\n```\\ns0 = max(s0, s1 - prices[i] ) //buy stock at current index or keep using previous \\ns1 = max(s1, prevS0+prices[i]- fee) //sell stock at current index or rest\\n```\\n\\nComplete solution\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        s0, s1 = -prices[0], 0\\n        ans = 0\\n        for i in range(1, len(prices)):\\n            prevS0 = s0\\n            s0 = max(s0, s1 - prices[i] )\\n            s1 = max(s1, prevS0+prices[i]- fee)\\n        return s1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ns0 = max(s0, s1 - prices[i] ) //buy stock at current index or keep using previous \\ns1 = max(s1, prevS0+prices[i]- fee) //sell stock at current index or rest\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        s0, s1 = -prices[0], 0\\n        ans = 0\\n        for i in range(1, len(prices)):\\n            prevS0 = s0\\n            s0 = max(s0, s1 - prices[i] )\\n            s1 = max(s1, prevS0+prices[i]- fee)\\n        return s1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656786,
                "title": "javascript-clean-dp-solution-with-comments",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} fee\\n * @return {number}\\n */\\nvar maxProfit = function(prices, fee) {\\n    let dp = Array(prices.length).fill().map(v=>Array(2).fill(-1));\\n    \\n    const traverse = (index, isHeld) =>{\\n        if(index >= prices.length) return 0;\\n        if(dp[index][isHeld] !== -1) return dp[index][isHeld];\\n        \\n        let profit = 0;\\n        //IF ALREADY HOLDING STOCK\\n        if(isHeld){\\n            \\n            //KEEP HOLDING IT\\n            profit = Math.max(profit, traverse(index + 1, 1));\\n            \\n            //SELL IF PRICE IS LOW THAN PROFIT\\n            profit = Math.max(profit, prices[index] - fee + traverse(index + 1, 0));\\n        }else{\\n            \\n            //DONT BUY\\n            profit = Math.max(profit, traverse(index + 1, 0));\\n            \\n            //BUY\\n            profit = Math.max(profit, traverse(index + 1, 1) - prices[index]);\\n        }\\n        dp[index][isHeld] = profit;\\n        return profit;\\n    }\\n    \\n    return traverse(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} fee\\n * @return {number}\\n */\\nvar maxProfit = function(prices, fee) {\\n    let dp = Array(prices.length).fill().map(v=>Array(2).fill(-1));\\n    \\n    const traverse = (index, isHeld) =>{\\n        if(index >= prices.length) return 0;\\n        if(dp[index][isHeld] !== -1) return dp[index][isHeld];\\n        \\n        let profit = 0;\\n        //IF ALREADY HOLDING STOCK\\n        if(isHeld){\\n            \\n            //KEEP HOLDING IT\\n            profit = Math.max(profit, traverse(index + 1, 1));\\n            \\n            //SELL IF PRICE IS LOW THAN PROFIT\\n            profit = Math.max(profit, prices[index] - fee + traverse(index + 1, 0));\\n        }else{\\n            \\n            //DONT BUY\\n            profit = Math.max(profit, traverse(index + 1, 0));\\n            \\n            //BUY\\n            profit = Math.max(profit, traverse(index + 1, 1) - prices[index]);\\n        }\\n        dp[index][isHeld] = profit;\\n        return profit;\\n    }\\n    \\n    return traverse(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565758,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1567333,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939683,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1799969,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1570369,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939428,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1788175,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939763,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939521,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939169,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1565758,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1567333,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939683,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1799969,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1570369,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939428,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1788175,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939763,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939521,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939169,
                "content": [
                    {
                        "username": "toplanzi",
                        "content": "Why don\\'t we consider the transaction fee both when buying an selling? This is what it is in the real world."
                    },
                    {
                        "username": "user0467H",
                        "content": "Glad that you have seen it that way . .the problem wrongly worded."
                    },
                    {
                        "username": "sanyam0410",
                        "content": "And what about the fee for opening a demat account.....haha dumb leetcode"
                    },
                    {
                        "username": "N1qro",
                        "content": "[@EternalStuden1](/EternalStuden1) What about broker commission?"
                    },
                    {
                        "username": "EternalStuden1",
                        "content": "When you buy a stock the seller pays transaction fee, that should helps you figure it out :)"
                    },
                    {
                        "username": "coder_inside",
                        "content": "buy + sell = 1 transaction , hence fee is considered 1 time"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n"
                    },
                    {
                        "username": "mloupe",
                        "content": "are they modeling capital gains tax?"
                    },
                    {
                        "username": "sohilg002",
                        "content": "Exactly, I had the same doubt. They should re-phrase the question. It\\'s not clear."
                    },
                    {
                        "username": "souvikd_pro",
                        "content": "[@AlecLC](/AlecLC) I was scratching my head why my answer is not correct. I was considering fee both the time. :("
                    },
                    {
                        "username": "TheHesoyam",
                        "content": "totally agree on it"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. Both selling and buying are transactions. If they wanted a selling fee, they should have said <b>selling fee</b>, not transaction fee. "
                    },
                    {
                        "username": "Brooky",
                        "content": "I am kind of confused. From the description, it sounds that we pay fee both at buying and selling. But the exmaple show we only pay fee once for \"buy then sell\". Am I the only one got confused?"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AlecLC](/AlecLC) You are still right. It just worded nonsensically. Its ridiculous to call both buying and selling on different days a single transaction. Call the fee a \"sales fee\" and that solves it\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "The problem description is simply <span style='color:red'>wrong</span>. It implies that both selling and buying are transactions (\"can't do multiple transactions simultaneously\") and states that there is a transaction fee. No, there is a selling fee (or a buying fee). The problem needs to be updated.\n\nEdit: upon rereading the description, that last line does seem to imply that a \"transaction\" is both buying and selling a stock. They should just state that rather than confusing everybody"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "Hint is even harder to understand than the problem itself."
                    },
                    {
                        "username": "elmubark",
                        "content": "Please re-word this question. It\\'s a selling fee not a transaction fee. Leetcode is riddled with questions that are artificially made more confusing through poor wording."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@divy_kant](/divy_kant) If you go to the grocery store and buy an apple, the transaction is complete. If at a later point in time you sell that apple, this is another separate transaction. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine."
                    },
                    {
                        "username": "ByteBeats",
                        "content": "My brain is twisted every time recursion problem occurs."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "is there is anyone who doest not understood the example second or is it only me"
                    },
                    {
                        "username": "__himanshu26",
                        "content": "[@liebrynth](/liebrynth) sweetie is (1-10)"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "Hey, just check this solution. It is the simplest and shortest solution available on lc :\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3669304/gpt-4-0-3-lines-greedy-solution-best-in-the-market/"
                    },
                    {
                        "username": "am14",
                        "content": "(10-1)-fee=6"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "We can buy on the 1-st day and sell on 5-th, so (10 - 1) - 3 =6"
                    },
                    {
                        "username": "liebrynth",
                        "content": "same"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>One transaction = both buying and selling</span>\n\nI was confused about this, because I thought transaction meant either buying or selling, but you should only take out the fee while selling (or you could do it buying)"
                    },
                    {
                        "username": "divy_kant",
                        "content": "actually if you will apply fee on both buying and selling then you will give the fee 2 times , but we have to pay only when a transaction is complete so either you can give it while buying a stock or while selling it , both works fine.\\n\\n"
                    },
                    {
                        "username": "rebooter",
                        "content": "Starting my coding journey from today on LeetCode.\nI'm excited to dive into LeetCode and discover the joy of coding challenges..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "welcome aboard :)"
                    },
                    {
                        "username": "fendrick_ar",
                        "content": "welcome bro!!!!"
                    },
                    {
                        "username": "rebooter",
                        "content": "Successfully completed today\\'s daily coding challenge without any hesitation on my first day here."
                    },
                    {
                        "username": "rebooter",
                        "content": "Thank's [@course321explorer](/course321explorer). By the way, I'm here on LeetCode for revision purposes. I have already tackled numerous coding questions on various platforms."
                    },
                    {
                        "username": "course321explorer",
                        "content": "Good luck on your coding journey! Enjoy exploring Leetcode and have fun solving challenges. It\\'s a fantastic platform to enhance your coding skills. Happy Coding!"
                    },
                    {
                        "username": "manohar_yadav",
                        "content": "explanation of the second example of this question\\n((10-1)-3)\\n=6\\nhere selling price=10\\nbuying price=1\\ntransaction fee=3"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No bro, the fees is for individual buy/sell combination. So, you\\'ll need to pay fees for both.\\n\\nHence, for your example, it would be : (7 - 1 - 3) + (10 - 5 - 3) = 5 which is less than (10 - 1 - 3) = 6."
                    },
                    {
                        "username": "Violet-",
                        "content": "[@ujjawal_OP](/ujjawal_OP) No, 7-1-3+10-5-3=5"
                    },
                    {
                        "username": "kertia",
                        "content": "[@ujjawal_OP](/ujjawal_OP) those are 2 complete transactions based on the description, so you need to pay the transaction fee 2 times"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Greedy to solve  stock problems.\nJust a hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "bhruti1",
                        "content": "[@paresh_singh](/paresh_singh) for second test case the transaction done is buy on prices[0]=1 and sell on prices[4]=10 so the profit is 10-1=9 minus the transaction fees for one transaction which is 3 so the total profit is 9-3=6."
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@EricRaw](/EricRaw) wow, totally missed that. Thanks"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@paresh_singh](/paresh_singh) buy at prices[0] = 1 and sell at prices[4] = 10. profit 10 - 1 - 3 = 6"
                    },
                    {
                        "username": "paresh_singh",
                        "content": "[@JustinAdams](/JustinAdams) isn\\'t the second case wrong? total profit is 11 and fee is 3*2=6. So the profit is 5 and not 6. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@JustinAdams](/JustinAdams) hint: sell = max(sell, prices[i] - fee- buy)"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Greedy doesn\\'t pass the second test case"
                    }
                ]
            },
            {
                "id": 1939241,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1939860,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1939699,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1727655,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1940125,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1939831,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1939746,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1939397,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 1939180,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 2053377,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Follow-up:\nDescribe a winning strategy for the case where new prices are coming in a ongoing stream, and you cannot backtrack and take a different action.\n\n*..Please?..*"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "While the question was asked in jest, if we take it seriously, [passive investing](https://www.investopedia.com/terms/p/passiveinvesting.asp) is probably the best answer, although it only works in the long run."
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "I think the last solution I did in this article could help you with that. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "that\\'s the holy grail question"
                    },
                    {
                        "username": "tifv",
                        "content": "\\u201CCannot backtrack\\u201D sounds a little vague for me. I would rather ask \\u201CSolve the problem with only one iteration though the `prices` array and with $O(1)$ extra memory.\\u201D."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Why are we still on this platform if we knew how to solve that?"
                    },
                    {
                        "username": "devle79",
                        "content": "Time limit exceeded two day straight. maybe I\\'m not ready for this... "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont understand 2nd test case like why the profit is 6 (10-1-3) shouldn\\'t we be considering 7-1 =6 plus 10-5 = 5 minus 3 = 8 ???"
                    },
                    {
                        "username": "yenting-biao",
                        "content": "You have to pay the transaction fee in each transaction(selling), so it would be (7-1-3)+(10-5-3)=3+2=5, which is not optimal."
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37\\uD83D\\uDE37We traverse through the array to find the profits if we buy or sell in each day.\\nOn the first day we cannot sell the stock so we initialze the old selling state profit(ossp)=0 and the old buying state profit(obsp)=-prices[0];\\nNow we traverse every single day and check whether we should buy,sell or hold according to the following conditions :\\n\\ni . if the cost of buying in a day after the old state of selling profit(ossp-prices[i]) is less then the old buying state.\\nii . if the profit after selling following the old buying state is more than the previous selling state profit.\\nUPVOTE IF YOU FIND IT HELPFUL.\\n"
                    },
                    {
                        "username": "jerrymano",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Sergei_Vladimirovich",
                        "content": "Description is unclear. There should be note that you can not make your i-day decision relying on future days (i + 1 .. n), only past ones. Because if you do, there can be (and they are) more profitable solutions."
                    },
                    {
                        "username": "san_gularity",
                        "content": "Ever since i started leetcoding, i have never cracked a recursion or dynamic programming problem. Albeit I haven\\'t tried that many. Just wanted to ask fellow coders if they had the same problem and how they overcame it. Anything deeper to know other than practice practice practice? Thank you"
                    },
                    {
                        "username": "er245hdfvs",
                        "content": "https://youtu.be/oBt53YbR9Kk\\n\\nThere have been a great amount of videos that are actively teaching me DP, but this tutorial is the most comprehensive to me thus far. The creator uses key techniques like drawing out recursion trees to illustrate how, why, and when DP is an effective strategy for solving a problem.\\n\\nI\\'m still working on my DP skills, too. Here are a few things I\\'ve noticed so far:\\n\\n- You NEED to understand recursion and how it\\'s used to help you solve your problem.\\n- It greatly helps to draw out recursion trees. You\\'ll see optimal substructures and overlapping subproblems this way. \\n- You need to see the brute force recursive solution before using DP to optimize your solution.\\n- Solving DP problems via recursive brute force is often the hardest step for me. The biggest hurdle for me is usually finding the proper recurrence relation. Caching (and therefore doing DP optimizations) is a much easier time than finding the recurrence relation.\\n- Doing LC\\'s Dynamic Programming Study Guide in order is a great way to stay motivated and continually run into problems that will help you exercise your DP muscle (https://leetcode.com/studyplan/dynamic-programming/)\\n- Breaks are necessary. DP is a dense topic that can be mentally fatiguing when you\\'re first learning it. You should prioritize taking breaks after learning your first few problems so that your brain can digest this information.\\n- Don\\'t give up! It\\'s very satisfying to come back and see how far you\\'ve come w.r.t. one of algo\\'s trickiest subjects. Leetcode is awesome at gamifying your learning experience. Be sure to find ways that you can reward yourself.\\n\\nWishing you the best, I believe in us!!"
                    },
                    {
                        "username": "harshawasthi90",
                        "content": "I struggle a lot with DP questions as well. \n\n\"(I am not if the following will help or not)\"\n\nI was about to give up, but before giving up I check out the Related Topics section where it mentioned DP as the tag.\n\nSo I thought of giving it another try, before looking hints and solutions,\n\nAnd I was able to do this one in 1st go.\n\nAnd the reason was,\nI did put all my effort in thinking about the DP states, without writing any code.\n\nJust think about,\nIf you are in buy state, what are your options,\nIf you are in sell state what are your options,\n\nHere's my initial solution, with the same though process. (I am yet to check the optimal solution.)\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/977158374/"
                    },
                    {
                        "username": "SashaKuzin",
                        "content": "I afraid this will be not very useful answer, but I had some breakthrough in DP after one of the lectures I saw in internet. And this is pretty good approach for me: check about 10-20 videos and articles, get one drop here and one drop there and finally complete picture or (if I am lucky enough) find some material that is very understandable exactly for me."
                    },
                    {
                        "username": "santanusen",
                        "content": "Found it quite difficult to solve."
                    },
                    {
                        "username": "Tarun5848",
                        "content": "for example 2 : output is 6 but if we see it manually it is different case\\nprices = [1,3,7,5,10,3], fee=3\\nbuying at prices[0] = 1\\nselling at prices[2] = 7\\nbuying at prices[3] = 5\\nselling at prices[4] = 10\\n\\nso total profit is ((7-1)-3)) + ((10-5) - 3)  = 3+2 = 5\\nbut output is showing 6\\nis it right approach or of not can anyone please suggest the explaination.."
                    },
                    {
                        "username": "Isha307",
                        "content": "We need the maximum profit so we\\'ll choose\\nbuying at prices[0] = 1\\nselling at prices [4] = 10\\nso total profit is (10-1)-3 = 6"
                    },
                    {
                        "username": "Nitin456",
                        "content": "buy at 1 and sell at 10. Net profit = 10-1-3 = 6 "
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "re-submit XD"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "[@Aabshar](/Aabshar) That\\'s just how it goes..."
                    },
                    {
                        "username": "Aabshar",
                        "content": ":) history repeats itself"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem must be definitely marked as hard."
                    }
                ]
            },
            {
                "id": 2048932,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1994314,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1941091,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1940358,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1940006,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1939950,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1939898,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1939722,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1939698,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1939687,
                "content": [
                    {
                        "username": "ericzeng95",
                        "content": "The description is obviously wrong.\\n"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091729690066862080-8KeK?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "Leul_lo",
                        "content": "The hint is quite helpful.\\n"
                    },
                    {
                        "username": "rianrbps",
                        "content": "So, the transaction fee corresponds to buying *and* selling, and not buying *or* selling? This is kind of misleading, the question would be way harder if there was no Explanation about it in the Examples."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "What would be the approach to solve if \\n1. holding and buying more was possible\\n2. simultaneous transaction was possible\\n\\nCan someone explain?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> if holding and buying more was possible\n\nThe task would boil down to:\n1. Find `maxPrice` among all prices\n2. Buy everything in front of it that is cheap enough to get a profit from the sale, i.e. such stocks that `maxPrice - price > fee`\n3. Sell all you've got at `maxPrice`\n4. Repeat steps 1-3 for a sub-array of everything following `maxPrice`\n\n\n>  if simultaneous transaction was possible\n\nNothing would change, as it's pointless to buy and sell at the same price, you just wasting money on fee."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "This is different from any Dynamic programming question that I\\'ve done before. Also I\\'ve done like around 50 dp questions; this tells the question\\'s really got something"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Input: prices = [1,3,2,8,4,9], fee = 2,Output: 8\\nWhat about Buying At 1 and selling at 8 \\nand Buying at 2 and selling at 9?"
                    },
                    {
                        "username": "umutmazkorkcan",
                        "content": "you got to sell before you buy again in order to complete a transaction"
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "How do we find number of transactions.\\nBecause in case 2 we can perform many transactions so that we can get the answer more than 6"
                    },
                    {
                        "username": "tifv",
                        "content": "The problem statement says \\u201CYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\u201D."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "****Space optimization: ****\\n\\nInitialize variables:\\n\\nn = size of prices\\ndp = [0, 0] (vector of two elements)\\ntemp = [0, 0] (vector of two elements)\\nIterate through the prices in reverse order, from index n-1 to 0:\\na. For each iteration, do the following:\\n\\nIterate over two possible states: buy (1) or not buy (0)\\n\\nFor each state, do the following:\\nIf the state is \"buy\" (1):\\nCalculate the maximum profit by choosing between buying the stock at the current price and the maximum profit\\nfrom the previous state (not buying):\\ntemp[1] = max(-prices[i] + dp[0], dp[1])\\nOtherwise, if the state is \"not buy\" (0):\\nCalculate the maximum profit by choosing between not buying the stock (no change in profit) and\\nselling the stock at the current price minus the transaction fee, plus the maximum profit from the previous state (buy):\\ntemp[0] = max(prices[i] - fee + dp[1], dp[0])\\nAssign the values of temp to dp for the next iteration: dp = temp\\n\\nReturn the maximum profit, which is stored in dp[1]\\n----------------------------------------\\nComplexity\\nTime complexity:\\n**1. recursive index,buy t.c=exponential\\n2. memoization t.c=O(n*2)\\n3. tabulation t.c=O(n*2)\\n4. Space optimization t.c=O(n*2)**\\n------------------------------------------\\nSpace complexity:\\n**1. recursive s.c=O(n)\\n2. memoization s.c=O(n*2) + O(n) stack space\\n3. tabulation s.c=O(n*2)\\n4. Space optimization s.c=O(2*2)**\\n\\n---------------------------\\nPlease Upvote If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668984/c-dp-solution-recursive-memoization-tabulation-space-optimaization/"
                    },
                    {
                        "username": "PinkiePieYay2707",
                        "content": "If your code outputs less profits than it should, please check if you\\'re applying the transaction fee twice. The description is worded incorrectly, the fee is only applied when selling or buying, but not both."
                    }
                ]
            },
            {
                "id": 1939553,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939493,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939436,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939351,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939337,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939313,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939239,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939217,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1939212,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            },
            {
                "id": 1918631,
                "content": [
                    {
                        "username": "idnedvryaasnein",
                        "content": "Idk, but most of the time I get more confused after reading the hint(s). \\uD83D\\uDE15"
                    },
                    {
                        "username": "bose_aritra2003",
                        "content": "For detailed explanation visit: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668244/detailed-explanation-fastest-cakewalk-solution-for-everyone/"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**This series of problems is awesome**"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Transaction fee should be applied to either buy or sell part of a transaction, but not both."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remember the first time when I encounter the problem, it is absolutely a terrible day. Once I know how to process with fee and buy price, another two hard problems can be solved: \n\n123. Best Time to Buy and Sell Stock III\n188. Best Time to Buy and Sell Stock IV\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "READING the question on one go made me think it\\'s very tough but with time i understood it is similar to BUY AND SELL STOCKS II. we just have to deduce the fee"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "There are only two states to consider, one is `STOCK is on hold` another is `STOCK is sold`, keep updating both states based on the current `price`. And the final answer will be given by the state in which `STOCK is sold`."
                    },
                    {
                        "username": "ivzap",
                        "content": "What helps ya\\'ll see the sub-problems in problems like these? "
                    },
                    {
                        "username": "realones",
                        "content": "Merge Interval Method, not sure why 26\\'s testcase failed, can anyone take a look and help? thanks!\\n\\nusing ii=pair<int,int>;\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n=prices.size();\\n        if(n<=1) return 0;\\n\\n        //get inc intervals\\n        vector<ii> intervals;\\n        for(int l=0,r=0;r<n&&r<n;l=r+1,r=l){\\n            while (r+1<n && prices[r+1]>prices[r]) r++;\\n            if(prices[r]>prices[l]) intervals.push_back({prices[l],prices[r]}); \\n        }\\n        \\n        //merge intervals\\n        for(int i=0;i<intervals.size()-1;){//check with next\\n            auto& [curS, curE] = intervals[i];\\n            auto& [nxtS, nxtE] = intervals[i+1];\\n            int curGain=curE-curS-fee;\\n            int nxtGain=nxtE-nxtS-fee;\\n            int totalGain=nxtE-curS-fee;\\n            if(totalGain > curGain + nxtGain){\\n                curE=nxtE;\\n                intervals.erase(intervals.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n\\n        //calcu res\\n        int res=0;\\n        for(auto [l,r]: intervals){\\n            if(r-l>fee) res+=r-l-fee;\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "tifv",
                        "content": "A general approach to large failing testcases: you can copy the testcase and remove some values from the start or from the end of the array to see if the failure persists. Repeat until the failing testcase becomes minimal, at which point it is usually manageable."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is a slightly smaller testcase that fails your code: `prices = [3,4,2,8,6,7,1,4,3,5,2,8]`, `fee = 5`. Hope it helps to fix the bug :)\n(Also, your solution seems to be $O(n^2)$, where $n = \\mathrm{prices}.\\mathrm{length}$ because `vector::erase` moves all the tailing values of the vector in memory. I wouldn't be surprised if you will encounter timeouts in further testcasesif you manage to make the solution correct.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "can I buy and sell at the same day?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "[@Shaw_Wesley](/Shaw_Wesley) Negative profit due to the fee."
                    },
                    {
                        "username": "Shaw_Wesley",
                        "content": "isnt your profit is 0 if you do that ?, so i think it\\'s meaningless"
                    }
                ]
            }
        ]
    }
]