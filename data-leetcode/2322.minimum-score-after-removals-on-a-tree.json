[
    {
        "title": "Minimum Score After Removals on a Tree",
        "question_content": "There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nRemove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n\tGet the XOR of all the values of the nodes for each of the three components respectively.\n\tThe difference between the largest XOR value and the smallest XOR value is the score of the pair.\n\n\tFor example, say the three components have the node values: [4,5,7], [1,9], and [3,3,3]. The three XOR values are 4 ^ 5 ^ 7 = 6, 1 ^ 9 = 8, and 3 ^ 3 ^ 3 = 3. The largest XOR value is 8 and the smallest XOR value is 3. The score is then 8 - 3 = 5.\n\nReturn the minimum score of any possible pair of edge removals on the given tree.\n&nbsp;\nExample 1:\n\nInput: nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]\nOutput: 9\nExplanation: The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1.\n- The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\nExample 2:\n\nInput: nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]\nOutput: 0\nExplanation: The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.\n- The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.\n- The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t3 <= n <= 1000\n\t1 <= nums[i] <= 108\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tedges represents a valid tree.",
        "solutions": [
            {
                "id": 2198665,
                "title": "python-3-explanation-with-pictures",
                "content": "\\n\\nFor each node `i`, we store the **XOR** value of the subtree **rooted** at `i`, let\\'s call the XOR value as `v_i`. \\nApparently, the XOR value of a leaf node is just itself, since there is no other node in the subtree rooted at it.\\n\\n![image](https://assets.leetcode.com/users/images/c7aaba3e-f780-472b-a7e9-e63d67eec778_1656218239.4267566.png)\\n\\nFor node 3 `(n3)`, since it has 2 children: node `1` and `2`, thus the XOR value of node 3 is `v3 = n1^n2^n3`, so on so forth, we can iterate over the nodes and get all such XOR values. \\n\\n![image](https://assets.leetcode.com/users/images/fb6397c0-d896-42e0-99a8-90f0e029fba8_1656218243.0575893.png)\\n\\nNow we got all the XOR values, we need to cut the whole tree into three parts as described.\\n\\\\\\nAssume the first cut is between node `a, b`, the second cut is between `c, d`, without loss of generality, let `a, c` be the lower nodes (`b` be the parent of `a` and `d` be the parent of `c`). \\n\\\\\\nWe can tell that there are 3 cases:\\n\\n- Two subtrees are \\'independent\\'.\\n- Node c under node a\\n- Node a under node c.\\n\\n(The values of the three parts are shown under the tree)\\n\\n![image](https://assets.leetcode.com/users/images/c4ed407e-cc51-4ba0-b553-99bdc36a5c58_1656218246.7365239.png)\\n\\nThus we just need to iterate over all edge pairs and calculate the minimum score among them.\\n\\n\\n- Time Complexity: `O(n^2)`, iteration over all edge pairs.\\n- Space Complexity: `O(n^2)`, the collection of children of each node `C` take `O(n^2)` space in the worst case scenario.\\n\\nFor `DFS` solution, you might also refer to @chestnut890123 \\'s solution in the comment.\\n\\n\\n**python**\\n```\\n class Solution:\\n    def minimumScore(self, N: List[int], E: List[List[int]]) -> int:\\n        n, m = len(N), len(E)\\n        \\n        G = collections.defaultdict(list)  # Graph\\n        C = collections.defaultdict(set)   # Children\\n        A = N[:]                  # subtree XOR value\\n        degree = [0] * n        # degree of each node \\n\\n        for x, y in E:\\n            G[x].append(y)\\n            G[y].append(x)\\n            degree[x] += 1\\n            degree[y] += 1\\n        \\n        V = 0   # XOR of all the nodes\\n        \\n        seen = set()\\n        dq = collections.deque()\\n        for i in range(n):\\n            V ^= N[i]\\n            if degree[i] == 1:\\n                dq.append(i)\\n                seen.add(i)\\n                \\n        # BFS, starting from the leaf nodes     \\n        while dq:\\n            cur = dq.popleft()\\n            for nxt in G[cur]:\\n                if nxt not in seen:  # \\'nxt is not in seen\\' means that node \\'nxt\\' is the parent of node \\'cur\\'.\\n                    C[nxt].add(cur)   # Update node \\'nxt\\'\\'s children by adding all the children of \\'cur\\' and \\'cur\\' itself.\\n                    C[nxt] |= C[cur]\\n                    A[nxt] ^= A[cur]   # Update the XOR value of node \\'nxt\\'\\n                degree[nxt] -= 1\\n                if degree[nxt] == 1:\\n                    seen.add(nxt)         # Only add a node into queue when it has no leaf nodes.\\n                    dq.append(nxt)\\n\\t\\t\\t\\t\\t\\n        ans = math.inf\\n        for i in range(m - 1):\\n            for j in range(i + 1, m):\\n                # Let a, c be the lower break points\\n                a, b = E[i]\\n                if b in C[a]: a, b = b, a \\n                \\n                c, d = E[j]\\n                if d in C[c]: c, d = d, c\\n                \\n                # 3 cases: c is a\\'s child, a is c\\'s child, or a and b are two independent subtrees.\\n                if c in C[a]:\\n                    cur = [A[c], A[a]^A[c], V^A[a]]\\n                elif a in C[c]:\\n                    cur = [A[a], A[c]^A[a], V^A[c]]\\n                else:\\n                    cur = [A[a], A[c], V^A[a]^A[c]]\\n                ans = min(ans, max(cur) - min(cur))\\n            \\n        return ans\\n```            \\n",
                "solutionTags": [],
                "code": "```\\n class Solution:\\n    def minimumScore(self, N: List[int], E: List[List[int]]) -> int:\\n        n, m = len(N), len(E)\\n        \\n        G = collections.defaultdict(list)  # Graph\\n        C = collections.defaultdict(set)   # Children\\n        A = N[:]                  # subtree XOR value\\n        degree = [0] * n        # degree of each node \\n\\n        for x, y in E:\\n            G[x].append(y)\\n            G[y].append(x)\\n            degree[x] += 1\\n            degree[y] += 1\\n        \\n        V = 0   # XOR of all the nodes\\n        \\n        seen = set()\\n        dq = collections.deque()\\n        for i in range(n):\\n            V ^= N[i]\\n            if degree[i] == 1:\\n                dq.append(i)\\n                seen.add(i)\\n                \\n        # BFS, starting from the leaf nodes     \\n        while dq:\\n            cur = dq.popleft()\\n            for nxt in G[cur]:\\n                if nxt not in seen:  # \\'nxt is not in seen\\' means that node \\'nxt\\' is the parent of node \\'cur\\'.\\n                    C[nxt].add(cur)   # Update node \\'nxt\\'\\'s children by adding all the children of \\'cur\\' and \\'cur\\' itself.\\n                    C[nxt] |= C[cur]\\n                    A[nxt] ^= A[cur]   # Update the XOR value of node \\'nxt\\'\\n                degree[nxt] -= 1\\n                if degree[nxt] == 1:\\n                    seen.add(nxt)         # Only add a node into queue when it has no leaf nodes.\\n                    dq.append(nxt)\\n\\t\\t\\t\\t\\t\\n        ans = math.inf\\n        for i in range(m - 1):\\n            for j in range(i + 1, m):\\n                # Let a, c be the lower break points\\n                a, b = E[i]\\n                if b in C[a]: a, b = b, a \\n                \\n                c, d = E[j]\\n                if d in C[c]: c, d = d, c\\n                \\n                # 3 cases: c is a\\'s child, a is c\\'s child, or a and b are two independent subtrees.\\n                if c in C[a]:\\n                    cur = [A[c], A[a]^A[c], V^A[a]]\\n                elif a in C[c]:\\n                    cur = [A[a], A[c]^A[a], V^A[c]]\\n                else:\\n                    cur = [A[a], A[c], V^A[a]^A[c]]\\n                ans = min(ans, max(cur) - min(cur))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198534,
                "title": "simple-dfs",
                "content": "**Approach**\\n\\nMath and a lil bit DP\\na xor a = 0\\n0 xor a = a\\n\\n**Remove any two edge pair and find the xors of the rest three group of nodes from the tree after removing these edges and then find the min of the required expression**\\n\\n* DFS on the tree and recurcively store the xor of the node below or at this node as child_xor\\n* Add the parent child pair in this dfs\\n* now make two loops for removing every two edge permutation and find the three xors of subsection\\n* If you remove an edge the tree will devide in two parts, you can find the seperate xors by the properties of xor that is, a xor a = 0 and 0 xor a = a .\\n* Suppose a is a node which is a ansestor of b ans a1, a2, a3, .. an is the nodes between a and b and b have childs b1, b2, b3, .. bn, you can find the xor of childs of a after removing b as child_xor[a] xor child_xor[b].\\n* Explaination of above step child_xor[a] = a ^ a1 ^ a2 ^ .... a^n ^ b ^ b1 ^ b2 ^ ... ^ bn, chid_xor[b] = b ^ b1 ^ b2 ^ ... ^ bn. So now child_xor[a] xor child_xor[b] = (a ^ a1 ^ a2 ^ .... a^n ^ b ^ b1 ^ b2 ^ ... ^ bn) ^ (b ^ b1 ^ b2 ^ ... ^ bn), now all the same xors will be 0 and 0 xor any number is any number therefor child_xor[a] xor child_xor[b] = a ^ a1 ^ a2 ^ .... a^n, this is xors of all the node except b and its childrens.\\n* To find if a node is a child of node b I\\'ve also maintained a boolian 2D array name childs to store that a is a child of b\\n\\n**Time and Space complexity**\\n\\n* Time Compexity is O(E^2), V is number of vertex or node and E is number of edges which will be V - 1 so Over all complexity will be O(V^2) = O(n^2) and also DFS will have a complexity of O(V^2 + E) due to parent traversal! still Overall complexity will be O(V^2) = O(n^2)\\n* Space Complexity O(n^2) for parent child boolean array, O(n) for storing child_xors and O(n) for DFS call stack so Overall complexity will be O(n^2)\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\n    vector<bool> visited;\\n    vector<vector<int>> pc, adj; // pc is the parent child edge in our dfs\\n    vector<vector<bool>> childs; // 2D array to store that i is a parent of j\\n    vector<int> child_xor, nums, par; // child_xor to store result of xors of a child node and par is a gloable array to track the parents of a node in dfs\\n    \\n    int dfs(int i) {\\n        int ans = nums[i];\\n        visited[i] = true;\\n\\t\\t\\n\\t\\tfor (int p: par) childs[p][i] = true; // Defining this node as the child of all its parents\\n\\t\\t\\n        par.push_back(i);\\n        \\n        for (int child: adj[i])\\n            if (!visited[child]) {\\n                pc.push_back({i, child});\\n                ans ^= dfs(child); // Recurcively calculating xors\\n            }\\n        \\n        par.pop_back();\\n        \\n        return child_xor[i] = ans;\\n    }\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n\\t\\t// Initialising gloable variables\\n        int n = nums.size(), ans = INT_MAX;\\n        visited = vector<bool>(n);\\n        pc = vector<vector<int>>();\\n        adj = vector<vector<int>>(n);\\n        child_xor = vector<int>(n, 0);\\n        childs = vector<vector<bool>>(n, vector<bool>(n, false));\\n        this->nums = nums;\\n\\t\\tpar = vector<int>();\\n\\t\\t\\n\\t\\t// Creating an adjacency matrix\\n        for (vector<int> &edge: edges) adj[edge[0]].push_back(edge[1]), adj[edge[1]].push_back(edge[0]);\\n\\t\\t\\n        dfs(0);\\n        \\n        for (int i = 0; i < pc.size(); i++)\\n            for (int j = i + 1; j < pc.size(); j++) { // removing an edge i and j\\n                int a = pc[i][1], b = pc[j][1]; // node that will come below when you delete an edge i and j\\n                int xa = child_xor[a], xb = child_xor[b], xc = child_xor[0];\\n                \\n                if (childs[a][b])\\n                    xc ^= xa, xa ^= xb;\\n                else\\n                    xc ^= xa, xc ^= xb;\\n                \\n                ans = min(max(xa, max(xb, xc)) - min(xa, min(xb, xc)), ans);\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python Code**\\n\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        visited = [False for _ in range(n)]\\n        pc = [] # Store the parent child edge node in our dfs\\n        adj = [[] for _ in range(n)]\\n        \\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n        \\n        childs = [[False for _ in range(n)] for _ in range(n)] # To store if node a contains b as on of its child tree\\n        child_xor = [0 for _ in range(n)] # To store the xor of node a and all its child tree\\n        par = [] to store parents of a node a while doing DFS\\n        \\n        def dfs(i: int) -> int:\\n            ans = nums[i]\\n            visited[i] = True\\n            \\n            for p in par: childs[p][i] = True\\n                \\n            par.append(i)\\n            \\n            for child in adj[i]:\\n                if (not visited[child]):\\n                    pc.append([i, child])\\n                    ans ^= dfs(child)\\n            \\n            par.pop()\\n            child_xor[i] = ans\\n            \\n            return ans\\n        \\n        dfs(0)\\n        \\n        ans = 1000000000\\n        \\n        for i in range(len(pc)):\\n            for j in range(i + 1, len(pc)):\\n                (a, b) = (pc[i][1], pc[j][1])\\n\\t\\t\\t\\t(xa, xb, xc) = (child_xor[a], child_xor[b], child_xor[0])\\n                \\n                if childs[a][b]: # here a is an ancestor of b or a has b in its child tree\\n                    xc ^= xa\\n                    xa ^= xb\\n                else:\\n                    xc ^= xa\\n                    xc ^= xb\\n                \\n                ans = min(max(xa, xb, xc) - min(xa, xb, xc), ans)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<bool> visited;\\n    vector<vector<int>> pc, adj; // pc is the parent child edge in our dfs\\n    vector<vector<bool>> childs; // 2D array to store that i is a parent of j\\n    vector<int> child_xor, nums, par; // child_xor to store result of xors of a child node and par is a gloable array to track the parents of a node in dfs\\n    \\n    int dfs(int i) {\\n        int ans = nums[i];\\n        visited[i] = true;\\n\\t\\t\\n\\t\\tfor (int p: par) childs[p][i] = true; // Defining this node as the child of all its parents\\n\\t\\t\\n        par.push_back(i);\\n        \\n        for (int child: adj[i])\\n            if (!visited[child]) {\\n                pc.push_back({i, child});\\n                ans ^= dfs(child); // Recurcively calculating xors\\n            }\\n        \\n        par.pop_back();\\n        \\n        return child_xor[i] = ans;\\n    }\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n\\t\\t// Initialising gloable variables\\n        int n = nums.size(), ans = INT_MAX;\\n        visited = vector<bool>(n);\\n        pc = vector<vector<int>>();\\n        adj = vector<vector<int>>(n);\\n        child_xor = vector<int>(n, 0);\\n        childs = vector<vector<bool>>(n, vector<bool>(n, false));\\n        this->nums = nums;\\n\\t\\tpar = vector<int>();\\n\\t\\t\\n\\t\\t// Creating an adjacency matrix\\n        for (vector<int> &edge: edges) adj[edge[0]].push_back(edge[1]), adj[edge[1]].push_back(edge[0]);\\n\\t\\t\\n        dfs(0);\\n        \\n        for (int i = 0; i < pc.size(); i++)\\n            for (int j = i + 1; j < pc.size(); j++) { // removing an edge i and j\\n                int a = pc[i][1], b = pc[j][1]; // node that will come below when you delete an edge i and j\\n                int xa = child_xor[a], xb = child_xor[b], xc = child_xor[0];\\n                \\n                if (childs[a][b])\\n                    xc ^= xa, xa ^= xb;\\n                else\\n                    xc ^= xa, xc ^= xb;\\n                \\n                ans = min(max(xa, max(xb, xc)) - min(xa, min(xb, xc)), ans);\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        visited = [False for _ in range(n)]\\n        pc = [] # Store the parent child edge node in our dfs\\n        adj = [[] for _ in range(n)]\\n        \\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n        \\n        childs = [[False for _ in range(n)] for _ in range(n)] # To store if node a contains b as on of its child tree\\n        child_xor = [0 for _ in range(n)] # To store the xor of node a and all its child tree\\n        par = [] to store parents of a node a while doing DFS\\n        \\n        def dfs(i: int) -> int:\\n            ans = nums[i]\\n            visited[i] = True\\n            \\n            for p in par: childs[p][i] = True\\n                \\n            par.append(i)\\n            \\n            for child in adj[i]:\\n                if (not visited[child]):\\n                    pc.append([i, child])\\n                    ans ^= dfs(child)\\n            \\n            par.pop()\\n            child_xor[i] = ans\\n            \\n            return ans\\n        \\n        dfs(0)\\n        \\n        ans = 1000000000\\n        \\n        for i in range(len(pc)):\\n            for j in range(i + 1, len(pc)):\\n                (a, b) = (pc[i][1], pc[j][1])\\n\\t\\t\\t\\t(xa, xb, xc) = (child_xor[a], child_xor[b], child_xor[0])\\n                \\n                if childs[a][b]: # here a is an ancestor of b or a has b in its child tree\\n                    xc ^= xa\\n                    xa ^= xb\\n                else:\\n                    xc ^= xa\\n                    xc ^= xb\\n                \\n                ans = min(max(xa, xb, xc) - min(xa, xb, xc), ans)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198204,
                "title": "using-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    unordered_set<int> v[1002];\\n    bool vis[1002];\\n\\n    int ans = INT_MAX, comp_1, comp_2, comp_3;\\n\\n    int dfs(int i, vector<int> &a)\\n    {\\n        int curr = a[i];\\n\\n        vis[i] = true;\\n\\n        for (auto x : v[i])\\n        {\\n            if (!vis[x])\\n            {\\n                curr = curr ^ dfs(x, a);\\n            }\\n        }\\n\\n        return curr;\\n    }\\n\\n    int dfs1(int i, int j, vector<int> &a)\\n    {\\n        vis[i] = true;\\n\\n        int curr = a[i];\\n\\n        for (auto x : v[i])\\n        {\\n            if (!vis[x])\\n            {\\n                int res = dfs1(x, j, a);\\n\\n                comp_2 = res;\\n                comp_3 = j ^ res;\\n\\n                ans = min(ans, max(comp_1, max(comp_2, comp_3)) - min(comp_1, min(comp_2, comp_3)));\\n\\n                curr = curr ^ res;\\n            }\\n        }\\n\\n        return curr;\\n    }\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n\\n        for (auto x : edges)\\n        {\\n            v[x[0]].insert(x[1]);\\n            v[x[1]].insert(x[0]);\\n        }\\n\\n        int val = 0;\\n\\n        for (auto x : nums)\\n        {\\n            val = val ^ x;\\n        }\\n\\n        ans = INT_MAX;\\n\\n        for (auto x : edges)\\n        {\\n            v[x[0]].erase(x[1]);\\n            v[x[1]].erase(x[0]);\\n\\n            for (int i = 0; i <= nums.size(); i++)\\n            {\\n                vis[i] = false;\\n            }\\n\\n            comp_1 = dfs(0, nums);\\n\\n            int pos;\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                if (!vis[i])\\n                {\\n                    pos = i;\\n                    dfs1(i, comp_1 ^ val, nums);\\n                }\\n            }\\n\\n            for (int i = 0; i <= nums.size(); i++)\\n            {\\n                vis[i] = false;\\n            }\\n\\n            comp_1 = dfs(pos, nums);\\n\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                if (!vis[i])\\n                {\\n                    dfs1(i, comp_1 ^ val, nums);\\n                }\\n            }\\n\\n            v[x[0]].insert(x[1]);\\n            v[x[1]].insert(x[0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nIf any query please ask in comments.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_set<int> v[1002];\\n    bool vis[1002];\\n\\n    int ans = INT_MAX, comp_1, comp_2, comp_3;\\n\\n    int dfs(int i, vector<int> &a)\\n    {\\n        int curr = a[i];\\n\\n        vis[i] = true;\\n\\n        for (auto x : v[i])\\n        {\\n            if (!vis[x])\\n            {\\n                curr = curr ^ dfs(x, a);\\n            }\\n        }\\n\\n        return curr;\\n    }\\n\\n    int dfs1(int i, int j, vector<int> &a)\\n    {\\n        vis[i] = true;\\n\\n        int curr = a[i];\\n\\n        for (auto x : v[i])\\n        {\\n            if (!vis[x])\\n            {\\n                int res = dfs1(x, j, a);\\n\\n                comp_2 = res;\\n                comp_3 = j ^ res;\\n\\n                ans = min(ans, max(comp_1, max(comp_2, comp_3)) - min(comp_1, min(comp_2, comp_3)));\\n\\n                curr = curr ^ res;\\n            }\\n        }\\n\\n        return curr;\\n    }\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n\\n        for (auto x : edges)\\n        {\\n            v[x[0]].insert(x[1]);\\n            v[x[1]].insert(x[0]);\\n        }\\n\\n        int val = 0;\\n\\n        for (auto x : nums)\\n        {\\n            val = val ^ x;\\n        }\\n\\n        ans = INT_MAX;\\n\\n        for (auto x : edges)\\n        {\\n            v[x[0]].erase(x[1]);\\n            v[x[1]].erase(x[0]);\\n\\n            for (int i = 0; i <= nums.size(); i++)\\n            {\\n                vis[i] = false;\\n            }\\n\\n            comp_1 = dfs(0, nums);\\n\\n            int pos;\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                if (!vis[i])\\n                {\\n                    pos = i;\\n                    dfs1(i, comp_1 ^ val, nums);\\n                }\\n            }\\n\\n            for (int i = 0; i <= nums.size(); i++)\\n            {\\n                vis[i] = false;\\n            }\\n\\n            comp_1 = dfs(pos, nums);\\n\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                if (!vis[i])\\n                {\\n                    dfs1(i, comp_1 ^ val, nums);\\n                }\\n            }\\n\\n            v[x[0]].insert(x[1]);\\n            v[x[1]].insert(x[0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202551,
                "title": "two-loops",
                "content": "The two loops idea is simple: pick one edge, pick another edge, and compute the score of 3 segments of the tree.\\n\\nThe implementation, especially an efficient one, is quite tricky. In the solution below, we assign ids to edges in a way that tells us whether one edge is in the same subtree as another.\\n\\n1. From a node (can be any node), do DFS and compute XOR.\\n\\t- As we traverse the tree, we assign incrementing ids to edges.\\n\\t- Memoise XOR of a subtree starting from each edge in `dp`.\\n\\t- Also, remember id of the `last` child in a subtree that starts from the current edge.\\n2. In the end, `dp` and `last` arrays are populated, and we get XOR of the entire tree (`all`).\\n\\n> Initially, I thought that we need to do DFS from a leaf, but it works if you do it from any node.\\n\\nFinally, we iterate through each pair of edges. To correctly compute XOR of each segment, we check if the second edge (with larger id) is in the same subtree as the first one. For that, we use information in the `last` array.\\n- `i` and `j` are in the same subree: `all ^ dp[i]` | `dp[i] ^ dp[j]` | `dp[j]`.\\n- `i` and `j` are in different subrees: `all ^ dp[i] ^ dp[j]` | `dp[i]` | `dp[j]`.\\n\\n**C++**\\n```cpp\\nint dp[1000] = {}, last[1000] = {};\\nint dfs(vector<int>& n, vector<vector<int>> &al, int i, int p, int &ids) {\\n    int res = n[i];\\n    for (auto j : al[i])\\n        if (j != p) {\\n            int id = ids++;\\n            dp[id] = dfs(n, al, j, i, ids);\\n            last[id] = ids;\\n            res ^= dp[id];\\n        }\\n    return res;    \\n}\\nint minimumScore(vector<int>& n, vector<vector<int>>& edges) {\\n    int ids = 0, res = INT_MAX;\\n    vector<vector<int>> al(n.size());\\n    for (auto &e :  edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int all = dfs(n, al, 0, -1, ids);    \\n    for (int i = 0; i < edges.size(); ++i)\\n        for (int j = i + 1; j < edges.size(); ++j) {\\n            int p1 = j < last[i] ? all ^ dp[i] : all ^ dp[i] ^ dp[j];\\n            int p2 = j < last[i] ? dp[i] ^ dp[j] : dp[i];\\n            res = min(res, max({p1, p2, dp[j]}) - min({p1, p2, dp[j]}));\\n        }\\n    return res;\\n}\\n```\\nWe can also memoise XOR for nodes, not edges. Each edge connects to a node, so it\\'s pretty much the same.\\n\\n**C++**\\n```cpp\\nint dp[1000] = {}, last[1000] = {};\\nint dfs(vector<int>& n, vector<vector<int>> &al, int i, int p, int &ids) {\\n    int id = ids++, res = n[i];\\n    for (auto j : al[i])\\n        if (j != p)\\n            res ^= dfs(n, al, j, i, ids);\\n    last[id] = ids;\\n    return dp[id] = res;    \\n}\\nint minimumScore(vector<int>& n, vector<vector<int>>& edges) {\\n    int ids = 0, res = INT_MAX;\\n    vector<vector<int>> al(n.size());\\n    for (auto &e :  edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int all = dfs(n, al, 0, -1, ids);    \\n    for (int i = 1; i < n.size(); ++i)\\n        for (int j = i + 1; j < n.size(); ++j) {\\n            int p1 = j < last[i] ? all ^ dp[i] : all ^ dp[i] ^ dp[j];\\n            int p2 = j < last[i] ? dp[i] ^ dp[j] : dp[i];\\n            res = min(res, max({p1, p2, dp[j]}) - min({p1, p2, dp[j]}));\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[1000] = {}, last[1000] = {};\\nint dfs(vector<int>& n, vector<vector<int>> &al, int i, int p, int &ids) {\\n    int res = n[i];\\n    for (auto j : al[i])\\n        if (j != p) {\\n            int id = ids++;\\n            dp[id] = dfs(n, al, j, i, ids);\\n            last[id] = ids;\\n            res ^= dp[id];\\n        }\\n    return res;    \\n}\\nint minimumScore(vector<int>& n, vector<vector<int>>& edges) {\\n    int ids = 0, res = INT_MAX;\\n    vector<vector<int>> al(n.size());\\n    for (auto &e :  edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int all = dfs(n, al, 0, -1, ids);    \\n    for (int i = 0; i < edges.size(); ++i)\\n        for (int j = i + 1; j < edges.size(); ++j) {\\n            int p1 = j < last[i] ? all ^ dp[i] : all ^ dp[i] ^ dp[j];\\n            int p2 = j < last[i] ? dp[i] ^ dp[j] : dp[i];\\n            res = min(res, max({p1, p2, dp[j]}) - min({p1, p2, dp[j]}));\\n        }\\n    return res;\\n}\\n```\n```cpp\\nint dp[1000] = {}, last[1000] = {};\\nint dfs(vector<int>& n, vector<vector<int>> &al, int i, int p, int &ids) {\\n    int id = ids++, res = n[i];\\n    for (auto j : al[i])\\n        if (j != p)\\n            res ^= dfs(n, al, j, i, ids);\\n    last[id] = ids;\\n    return dp[id] = res;    \\n}\\nint minimumScore(vector<int>& n, vector<vector<int>>& edges) {\\n    int ids = 0, res = INT_MAX;\\n    vector<vector<int>> al(n.size());\\n    for (auto &e :  edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int all = dfs(n, al, 0, -1, ids);    \\n    for (int i = 1; i < n.size(); ++i)\\n        for (int j = i + 1; j < n.size(); ++j) {\\n            int p1 = j < last[i] ? all ^ dp[i] : all ^ dp[i] ^ dp[j];\\n            int p2 = j < last[i] ? dp[i] ^ dp[j] : dp[i];\\n            res = min(res, max({p1, p2, dp[j]}) - min({p1, p2, dp[j]}));\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198125,
                "title": "python-o-n-2-iterate-two-edges-with-caching",
                "content": "For every edge (x, y), we iterate another edge either from the x (left) part or the y (right) part.\\n\\nThe `get_xors_of_subtree` function returns all `XOR` values of all subtrees of a given tree. \\n\\n\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        find = defaultdict(list)\\n        for x, y in edges:\\n            find[x].append(y)\\n            find[y].append(x)\\n\\n        @cache\\n        def get_xors_of_subtree(root, prev):\\n            res = []\\n            val = nums[root]\\n            for y in find[root]:\\n                if y != prev:\\n                    tmp = get_xors_of_subtree(y, root)\\n                    res.extend(tmp)\\n                    val ^= tmp[-1]\\n            res.append(val)\\n            return res\\n\\n        res = math.inf\\n        for x, y in edges:\\n            left_xors = get_xors_of_subtree(x, y)\\n            right_xors = get_xors_of_subtree(y, x)\\n            left_val = left_xors[-1]\\n            right_val = right_xors[-1]\\n            for l1 in left_xors[:-1]:\\n                l2 = left_val ^ l1\\n                res = min(res, max(l1, l2, right_val) - min(l1, l2, right_val))\\n            for r1 in right_xors[:-1]:\\n                r2 = right_val ^ r1\\n                res = min(res, max(r1, r2, left_val) - min(r1, r2, left_val))\\n\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        find = defaultdict(list)\\n        for x, y in edges:\\n            find[x].append(y)\\n            find[y].append(x)\\n\\n        @cache\\n        def get_xors_of_subtree(root, prev):\\n            res = []\\n            val = nums[root]\\n            for y in find[root]:\\n                if y != prev:\\n                    tmp = get_xors_of_subtree(y, root)\\n                    res.extend(tmp)\\n                    val ^= tmp[-1]\\n            res.append(val)\\n            return res\\n\\n        res = math.inf\\n        for x, y in edges:\\n            left_xors = get_xors_of_subtree(x, y)\\n            right_xors = get_xors_of_subtree(y, x)\\n            left_val = left_xors[-1]\\n            right_val = right_xors[-1]\\n            for l1 in left_xors[:-1]:\\n                l2 = left_val ^ l1\\n                res = min(res, max(l1, l2, right_val) - min(l1, l2, right_val))\\n            for r1 in right_xors[:-1]:\\n                r2 = right_val ^ r1\\n                res = min(res, max(r1, r2, left_val) - min(r1, r2, left_val))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199703,
                "title": "simple-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[1005];\\n    int dp[1005],dp1[1005];\\n    int help(vector<int>& nums,int node,int par){\\n        int tmp=nums[node];\\n        int f=0;\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n                f=1;\\n                tmp^=help(nums,x,node);\\n            }\\n        }\\n        return dp[node]=tmp;\\n    }\\n\\t\\n\\t\\n    int help1(vector<int>& nums,int node,int par){\\n        int tmp=nums[node];\\n        int f=0;\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n                f=1;\\n                tmp^=help1(nums,x,node);\\n            }\\n        }\\n        return dp1[node]=tmp;\\n    }\\n\\t\\n\\t//function to find second optimal edge breaking in first component\\n\\t\\n    void fn1(vector<int>& nums,int node,vector<int>& vis,int f,int f1,int f2,int& mn){\\n        vis[node]=1;\\n        for(auto x:adj[node]){\\n            if(vis[x]==0 && x!=f){\\n                //cout<<\"Second edge: \"<<node<<\" \"<<x<<\"\\\\n\";\\n                int z1=f1^dp1[x];\\n                int z2=dp1[x];\\n                int mx=max({z1,z2,f2});\\n                int mn1=min({z1,z2,f2});\\n                mn=min(mx-mn1,mn);\\n                fn1(nums,x,vis,f,f1,f2,mn);\\n            }\\n        }  \\n    }\\n\\t\\n\\t//function to find second optimal edge breaking in second component\\n\\t\\n    void fn2(vector<int>& nums,int node,int par,int f1,int f2,int& mn){\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n                int z1=f2^dp[x];\\n                int z2=dp[x];\\n                int mx=max({z1,z2,f1});\\n                int mn1=min({z1,z2,f1});\\n                mn=min(mx-mn1,mn);\\n                fn2(nums,x,node,f1,f2,mn);\\n            }\\n        } \\n    }\\n\\t\\n\\t//function to break first edge\\n\\t\\n    void fn(vector<int>& nums,int node,int par,int& ans,int tot){\\n        int tmp=nums[node];\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n                //cout<<\"First edge: \"<<node<<\" \"<<x<<\"\\\\n\";\\n                int f1=tot^dp[x];\\n                int f2=dp[x];\\n                int mn=INT_MAX;\\n                vector<int> vis(nums.size(),0);\\n                help1(nums,node,-1);       //storing each subtree\\'s xor in dp1 by making node as root \\n                fn1(nums,node,vis,x,f1,f2,mn);\\n                fn2(nums,x,node,f1,f2,mn);\\n                ans=min(ans,mn);\\n                fn(nums,x,node,ans,tot);\\n            }\\n        }\\n        \\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(int i=0;i<nums.size();i++){\\n            adj[i].clear();\\n        }\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int tot=0;\\n        for(auto x:nums){\\n            tot^=x;\\n        }\\n        int n=nums.size();\\n        help(nums,0,-1);    //storing each subtree\\'s xor in dp array\\n        int ans=INT_MAX;\\n        fn(nums,0,-1,ans,tot);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> adj[1005];\\n    int dp[1005],dp1[1005];\\n    int help(vector<int>& nums,int node,int par){\\n        int tmp=nums[node];\\n        int f=0;\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n                f=1;\\n                tmp^=help(nums,x,node);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2199343,
                "title": "c-solution-o-n-2",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int ans=1e9,xo=0,time=0;\\n    void dfs(int node, int par, vector<vector<int>>& adj, vector<int>& nums, vector<int>& sub, vector<int>& in, vector<int>& out)\\n    {\\n        in[node]=time++;\\n        sub[node]=nums[node];\\n        for(auto child: adj[node])\\n        {\\n            if(child==par) continue;\\n            dfs(child,node,adj,nums,sub,in,out);\\n            sub[node]^=sub[child];\\n        }\\n        out[node]=time++;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges)\\n    {\\n        int n=nums.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            xo^=nums[i];\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> sub(n,0),in(n),out(n);\\n        dfs(0,0,adj,nums,sub,in,out);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(i==j) continue;\\n                else if(in[i]<in[j] && out[i]>out[j])\\n                {\\n                    int x=sub[j];\\n                    int y=sub[i]^sub[j];\\n                    int z=xo^sub[i];\\n                    int mn=min(x,min(y,z)),mx=max(x,max(y,z));\\n                    ans=min(ans,mx-mn);\\n                }\\n                else if(in[i]>in[j] && out[i]<out[j])\\n                {\\n                    int x=sub[i];\\n                    int y=sub[i]^sub[j];\\n                    int z=xo^sub[j];\\n                    int mn=min(x,min(y,z)),mx=max(x,max(y,z));\\n                    ans=min(ans,mx-mn);\\n                }\\n                else \\n                {\\n                    int x=sub[i];\\n                    int y=sub[j];\\n                    int z=xo^sub[i]^sub[j];\\n                    int mn=min(x,min(y,z)),mx=max(x,max(y,z));\\n                    ans=min(ans,mx-mn);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=1e9,xo=0,time=0;\\n    void dfs(int node, int par, vector<vector<int>>& adj, vector<int>& nums, vector<int>& sub, vector<int>& in, vector<int>& out)\\n    {\\n        in[node]=time++;\\n        sub[node]=nums[node];\\n        for(auto child: adj[node])\\n        {\\n            if(child==par) continue;\\n            dfs(child,node,adj,nums,sub,in,out);\\n            sub[node]^=sub[child];\\n        }\\n        out[node]=time++;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges)\\n    {\\n        int n=nums.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            xo^=nums[i];\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> sub(n,0),in(n),out(n);\\n        dfs(0,0,adj,nums,sub,in,out);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(i==j) continue;\\n                else if(in[i]<in[j] && out[i]>out[j])\\n                {\\n                    int x=sub[j];\\n                    int y=sub[i]^sub[j];\\n                    int z=xo^sub[i];\\n                    int mn=min(x,min(y,z)),mx=max(x,max(y,z));\\n                    ans=min(ans,mx-mn);\\n                }\\n                else if(in[i]>in[j] && out[i]<out[j])\\n                {\\n                    int x=sub[i];\\n                    int y=sub[i]^sub[j];\\n                    int z=xo^sub[j];\\n                    int mn=min(x,min(y,z)),mx=max(x,max(y,z));\\n                    ans=min(ans,mx-mn);\\n                }\\n                else \\n                {\\n                    int x=sub[i];\\n                    int y=sub[j];\\n                    int z=xo^sub[i]^sub[j];\\n                    int mn=min(x,min(y,z)),mx=max(x,max(y,z));\\n                    ans=min(ans,mx-mn);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199740,
                "title": "python-one-pass-dfs-hashset-easy-to-understand-with-pics",
                "content": "- hint 0: though there is no explicit root given in the undirected graph, you can pick anyone as the root (e.g., node #0), then specify the order to construct and traverse the tree.\\n- hint 1: treat XOR as some kind of `+` operator, both of them are invertible, commutive, and associative:  if `a + b = c`, we can get `a` by `c - b`; similarly, if we have already known `a XOR b = c` we can get `a = c XOR b`. Thus, we only need to specify two components in the tree then we can quickly calculate the XOR value of the rest part by `XOR` operation like above.\\n-  hint 2: so how to determine the first removed edge and split the tree into two components? As I have no idea how to cut the tree to make the score as min as possible, I may enumerate all possible splits. For the first cut, just choose an edge arbitarily. Remember that we have specified the order of the tree by selecting a node as root, so the cut must occur on a `parent -> child` edge, that is, it removes a subtree rooted at `child` from its `parent` node. For example, in the picture below, I chose to cut the edge between parent 13 and child 5, and I got a new subtree rooted at node 5.\\n\\n![image](https://assets.leetcode.com/users/images/e4e510f1-fcfb-4a50-bc2b-ab7427ce3598_1656295369.1061661.png)\\n\\n\\n- hint 3: Then it\\'s time to decide which part to be split further, the subtree rooted at 5 or the rest of the whole tree?\\n\\t- If you choose the rest of the tree, for example, cut the edge 13->2 or 11->4, you will get new subtrees rooted at those nodes (2 or 4). In this case, you only need to calculate the XOR values of the two subtrees, rooted at 5 and 2 (or 4), assume they are `sub1` and `sub2`, as you can calculate the XOR of the whole tree as `s`, the XOR value of the rest part is calculated by `s XOR sub1 XOR sub2`. The score of this case is `max(sub1,sub2,s XOR sub1 XOR sub2) - min(sub1,sub2,s XOR sub1 XOR sub2)`\\n\\t- If you choose to split the subtree rooted at 5 further, for example, you choose to cut down the edge between 5 and 6, you get a new subtree rooted at 6. We denote the XOR of the subtree rooted at 5 as `sub1` and the one rooted at 6 as `sub2`. We can easily calculate the XOR of `subtree 5` minus `subtree 6` as `sub1 XOR sub2`, while the rest part of whole tree is `s XOR sub1`, which is still the XOR value of the whole tree as well. So the score is written as `max(sub2,sub1 XOR sub2, s XOR sub1)-min(sub2,sub1 XOR sub2, s XOR sub1)`.\\n\\nFine. It looks possible to enumerate all splits if we first fix the first cut by a  DFS to choose a node as the current root of a subtree and the calculate the XOR value `sub1` of this subtree, which can also be performed by a post-order DFS (similar to the sum of all subtrees in  ab inary-tree problem, see [LC508](https://leetcode.com/problems/most-frequent-subtree-sum/)). But how to enumerate the second cut? Take a look at how to distinguish the two cases above:\\n\\n![image](https://assets.leetcode.com/users/images/f01ab241-abc8-464c-a998-d7a940c851d2_1656295382.1757061.png)\\n\\n\\n- If the second root node is a descendant (i.e., in the subtree) of the first-cut root node, it must form a smaller sub-subtree, which belongs to the second case discussed above, and is highlighted in purple in the pic above. Those nodes can be easily listed out by a post-order DFS from current (first-cut) root node.\\n- If the second root node is not a descendant or ancestor of the first-cut root node, it can split a new subtree independent from the first subtree. But how to find them out?\\n\\t- Let\\'s take a pre-order DFS. All nodes visited in other branches different from our current nodes satisfy the requirement. We can record their XOR values of subtrees rooted at them in a container such as a HashSet. When we traverse node 5, we take all `sub2` from that set and `sub1` of node 5 to calculate the score. Those nodes are highlighted in red in the pic above.\\n\\t- For those unvisited ones in green in the pic, when we traverse them and set them as the current roots, the XOR value of `subtree 5` is already put into the set. We only need to treat it as `sub1` and take the XOR value of `subtree 5` to calculate the score.\\n\\nI use `dfs(root, parent, others)` to implement the idea in my code: `root` is the current root node of the subtree, and `parent` is its parent node to avoid re-visiting, `others` is the set to maintain XOR values of all visited subtree independent from the current root (their root nodes are in red in pics). I also update `others` branch by branch after traversing every child node and make nodes in those subtrees as one part of `others` to nodes rooted in their siblings. The function returns both the XOR value of the subtree rooted at `root` and a list of all XOR values of sub-subtrees in current subtrees and updates `self.res` for every possible split during reversal.\\n\\n```py\\nfrom functools import reduce\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        s = reduce(lambda x,y:x^y, nums)\\n        adj = defaultdict(list)\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        self.res = float(\\'inf\\')\\n        \\n        def calc_res(a,b,c):\\n            return max(a,b,c) - min(a,b,c)\\n        \\n        def dfs(root,parent,others):\\n            subtrees = set()\\n            cur = nums[root]\\n            for i in adj[root]:\\n                if i!=parent:\\n                    v, children = dfs(i,root,others|subtrees)\\n                    subtrees |= children\\n                    cur ^= v\\n\\t\\t\\t\\n            for other in others:\\n                self.res = min(self.res,calc_res(cur,i,s^cur^other))\\n            if parent!=-1:\\n                for child in subtrees:\\n                    self.res = min(self.res,calc_res(cur^child,s^cur,child))\\n            subtrees.add(cur)\\n            return cur,subtrees\\n        \\n        dfs(0,-1,set())\\n        \\n        return self.res\\n```\\n\\nTime complexity: `O(n^2)`, although we reduce the DFS to only once, for each node, the size of `others+subtrees` is still `O(n)`.  \\nSpace complexity: `O(n)`\\n\\nSorry for plenty of typos, perhaps. I feel so sleepy now.",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```py\\nfrom functools import reduce\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        s = reduce(lambda x,y:x^y, nums)\\n        adj = defaultdict(list)\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        self.res = float(\\'inf\\')\\n        \\n        def calc_res(a,b,c):\\n            return max(a,b,c) - min(a,b,c)\\n        \\n        def dfs(root,parent,others):\\n            subtrees = set()\\n            cur = nums[root]\\n            for i in adj[root]:\\n                if i!=parent:\\n                    v, children = dfs(i,root,others|subtrees)\\n                    subtrees |= children\\n                    cur ^= v\\n\\t\\t\\t\\n            for other in others:\\n                self.res = min(self.res,calc_res(cur,i,s^cur^other))\\n            if parent!=-1:\\n                for child in subtrees:\\n                    self.res = min(self.res,calc_res(cur^child,s^cur,child))\\n            subtrees.add(cur)\\n            return cur,subtrees\\n        \\n        dfs(0,-1,set())\\n        \\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198171,
                "title": "c-solution-with-2-dfs",
                "content": "Upvote please if you find this solution helpful, if not leave a comment :)\\n```\\nclass Solution {\\n    int dp[1005];//for each node i such that  0< i <n dp[i] stores the value of the xor for the subtree strats from i \\n    vector<int>adj[1005];// this is adjacency list \\n    int ans=1e9;//here is the answer will be stored\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto it:edges){//build the adjacency list\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<nums.size();++i)dp[i]=nums[i];//initially the value of the dp[i] is the value of the root (which is i)\\n        dfs(0,-1);//build dp[i] to store the value of the xor for each subtree\\n        int n=nums.size();\\n        for(int i=1;i<n;++i){\\n            dfs2(0,-1,i,0);//define a cut on the node i (this is the predefined node) (remove the edge that goas to node i\\n        }\\n        return ans;\\n    }\\n    int dfs2(int node,int par,int n,bool ok){\\n        ok|=node==n;//check wheather the path from 1 to the current node pathed through the predifined node\\n        int ret=node==n;//to store if the subtree starts from node has the predefined node as a child or not\\n        for(int nxt:adj[node]){\\n            if(par==nxt)continue;\\n            ret|=dfs2(nxt,node,n,ok);\\n        }\\n        if(!ret&&node!=0&&node!=n){//if the current node is not the first node and it\\'s node the predifind node and the subtree starts from node doesn\\'t have the predifined node as a child then we can cut the tree here\\n            int x1=dp[0]^dp[n]^dp[node];\\n            int x2=dp[n];\\n            int x3=dp[node];\\n            if(ok)\\n                x1^=dp[node],x2^=dp[node];//if we pathed through the predefined node ,then we xored the value of this subtree twice so we need to add it\\n            ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n        }\\n        return ret;\\n    }\\n    int dfs(int node,int par){\\n        for(int nxt:adj[node]){\\n            if(par==nxt)continue;\\n            dp[node]^=dfs(nxt,node);\\n        }\\n        return dp[node];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1005];//for each node i such that  0< i <n dp[i] stores the value of the xor for the subtree strats from i \\n    vector<int>adj[1005];// this is adjacency list \\n    int ans=1e9;//here is the answer will be stored\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto it:edges){//build the adjacency list\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<nums.size();++i)dp[i]=nums[i];//initially the value of the dp[i] is the value of the root (which is i)\\n        dfs(0,-1);//build dp[i] to store the value of the xor for each subtree\\n        int n=nums.size();\\n        for(int i=1;i<n;++i){\\n            dfs2(0,-1,i,0);//define a cut on the node i (this is the predefined node) (remove the edge that goas to node i\\n        }\\n        return ans;\\n    }\\n    int dfs2(int node,int par,int n,bool ok){\\n        ok|=node==n;//check wheather the path from 1 to the current node pathed through the predifined node\\n        int ret=node==n;//to store if the subtree starts from node has the predefined node as a child or not\\n        for(int nxt:adj[node]){\\n            if(par==nxt)continue;\\n            ret|=dfs2(nxt,node,n,ok);\\n        }\\n        if(!ret&&node!=0&&node!=n){//if the current node is not the first node and it\\'s node the predifind node and the subtree starts from node doesn\\'t have the predifined node as a child then we can cut the tree here\\n            int x1=dp[0]^dp[n]^dp[node];\\n            int x2=dp[n];\\n            int x3=dp[node];\\n            if(ok)\\n                x1^=dp[node],x2^=dp[node];//if we pathed through the predefined node ,then we xored the value of this subtree twice so we need to add it\\n            ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n        }\\n        return ret;\\n    }\\n    int dfs(int node,int par){\\n        for(int nxt:adj[node]){\\n            if(par==nxt)continue;\\n            dp[node]^=dfs(nxt,node);\\n        }\\n        return dp[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200046,
                "title": "java-and-c-simple-solution-using-dfs-twice-o-n-2",
                "content": "This is a tricky but simple problem.\\nWe will do simply what the problem says, i.e., **try and remove each and every combination of the two edges** because the constraints are quite low.\\n**First we\\'ll find the XOR of the entire tree by simply calultaing XOR of all the values.**\\nThen while traversing the tree, along **with calculating the XOR of the subtree, we will try and remove each edge.\\nWhile doing this we will get the XOR of the subtree that we clipped, let it be XOR1.**\\nThen we after cutting this edge, we will use another DFS from the root after **blocking** the first edge that we cut, to cut yet another subtree with the same approach as above. \\n**We will get XOR of the second subtree say, XOR2.**\\n**Then the XOR of the remaing portion of the tree will be TOTAL_XOR ^ XOR1 ^ XOR2.** Then we can calculate what the problem asks us to calulate, i.e., minimum difference bw the maximum and the minimum XOR. \\n\\nJava Code :\\n```\\nclass Solution {\\n    \\n    private int ans = Integer.MAX_VALUE;\\n\\n    private int helper(int src, ArrayList<Integer>[] graph, int[] arr, int par, int block, int xor1, int tot) { // function to travel 2nd time on the tree and find the second edge to be removed\\n\\t\\n        int myXOR = arr[src];   // Setting the value for the current subtree\\'s XOR value\\n        \\n        for (int nbr : graph[src]) {\\n            if (nbr != par && nbr != block) { // If the current nbr is niether the parent of this node nor the blocked node  , then only we\\'ll proceed\\n\\t\\t\\t\\n                int nbrXOR = helper(nbr, graph, arr, src, block, xor1, tot);\\n\\t\\t\\t\\t// \\'src <----> nbr\\' is the second edge to be removed\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint xor2 = nbrXOR; // Getting the XOR value of the current neighbor\\n            \\n\\t\\t\\t\\tint xor3 = (tot ^ xor1) ^ xor2;  // The XOR of the remaining component\\n                \\n                int max = Math.max(xor1, Math.max(xor2, xor3));   // Getting the minimum of the three values\\n                int min = Math.min(xor1, Math.min(xor2, xor3));    // Getting the maximum of the three value\\n                 \\n                this.ans = Math.min(ans, max - min);\\n\\t\\t\\t\\t\\n                myXOR ^= nbrXOR;  // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n\\n            }\\n        }\\n        \\n        return myXOR;  // Returing the XOR value of the current subtree rooted at the src node\\n    }\\n    \\n    private int dfs(int src, ArrayList<Integer>[] graph, int[] arr, int par, int tot) { // function to travel 1st time on the tree and find the first edge to be removed and then block the node at which the edge ends to avoid selecting the same node again\\n        int myXOR = arr[src]; // Setting the value for the current subtree\\'s XOR value\\n        for (int nbr : graph[src]) {\\n            if (nbr != par) { // If the current nbr is not the parent of this node, then only we\\'ll proceed\\n                \\n                int nbrXOR = dfs(nbr, graph, arr, src, tot);  // After selecting \\'src <----> nbr\\' as the first edge, we block \\'nbr\\' node and then make a call to try all the second edges\\n            \\n\\t\\t\\t\\t// Calling the helper to find the try all the second edges after blocking the current node\\n                helper(0, graph, arr, -1, nbr, nbrXOR, tot); \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tmyXOR ^= nbrXOR; // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n            }\\n        }\\n        \\n        return myXOR; // Returing the XOR value of the current subtree rooted at the src node\\n        \\n    }\\n    \\n    public int minimumScore(int[] arr, int[][] edges) {\\n        int n = arr.length;\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        int tot = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// Initializing the graph and finding the total XOR\\n            graph[i] = new ArrayList<>();\\n            tot ^= arr[i];\\n        }\\n        \\n        \\n        for (int[] edge : edges) {\\n\\t\\t\\t// adding the edges \\n            int u = edge[0], v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n       \\n        this.ans = Integer.MAX_VALUE;\\n   \\n        dfs(0, graph, arr, -1, tot);\\n        \\n        return this.ans;\\n    }\\n}\\n```\\n\\nC++ Code :\\n```\\nclass Solution {\\n    \\n    int ans;\\n    \\n    int helper(int src, vector<vector<int>>& graph, vector<int>& arr, int par, int block, int xor1, int tot) { // function to travel 2nd time on the tree and find \\n                                                                                                               // the second edge to be removed\\n\\t\\n        int myXOR = arr[src];   // Setting the value for the current subtree\\'s XOR value\\n        \\n        for (int nbr : graph[src]) {\\n            if (nbr != par && nbr != block) { // If the current nbr is niether the parent of this node nor the blocked node  , then only we\\'ll proceed\\n\\t\\t\\t\\n                int nbrXOR = helper(nbr, graph, arr, src, block, xor1, tot);\\n\\t\\t\\t\\t// \\'src <----> nbr\\' is the second edge to be removed\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint xor2 = nbrXOR; // Getting the XOR value of the current neighbor\\n            \\n\\t\\t\\t\\tint xor3 = (tot ^ xor1) ^ xor2;  // The XOR of the remaining component\\n                \\n                int maxXOR = max({xor1, xor2, xor3});   // Getting the minimum of the three values\\n                int minXOR = min({xor1, xor2, xor3});    // Getting the maximum of the three value\\n                 \\n                this->ans = min(ans, maxXOR - minXOR);\\n\\t\\t\\t\\t\\n                myXOR ^= nbrXOR;  // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n\\n            }\\n        }\\n        \\n        return myXOR;  // Returing the XOR value of the current subtree rooted at the src node\\n    }\\n    \\n    int dfs(int src, vector<vector<int>>& graph, vector<int>& arr, int par, int tot) { // function to travel 1st time on the tree and find the first edge to be \\n                                                                                       // removed and then block the node at which the edge ends to avoid\\n                                                                                       //selecting the same node again\\n        int myXOR = arr[src]; // Setting the value for the current subtree\\'s XOR value\\n        \\n        for (int nbr : graph[src]) {\\n        \\n            if (nbr != par) { // If the current nbr is not the parent of this node, then only we\\'ll proceed\\n                \\n                int nbrXOR = dfs(nbr, graph, arr, src, tot);  // After selecting \\'src <----> nbr\\' as the first edge, we block \\'nbr\\' node and then make a call to                                                                 // try all the second edges\\n            \\n\\t\\t\\t\\t// Calling the helper to find the try all the second edges after blocking the current node\\n                helper(0, graph, arr, -1, nbr, nbrXOR, tot); \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tmyXOR ^= nbrXOR; // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n            }\\n        }\\n        \\n        return myXOR; // Returing the XOR value of the current subtree rooted at the src node\\n        \\n    }\\n    \\npublic:\\n    int minimumScore(vector<int>& arr, vector<vector<int>>& edges) {\\n        int n = arr.size();\\n        vector<vector<int>> graph(n);\\n        int tot = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Finding the total XOR\\n            tot ^= arr[i];\\n        }\\n        \\n        \\n        for (vector<int>& edge : edges) {\\n            // adding the edges \\n            int u = edge[0], v = edge[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        \\n        this->ans = INT32_MAX;\\n   \\n        vector<bool> isVis(n);\\n        dfs(0, graph, arr, -1, tot);\\n        \\n        return this->ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int ans = Integer.MAX_VALUE;\\n\\n    private int helper(int src, ArrayList<Integer>[] graph, int[] arr, int par, int block, int xor1, int tot) { // function to travel 2nd time on the tree and find the second edge to be removed\\n\\t\\n        int myXOR = arr[src];   // Setting the value for the current subtree\\'s XOR value\\n        \\n        for (int nbr : graph[src]) {\\n            if (nbr != par && nbr != block) { // If the current nbr is niether the parent of this node nor the blocked node  , then only we\\'ll proceed\\n\\t\\t\\t\\n                int nbrXOR = helper(nbr, graph, arr, src, block, xor1, tot);\\n\\t\\t\\t\\t// \\'src <----> nbr\\' is the second edge to be removed\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint xor2 = nbrXOR; // Getting the XOR value of the current neighbor\\n            \\n\\t\\t\\t\\tint xor3 = (tot ^ xor1) ^ xor2;  // The XOR of the remaining component\\n                \\n                int max = Math.max(xor1, Math.max(xor2, xor3));   // Getting the minimum of the three values\\n                int min = Math.min(xor1, Math.min(xor2, xor3));    // Getting the maximum of the three value\\n                 \\n                this.ans = Math.min(ans, max - min);\\n\\t\\t\\t\\t\\n                myXOR ^= nbrXOR;  // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n\\n            }\\n        }\\n        \\n        return myXOR;  // Returing the XOR value of the current subtree rooted at the src node\\n    }\\n    \\n    private int dfs(int src, ArrayList<Integer>[] graph, int[] arr, int par, int tot) { // function to travel 1st time on the tree and find the first edge to be removed and then block the node at which the edge ends to avoid selecting the same node again\\n        int myXOR = arr[src]; // Setting the value for the current subtree\\'s XOR value\\n        for (int nbr : graph[src]) {\\n            if (nbr != par) { // If the current nbr is not the parent of this node, then only we\\'ll proceed\\n                \\n                int nbrXOR = dfs(nbr, graph, arr, src, tot);  // After selecting \\'src <----> nbr\\' as the first edge, we block \\'nbr\\' node and then make a call to try all the second edges\\n            \\n\\t\\t\\t\\t// Calling the helper to find the try all the second edges after blocking the current node\\n                helper(0, graph, arr, -1, nbr, nbrXOR, tot); \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tmyXOR ^= nbrXOR; // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n            }\\n        }\\n        \\n        return myXOR; // Returing the XOR value of the current subtree rooted at the src node\\n        \\n    }\\n    \\n    public int minimumScore(int[] arr, int[][] edges) {\\n        int n = arr.length;\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        int tot = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// Initializing the graph and finding the total XOR\\n            graph[i] = new ArrayList<>();\\n            tot ^= arr[i];\\n        }\\n        \\n        \\n        for (int[] edge : edges) {\\n\\t\\t\\t// adding the edges \\n            int u = edge[0], v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n       \\n        this.ans = Integer.MAX_VALUE;\\n   \\n        dfs(0, graph, arr, -1, tot);\\n        \\n        return this.ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    int ans;\\n    \\n    int helper(int src, vector<vector<int>>& graph, vector<int>& arr, int par, int block, int xor1, int tot) { // function to travel 2nd time on the tree and find \\n                                                                                                               // the second edge to be removed\\n\\t\\n        int myXOR = arr[src];   // Setting the value for the current subtree\\'s XOR value\\n        \\n        for (int nbr : graph[src]) {\\n            if (nbr != par && nbr != block) { // If the current nbr is niether the parent of this node nor the blocked node  , then only we\\'ll proceed\\n\\t\\t\\t\\n                int nbrXOR = helper(nbr, graph, arr, src, block, xor1, tot);\\n\\t\\t\\t\\t// \\'src <----> nbr\\' is the second edge to be removed\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint xor2 = nbrXOR; // Getting the XOR value of the current neighbor\\n            \\n\\t\\t\\t\\tint xor3 = (tot ^ xor1) ^ xor2;  // The XOR of the remaining component\\n                \\n                int maxXOR = max({xor1, xor2, xor3});   // Getting the minimum of the three values\\n                int minXOR = min({xor1, xor2, xor3});    // Getting the maximum of the three value\\n                 \\n                this->ans = min(ans, maxXOR - minXOR);\\n\\t\\t\\t\\t\\n                myXOR ^= nbrXOR;  // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n\\n            }\\n        }\\n        \\n        return myXOR;  // Returing the XOR value of the current subtree rooted at the src node\\n    }\\n    \\n    int dfs(int src, vector<vector<int>>& graph, vector<int>& arr, int par, int tot) { // function to travel 1st time on the tree and find the first edge to be \\n                                                                                       // removed and then block the node at which the edge ends to avoid\\n                                                                                       //selecting the same node again\\n        int myXOR = arr[src]; // Setting the value for the current subtree\\'s XOR value\\n        \\n        for (int nbr : graph[src]) {\\n        \\n            if (nbr != par) { // If the current nbr is not the parent of this node, then only we\\'ll proceed\\n                \\n                int nbrXOR = dfs(nbr, graph, arr, src, tot);  // After selecting \\'src <----> nbr\\' as the first edge, we block \\'nbr\\' node and then make a call to                                                                 // try all the second edges\\n            \\n\\t\\t\\t\\t// Calling the helper to find the try all the second edges after blocking the current node\\n                helper(0, graph, arr, -1, nbr, nbrXOR, tot); \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tmyXOR ^= nbrXOR; // Including the neighbour subtree\\'s XOR value in the XOR value of the subtree rooted at src node\\n            }\\n        }\\n        \\n        return myXOR; // Returing the XOR value of the current subtree rooted at the src node\\n        \\n    }\\n    \\npublic:\\n    int minimumScore(vector<int>& arr, vector<vector<int>>& edges) {\\n        int n = arr.size();\\n        vector<vector<int>> graph(n);\\n        int tot = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Finding the total XOR\\n            tot ^= arr[i];\\n        }\\n        \\n        \\n        for (vector<int>& edge : edges) {\\n            // adding the edges \\n            int u = edge[0], v = edge[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        \\n        this->ans = INT32_MAX;\\n   \\n        vector<bool> isVis(n);\\n        dfs(0, graph, arr, -1, tot);\\n        \\n        return this->ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199882,
                "title": "dfs-c",
                "content": "```\\n// XOR concepts required\\n// a ^ 0 = a\\n// a ^ a = 0\\n\\nclass Solution {\\npublic:\\n    vector<int> g[1001]; // adjecency list\\n    int visited[1001];\\n\\t// in and out timers to detect subtree element\\n    int in[1001];\\n    int out[1001];\\n    int timer;\\n    int X[1001];\\n    void dfs(int u,vector<int>& A, vector<pair<int,int>>& p)\\n    {\\n        in[u] = timer++;\\n\\n        visited[u] = 1;\\n        // subtree xor\\n        X[u] = A[u];\\n\\n        for(auto v: g[u])\\n        {\\n            if(visited[v])continue;\\n            p.push_back({u,v});\\n            dfs(v,A,p);\\n            X[u] ^= X[v];\\n        }\\n\\n        out[u] = timer++;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n           \\n           int ans = 1e9;\\n            timer = 0;\\n            memset(visited,0,sizeof visited);\\n           for(int i=0;i<=nums.size();i++)g[i].clear();\\n\\n\\n           vector<pair<int,int>> v;\\n\\n           for(auto it: edges)\\n           {\\n                int s = it[0];\\n                int d = it[1];\\n\\n                g[s].push_back(d);\\n                g[d].push_back(s);\\n           }\\n\\n\\n           dfs(0,nums,v);\\n\\n\\n           for(int i=0;i<v.size();i++)\\n           {\\n                for(int j=i+1;j<v.size();j++)\\n                {\\n                    int a = v[i].second;\\n                    int b = v[j].second;\\n\\t\\t\\t\\t\\t// three xors\\n                    int x,y,z;\\n                    x = y = 0;\\n                    z = X[0];\\n\\n\\n                    // if b lies in subtree of a\\n                    if(in[b] > in[a] && out[b] < out[a])\\n                    {\\n                        x = X[a];\\n                        y = X[b];\\n                        x ^= y;\\n                        z ^= x;\\n                        z ^= y;\\n                    }\\n                    else if(in[a] > in[b] && out[a] < out[b]) // if a lies in subtree of b\\n                    {\\n                        swap(a,b);\\n                        x = X[a];\\n                        y = X[b];\\n                        x ^= y;\\n                        z ^= x;\\n                        z ^= y;\\n                    }\\n                    else // hame mat jodiye hum alag hai :)\\n                    {\\n                        x = X[a];\\n                        y = X[b];\\n                        z ^= x;\\n                        z ^= y;\\n                    }\\n\\n\\n                    ans = min(ans,max({x,y,z}) - min({x,y,z}));\\n\\n                }\\n           }\\n\\n\\n\\n\\n           return ans;\\n\\n\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> g[1001]; // adjecency list\\n    int visited[1001];\\n\\t// in and out timers to detect subtree element\\n    int in[1001];\\n    int out[1001];\\n    int timer;\\n    int X[1001];\\n    void dfs(int u,vector<int>& A, vector<pair<int,int>>& p)\\n    {\\n        in[u] = timer++;\\n\\n        visited[u] = 1;\\n        // subtree xor\\n        X[u] = A[u];\\n\\n        for(auto v: g[u])\\n        {\\n            if(visited[v])continue;\\n            p.push_back({u,v}",
                "codeTag": "Java"
            },
            {
                "id": 2198386,
                "title": "python3-dfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/0cdc07e704aeceebd9f20162639cca47846e6641) for solutions of weekly 299. \\n\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        \\n        n = len(nums)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        def fn(u): \\n            score[u] = nums[u]\\n            child[u] = {u}\\n            for v in graph[u]: \\n                if seen[v] == 0: \\n                    seen[v] = 1\\n                    fn(v)\\n                    score[u] ^= score[v]\\n                    child[u] |= child[v]\\n        \\n        seen = [1] + [0]*(n-1)\\n        score = [0]*n\\n        child = [set() for _ in range(n)]\\n        fn(0)\\n        \\n        ans = inf \\n        for u in range(1, n): \\n            for v in range(u+1, n): \\n                if u in child[v]: \\n                    uu = score[u]\\n                    vv = score[v] ^ score[u]\\n                    xx = score[0] ^ score[v]\\n                elif v in child[u]: \\n                    uu = score[u] ^ score[v]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u]\\n                else: \\n                    uu = score[u]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u] ^ score[v]\\n                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))\\n        return ans  \\n```\\n\\nAdded an alternative implement (based on the solution of @cuiaoxiang). \\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        \\n        n = len(nums)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        def fn(u, p): \\n            nonlocal t\\n            score[u] = nums[u]\\n            tin[u] = (t := t+1) # time to enter\\n            for v in graph[u]: \\n                if v != p: \\n                    fn(v, u)\\n                    score[u] ^= score[v]\\n            tout[u] = t # time to exit \\n        \\n        t = 0 \\n        score = [0]*n\\n        tin = [0]*n \\n        tout = [0]*n \\n        fn(0, -1)\\n        \\n        ans = inf \\n        for u in range(1, n): \\n            for v in range(u+1, n): \\n                if tin[v] <= tin[u] and tout[v] >= tout[u]: # enter earlier & exit later == parent \\n                    uu = score[u]\\n                    vv = score[v] ^ score[u]\\n                    xx = score[0] ^ score[v]\\n                elif tin[v] >= tin[u] and tout[v] <= tout[u]: \\n                    uu = score[u] ^ score[v]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u]\\n                else: \\n                    uu = score[u]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u] ^ score[v]\\n                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))\\n        return ans  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        \\n        n = len(nums)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        def fn(u): \\n            score[u] = nums[u]\\n            child[u] = {u}\\n            for v in graph[u]: \\n                if seen[v] == 0: \\n                    seen[v] = 1\\n                    fn(v)\\n                    score[u] ^= score[v]\\n                    child[u] |= child[v]\\n        \\n        seen = [1] + [0]*(n-1)\\n        score = [0]*n\\n        child = [set() for _ in range(n)]\\n        fn(0)\\n        \\n        ans = inf \\n        for u in range(1, n): \\n            for v in range(u+1, n): \\n                if u in child[v]: \\n                    uu = score[u]\\n                    vv = score[v] ^ score[u]\\n                    xx = score[0] ^ score[v]\\n                elif v in child[u]: \\n                    uu = score[u] ^ score[v]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u]\\n                else: \\n                    uu = score[u]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u] ^ score[v]\\n                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))\\n        return ans  \\n```\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        \\n        n = len(nums)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        def fn(u, p): \\n            nonlocal t\\n            score[u] = nums[u]\\n            tin[u] = (t := t+1) # time to enter\\n            for v in graph[u]: \\n                if v != p: \\n                    fn(v, u)\\n                    score[u] ^= score[v]\\n            tout[u] = t # time to exit \\n        \\n        t = 0 \\n        score = [0]*n\\n        tin = [0]*n \\n        tout = [0]*n \\n        fn(0, -1)\\n        \\n        ans = inf \\n        for u in range(1, n): \\n            for v in range(u+1, n): \\n                if tin[v] <= tin[u] and tout[v] >= tout[u]: # enter earlier & exit later == parent \\n                    uu = score[u]\\n                    vv = score[v] ^ score[u]\\n                    xx = score[0] ^ score[v]\\n                elif tin[v] >= tin[u] and tout[v] <= tout[u]: \\n                    uu = score[u] ^ score[v]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u]\\n                else: \\n                    uu = score[u]\\n                    vv = score[v]\\n                    xx = score[0] ^ score[u] ^ score[v]\\n                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240319,
                "title": "c-o-n-2-o-n-2-using-dfs-and-preprocessing",
                "content": "I feel that this is a pretty good question to be honest. I really enjoyed solving it.\\nWhat i am doing is:\\ninitially, assuming root to be 0, i am precalculating the subtree xors and depths, and along side that, i am also storing all ancestors of each node (Since allowed complexity is n^2, we can comfortably do that). Then,\\nbasically, for every pair of edges:\\nlet them be ed1 and ed2,\\nhere, case 1:\\ned2 is in the subtree connected by ed1. (the lower node of ed1 is an ancestor of the lower node of ed2)\\nHere, we can calculate the xors of the three subtrees by:\\n```\\nint x1=xors[ed2[1]];\\nint x2=xors[ed1[1]]^x1;\\nint x3=xors[0]^x2^x1;\\n```\\nSimilarly, when ed1 is in subtree connected by ed2:\\n```\\nint x1=xors[ed1[1]];\\nint x2=xors[ed2[1]]^x1;\\nint x3=xors[0]^x2^x1;\\n```\\ncase 2: when both edges connect different subtrees:\\n```\\nint x1=xors[ed2[1]];\\nint x2=xors[ed1[1]];\\nint x3=xors[0]^x2^x1;\\n```\\nNow, we can calculate the answer by calculating the difference between max and min of these values.\\n\\nThe code is given below:\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i,vector<int>adj[],vector<int>&cur,vector<vector<bool>>&anc,int par){\\n        for(auto &x:cur)anc[i][x]=true;\\n        cur.push_back(i);\\n        for(auto &x:adj[i]){\\n            if(x!=par){\\n                dfs(x,adj,cur,anc,i);\\n            }\\n        }\\n        cur.pop_back();\\n    }\\n    \\n    int calcXor(int i,vector<int>&a,vector<int>&xors,vector<int>adj[],int par,vector<int>&dep,int curDep){\\n        xors[i]=a[i];\\n        dep[i]=curDep;\\n        for(auto &x:adj[i]){\\n            if(x!=par)\\n                xors[i]^=calcXor(x,a,xors,adj,i,dep,curDep+1);\\n        }\\n        return xors[i];\\n    }\\n        \\n    int minimumScore(vector<int>& a, vector<vector<int>>& edges) {\\n        int n=a.size();\\n        vector<int>adj[n];\\n        for(auto &v:edges){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<int>xors(n,0);\\n        vector<int>dep(n,0);\\n        vector<vector<bool>>anc(n,vector<bool>(n,false));\\n        vector<int>curAnc;\\n        calcXor(0,a,xors,adj,-1,dep,0);\\n        dfs(0,adj,curAnc,anc,-1);\\n        // for(int i=0;i<n;i++){\\n        //     // cout<<i<<\" \"<<xors[i]<<\" \"<<dep[i]<<endl;\\n        // }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++){\\n            auto &ed1=edges[i];\\n            if(dep[ed1[0]]>dep[ed1[1]]) swap(ed1[0],ed1[1]);\\n            for(int j=i+1;j<n-1;j++){\\n                auto &ed2=edges[j];\\n                if(dep[ed2[0]]>dep[ed2[1]]) swap(ed2[0],ed2[1]);\\n                \\n                if(anc[ed2[1]][ed1[1]]){ //ed2 is in the subtree connected by ed1\\n                    // cout<<ed1[0]<<\" \"<<ed1[1]<<\", \"<<ed2[0]<<\" \"<<ed2[1]<<endl;\\n                    int x1=xors[ed2[1]];\\n                    int x2=xors[ed1[1]]^x1;\\n                    int x3=xors[0]^x2^x1;\\n                    // cout<<x1<<\" \"<<x2<<\" \"<<x3<<endl<<endl;\\n                    ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n                }\\n                else if(anc[ed1[1]][ed2[1]]){ //ed1 is in the subtree connected by ed2\\n                    // cout<<ed1[0]<<\" \"<<ed1[1]<<\", \"<<ed2[0]<<\" \"<<ed2[1]<<endl;\\n                    int x1=xors[ed1[1]];\\n                    int x2=xors[ed2[1]]^x1;\\n                    int x3=xors[0]^x2^x1;\\n                    // cout<<x1<<\" \"<<x2<<\" \"<<x3<<endl<<endl;\\n                    ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n                }\\n                else{ //ed1 and ed2 connect different, independent subtrees\\n                    int x1=xors[ed2[1]];\\n                    int x2=xors[ed1[1]];\\n                    int x3=xors[0]^x2^x1;\\n                    ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nint x1=xors[ed2[1]];\\nint x2=xors[ed1[1]]^x1;\\nint x3=xors[0]^x2^x1;\\n```\n```\\nint x1=xors[ed1[1]];\\nint x2=xors[ed2[1]]^x1;\\nint x3=xors[0]^x2^x1;\\n```\n```\\nint x1=xors[ed2[1]];\\nint x2=xors[ed1[1]];\\nint x3=xors[0]^x2^x1;\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i,vector<int>adj[],vector<int>&cur,vector<vector<bool>>&anc,int par){\\n        for(auto &x:cur)anc[i][x]=true;\\n        cur.push_back(i);\\n        for(auto &x:adj[i]){\\n            if(x!=par){\\n                dfs(x,adj,cur,anc,i);\\n            }\\n        }\\n        cur.pop_back();\\n    }\\n    \\n    int calcXor(int i,vector<int>&a,vector<int>&xors,vector<int>adj[],int par,vector<int>&dep,int curDep){\\n        xors[i]=a[i];\\n        dep[i]=curDep;\\n        for(auto &x:adj[i]){\\n            if(x!=par)\\n                xors[i]^=calcXor(x,a,xors,adj,i,dep,curDep+1);\\n        }\\n        return xors[i];\\n    }\\n        \\n    int minimumScore(vector<int>& a, vector<vector<int>>& edges) {\\n        int n=a.size();\\n        vector<int>adj[n];\\n        for(auto &v:edges){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<int>xors(n,0);\\n        vector<int>dep(n,0);\\n        vector<vector<bool>>anc(n,vector<bool>(n,false));\\n        vector<int>curAnc;\\n        calcXor(0,a,xors,adj,-1,dep,0);\\n        dfs(0,adj,curAnc,anc,-1);\\n        // for(int i=0;i<n;i++){\\n        //     // cout<<i<<\" \"<<xors[i]<<\" \"<<dep[i]<<endl;\\n        // }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++){\\n            auto &ed1=edges[i];\\n            if(dep[ed1[0]]>dep[ed1[1]]) swap(ed1[0],ed1[1]);\\n            for(int j=i+1;j<n-1;j++){\\n                auto &ed2=edges[j];\\n                if(dep[ed2[0]]>dep[ed2[1]]) swap(ed2[0],ed2[1]);\\n                \\n                if(anc[ed2[1]][ed1[1]]){ //ed2 is in the subtree connected by ed1\\n                    // cout<<ed1[0]<<\" \"<<ed1[1]<<\", \"<<ed2[0]<<\" \"<<ed2[1]<<endl;\\n                    int x1=xors[ed2[1]];\\n                    int x2=xors[ed1[1]]^x1;\\n                    int x3=xors[0]^x2^x1;\\n                    // cout<<x1<<\" \"<<x2<<\" \"<<x3<<endl<<endl;\\n                    ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n                }\\n                else if(anc[ed1[1]][ed2[1]]){ //ed1 is in the subtree connected by ed2\\n                    // cout<<ed1[0]<<\" \"<<ed1[1]<<\", \"<<ed2[0]<<\" \"<<ed2[1]<<endl;\\n                    int x1=xors[ed1[1]];\\n                    int x2=xors[ed2[1]]^x1;\\n                    int x3=xors[0]^x2^x1;\\n                    // cout<<x1<<\" \"<<x2<<\" \"<<x3<<endl<<endl;\\n                    ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n                }\\n                else{ //ed1 and ed2 connect different, independent subtrees\\n                    int x1=xors[ed2[1]];\\n                    int x2=xors[ed1[1]];\\n                    int x3=xors[0]^x2^x1;\\n                    ans=min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3368464,
                "title": "one-line-code-100-easy-no-time-taken-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/a2d9dd61-ea38-4a10-a0a9-5a76a94821b3_1680408478.3010898.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// TC : O(nodes*nodes)\\n// SC : O(nodes)\\n\\nclass Solution {\\n    private ArrayList<Integer> tree[];\\n    private int val[];\\n    private int minScore;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        val = nums;\\n        int nodes = nums.length;\\n        int len = edges.length;\\n        tree = new ArrayList[nodes];\\n        \\n        for(int node =0;node<nodes;node++) tree[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            tree[node1].add(node2);\\n            tree[node2].add(node1);\\n        }\\n        \\n        minScore = Integer.MAX_VALUE;\\n        \\n        for(int idx =0;idx<len;idx++){\\n            int node1 = edges[idx][0];\\n            int node2 = edges[idx][1];\\n            \\n            int xor1 = dfs(node1,node2);\\n            int xor2 = dfs(node2,node1);\\n            \\n            dfs(node1,node2,xor1,xor2);\\n            dfs(node2,node1,xor2,xor1);\\n        }\\n        \\n        return minScore;\\n    }\\n    \\n    private int dfs(int parent,int node,int compXor1,int treeXor){\\n        int childXor = 0;\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent){\\n                 int currChildXor = dfs(node,child,compXor1,treeXor);\\n                 int compXor2 = currChildXor;\\n                 int compXor3 = treeXor^compXor2;\\n                \\n                 int maxXor = Math.max(compXor1,Math.max(compXor2,compXor3));\\n                 int minXor = Math.min(compXor1,Math.min(compXor2,compXor3));\\n\\n                 minScore = Math.min(minScore,maxXor-minXor);\\n                 childXor^=currChildXor;\\n            }\\n        }\\n        \\n        return childXor^val[node];\\n    }\\n    \\n    private int dfs(int node,int parent){\\n        int xor = val[node];\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent) xor^=dfs(child,node);\\n        }\\n        \\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TC : O(nodes*nodes)\\n// SC : O(nodes)\\n\\nclass Solution {\\n    private ArrayList<Integer> tree[];\\n    private int val[];\\n    private int minScore;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        val = nums;\\n        int nodes = nums.length;\\n        int len = edges.length;\\n        tree = new ArrayList[nodes];\\n        \\n        for(int node =0;node<nodes;node++) tree[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            tree[node1].add(node2);\\n            tree[node2].add(node1);\\n        }\\n        \\n        minScore = Integer.MAX_VALUE;\\n        \\n        for(int idx =0;idx<len;idx++){\\n            int node1 = edges[idx][0];\\n            int node2 = edges[idx][1];\\n            \\n            int xor1 = dfs(node1,node2);\\n            int xor2 = dfs(node2,node1);\\n            \\n            dfs(node1,node2,xor1,xor2);\\n            dfs(node2,node1,xor2,xor1);\\n        }\\n        \\n        return minScore;\\n    }\\n    \\n    private int dfs(int parent,int node,int compXor1,int treeXor){\\n        int childXor = 0;\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent){\\n                 int currChildXor = dfs(node,child,compXor1,treeXor);\\n                 int compXor2 = currChildXor;\\n                 int compXor3 = treeXor^compXor2;\\n                \\n                 int maxXor = Math.max(compXor1,Math.max(compXor2,compXor3));\\n                 int minXor = Math.min(compXor1,Math.min(compXor2,compXor3));\\n\\n                 minScore = Math.min(minScore,maxXor-minXor);\\n                 childXor^=currChildXor;\\n            }\\n        }\\n        \\n        return childXor^val[node];\\n    }\\n    \\n    private int dfs(int node,int parent){\\n        int xor = val[node];\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent) xor^=dfs(child,node);\\n        }\\n        \\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202121,
                "title": "java-dfs-larry-s-solution",
                "content": "Java implementation of Larry\\'s Solution\\nhttps://www.youtube.com/watch?v=hZRn3ZL0NVE\\n\\n```\\nclass Solution {\\n    int[] xors;\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    Map<Integer, Set<Integer>> subTree = new HashMap<>();\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int total = 0;\\n        int n = nums.length;\\n        xors = new int[n];\\n        for (int i = 0; i < nums.length; ++i) {\\n            total = total ^ nums[i];\\n        }\\n        \\n        // System.out.println(\"total \" + total);\\n        \\n        \\n        for (var edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            var list = map.getOrDefault(u, new ArrayList<>());\\n            list.add(v);\\n            map.put(u, list);\\n            \\n            list = map.getOrDefault(v, new ArrayList<>());\\n            list.add(u);\\n            \\n            map.put(v, list);\\n        }\\n        \\n        go (0, -1, nums);\\n        populateSubTree(0, -1);\\n        \\n        // for (var entry : subTree.entrySet()) {\\n        //     System.out.println(entry.getKey() + \"\\\\t\" + entry.getValue());\\n        // }\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                int t1, t2, t3;\\n                \\n                if (subTree.get(i).contains(j)) {\\n                    // i is the parent of j\\n                    t1 = xors[0] ^ xors[i];\\n                    \\n                    t2 = xors[j];\\n                    t3 = xors[0] ^ t1 ^ t2;\\n                    // System.out.println(\"i=\" + i + \"\\\\t\" + \"j=\" + j);\\n                    // System.out.println(t1 + \"\\\\t\" + t2 + \"\\\\t\" + t3);\\n                } else if (subTree.get(j).contains(i)) {\\n                    // j is the parent of i\\n                    t1 = xors[i];\\n                    t2 = xors[0] ^ xors[j];\\n                    t3 = xors[0] ^ t1 ^ t2;\\n                } else {\\n                    t1 = xors[j];\\n                    t2 = xors[i];\\n                    t3 = xors[0] ^ t1 ^ t2;\\n                }\\n                \\n                int max_t = Math.max(Math.max(t1, t2), t3);\\n                int min_t = Math.min(Math.min(t1, t2), t3);\\n                min = Math.min(min, max_t - min_t);\\n            }\\n        }\\n        \\n        return min;\\n    }\\n    \\n    Set<Integer> populateSubTree(int index, int p_index) {\\n        Set<Integer> result = new HashSet<>();\\n        result.add(index);\\n        for (var node : map.getOrDefault(index, new ArrayList<>())) {\\n            if (p_index != node) {\\n                var childSet = populateSubTree(node, index);\\n                result.addAll(childSet);\\n            }\\n        }\\n        \\n        // System.out.println(\"Putting \" + index + \"\\\\t\" + result);\\n        subTree.put(index, result);\\n        return result;\\n    }\\n    \\n    int go(int index, int p_index, int[] nums) {\\n        xors[index] = nums[index];\\n        for (var node : map.getOrDefault(index, new ArrayList<>())) {\\n            if (p_index != node) {\\n                xors[index] = xors[index] ^ go(node, index, nums);\\n            }\\n        }\\n        \\n        // System.out.println(\"xors: \" + index + \"\\\\t\" + xors[index]);\\n        return xors[index];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] xors;\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    Map<Integer, Set<Integer>> subTree = new HashMap<>();\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int total = 0;\\n        int n = nums.length;\\n        xors = new int[n];\\n        for (int i = 0; i < nums.length; ++i) {\\n            total = total ^ nums[i];\\n        }\\n        \\n        // System.out.println(\"total \" + total);\\n        \\n        \\n        for (var edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            var list = map.getOrDefault(u, new ArrayList<>());\\n            list.add(v);\\n            map.put(u, list);\\n            \\n            list = map.getOrDefault(v, new ArrayList<>());\\n            list.add(u);\\n            \\n            map.put(v, list);\\n        }\\n        \\n        go (0, -1, nums);\\n        populateSubTree(0, -1);\\n        \\n        // for (var entry : subTree.entrySet()) {\\n        //     System.out.println(entry.getKey() + \"\\\\t\" + entry.getValue());\\n        // }\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                int t1, t2, t3;\\n                \\n                if (subTree.get(i).contains(j)) {\\n                    // i is the parent of j\\n                    t1 = xors[0] ^ xors[i];\\n                    \\n                    t2 = xors[j];\\n                    t3 = xors[0] ^ t1 ^ t2;\\n                    // System.out.println(\"i=\" + i + \"\\\\t\" + \"j=\" + j);\\n                    // System.out.println(t1 + \"\\\\t\" + t2 + \"\\\\t\" + t3);\\n                } else if (subTree.get(j).contains(i)) {\\n                    // j is the parent of i\\n                    t1 = xors[i];\\n                    t2 = xors[0] ^ xors[j];\\n                    t3 = xors[0] ^ t1 ^ t2;\\n                } else {\\n                    t1 = xors[j];\\n                    t2 = xors[i];\\n                    t3 = xors[0] ^ t1 ^ t2;\\n                }\\n                \\n                int max_t = Math.max(Math.max(t1, t2), t3);\\n                int min_t = Math.min(Math.min(t1, t2), t3);\\n                min = Math.min(min, max_t - min_t);\\n            }\\n        }\\n        \\n        return min;\\n    }\\n    \\n    Set<Integer> populateSubTree(int index, int p_index) {\\n        Set<Integer> result = new HashSet<>();\\n        result.add(index);\\n        for (var node : map.getOrDefault(index, new ArrayList<>())) {\\n            if (p_index != node) {\\n                var childSet = populateSubTree(node, index);\\n                result.addAll(childSet);\\n            }\\n        }\\n        \\n        // System.out.println(\"Putting \" + index + \"\\\\t\" + result);\\n        subTree.put(index, result);\\n        return result;\\n    }\\n    \\n    int go(int index, int p_index, int[] nums) {\\n        xors[index] = nums[index];\\n        for (var node : map.getOrDefault(index, new ArrayList<>())) {\\n            if (p_index != node) {\\n                xors[index] = xors[index] ^ go(node, index, nums);\\n            }\\n        }\\n        \\n        // System.out.println(\"xors: \" + index + \"\\\\t\" + xors[index]);\\n        return xors[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198490,
                "title": "c-o-n-2-soln-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int x, vector<int> &values, vector<int> adj[],vector<bool>&vis, vector<int> &nums,vector<int> adjnew[]){\\n        vis[x] = true;\\n        int xora = nums[x];\\n        for(auto t:adj[x]){\\n            if(vis[t])continue;\\n            adjnew[x].push_back(t);\\n            dfs(t,values,adj,vis,nums,adjnew);\\n            xora = (xora^values[t]);\\n        }\\n        values[x] = xora;\\n    }\\n    int totalxor;\\n    int minmscore = 1e9;\\n    void dfs3(int a, int x, int t, vector<int> &values, vector<int> adj2[],vector<bool>&vis){\\n        for(auto hey:adj2[a]){\\n            if(hey==t && a==x) continue;\\n            int xor1 = values[t];\\n            int xor2;\\n            if(vis[hey])\\n                xor2 = (values[hey]^xor1);\\n            else xor2 = (values[hey]);\\n            int xor3 = ((totalxor^xor1)^xor2);\\n            int minm = min(xor1,min(xor2,xor3));\\n            int maxm = max(xor1,max(xor2,xor3));\\n            // cout  <<\"x\" << x << \"t\" <<t << \" \" << \"hey\" << hey << endl;\\n            // cout << xor1 << xor2 << xor3 << endl;\\n            // cout << minm << \" \" << maxm << endl;\\n            minmscore = min(minmscore,maxm-minm);\\n            dfs3(hey,x,t,values,adj2,vis);\\n        }\\n    }\\n    \\n    void dfs2(int x, vector<int> &values,vector<int> adj2[],vector<bool>&vis){\\n        vis[x] = true;\\n        for(auto t:adj2[x]){\\n            dfs3(0,x,t,values,adj2,vis);\\n            dfs2(t,values,adj2,vis);\\n        }\\n        vis[x] = false; \\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<int> adj[n];\\n        vector<int> adjnew[n];\\n        for(auto p:edges){\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<int> values(n);\\n        vector<bool> vis(n,false);\\n        dfs(0,values,adj,vis,nums,adjnew);\\n        // for(int i=0;i<n;i++){\\n        //     cout << values[i] << endl;\\n        // }\\n        totalxor = values[0];\\n        minmscore = 1e9;\\n        vector<bool> visnew(n,false);\\n        dfs2(0,values,adjnew,visnew);\\n        return minmscore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int x, vector<int> &values, vector<int> adj[],vector<bool>&vis, vector<int> &nums,vector<int> adjnew[]){\\n        vis[x] = true;\\n        int xora = nums[x];\\n        for(auto t:adj[x]){\\n            if(vis[t])continue;\\n            adjnew[x].push_back(t);\\n            dfs(t,values,adj,vis,nums,adjnew);\\n            xora = (xora^values[t]);\\n        }\\n        values[x] = xora;\\n    }\\n    int totalxor;\\n    int minmscore = 1e9;\\n    void dfs3(int a, int x, int t, vector<int> &values, vector<int> adj2[],vector<bool>&vis){\\n        for(auto hey:adj2[a]){\\n            if(hey==t && a==x) continue;\\n            int xor1 = values[t];\\n            int xor2;\\n            if(vis[hey])\\n                xor2 = (values[hey]^xor1);\\n            else xor2 = (values[hey]);\\n            int xor3 = ((totalxor^xor1)^xor2);\\n            int minm = min(xor1,min(xor2,xor3));\\n            int maxm = max(xor1,max(xor2,xor3));\\n            // cout  <<\"x\" << x << \"t\" <<t << \" \" << \"hey\" << hey << endl;\\n            // cout << xor1 << xor2 << xor3 << endl;\\n            // cout << minm << \" \" << maxm << endl;\\n            minmscore = min(minmscore,maxm-minm);\\n            dfs3(hey,x,t,values,adj2,vis);\\n        }\\n    }\\n    \\n    void dfs2(int x, vector<int> &values,vector<int> adj2[],vector<bool>&vis){\\n        vis[x] = true;\\n        for(auto t:adj2[x]){\\n            dfs3(0,x,t,values,adj2,vis);\\n            dfs2(t,values,adj2,vis);\\n        }\\n        vis[x] = false; \\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<int> adj[n];\\n        vector<int> adjnew[n];\\n        for(auto p:edges){\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<int> values(n);\\n        vector<bool> vis(n,false);\\n        dfs(0,values,adj,vis,nums,adjnew);\\n        // for(int i=0;i<n;i++){\\n        //     cout << values[i] << endl;\\n        // }\\n        totalxor = values[0];\\n        minmscore = 1e9;\\n        vector<bool> visnew(n,false);\\n        dfs2(0,values,adjnew,visnew);\\n        return minmscore;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2200093,
                "title": "javascript-dfs-solution",
                "content": "\\n```js\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nconst minimumScore = function (nums, edges) {\\n  const n = nums.length;\\n  let ans = Infinity;\\n  const visited = Array(n).fill(0);\\n  const pc = [];\\n  const adj = Array.from({ length: n }, () => []);\\n  const child_xor = Array(n).fill(0);\\n  const childs = Array.from({ length: n }, () => Array(n).fill(false));\\n  const { min, max } = Math;\\n  const par = Array(n).fill(0);\\n\\n  for (const edge of edges)\\n    adj[edge[0]].push(edge[1]), adj[edge[1]].push(edge[0]);\\n\\n  dfs(0);\\n\\n  for (let i = 0; i < pc.length; i++)\\n    for (let j = i + 1; j < pc.length; j++) {\\n      // removing an edge i and j\\n      const a = pc[i][1],\\n        b = pc[j][1]; // node that will come below when you delete an edge i and j\\n      let xa = child_xor[a],\\n        xb = child_xor[b],\\n        xc = child_xor[0];\\n      if (childs[a][b]) (xc ^= xa), (xa ^= xb);\\n      else (xc ^= xa), (xc ^= xb);\\n\\n      ans = min(max(xa, max(xb, xc)) - min(xa, min(xb, xc)), ans);\\n    }\\n\\n  return ans;\\n\\n  function dfs(i) {\\n    let ans = nums[i];\\n    visited[i] = true;\\n\\n    for (let p of par) childs[p][i] = true; // Defining this node as the child of all its parents\\n\\n    par.push(i);\\n\\n    for (let child of adj[i] || [])\\n      if (!visited[child]) {\\n        pc.push([i, child]);\\n        ans ^= dfs(child); // Recurcively calculating xors\\n      }\\n\\n    par.pop();\\n\\n    return (child_xor[i] = ans);\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nconst minimumScore = function (nums, edges) {\\n  const n = nums.length;\\n  let ans = Infinity;\\n  const visited = Array(n).fill(0);\\n  const pc = [];\\n  const adj = Array.from({ length: n }, () => []);\\n  const child_xor = Array(n).fill(0);\\n  const childs = Array.from({ length: n }, () => Array(n).fill(false));\\n  const { min, max } = Math;\\n  const par = Array(n).fill(0);\\n\\n  for (const edge of edges)\\n    adj[edge[0]].push(edge[1]), adj[edge[1]].push(edge[0]);\\n\\n  dfs(0);\\n\\n  for (let i = 0; i < pc.length; i++)\\n    for (let j = i + 1; j < pc.length; j++) {\\n      // removing an edge i and j\\n      const a = pc[i][1],\\n        b = pc[j][1]; // node that will come below when you delete an edge i and j\\n      let xa = child_xor[a],\\n        xb = child_xor[b],\\n        xc = child_xor[0];\\n      if (childs[a][b]) (xc ^= xa), (xa ^= xb);\\n      else (xc ^= xa), (xc ^= xb);\\n\\n      ans = min(max(xa, max(xb, xc)) - min(xa, min(xb, xc)), ans);\\n    }\\n\\n  return ans;\\n\\n  function dfs(i) {\\n    let ans = nums[i];\\n    visited[i] = true;\\n\\n    for (let p of par) childs[p][i] = true; // Defining this node as the child of all its parents\\n\\n    par.push(i);\\n\\n    for (let child of adj[i] || [])\\n      if (!visited[child]) {\\n        pc.push([i, child]);\\n        ans ^= dfs(child); // Recurcively calculating xors\\n      }\\n\\n    par.pop();\\n\\n    return (child_xor[i] = ans);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198433,
                "title": "python3-o-n-2-enumerate-all-splitting-ways-explained",
                "content": "Every node can be the root. We pick node 0 as root.\\nFor each node, we calculate its sub-tree xor value using dfs, O(n) time.\\nThen we choose 2 nodes to separate from the tree. Exclude their xor values from root, we have all the 3 xor values to calculate scores now. Chooing all possible 2 nodes takes O(n^2) time.\\nHowever, if the 2 nodes that we choose, let\\'s say node1, node2, if node1 happend to be the parent of node2, then node2 xor value need to be reduced from node1.\\nIn order to know whether node1 is parent of node2, we need to remember all parents of each node in dfs, O(n^2) time.\\n\\n```\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        d = defaultdict(list)\\n        for a,b in edges:\\n            d[a].append(b)\\n            d[b].append(a)\\n        scores = [0]*n\\n        parent_sets = [set() for _ in range(n)]\\n        def dfs(node,parent):\\n            score = nums[node]\\n            parent_sets[node] = set(parent)\\n            parent.append(node)\\n            for nxt in d[node]:\\n                if len(parent)<=1 or nxt!=parent[-2]:\\n                    dfs(nxt,parent)\\n                    score ^= scores[nxt]\\n            scores[node] = score\\n            parent.pop()\\n        dfs(0,[])\\n        res = math.inf\\n        for i in range(2,n):\\n            for j in range(1,i):\\n                a,b = scores[i],scores[j]\\n                if j in parent_sets[i]:\\n                    b ^= a\\n                elif i in parent_sets[j]:\\n                    a ^= b\\n                c = scores[0]^a^b\\n                tmp = sorted([a,b,c])\\n                res = min(res, tmp[-1]-tmp[0])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        d = defaultdict(list)\\n        for a,b in edges:\\n            d[a].append(b)\\n            d[b].append(a)\\n        scores = [0]*n\\n        parent_sets = [set() for _ in range(n)]\\n        def dfs(node,parent):\\n            score = nums[node]\\n            parent_sets[node] = set(parent)\\n            parent.append(node)\\n            for nxt in d[node]:\\n                if len(parent)<=1 or nxt!=parent[-2]:\\n                    dfs(nxt,parent)\\n                    score ^= scores[nxt]\\n            scores[node] = score\\n            parent.pop()\\n        dfs(0,[])\\n        res = math.inf\\n        for i in range(2,n):\\n            for j in range(1,i):\\n                a,b = scores[i],scores[j]\\n                if j in parent_sets[i]:\\n                    b ^= a\\n                elif i in parent_sets[j]:\\n                    a ^= b\\n                c = scores[0]^a^b\\n                tmp = sorted([a,b,c])\\n                res = min(res, tmp[-1]-tmp[0])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2198212,
                "title": "c-lca",
                "content": "```C++\\nclass Solution {\\n    int n;\\n    vector<vector<int>> adj;\\n    vector<int> val;\\n    int LCA[1010][22];\\n    int level[1000];\\n\\n    int dfs(vector<int>& A, int u, int par, int lvl = 0) {\\n        val[u] = A[u];\\n        level[u] = lvl;\\n        LCA[u][0] = par;\\n        for(auto& v : adj[u]) {\\n            if(v == par) continue;\\n            val[u] ^= dfs(A, v, u, lvl + 1);\\n        }\\n        return val[u];\\n    }\\n    void init() {\\n        for(int j = 0; j < 21; j++) {\\n            for(int i = 0; i < n; i++) {\\n                if(LCA[i][j] == -1) continue;\\n                LCA[i][j+1] = LCA[LCA[i][j]][j];\\n            }\\n        }\\n    }\\n    int query(int u, int v) {\\n        if(level[u] < level[v]) swap(u, v);\\n        int diff = level[u] - level[v];\\n        for(int i = 0; diff; i++, diff/=2) {\\n            if(diff&1) u = LCA[u][i];\\n        }\\n        if(u != v) {\\n            for(int i = 21; i >= 0; i--) {\\n                if(LCA[u][i] == LCA[v][i]) continue;\\n                u = LCA[u][i];\\n                v = LCA[v][i];\\n            }\\n            u = LCA[u][0];\\n        }\\n        return u;\\n    }\\npublic:\\n    int minimumScore(vector<int>& A, vector<vector<int>>& edges) {\\n        n = A.size();\\n        adj = vector<vector<int>>(n);\\n        val = vector<int>(n);\\n        memset(LCA, -1, sizeof LCA);\\n        memset(level, -1, sizeof level);\\n        for(auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfs(A,0,-1);\\n        init();\\n        int res = INT_MAX;\\n        for(int i = 1; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                int lca = query(i,j);\\n                int a, b, c;\\n                if(lca == i) {\\n                    a = val[0] ^ val[i], b = val[i] ^ val[j], c = val[j]; \\n                } else if(lca == j) {\\n                    a = val[0] ^ val[j], b = val[j] ^ val[i], c = val[i];\\n                } else {\\n                    a = val[0] ^ val[i] ^ val[j], b = val[i], c = val[j];\\n                }\\n                int ma = max({a,b,c}), mi = min({a,b,c});\\n                res = min(res, ma - mi);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    int n;\\n    vector<vector<int>> adj;\\n    vector<int> val;\\n    int LCA[1010][22];\\n    int level[1000];\\n\\n    int dfs(vector<int>& A, int u, int par, int lvl = 0) {\\n        val[u] = A[u];\\n        level[u] = lvl;\\n        LCA[u][0] = par;\\n        for(auto& v : adj[u]) {\\n            if(v == par) continue;\\n            val[u] ^= dfs(A, v, u, lvl + 1);\\n        }\\n        return val[u];\\n    }\\n    void init() {\\n        for(int j = 0; j < 21; j++) {\\n            for(int i = 0; i < n; i++) {\\n                if(LCA[i][j] == -1) continue;\\n                LCA[i][j+1] = LCA[LCA[i][j]][j];\\n            }\\n        }\\n    }\\n    int query(int u, int v) {\\n        if(level[u] < level[v]) swap(u, v);\\n        int diff = level[u] - level[v];\\n        for(int i = 0; diff; i++, diff/=2) {\\n            if(diff&1) u = LCA[u][i];\\n        }\\n        if(u != v) {\\n            for(int i = 21; i >= 0; i--) {\\n                if(LCA[u][i] == LCA[v][i]) continue;\\n                u = LCA[u][i];\\n                v = LCA[v][i];\\n            }\\n            u = LCA[u][0];\\n        }\\n        return u;\\n    }\\npublic:\\n    int minimumScore(vector<int>& A, vector<vector<int>>& edges) {\\n        n = A.size();\\n        adj = vector<vector<int>>(n);\\n        val = vector<int>(n);\\n        memset(LCA, -1, sizeof LCA);\\n        memset(level, -1, sizeof level);\\n        for(auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfs(A,0,-1);\\n        init();\\n        int res = INT_MAX;\\n        for(int i = 1; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                int lca = query(i,j);\\n                int a, b, c;\\n                if(lca == i) {\\n                    a = val[0] ^ val[i], b = val[i] ^ val[j], c = val[j]; \\n                } else if(lca == j) {\\n                    a = val[0] ^ val[j], b = val[j] ^ val[i], c = val[i];\\n                } else {\\n                    a = val[0] ^ val[i] ^ val[j], b = val[i], c = val[j];\\n                }\\n                int ma = max({a,b,c}), mi = min({a,b,c});\\n                res = min(res, ma - mi);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202430,
                "title": "most-easily-readable-java-solution-from-larry",
                "content": "https://www.youtube.com/watch?v=hZRn3ZL0NVE\\nI followed his explanation, which was the clearest one I could find. \\nI added comments -> TC : O(N^2).\\n\\nThe one thing is that if you use list instead of set as descendants, you get into a TLE at large cases. I don\\'t get it it is a loop or a performance issue.\\nEdit: probably due to lookup in List is slower (O(N)) instead of set.\\n```\\n\\nclass Solution {\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        \\n        // 1.) Compute the adjacency table. Contains all paths, (including to root, must be filtered out later).\\n        Map<Integer, List<Integer>> adjGraph = computeAdjGraph(edges);\\n        \\n        // 2.) Know compute the total Xors of each node DFS style.\\n        Map<Integer, Integer> xorMap = new HashMap<>();\\n        computeNodeXorDfs(0, -1, nums, xorMap, adjGraph);\\n        int rootXor = xorMap.get(0);\\n        \\n        // 3.) Before computing all XORs in O(N^2) fashion, we want to compute a list of nodes of ascendant, descendant relationships.\\n            // Here we have to chose a SET instead of a list -> else we will run into TLS, obviously there are some duplicates.\\n        Map<Integer, Set<Integer>> descendants = new HashMap<>();\\n        Set<Integer> rootChildren = computeDescendants(0, -1, descendants, adjGraph);\\n        \\n        // 4.) We can check now the parent <-> child relationships. \\n            // Compute each node under the root (not the root itself) for the following conditions:\\n                // node_i is parent of node_j\\n                    // rootXor = total ^ node_i (removing node_i from total)\\n                    // xor1 = node_i^ node_j (removing node_j from node_i)\\n                    // xor2 = node_j\\n                // node_j is parent of node_i\\n                    // rootXor = total ^ node_j (removing node_j from total)\\n                    // xor1 = node_j^ node_i (removing node_i from node_j)\\n                    // xor2 = node_i\\n                // node_j & node_i belong to different parents.\\n                    // rootXor = total ^ node_j^ nodE_i (removing node_i & node_j from total)\\n                    // xor1 = node_i\\n                    // xor2 = node_j\\n        \\n        int minScore = Integer.MAX_VALUE;\\n        \\n        for(int i = 1; i < adjGraph.keySet().size(); i++){\\n            for(int j = i+1; j < adjGraph.keySet().size(); j++){\\n                // Is node_i parent of node_j\\n                if(descendants.get(i).contains(j)){\\n                    int rootXor1 =  rootXor ^ xorMap.get(i);\\n                    int xor1 = xorMap.get(i) ^ xorMap.get(j);\\n                    int xor2 = xorMap.get(j);\\n                    int maxValue = Math.max(rootXor1, Math.max(xor1, xor2));\\n                    int minValue = Math.min(rootXor1, Math.min(xor1, xor2));\\n                    minScore = Math.min(minScore, maxValue - minValue);\\n                } else if(descendants.get(j).contains(i)){\\n                    int rootXor1 =  rootXor ^ xorMap.get(j);\\n                    int xor1 = xorMap.get(j) ^ xorMap.get(i);\\n                    int xor2 = xorMap.get(i);\\n                    int maxValue = Math.max(rootXor1, Math.max(xor1, xor2));\\n                    int minValue = Math.min(rootXor1, Math.min(xor1, xor2));\\n                    minScore = Math.min(minScore, maxValue - minValue);\\n                } else {\\n                    int rootXor1 =  rootXor ^ (xorMap.get(i) ^ xorMap.get(j));\\n                    int xor1 = xorMap.get(i);\\n                    int xor2 = xorMap.get(j);\\n                    int maxValue = Math.max(rootXor1, Math.max(xor1, xor2));\\n                    int minValue = Math.min(rootXor1, Math.min(xor1, xor2));\\n                    minScore = Math.min(minScore, maxValue - minValue);\\n                }\\n            }\\n        }\\n        \\n        \\n        return minScore;\\n    }\\n    \\n    Set<Integer> computeDescendants(int src, int parent, Map<Integer, Set<Integer>> descendants, Map<Integer, List<Integer>> adjGraph){\\n        \\n        Set<Integer> childrenOfNode = new HashSet<>();\\n        \\n        for(int child : adjGraph.get(src)){\\n            if(child != parent){\\n                // add the child node\\n                childrenOfNode.add(child);\\n                // add all its children.\\n                childrenOfNode.addAll(computeDescendants(child, src, descendants, adjGraph));\\n            }    \\n        }\\n        \\n        descendants.put(src, childrenOfNode);\\n        return childrenOfNode;\\n    }\\n        \\n    int computeNodeXorDfs(int src, int parent, int[] nums, Map<Integer, Integer> xorMap, Map<Integer, List<Integer>> adjGraph){\\n        \\n        int srcXor = nums[src];\\n        \\n        for(int child : adjGraph.get(src)){\\n            if(child != parent)\\n                srcXor ^= computeNodeXorDfs(child, src, nums, xorMap, adjGraph);\\n        }\\n        \\n        xorMap.put(src, srcXor);\\n        return srcXor;\\n    }\\n    \\n    Map<Integer, List<Integer>> computeAdjGraph(int[][] edges){\\n     \\n        Map<Integer, List<Integer>> adjGraph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            int v1 = edge[0];\\n            int v2 = edge[1];\\n            \\n            if(!adjGraph.containsKey(v1)){\\n                adjGraph.put(v1, new ArrayList<>());\\n            }\\n            \\n            if(!adjGraph.containsKey(v2)){\\n                adjGraph.put(v2, new ArrayList<>());\\n            }\\n            adjGraph.get(v1).add(v2);\\n            adjGraph.get(v2).add(v1);\\n        }\\n        return adjGraph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        \\n        // 1.) Compute the adjacency table. Contains all paths, (including to root, must be filtered out later).\\n        Map<Integer, List<Integer>> adjGraph = computeAdjGraph(edges);\\n        \\n        // 2.) Know compute the total Xors of each node DFS style.\\n        Map<Integer, Integer> xorMap = new HashMap<>();\\n        computeNodeXorDfs(0, -1, nums, xorMap, adjGraph);\\n        int rootXor = xorMap.get(0);\\n        \\n        // 3.) Before computing all XORs in O(N^2) fashion, we want to compute a list of nodes of ascendant, descendant relationships.\\n            // Here we have to chose a SET instead of a list -> else we will run into TLS, obviously there are some duplicates.\\n        Map<Integer, Set<Integer>> descendants = new HashMap<>();\\n        Set<Integer> rootChildren = computeDescendants(0, -1, descendants, adjGraph);\\n        \\n        // 4.) We can check now the parent <-> child relationships. \\n            // Compute each node under the root (not the root itself) for the following conditions:\\n                // node_i is parent of node_j\\n                    // rootXor = total ^ node_i (removing node_i from total)\\n                    // xor1 = node_i^ node_j (removing node_j from node_i)\\n                    // xor2 = node_j\\n                // node_j is parent of node_i\\n                    // rootXor = total ^ node_j (removing node_j from total)\\n                    // xor1 = node_j^ node_i (removing node_i from node_j)\\n                    // xor2 = node_i\\n                // node_j & node_i belong to different parents.\\n                    // rootXor = total ^ node_j^ nodE_i (removing node_i & node_j from total)\\n                    // xor1 = node_i\\n                    // xor2 = node_j\\n        \\n        int minScore = Integer.MAX_VALUE;\\n        \\n        for(int i = 1; i < adjGraph.keySet().size(); i++){\\n            for(int j = i+1; j < adjGraph.keySet().size(); j++){\\n                // Is node_i parent of node_j\\n                if(descendants.get(i).contains(j)){\\n                    int rootXor1 =  rootXor ^ xorMap.get(i);\\n                    int xor1 = xorMap.get(i) ^ xorMap.get(j);\\n                    int xor2 = xorMap.get(j);\\n                    int maxValue = Math.max(rootXor1, Math.max(xor1, xor2));\\n                    int minValue = Math.min(rootXor1, Math.min(xor1, xor2));\\n                    minScore = Math.min(minScore, maxValue - minValue);\\n                } else if(descendants.get(j).contains(i)){\\n                    int rootXor1 =  rootXor ^ xorMap.get(j);\\n                    int xor1 = xorMap.get(j) ^ xorMap.get(i);\\n                    int xor2 = xorMap.get(i);\\n                    int maxValue = Math.max(rootXor1, Math.max(xor1, xor2));\\n                    int minValue = Math.min(rootXor1, Math.min(xor1, xor2));\\n                    minScore = Math.min(minScore, maxValue - minValue);\\n                } else {\\n                    int rootXor1 =  rootXor ^ (xorMap.get(i) ^ xorMap.get(j));\\n                    int xor1 = xorMap.get(i);\\n                    int xor2 = xorMap.get(j);\\n                    int maxValue = Math.max(rootXor1, Math.max(xor1, xor2));\\n                    int minValue = Math.min(rootXor1, Math.min(xor1, xor2));\\n                    minScore = Math.min(minScore, maxValue - minValue);\\n                }\\n            }\\n        }\\n        \\n        \\n        return minScore;\\n    }\\n    \\n    Set<Integer> computeDescendants(int src, int parent, Map<Integer, Set<Integer>> descendants, Map<Integer, List<Integer>> adjGraph){\\n        \\n        Set<Integer> childrenOfNode = new HashSet<>();\\n        \\n        for(int child : adjGraph.get(src)){\\n            if(child != parent){\\n                // add the child node\\n                childrenOfNode.add(child);\\n                // add all its children.\\n                childrenOfNode.addAll(computeDescendants(child, src, descendants, adjGraph));\\n            }    \\n        }\\n        \\n        descendants.put(src, childrenOfNode);\\n        return childrenOfNode;\\n    }\\n        \\n    int computeNodeXorDfs(int src, int parent, int[] nums, Map<Integer, Integer> xorMap, Map<Integer, List<Integer>> adjGraph){\\n        \\n        int srcXor = nums[src];\\n        \\n        for(int child : adjGraph.get(src)){\\n            if(child != parent)\\n                srcXor ^= computeNodeXorDfs(child, src, nums, xorMap, adjGraph);\\n        }\\n        \\n        xorMap.put(src, srcXor);\\n        return srcXor;\\n    }\\n    \\n    Map<Integer, List<Integer>> computeAdjGraph(int[][] edges){\\n     \\n        Map<Integer, List<Integer>> adjGraph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            int v1 = edge[0];\\n            int v2 = edge[1];\\n            \\n            if(!adjGraph.containsKey(v1)){\\n                adjGraph.put(v1, new ArrayList<>());\\n            }\\n            \\n            if(!adjGraph.containsKey(v2)){\\n                adjGraph.put(v2, new ArrayList<>());\\n            }\\n            adjGraph.get(v1).add(v2);\\n            adjGraph.get(v2).add(v1);\\n        }\\n        return adjGraph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200989,
                "title": "c-single-dfs-easy-to-understand",
                "content": "**Intution**\\n\\nFor every pair of edge we can calculate the XOR of the three components if we remove the two edges.\\nConstraints ```3 <= n <= 1000``` that means we can go for an ```O(n^2)``` solution.\\nBut if we try to remove every pair of edge and calculate the XORs then it will take ```O(n^3)``` time.\\n(```O(n^2)``` for selecting every pair of edge and ```O(n)``` for DFS or BFS to calculate XOR of three components.\\n\\nThen what should we do to make it ```O(n^2)``` ?\\n\\n**Explanation**\\n\\nUsing DFS :\\n1. Calculate XOR of all node\\'s values and store it in ```txr```.\\n2. For a subtree calculate the XOR for every subtree in it.\\n3. For every child of current node we have two arrays one in which the XOR of all subtrees of current child (```x```) and another having XOR of all subtrees of previous childs till calculated (```xrs```).\\n4. Calculate XOR for every pair in these two arrays.\\n5. Also calculate XOR for edge connecting this child to its parent and all edges of its child (```x```).\\n6. Merge the array ```x``` into ```xrs```.\\n7. Return this array to its parent for further calculation.\\n\\n\\n![image](https://assets.leetcode.com/users/images/e4de4d86-31f7-400c-96da-9dcf28717e70_1656252104.181848.jpeg)\\n\\nFor every edge in set ```B``` we can select an edge form set ```A``` and calculate the ans.\\nAnd also for every edge in ```B``` and its parent edge ```D``` we will have to calculate.\\n\\n\\n**Time Complexity**\\n\\n```O(n^2)``` as we are calculating ans for every pair of edge and only one DFS call.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int src, vector<int> gr[], vector<int> &a, int par, int &ans, int &txr){\\n        int xr = 0;\\n        //get the XOR\\'s of all the children subtrees;\\n        vector<int> xrs;\\n        for(int &nbr : gr[src]){\\n            if(nbr != par){\\n                vector<int> x = dfs(nbr, gr, a, src, ans, txr);\\n                xr ^= x[x.size()-1];\\n                \\n                //below u, v and w are 3 XOR values;\\n                \\n                //for all subtrees check for any two edges in two different subtrees;\\n                for(int &u : x){\\n                    for(int &v : xrs){\\n                        int w = txr^u^v;\\n                        int uu = max({u, v, w});\\n                        int vv = min({u, v, w});\\n                        ans = min(ans, uu-vv);\\n                    }\\n                }\\n                \\n                //check for edge between its parent and any of its child nodes;\\n                for(int i=0; i<x.size()-1; i++){\\n                    int u = x[i];\\n                    int v = x[x.size()-1]^u;\\n                    int w = txr^x[x.size()-1];\\n                    int uu = max({u, v, w});\\n                    int vv = min({u, v, w});\\n                    ans = min(ans, uu-vv);\\n                    \\n                }\\n                for(int &u : x) xrs.push_back(u);\\n            }\\n        }\\n        xr ^= a[src];\\n        xrs.push_back(xr);\\n        return xrs;\\n    }\\n    int minimumScore(vector<int>& a, vector<vector<int>>& edges) {\\n        int txr = 0, ans = INT_MAX;\\n        \\n        //calculate XOR of whole tree;\\n        for(int &x : a) txr ^= x;\\n        \\n        vector<int> gr[a.size()];\\n        for(auto &e : edges){\\n            gr[e[0]].push_back(e[1]);\\n            gr[e[1]].push_back(e[0]);\\n        }\\n        \\n        dfs(0, gr, a, -1, ans, txr);\\n        return ans;\\n    }\\n};\\n```\\n\\nIf this approach helped you, please consider giving it a like :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```3 <= n <= 1000```\n```O(n^2)```\n```O(n^3)```\n```O(n^2)```\n```O(n)```\n```O(n^2)```\n```txr```\n```x```\n```xrs```\n```x```\n```x```\n```xrs```\n```B```\n```A```\n```B```\n```D```\n```O(n^2)```\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int src, vector<int> gr[], vector<int> &a, int par, int &ans, int &txr){\\n        int xr = 0;\\n        //get the XOR\\'s of all the children subtrees;\\n        vector<int> xrs;\\n        for(int &nbr : gr[src]){\\n            if(nbr != par){\\n                vector<int> x = dfs(nbr, gr, a, src, ans, txr);\\n                xr ^= x[x.size()-1];\\n                \\n                //below u, v and w are 3 XOR values;\\n                \\n                //for all subtrees check for any two edges in two different subtrees;\\n                for(int &u : x){\\n                    for(int &v : xrs){\\n                        int w = txr^u^v;\\n                        int uu = max({u, v, w});\\n                        int vv = min({u, v, w});\\n                        ans = min(ans, uu-vv);\\n                    }\\n                }\\n                \\n                //check for edge between its parent and any of its child nodes;\\n                for(int i=0; i<x.size()-1; i++){\\n                    int u = x[i];\\n                    int v = x[x.size()-1]^u;\\n                    int w = txr^x[x.size()-1];\\n                    int uu = max({u, v, w});\\n                    int vv = min({u, v, w});\\n                    ans = min(ans, uu-vv);\\n                    \\n                }\\n                for(int &u : x) xrs.push_back(u);\\n            }\\n        }\\n        xr ^= a[src];\\n        xrs.push_back(xr);\\n        return xrs;\\n    }\\n    int minimumScore(vector<int>& a, vector<vector<int>>& edges) {\\n        int txr = 0, ans = INT_MAX;\\n        \\n        //calculate XOR of whole tree;\\n        for(int &x : a) txr ^= x;\\n        \\n        vector<int> gr[a.size()];\\n        for(auto &e : edges){\\n            gr[e[0]].push_back(e[1]);\\n            gr[e[1]].push_back(e[0]);\\n        }\\n        \\n        dfs(0, gr, a, -1, ans, txr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199799,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs1(int node, vector<int> &nums, vector<vector<int> > &graph, int p) {\\n        int ans = nums[node];\\n        for(auto nbr : graph[node]) {\\n            if(nbr == p) continue;\\n            ans ^= dfs1(nbr, nums, graph, node);\\n        }\\n        return ans;\\n    }\\n    int dfs2(int node, vector<int> &nums, vector<vector<int> > &graph, int val1, int val2, int &res, int p) {\\n        int ans = nums[node];\\n        for(auto nbr : graph[node]) {\\n            if(nbr == p) continue;\\n            int x = dfs2(nbr, nums, graph, val1, val2, res, node);\\n            res = min(res, max(x, max(val1^x, val2))-min(x, min(val1^x, val2)));\\n            ans ^= x;\\n        }\\n        return ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int> > graph(n);\\n        for(auto e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        int res = INT_MAX;\\n        for(auto e : edges) {\\n            auto it1 = find(graph[e[0]].begin(), graph[e[0]].end(), e[1]);\\n            auto it2 = find(graph[e[1]].begin(), graph[e[1]].end(), e[0]);\\n            graph[e[0]].erase(it1);\\n            graph[e[1]].erase(it2);\\n            int Xor1 = dfs1(e[0], nums, graph, -1);\\n            int Xor2 = dfs1(e[1], nums, graph, -1);\\n            int x = dfs2(e[0], nums, graph, Xor1, Xor2, res, -1);\\n            int y = dfs2(e[1], nums, graph, Xor2, Xor1, res, -1);\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs1(int node, vector<int> &nums, vector<vector<int> > &graph, int p) {\\n        int ans = nums[node];\\n        for(auto nbr : graph[node]) {\\n            if(nbr == p) continue;\\n            ans ^= dfs1(nbr, nums, graph, node);\\n        }\\n        return ans;\\n    }\\n    int dfs2(int node, vector<int> &nums, vector<vector<int> > &graph, int val1, int val2, int &res, int p) {\\n        int ans = nums[node];\\n        for(auto nbr : graph[node]) {\\n            if(nbr == p) continue;\\n            int x = dfs2(nbr, nums, graph, val1, val2, res, node);\\n            res = min(res, max(x, max(val1^x, val2))-min(x, min(val1^x, val2)));\\n            ans ^= x;\\n        }\\n        return ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int> > graph(n);\\n        for(auto e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        int res = INT_MAX;\\n        for(auto e : edges) {\\n            auto it1 = find(graph[e[0]].begin(), graph[e[0]].end(), e[1]);\\n            auto it2 = find(graph[e[1]].begin(), graph[e[1]].end(), e[0]);\\n            graph[e[0]].erase(it1);\\n            graph[e[1]].erase(it2);\\n            int Xor1 = dfs1(e[0], nums, graph, -1);\\n            int Xor2 = dfs1(e[1], nums, graph, -1);\\n            int x = dfs2(e[0], nums, graph, Xor1, Xor2, res, -1);\\n            int y = dfs2(e[1], nums, graph, Xor2, Xor1, res, -1);\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198672,
                "title": "clean-c-code-with-explanation",
                "content": "First of all make a tree of any root I take here 0 for simplicity\\nFor every edge we can break whole tree in 2 component\\nfor every [u,v] we get 2 componets \\n        => rooted at v\\n        => other than 1st component\\nNow every component we again break into 2 component\\n\\nkeep a ans \\nreturn the minimum ans;\\nRest code is commented\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int i,int par,vector<int>& v,vector<int> &p){\\n        p[i]=par;\\n        for(auto j: adj[i]){\\n            if(j==par) continue;\\n            dfs(adj,j,i,v,p);\\n            v[i]^=v[j];\\n        }\\n    }\\n\\n    // a= xor of all elemnts of component\\n    // b=xor of rest elements\\n    // this function will also return XOR of all elemts in component rooted at i\\n\\n    int dfs2(vector<int> adj[],int i,int par,vector<int>& nums,int &ans,int a,int b){\\n        int res=nums[i];\\n        for(auto j: adj[i]){\\n            if(j==par) continue;\\n            int z=dfs2(adj,j,i,nums,ans,a,b);\\n            res^=z;\\n            int x=z;\\n            int y=a^x;\\n            int Max=max(x,max(y,b));\\n            int Min=min(x,min(y,b));\\n            ans=min(ans,abs(Max-Min));\\n        }\\n        return res;\\n    }\\n\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<int> adj[n];\\n        vector<int> p(n,-1);\\n        vector<int> v(nums.begin(), nums.end());\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        // a dfs to make parent array \\n        // i assume root to 0 \\n        dfs(adj,0,-1,v,p);\\n        int ans=INT_MAX;\\n        int total=v[0];\\n\\n        for(auto i: edges){\\n\\t\\t // for [u,v]  u can be parent of v or v can be parent of u ,we have to check for it\\n                if(p[i[0]]==i[1]){         \\n                dfs2(adj,i[0],i[1],nums,ans,v[i[0]],total^v[i[0]]);\\n                dfs2(adj,i[1],i[0],nums,ans,total^v[i[0]],v[i[0]]);\\n            }else{\\n                dfs2(adj,i[1],i[0],nums,ans,v[i[1]],total^v[i[1]]);\\n                dfs2(adj,i[0],i[1],nums,ans,total^v[i[1]],v[i[1]]);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helps\\nComment down if any query\\nThanks",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int i,int par,vector<int>& v,vector<int> &p){\\n        p[i]=par;\\n        for(auto j: adj[i]){\\n            if(j==par) continue;\\n            dfs(adj,j,i,v,p);\\n            v[i]^=v[j];\\n        }\\n    }\\n\\n    // a= xor of all elemnts of component\\n    // b=xor of rest elements\\n    // this function will also return XOR of all elemts in component rooted at i\\n\\n    int dfs2(vector<int> adj[],int i,int par,vector<int>& nums,int &ans,int a,int b){\\n        int res=nums[i];\\n        for(auto j: adj[i]){\\n            if(j==par) continue;\\n            int z=dfs2(adj,j,i,nums,ans,a,b);\\n            res^=z;\\n            int x=z;\\n            int y=a^x;\\n            int Max=max(x,max(y,b));\\n            int Min=min(x,min(y,b));\\n            ans=min(ans,abs(Max-Min));\\n        }\\n        return res;\\n    }\\n\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<int> adj[n];\\n        vector<int> p(n,-1);\\n        vector<int> v(nums.begin(), nums.end());\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        // a dfs to make parent array \\n        // i assume root to 0 \\n        dfs(adj,0,-1,v,p);\\n        int ans=INT_MAX;\\n        int total=v[0];\\n\\n        for(auto i: edges){\\n\\t\\t // for [u,v]  u can be parent of v or v can be parent of u ,we have to check for it\\n                if(p[i[0]]==i[1]){         \\n                dfs2(adj,i[0],i[1],nums,ans,v[i[0]],total^v[i[0]]);\\n                dfs2(adj,i[1],i[0],nums,ans,total^v[i[0]],v[i[0]]);\\n            }else{\\n                dfs2(adj,i[1],i[0],nums,ans,v[i[1]],total^v[i[1]]);\\n                dfs2(adj,i[0],i[1],nums,ans,total^v[i[1]],v[i[1]]);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198207,
                "title": "c-explained-without-lca-explicitily",
                "content": "Explanation:\\n\\n1.) We will check with each pair of edges.\\n2.) xors[i] will calculate xor of subtree rooted at i.\\n3.) subs[i] will contain all the nodes in the subtree of i.\\n4.) above two artifacts can be calculted using simple dfs(postorder traversal)\\n5.) Next check if one of them is lca of other using subs.\\n\\nPLease Upvote if you liked.!!\\n\\nAlso correct me in comments or ask anything if you want to.\\n```\\nclass Solution {\\npublic:\\n    vector <vector<int>> g;\\n    int n;\\n    vector<int> a, p, xors;\\n    vector <unordered_set<int>> subs;\\n    void dfs(int x, int par) {\\n      p[x] = par;\\n      xors[x] = a[x];\\n      subs[x].insert(x);\\n      for (auto it : g[x]) {\\n        if (it != par) {\\n          dfs(it, x);\\n        }\\n      }\\n      for (auto it : g[x]) {\\n        if (it != par) {\\n          xors[x] ^= xors[it];\\n          for (auto in : subs[it]) {\\n            subs[x].insert(in);\\n          }\\n        }\\n      }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& e) {\\n        a = nums;\\n        n = a.size();\\n        g.resize(n);\\n        for (auto ee : e) {\\n          g[ee[0]].push_back(ee[1]);\\n          g[ee[1]].push_back(ee[0]);\\n        }\\n        int root = 0;\\n        p.assign(n, -1);\\n        xors.assign(n, 0);\\n        subs.resize(n);\\n        dfs(root, -1);\\n        /*\\n        debugging\\n        for (int i = 0; i < n; ++i) {\\n            cout << i << \" :\";\\n            for (auto it : subs[i]) {\\n                cout << it << \" \";\\n            }\\n            cout << \\'\\\\n\\';\\n        }\\n        */\\n        // number of edges\\n        int m = e.size();\\n        int tot_xor = 0;\\n        for (int i = 0; i < n; ++i) {\\n          tot_xor ^= a[i];\\n        }\\n        int ans = 2e9;\\n        for (int i = 0; i < m; ++i) {\\n          for (int j = i + 1; j < m; ++j) {\\n            int x = (p[e[i][0]] == e[i][1]) ? e[i][0] : e[i][1];\\n            int y = (p[e[j][0]] == e[j][1]) ? e[j][0] : e[j][1];\\n            int x_xor = xors[x];\\n            int y_xor = xors[y];\\n            if (subs[x].count(y)) {\\n              x_xor ^= y_xor;\\n            } else if (subs[y].count(x)) {\\n              y_xor ^= x_xor;\\n            }\\n            int rem_xor = tot_xor ^ x_xor ^ y_xor;\\n            int mx = max({x_xor, y_xor, rem_xor});\\n            int mn = min({x_xor, y_xor, rem_xor});\\n            ans = min(ans, mx - mn);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <vector<int>> g;\\n    int n;\\n    vector<int> a, p, xors;\\n    vector <unordered_set<int>> subs;\\n    void dfs(int x, int par) {\\n      p[x] = par;\\n      xors[x] = a[x];\\n      subs[x].insert(x);\\n      for (auto it : g[x]) {\\n        if (it != par) {\\n          dfs(it, x);\\n        }\\n      }\\n      for (auto it : g[x]) {\\n        if (it != par) {\\n          xors[x] ^= xors[it];\\n          for (auto in : subs[it]) {\\n            subs[x].insert(in);\\n          }\\n        }\\n      }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& e) {\\n        a = nums;\\n        n = a.size();\\n        g.resize(n);\\n        for (auto ee : e) {\\n          g[ee[0]].push_back(ee[1]);\\n          g[ee[1]].push_back(ee[0]);\\n        }\\n        int root = 0;\\n        p.assign(n, -1);\\n        xors.assign(n, 0);\\n        subs.resize(n);\\n        dfs(root, -1);\\n        /*\\n        debugging\\n        for (int i = 0; i < n; ++i) {\\n            cout << i << \" :\";\\n            for (auto it : subs[i]) {\\n                cout << it << \" \";\\n            }\\n            cout << \\'\\\\n\\';\\n        }\\n        */\\n        // number of edges\\n        int m = e.size();\\n        int tot_xor = 0;\\n        for (int i = 0; i < n; ++i) {\\n          tot_xor ^= a[i];\\n        }\\n        int ans = 2e9;\\n        for (int i = 0; i < m; ++i) {\\n          for (int j = i + 1; j < m; ++j) {\\n            int x = (p[e[i][0]] == e[i][1]) ? e[i][0] : e[i][1];\\n            int y = (p[e[j][0]] == e[j][1]) ? e[j][0] : e[j][1];\\n            int x_xor = xors[x];\\n            int y_xor = xors[y];\\n            if (subs[x].count(y)) {\\n              x_xor ^= y_xor;\\n            } else if (subs[y].count(x)) {\\n              y_xor ^= x_xor;\\n            }\\n            int rem_xor = tot_xor ^ x_xor ^ y_xor;\\n            int mx = max({x_xor, y_xor, rem_xor});\\n            int mn = min({x_xor, y_xor, rem_xor});\\n            ans = min(ans, mx - mn);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3732061,
                "title": "no-bit-manipulation-no-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, int nod, vector<int> &par){\\n        for(auto it: adj[nod]){\\n            if(par[it]==-1){\\n                par[it]=nod;\\n                dfs(adj,it,par);\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(nums.size());\\n        vector<int> deg(nums.size());\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n\\n        int root=0;\\n        queue<int> q;\\n        for(int i=0;i<deg.size();i++){\\n            if(deg[i]==1&&i!=root){\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> vis(nums.size(),0);\\n        vector<int> val(nums.size(),0);\\n        vector<vector<int>> lvled;\\n        while(!q.empty()){\\n            int nod=q.front();\\n            val[nod]=val[nod]^nums[nod];\\n            vis[nod]=1;\\n            q.pop();\\n            for(auto it: adj[nod]){\\n                if(!vis[it]){\\n                    vector<int> tem={nod,it};\\n                    lvled.push_back(tem);\\n                    deg[it]--;\\n                    val[it]=val[it]^val[nod];\\n                    if(deg[it]==1&&it!=root){\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            //cout<<nod<<\" \"<<val[nod]<<\\'\\\\n\\';\\n        }\\n        val[0]=nums[0]^val[0];\\n\\n\\n        vector<int> par(nums.size(),-1);\\n        par[0]=-2;\\n        dfs(adj,0,par);\\n\\n        // for(int i=0;i<lvled.size();i++){\\n        //     cout<<lvled[i][0]<<\" \"<<lvled[i][1]<<\\'\\\\n\\';\\n        // }\\n\\n        int mini=INT_MAX;\\n        for(int i=0;i<lvled.size();i++){\\n            vector<int> tval=val;\\n            int tn=lvled[i][0];\\n            while(tn!=0){\\n                tval[par[tn]]=tval[par[tn]]^tval[lvled[i][0]];\\n                tn=par[tn];\\n            }\\n            // if(lvled[i][0]==2){\\n            //     cout<<tval[2]<<\" \"<<tval[1]<<\" \"<<tval[0]<<\" \";\\n            // }\\n            \\n            int v1=tval[lvled[i][0]];\\n            for(int j=i+1;j<lvled.size();j++){\\n                int v2=tval[lvled[j][0]];\\n                int v3=tval[0]^v2;\\n                mini=min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                // if(lvled[i][0]==2){\\n                //     cout<<v1<<\" \"<<v2<<\" \"<<v3<<\\'\\\\n\\';\\n                // }\\n            }\\n            \\n        }\\n        \\n        return mini;\\n\\n        //return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, int nod, vector<int> &par){\\n        for(auto it: adj[nod]){\\n            if(par[it]==-1){\\n                par[it]=nod;\\n                dfs(adj,it,par);\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(nums.size());\\n        vector<int> deg(nums.size());\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n\\n        int root=0;\\n        queue<int> q;\\n        for(int i=0;i<deg.size();i++){\\n            if(deg[i]==1&&i!=root){\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> vis(nums.size(),0);\\n        vector<int> val(nums.size(),0);\\n        vector<vector<int>> lvled;\\n        while(!q.empty()){\\n            int nod=q.front();\\n            val[nod]=val[nod]^nums[nod];\\n            vis[nod]=1;\\n            q.pop();\\n            for(auto it: adj[nod]){\\n                if(!vis[it]){\\n                    vector<int> tem={nod,it};\\n                    lvled.push_back(tem);\\n                    deg[it]--;\\n                    val[it]=val[it]^val[nod];\\n                    if(deg[it]==1&&it!=root){\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            //cout<<nod<<\" \"<<val[nod]<<\\'\\\\n\\';\\n        }\\n        val[0]=nums[0]^val[0];\\n\\n\\n        vector<int> par(nums.size(),-1);\\n        par[0]=-2;\\n        dfs(adj,0,par);\\n\\n        // for(int i=0;i<lvled.size();i++){\\n        //     cout<<lvled[i][0]<<\" \"<<lvled[i][1]<<\\'\\\\n\\';\\n        // }\\n\\n        int mini=INT_MAX;\\n        for(int i=0;i<lvled.size();i++){\\n            vector<int> tval=val;\\n            int tn=lvled[i][0];\\n            while(tn!=0){\\n                tval[par[tn]]=tval[par[tn]]^tval[lvled[i][0]];\\n                tn=par[tn];\\n            }\\n            // if(lvled[i][0]==2){\\n            //     cout<<tval[2]<<\" \"<<tval[1]<<\" \"<<tval[0]<<\" \";\\n            // }\\n            \\n            int v1=tval[lvled[i][0]];\\n            for(int j=i+1;j<lvled.size();j++){\\n                int v2=tval[lvled[j][0]];\\n                int v3=tval[0]^v2;\\n                mini=min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                // if(lvled[i][0]==2){\\n                //     cout<<v1<<\" \"<<v2<<\" \"<<v3<<\\'\\\\n\\';\\n                // }\\n            }\\n            \\n        }\\n        \\n        return mini;\\n\\n        //return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2514877,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int in[1001],out[1001];\\n    int sub[1001];\\n    int time=1;\\n    vector<int>dp[1001];\\n    void find(int node,vector<int>&nums,int p=-1)\\n    {\\n        in[node]=time++;\\n        sub[node]=nums[node];\\n        for(auto &it:dp[node])\\n        {\\n            if(it!=p)\\n            {\\n               find(it,nums,node);\\n               sub[node]^=sub[it];\\n            }\\n        }\\n        out[node]=time++;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n=nums.size();\\n        for(auto it:edges)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        find(0,nums);\\n        int total=sub[0];\\n        int ans=1e9;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(i==j)\\n                {\\n                    continue;\\n                }\\n                int x=i;\\n                int y=j;\\n                if(in[x]<in[y]&&out[x]>out[y])\\n                {\\n                    int first=sub[y];\\n                    int second=sub[x]^sub[y];\\n                    int third=total^sub[x];\\n                    ans=min({ans,max({first,second,third})-min({first,second,third})});\\n                }\\n                else if(in[x]>in[y]&&out[x]<out[y])\\n                {\\n                     int first=sub[x];\\n                     int second=sub[y]^sub[x];\\n                     int third=total^sub[y];\\n                      ans=min({ans,max({first,second,third})-min({first,second,third})});\\n                }\\n                else\\n                {\\n                    int first=sub[x];\\n                    int second=sub[y];\\n                    int third=total^sub[x]^sub[y];\\n                    ans=min({ans,max({first,second,third})-min({first,second,third})});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int in[1001],out[1001];\\n    int sub[1001];\\n    int time=1;\\n    vector<int>dp[1001];\\n    void find(int node,vector<int>&nums,int p=-1)\\n    {\\n        in[node]=time++;\\n        sub[node]=nums[node];\\n        for(auto &it:dp[node])\\n        {\\n            if(it!=p)\\n            {\\n               find(it,nums,node);\\n               sub[node]^=sub[it];\\n            }\\n        }\\n        out[node]=time++;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n=nums.size();\\n        for(auto it:edges)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        find(0,nums);\\n        int total=sub[0];\\n        int ans=1e9;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(i==j)\\n                {\\n                    continue;\\n                }\\n                int x=i;\\n                int y=j;\\n                if(in[x]<in[y]&&out[x]>out[y])\\n                {\\n                    int first=sub[y];\\n                    int second=sub[x]^sub[y];\\n                    int third=total^sub[x];\\n                    ans=min({ans,max({first,second,third})-min({first,second,third})});\\n                }\\n                else if(in[x]>in[y]&&out[x]<out[y])\\n                {\\n                     int first=sub[x];\\n                     int second=sub[y]^sub[x];\\n                     int third=total^sub[y];\\n                      ans=min({ans,max({first,second,third})-min({first,second,third})});\\n                }\\n                else\\n                {\\n                    int first=sub[x];\\n                    int second=sub[y];\\n                    int third=total^sub[x]^sub[y];\\n                    ans=min({ans,max({first,second,third})-min({first,second,third})});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493392,
                "title": "java-o-n-2-dfs-optimize-parent-node-searching",
                "content": "```\\nclass Solution {\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int len = nums.length;\\n        Set<Integer>[] to = new HashSet[len];\\n        for(int i = 0; i < len; i++) to[i] = new HashSet<>();\\n        for(int[] edge: edges) {\\n            to[edge[0]].add(edge[1]);\\n            to[edge[1]].add(edge[0]);\\n        }\\n        \\n        int[] xors = new int[len];\\n        int[] pa = new int[len];\\n        int total = dfs(pa, to, len, 0, 0, xors, nums);\\n        int ans = -1;\\n        for(int i = 0; i < len; i++) {\\n            to[i].clear();\\n            int p = pa[i];\\n            for(int k = 0; k < len; k++) {\\n                to[i].add(p);\\n                p = pa[p];\\n            }\\n        }\\n        for(int i = 1; i < len; i++) {\\n            for(int j = i + 1; j < len; j++) {\\n                int I = xors[i], J = xors[j], K = total;\\n                if(to[i].contains(j)) {\\n                    J ^= I;\\n                }\\n                else if(to[j].contains(i)) {\\n                    I ^= J;\\n                }\\n                K = K ^ I ^ J;\\n                int diff = Math.max(K, Math.max(J, I)) - Math.min(K, Math.min(J, I));\\n                if(ans == -1 || diff < ans) {\\n                    ans = diff;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(int[] pa, Set<Integer>[] to, int len, int node, int p, int[] xors, int[] nums) {\\n        int xor = nums[node];\\n        pa[node] = p;\\n        for(Integer nei: to[node]) {\\n            if(nei == p) continue;\\n            xor ^= dfs(pa, to, len, nei, node, xors, nums);\\n        }\\n        xors[node] = xor;\\n        return xor;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int len = nums.length;\\n        Set<Integer>[] to = new HashSet[len];\\n        for(int i = 0; i < len; i++) to[i] = new HashSet<>();\\n        for(int[] edge: edges) {\\n            to[edge[0]].add(edge[1]);\\n            to[edge[1]].add(edge[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2351673,
                "title": "99-faster-at-my-time-python3-solution",
                "content": "![image](https://assets.leetcode.com/users/images/1277b664-d19e-40f1-a400-7d06975c94bd_1659114641.2247598.png)\\n\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        s,n=0,len(nums)\\n        for x in nums:\\n            s^=x\\n        es=[[] for _ in range(n)]\\n        for a,b in edges:\\n            es[a].append(b)\\n            es[b].append(a)\\n        def f(a,b,c):\\n            return max(a,b,c)-min(a,b,c)\\n        def dfs(x,par=-1):\\n            S,m,p=[],10**9,nums[x]\\n            for y in es[x]:\\n                if y!=par:\\n                    t,u,v=dfs(y,x)\\n                    m=min(m,u,min(f(s^v,v^k,k) for k in t) if t else u)\\n                    t.add(v)\\n                    S.append(t)\\n                    p^=v\\n            r=set()\\n            for t in S:\\n                r|=t\\n            for i in range(len(S)):\\n                for j in range(i+1,len(S)):\\n                    m=min(m,min(f(s^k^l,k,l) for k in S[i] for l in S[j]))\\n            return r,m,p\\n        return dfs(0)[1]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        s,n=0,len(nums)\\n        for x in nums:\\n            s^=x\\n        es=[[] for _ in range(n)]\\n        for a,b in edges:\\n            es[a].append(b)\\n            es[b].append(a)\\n        def f(a,b,c):\\n            return max(a,b,c)-min(a,b,c)\\n        def dfs(x,par=-1):\\n            S,m,p=[],10**9,nums[x]\\n            for y in es[x]:\\n                if y!=par:\\n                    t,u,v=dfs(y,x)\\n                    m=min(m,u,min(f(s^v,v^k,k) for k in t) if t else u)\\n                    t.add(v)\\n                    S.append(t)\\n                    p^=v\\n            r=set()\\n            for t in S:\\n                r|=t\\n            for i in range(len(S)):\\n                for j in range(i+1,len(S)):\\n                    m=min(m,min(f(s^k^l,k,l) for k in S[i] for l in S[j]))\\n            return r,m,p\\n        return dfs(0)[1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235386,
                "title": "python-go-dfs-memo-w-three-xor-o-n",
                "content": "*Python* solution w/ built-in caching\\n\\n```python\\ndef minimumScore(self, nums, edges):\\n    @functools.cache\\n    def dfs(i, j):\\n        X, x = [], nums[j]\\n        for k in adj[j]:\\n            if k == i: continue\\n            X += dfs(j, k)\\n            x ^= X[-1]\\n        X.append(x)\\n        return X\\n\\n    res, adj = math.inf, [[] for _ in range(len(nums))]\\n    for i, j in edges:\\n        adj[i].append(j)\\n        adj[j].append(i)\\n    for i, j in edges:\\n        X, Y = dfs(i, j), dfs(j, i)\\n        for X, Y in (X, Y), (Y, X):\\n            for x in X[:-1]:\\n                res = min(res, max(x, y := X[-1] ^ x, Y[-1]) - min(x, y, Y[-1]))\\n    return res\\n```\\n\\n*Go* solution w/ handcraft DP memo in 43ms\\n\\n```go\\ntype graph struct {\\n\\tnums []int\\n\\tadj  [][]int\\n\\tdp   map[[2]int][]int\\n}\\n\\nfunc (G *graph) dfs(i, j int) []int {\\n\\te := [2]int{i, j}\\n\\tif _, ok := G.dp[e]; !ok {\\n\\t\\tx := G.nums[j]\\n\\t\\tG.dp[e] = []int{}\\n\\t\\tfor _, k := range G.adj[j] {\\n\\t\\t\\tif k != i {\\n\\t\\t\\t\\tG.dp[e] = append(G.dp[e], G.dfs(j, k)...)\\n\\t\\t\\t\\tx ^= G.dp[e][len(G.dp[e])-1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tG.dp[e] = append(G.dp[e], x)\\n\\t}\\n\\treturn G.dp[e]\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tvar (\\n\\t\\tres = math.MaxInt\\n\\t\\tG   = graph{nums, make([][]int, len(nums)), make(map[[2]int][]int)}\\n\\t)\\n\\tfor _, e := range edges {\\n\\t\\tG.adj[e[0]] = append(G.adj[e[0]], e[1])\\n\\t\\tG.adj[e[1]] = append(G.adj[e[1]], e[0])\\n\\t}\\n\\tfor _, e := range edges {\\n\\t\\tX, Y := G.dfs(e[0], e[1]), G.dfs(e[1], e[0])\\n\\t\\tfor _, Z := range [2][2][]int{[2][]int{X, Y}, [2][]int{Y, X}} {\\n\\t\\t\\tm, n := len(Z[0])-1, len(Z[1])-1\\n\\t\\t\\tfor _, x := range Z[0][:m] {\\n\\t\\t\\t\\ty := Z[0][m] ^ x\\n\\t\\t\\t\\tres = min(res, max(max(x, y), Z[1][n])-min(min(x, y), Z[1][n]))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumScore(self, nums, edges):\\n    @functools.cache\\n    def dfs(i, j):\\n        X, x = [], nums[j]\\n        for k in adj[j]:\\n            if k == i: continue\\n            X += dfs(j, k)\\n            x ^= X[-1]\\n        X.append(x)\\n        return X\\n\\n    res, adj = math.inf, [[] for _ in range(len(nums))]\\n    for i, j in edges:\\n        adj[i].append(j)\\n        adj[j].append(i)\\n    for i, j in edges:\\n        X, Y = dfs(i, j), dfs(j, i)\\n        for X, Y in (X, Y), (Y, X):\\n            for x in X[:-1]:\\n                res = min(res, max(x, y := X[-1] ^ x, Y[-1]) - min(x, y, Y[-1]))\\n    return res\\n```\n```go\\ntype graph struct {\\n\\tnums []int\\n\\tadj  [][]int\\n\\tdp   map[[2]int][]int\\n}\\n\\nfunc (G *graph) dfs(i, j int) []int {\\n\\te := [2]int{i, j}\\n\\tif _, ok := G.dp[e]; !ok {\\n\\t\\tx := G.nums[j]\\n\\t\\tG.dp[e] = []int{}\\n\\t\\tfor _, k := range G.adj[j] {\\n\\t\\t\\tif k != i {\\n\\t\\t\\t\\tG.dp[e] = append(G.dp[e], G.dfs(j, k)...)\\n\\t\\t\\t\\tx ^= G.dp[e][len(G.dp[e])-1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tG.dp[e] = append(G.dp[e], x)\\n\\t}\\n\\treturn G.dp[e]\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tvar (\\n\\t\\tres = math.MaxInt\\n\\t\\tG   = graph{nums, make([][]int, len(nums)), make(map[[2]int][]int)}\\n\\t)\\n\\tfor _, e := range edges {\\n\\t\\tG.adj[e[0]] = append(G.adj[e[0]], e[1])\\n\\t\\tG.adj[e[1]] = append(G.adj[e[1]], e[0])\\n\\t}\\n\\tfor _, e := range edges {\\n\\t\\tX, Y := G.dfs(e[0], e[1]), G.dfs(e[1], e[0])\\n\\t\\tfor _, Z := range [2][2][]int{[2][]int{X, Y}, [2][]int{Y, X}} {\\n\\t\\t\\tm, n := len(Z[0])-1, len(Z[1])-1\\n\\t\\t\\tfor _, x := range Z[0][:m] {\\n\\t\\t\\t\\ty := Z[0][m] ^ x\\n\\t\\t\\t\\tres = min(res, max(max(x, y), Z[1][n])-min(min(x, y), Z[1][n]))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2234754,
                "title": "o-n-log-u-algorithm-c-32ms-100",
                "content": "https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/solution/bi-on2geng-kuai-de-yi-xie-suan-fa-by-hqz-lew0/ (in chinese)\\n![image](https://assets.leetcode.com/users/images/d4dc2de4-602b-4537-a11c-4a9096913c27_1657780948.517953.png)\\n```\\nconst int N=1005,L=27,inf=~0u>>2;\\nstruct node{\\n\\tnode *_l,*_r;\\n\\tint v,min,max;\\n\\tnode(node *_l=0,node *_r=0,int _min=inf,int _max=0)\\n\\t\\t:_l(_l),_r(_r),min(_min),max(_max),v(-1){}\\n\\tnode *l(){return _l;}\\n\\tnode *r(){return _r;}\\n}Pool[N*L*5],*p,*root;\\nnode *t1[N],*t2[N],*t3[N],*t4[N];  //bottom, up, prefix, suffix\\ninline node* newnode(node *l=0,node *r=0,int x=-1){\\n\\tp->_l=l; p->_r=r;\\n\\tif (x==-1){\\n\\t\\tp->min=l?l->min:(r?r->min:inf);\\n\\t\\tp->max=r?r->max:(l?l->max:0);\\n\\t\\tp->v=-1;\\n\\t}\\n\\telse p->v=p->min=p->max=x;\\n\\treturn p++;\\n}\\nnode* merge(node *x,node *y){\\n\\tif (!x||!y)return x?x:y;\\n\\treturn newnode(merge(x->_l,y->_l),merge(x->_r,y->_r),x->v);\\n}\\nnode *insert(node *x,int key,int d=L-1){\\n\\tif (d<0)return x?x:newnode(0,0,key);\\n\\tnode *l=x?x->_l:0,*r=x?x->_r:0;\\n\\tif ((key>>d)&1)return newnode(l,insert(r,key,d-1));\\n\\telse return newnode(insert(l,key,d-1),r);\\n}\\nvoid print(node *x,int key=0,int d=L){\\n\\tif (!x)return;\\n\\tif (!x->_l&&!x->_r)printf(\"%d %d d=%d\\\\n\",key,x->v,d);\\n\\telse print(x->_l,key*2,d-1),print(x->_r,key*2+1,d-1);\\n}\\nint D(node *x){\\n\\treturn !x?-1:max(D(x->_l),D(x->_r))+1;\\n}\\nstruct node3;\\nnode3* newnode3(node *a0,node *a1,node *a2);\\nstruct node3{\\n\\tnode *a[3];\\n\\tint v,min,max;\\n\\tnode3(){}\\n\\tnode3(node *a0,node *a1,node *a2){\\n\\t\\ta[0]=a0; a[1]=a1; a[2]=a2;\\n\\t\\tmin=inf; max=0; v=-1;\\n\\t\\tif (a0)min=::min(min,a0->min),max=::max(max,a0->max),v=a0->v;\\n\\t\\tif (a1)min=::min(min,a1->min),max=::max(max,a1->max),v=a1->v;\\n\\t\\tif (a2)min=::min(min,a2->min),max=::max(max,a2->max),v=a2->v;\\n\\t}\\n\\tnode3 *l(){return newnode3(a[0]?a[0]->_l:0,a[1]?a[1]->_l:0,a[2]?a[2]->_l:0);}\\n\\tnode3 *r(){return newnode3(a[0]?a[0]->_r:0,a[1]?a[1]->_r:0,a[2]?a[2]->_r:0);}\\n}Pool3[N*L*5],*p3;\\ninline node3* newnode3(node *a0,node *a1,node *a2){\\n\\t*p3=node3(a0,a1,a2);\\n\\treturn p3++;\\n}\\ninline bool exist(node *x){return x;}\\ninline bool exist(node3 *x){return x&&(x->a[0]||x->a[1]||x->a[2]);}\\ninline int get(int x,int i){return (x>>i)&1;}\\ninline int msb(int x){return x?31-__builtin_clz(x):-1;}\\nint s_below[N],s,ans,*a;\\nvector<int> e[N];\\nclass Solution {\\npublic:\\n\\tvoid dfs1(int x,int fa){\\n\\t\\ts_below[x]=a[x]; t1[x]=0;\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa){\\n\\t\\t\\t\\tdfs1(y,x);\\n\\t\\t\\t\\ts_below[x]^=s_below[y];\\n\\t\\t\\t\\tt1[x]=merge(t1[x],insert(t1[y],s_below[y]));\\n\\t\\t\\t}\\n\\t}\\n\\tvoid dfs2(int x,int fa,int fa1){\\n\\t\\tif (fa1!=-1)t2[x]=insert(t2[fa],s^s_below[fa]);\\n\\t\\telse t2[x]=0;\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa)dfs2(y,x,fa);\\n\\t}\\n\\tvoid dfs3(int x,int fa){\\n\\t\\tt3[x]=root;\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa)dfs3(y,x);\\n\\t\\troot=insert(root,s_below[x]);\\n\\t}\\n\\tvoid dfs4(int x,int fa){\\n\\t\\tt4[x]=root;\\n\\t\\tfor (int i=e[x].size()-1;i>=0;--i){\\n\\t\\t\\tint y=e[x][i];\\n\\t\\t\\tif (y!=fa)dfs4(y,x);\\n\\t\\t}\\n\\t\\troot=insert(root,s_below[x]);\\n\\t}\\n\\ttemplate<class Tnode>\\n\\tvoid solve(int x,int u,Tnode *root){\\n\\t\\tint v=s^u,d=msb(u);\\n\\t\\tif (!exist(root))return;\\n\\t\\t// 1.1. ((A,B),C), C good. enumerate C. A,B can be the same.\\n\\t\\tfor (int I=1;I<=1;++I){\\n\\t\\t\\tif (d==L-1)break;\\n\\t\\t\\tint i=L-1,pre_dep; Tnode *cur=root,*pre=0;\\n\\t\\t\\tfor (;i>d;--i){\\n\\t\\t\\t\\tif (get(v,i)){\\n\\t\\t\\t\\t\\tif (exist(cur->l()))pre=cur->l(),pre_dep=i-1;\\n\\t\\t\\t\\t\\tif (!exist(cur->r()))break;\\n\\t\\t\\t\\t\\telse cur=cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (!exist(cur->l()))break;\\n\\t\\t\\t\\t\\telse cur=cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// special case: A=B=C\\n\\t\\t\\tif (d==-1&&i==d){\\n\\t\\t\\t\\tans=0; return;\\n\\t\\t\\t}\\n\\t\\t\\tif (!exist(pre))break;\\n\\t\\t\\tfor (i=pre_dep;i>d;--i)\\n\\t\\t\\t\\tpre=exist(pre->r())?pre->r():pre->l();\\n\\t\\t\\tif (d==-1){\\n\\t\\t\\t\\tans=min(ans,v-pre->v);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// 1.1.1. A good\\n\\t\\t\\tif (exist(pre->l()))ans=min(ans,v-pre->l()->max);\\n\\t\\t\\t// 1.1.2. B good\\n\\t\\t\\tif (exist(pre->r())){\\n\\t\\t\\t\\tfor (cur=pre->r(),i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t\\telse cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,v-(u^cur->v));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// 1.2. (A,(B,C)), A good. enumerate A. B,C can be the same.\\n\\t\\tfor (int I=1;I<=1;++I){\\n\\t\\t\\tif (d==L-1)break;\\n\\t\\t\\tint i=L-1,pre_dep; Tnode *cur=root,*pre=0;\\n\\t\\t\\tfor (;i>d;--i){\\n\\t\\t\\t\\tif (!get(v,i)){\\n\\t\\t\\t\\t\\tif (exist(cur->r()))pre=cur->r(),pre_dep=i-1;\\n\\t\\t\\t\\t\\tif (!exist(cur->l()))break;\\n\\t\\t\\t\\t\\telse cur=cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (!exist(cur->r()))break;\\n\\t\\t\\t\\t\\telse cur=cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!exist(pre))break;\\n\\t\\t\\tfor (i=pre_dep;i>d;--i)\\n\\t\\t\\t\\tpre=exist(pre->l())?pre->l():pre->r();\\n\\t\\t\\tif (d==-1){\\n\\t\\t\\t\\tans=min(ans,pre->v-v);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// 1.2.1. C good\\n\\t\\t\\tif (exist(pre->r()))ans=min(ans,pre->r()->min-v);\\n\\t\\t\\t// 1.2.2. B good\\n\\t\\t\\tif (exist(pre->l())){\\n\\t\\t\\t\\tfor (cur=pre->l(),i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t\\telse cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,(u^cur->v)-v);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// 1.3 & 1.4\\n\\t\\tfor (int I=1;I<=1;++I){\\n\\t\\t\\tif (d==-1)break; \\n\\t\\t\\tint i=L-1; Tnode *cur=root;\\n\\t\\t\\tfor (;i>d;--i){\\n\\t\\t\\t\\tif (get(v,i)){\\n\\t\\t\\t\\t\\tif (!exist(cur->r()))break;\\n\\t\\t\\t\\t\\telse cur=cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (!exist(cur->l()))break;\\n\\t\\t\\t\\t\\telse cur=cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (i>d)break;\\n\\t\\t\\t// 1.3. ((A,B),C), A&B good. enumerate A\\n\\t\\t\\tif (!get(v,d)){\\n\\t\\t\\t\\tcur=cur->l();\\n\\t\\t\\t\\tif (!exist(cur)||cur->max<v)break;\\n\\t\\t\\t\\tfor (i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(v,i))cur=cur->r();\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif (get(u,i)){\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->r())){cur=cur->r(); --i; break;}\\n\\t\\t\\t\\t\\t\\t\\telse cur=cur->l(); \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->l())&&cur->l()->max>=v)cur=cur->l();\\n\\t\\t\\t\\t\\t\\t\\telse {cur=cur->r(); --i; break;}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t\\telse cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,(u^cur->v)-v);\\n\\t\\t\\t}\\n\\t\\t\\t// 1.4. (A,(B,C)), B&C good. enumerate C\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcur=cur->r();\\n\\t\\t\\t\\tif (!exist(cur)||cur->min>v)break;\\n\\t\\t\\t\\tfor (i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (!get(v,i))cur=cur->l();\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif (get(u,i)){\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->l())){cur=cur->l(); --i; break;}\\n\\t\\t\\t\\t\\t\\t\\telse cur=cur->r(); \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->r())&&cur->r()->min<=v)cur=cur->r();\\n\\t\\t\\t\\t\\t\\t\\telse {cur=cur->l(); --i; break;}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t\\telse cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,v-(u^cur->v));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint lb(int x){  //lower bound\\n\\t\\tint v=s^x,k=msb(v);\\n\\t\\tif (k<=0)return 0;\\n\\t\\tint l=msb(~v&((1<<k)-1));\\n\\t\\treturn max(l>=0?1<<l:0,x&(1<<k)?x&((1<<k)-1):(1<<k)-(x&((1<<k)-1)));\\n\\t}\\n\\tvoid dfs(int x,int fa){  // Compute the solution.\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa)dfs(y,x);\\n\\t\\t// Case 1. enumerate above x\\n\\t\\tif (lb(s^s_below[x])<ans)solve(x,s_below[x],x?t1[x]:0);\\n\\t\\t// Case 2. enumerate below x\\n\\t\\tif (lb(s_below[x])<ans)solve(x,s^s_below[x],newnode3(t2[x],t3[x],t4[x]));\\n\\t}\\n\\tint minimumScore(vector<int>& _a, vector<vector<int>>& edges) {\\n\\t\\tint n=_a.size();\\n\\t\\ta=&_a[0]; s=0; p=Pool; p3=Pool3; ans=inf;\\n\\t\\tfor (int i=0;i<n;++i)s^=a[i],e[i].clear();\\n\\t\\tfor (auto &e0:edges){\\n\\t\\t\\tint x=e0[0],y=e0[1];\\n\\t\\t\\te[x].push_back(y);\\n\\t\\t\\te[y].push_back(x);\\n\\t\\t}\\n\\t\\tdfs1(0,-1);\\n\\t\\tdfs2(0,-1,-1);\\n\\t\\troot=0; dfs3(0,-1);\\n\\t\\troot=0; dfs4(0,-1);\\n\\t\\tdfs(0,-1);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N=1005,L=27,inf=~0u>>2;\\nstruct node{\\n\\tnode *_l,*_r;\\n\\tint v,min,max;\\n\\tnode(node *_l=0,node *_r=0,int _min=inf,int _max=0)\\n\\t\\t:_l(_l),_r(_r),min(_min),max(_max),v(-1){}\\n\\tnode *l(){return _l;}\\n\\tnode *r(){return _r;}\\n}Pool[N*L*5],*p,*root;\\nnode *t1[N],*t2[N],*t3[N],*t4[N];  //bottom, up, prefix, suffix\\ninline node* newnode(node *l=0,node *r=0,int x=-1){\\n\\tp->_l=l; p->_r=r;\\n\\tif (x==-1){\\n\\t\\tp->min=l?l->min:(r?r->min:inf);\\n\\t\\tp->max=r?r->max:(l?l->max:0);\\n\\t\\tp->v=-1;\\n\\t}\\n\\telse p->v=p->min=p->max=x;\\n\\treturn p++;\\n}\\nnode* merge(node *x,node *y){\\n\\tif (!x||!y)return x?x:y;\\n\\treturn newnode(merge(x->_l,y->_l),merge(x->_r,y->_r),x->v);\\n}\\nnode *insert(node *x,int key,int d=L-1){\\n\\tif (d<0)return x?x:newnode(0,0,key);\\n\\tnode *l=x?x->_l:0,*r=x?x->_r:0;\\n\\tif ((key>>d)&1)return newnode(l,insert(r,key,d-1));\\n\\telse return newnode(insert(l,key,d-1),r);\\n}\\nvoid print(node *x,int key=0,int d=L){\\n\\tif (!x)return;\\n\\tif (!x->_l&&!x->_r)printf(\"%d %d d=%d\\\\n\",key,x->v,d);\\n\\telse print(x->_l,key*2,d-1),print(x->_r,key*2+1,d-1);\\n}\\nint D(node *x){\\n\\treturn !x?-1:max(D(x->_l),D(x->_r))+1;\\n}\\nstruct node3;\\nnode3* newnode3(node *a0,node *a1,node *a2);\\nstruct node3{\\n\\tnode *a[3];\\n\\tint v,min,max;\\n\\tnode3(){}\\n\\tnode3(node *a0,node *a1,node *a2){\\n\\t\\ta[0]=a0; a[1]=a1; a[2]=a2;\\n\\t\\tmin=inf; max=0; v=-1;\\n\\t\\tif (a0)min=::min(min,a0->min),max=::max(max,a0->max),v=a0->v;\\n\\t\\tif (a1)min=::min(min,a1->min),max=::max(max,a1->max),v=a1->v;\\n\\t\\tif (a2)min=::min(min,a2->min),max=::max(max,a2->max),v=a2->v;\\n\\t}\\n\\tnode3 *l(){return newnode3(a[0]?a[0]->_l:0,a[1]?a[1]->_l:0,a[2]?a[2]->_l:0);}\\n\\tnode3 *r(){return newnode3(a[0]?a[0]->_r:0,a[1]?a[1]->_r:0,a[2]?a[2]->_r:0);}\\n}Pool3[N*L*5],*p3;\\ninline node3* newnode3(node *a0,node *a1,node *a2){\\n\\t*p3=node3(a0,a1,a2);\\n\\treturn p3++;\\n}\\ninline bool exist(node *x){return x;}\\ninline bool exist(node3 *x){return x&&(x->a[0]||x->a[1]||x->a[2]);}\\ninline int get(int x,int i){return (x>>i)&1;}\\ninline int msb(int x){return x?31-__builtin_clz(x):-1;}\\nint s_below[N],s,ans,*a;\\nvector<int> e[N];\\nclass Solution {\\npublic:\\n\\tvoid dfs1(int x,int fa){\\n\\t\\ts_below[x]=a[x]; t1[x]=0;\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa){\\n\\t\\t\\t\\tdfs1(y,x);\\n\\t\\t\\t\\ts_below[x]^=s_below[y];\\n\\t\\t\\t\\tt1[x]=merge(t1[x],insert(t1[y],s_below[y]));\\n\\t\\t\\t}\\n\\t}\\n\\tvoid dfs2(int x,int fa,int fa1){\\n\\t\\tif (fa1!=-1)t2[x]=insert(t2[fa],s^s_below[fa]);\\n\\t\\telse t2[x]=0;\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa)dfs2(y,x,fa);\\n\\t}\\n\\tvoid dfs3(int x,int fa){\\n\\t\\tt3[x]=root;\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa)dfs3(y,x);\\n\\t\\troot=insert(root,s_below[x]);\\n\\t}\\n\\tvoid dfs4(int x,int fa){\\n\\t\\tt4[x]=root;\\n\\t\\tfor (int i=e[x].size()-1;i>=0;--i){\\n\\t\\t\\tint y=e[x][i];\\n\\t\\t\\tif (y!=fa)dfs4(y,x);\\n\\t\\t}\\n\\t\\troot=insert(root,s_below[x]);\\n\\t}\\n\\ttemplate<class Tnode>\\n\\tvoid solve(int x,int u,Tnode *root){\\n\\t\\tint v=s^u,d=msb(u);\\n\\t\\tif (!exist(root))return;\\n\\t\\t// 1.1. ((A,B),C), C good. enumerate C. A,B can be the same.\\n\\t\\tfor (int I=1;I<=1;++I){\\n\\t\\t\\tif (d==L-1)break;\\n\\t\\t\\tint i=L-1,pre_dep; Tnode *cur=root,*pre=0;\\n\\t\\t\\tfor (;i>d;--i){\\n\\t\\t\\t\\tif (get(v,i)){\\n\\t\\t\\t\\t\\tif (exist(cur->l()))pre=cur->l(),pre_dep=i-1;\\n\\t\\t\\t\\t\\tif (!exist(cur->r()))break;\\n\\t\\t\\t\\t\\telse cur=cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (!exist(cur->l()))break;\\n\\t\\t\\t\\t\\telse cur=cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// special case: A=B=C\\n\\t\\t\\tif (d==-1&&i==d){\\n\\t\\t\\t\\tans=0; return;\\n\\t\\t\\t}\\n\\t\\t\\tif (!exist(pre))break;\\n\\t\\t\\tfor (i=pre_dep;i>d;--i)\\n\\t\\t\\t\\tpre=exist(pre->r())?pre->r():pre->l();\\n\\t\\t\\tif (d==-1){\\n\\t\\t\\t\\tans=min(ans,v-pre->v);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// 1.1.1. A good\\n\\t\\t\\tif (exist(pre->l()))ans=min(ans,v-pre->l()->max);\\n\\t\\t\\t// 1.1.2. B good\\n\\t\\t\\tif (exist(pre->r())){\\n\\t\\t\\t\\tfor (cur=pre->r(),i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t\\telse cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,v-(u^cur->v));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// 1.2. (A,(B,C)), A good. enumerate A. B,C can be the same.\\n\\t\\tfor (int I=1;I<=1;++I){\\n\\t\\t\\tif (d==L-1)break;\\n\\t\\t\\tint i=L-1,pre_dep; Tnode *cur=root,*pre=0;\\n\\t\\t\\tfor (;i>d;--i){\\n\\t\\t\\t\\tif (!get(v,i)){\\n\\t\\t\\t\\t\\tif (exist(cur->r()))pre=cur->r(),pre_dep=i-1;\\n\\t\\t\\t\\t\\tif (!exist(cur->l()))break;\\n\\t\\t\\t\\t\\telse cur=cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (!exist(cur->r()))break;\\n\\t\\t\\t\\t\\telse cur=cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!exist(pre))break;\\n\\t\\t\\tfor (i=pre_dep;i>d;--i)\\n\\t\\t\\t\\tpre=exist(pre->l())?pre->l():pre->r();\\n\\t\\t\\tif (d==-1){\\n\\t\\t\\t\\tans=min(ans,pre->v-v);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// 1.2.1. C good\\n\\t\\t\\tif (exist(pre->r()))ans=min(ans,pre->r()->min-v);\\n\\t\\t\\t// 1.2.2. B good\\n\\t\\t\\tif (exist(pre->l())){\\n\\t\\t\\t\\tfor (cur=pre->l(),i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t\\telse cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,(u^cur->v)-v);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// 1.3 & 1.4\\n\\t\\tfor (int I=1;I<=1;++I){\\n\\t\\t\\tif (d==-1)break; \\n\\t\\t\\tint i=L-1; Tnode *cur=root;\\n\\t\\t\\tfor (;i>d;--i){\\n\\t\\t\\t\\tif (get(v,i)){\\n\\t\\t\\t\\t\\tif (!exist(cur->r()))break;\\n\\t\\t\\t\\t\\telse cur=cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (!exist(cur->l()))break;\\n\\t\\t\\t\\t\\telse cur=cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (i>d)break;\\n\\t\\t\\t// 1.3. ((A,B),C), A&B good. enumerate A\\n\\t\\t\\tif (!get(v,d)){\\n\\t\\t\\t\\tcur=cur->l();\\n\\t\\t\\t\\tif (!exist(cur)||cur->max<v)break;\\n\\t\\t\\t\\tfor (i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(v,i))cur=cur->r();\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif (get(u,i)){\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->r())){cur=cur->r(); --i; break;}\\n\\t\\t\\t\\t\\t\\t\\telse cur=cur->l(); \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->l())&&cur->l()->max>=v)cur=cur->l();\\n\\t\\t\\t\\t\\t\\t\\telse {cur=cur->r(); --i; break;}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t\\telse cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,(u^cur->v)-v);\\n\\t\\t\\t}\\n\\t\\t\\t// 1.4. (A,(B,C)), B&C good. enumerate C\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcur=cur->r();\\n\\t\\t\\t\\tif (!exist(cur)||cur->min>v)break;\\n\\t\\t\\t\\tfor (i=d-1;i>=0;--i){\\n\\t\\t\\t\\t\\tif (!get(v,i))cur=cur->l();\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif (get(u,i)){\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->l())){cur=cur->l(); --i; break;}\\n\\t\\t\\t\\t\\t\\t\\telse cur=cur->r(); \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tif (exist(cur->r())&&cur->r()->min<=v)cur=cur->r();\\n\\t\\t\\t\\t\\t\\t\\telse {cur=cur->l(); --i; break;}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (;i>=0;--i){\\n\\t\\t\\t\\t\\tif (get(u,i))cur=exist(cur->l())?cur->l():cur->r();\\n\\t\\t\\t\\t\\telse cur=exist(cur->r())?cur->r():cur->l();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=min(ans,v-(u^cur->v));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint lb(int x){  //lower bound\\n\\t\\tint v=s^x,k=msb(v);\\n\\t\\tif (k<=0)return 0;\\n\\t\\tint l=msb(~v&((1<<k)-1));\\n\\t\\treturn max(l>=0?1<<l:0,x&(1<<k)?x&((1<<k)-1):(1<<k)-(x&((1<<k)-1)));\\n\\t}\\n\\tvoid dfs(int x,int fa){  // Compute the solution.\\n\\t\\tfor (int y:e[x])\\n\\t\\t\\tif (y!=fa)dfs(y,x);\\n\\t\\t// Case 1. enumerate above x\\n\\t\\tif (lb(s^s_below[x])<ans)solve(x,s_below[x],x?t1[x]:0);\\n\\t\\t// Case 2. enumerate below x\\n\\t\\tif (lb(s_below[x])<ans)solve(x,s^s_below[x],newnode3(t2[x],t3[x],t4[x]));\\n\\t}\\n\\tint minimumScore(vector<int>& _a, vector<vector<int>>& edges) {\\n\\t\\tint n=_a.size();\\n\\t\\ta=&_a[0]; s=0; p=Pool; p3=Pool3; ans=inf;\\n\\t\\tfor (int i=0;i<n;++i)s^=a[i],e[i].clear();\\n\\t\\tfor (auto &e0:edges){\\n\\t\\t\\tint x=e0[0],y=e0[1];\\n\\t\\t\\te[x].push_back(y);\\n\\t\\t\\te[y].push_back(x);\\n\\t\\t}\\n\\t\\tdfs1(0,-1);\\n\\t\\tdfs2(0,-1,-1);\\n\\t\\troot=0; dfs3(0,-1);\\n\\t\\troot=0; dfs4(0,-1);\\n\\t\\tdfs(0,-1);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223403,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int,int>>record;\\n    vector<vector<int>>G;\\n    vector<int>nums;\\n    int tot,ans;\\n    void cal(int cur,int pre)\\n    {\\n        record[cur][-1]=nums[cur];\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            cal(x,cur);\\n            record[cur][x]=tot^record[x][-1];\\n            record[x][cur]=tot^record[cur][x];\\n            record[cur][-1]^=record[x][-1];\\n        }\\n    }\\n    void dfs(int cur,int pre,int left)\\n    {\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            int v1=record[cur][x]^left;\\n            int v2=left;\\n            int v3=tot^v1^v2;\\n            if(v1<v2)swap(v1,v2);if(v1<v3)swap(v1,v3);\\n            if(v3>v1)swap(v3,v1);if(v3>v2)swap(v3,v2);\\n            ans=min(ans,v1-v3);\\n            dfs(x,cur,left);\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n=nums.size();\\n        this->nums=nums;\\n        tot=0,ans=INT_MAX;\\n        record.clear(),record.resize(n);\\n        G.clear(),G.resize(n);\\n        for(auto &x:nums)tot^=x;\\n        for(auto &x:edges)G[x[0]].push_back(x[1]),G[x[1]].push_back(x[0]);\\n        cal(0,-1);\\n        for(auto &x:edges)\\n        {\\n            dfs(x[0],x[1],tot^record[x[0]][x[1]]);\\n            dfs(x[1],x[0],tot^record[x[1]][x[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int,int>>record;\\n    vector<vector<int>>G;\\n    vector<int>nums;\\n    int tot,ans;\\n    void cal(int cur,int pre)\\n    {\\n        record[cur][-1]=nums[cur];\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            cal(x,cur);\\n            record[cur][x]=tot^record[x][-1];\\n            record[x][cur]=tot^record[cur][x];\\n            record[cur][-1]^=record[x][-1];\\n        }\\n    }\\n    void dfs(int cur,int pre,int left)\\n    {\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            int v1=record[cur][x]^left;\\n            int v2=left;\\n            int v3=tot^v1^v2;\\n            if(v1<v2)swap(v1,v2);if(v1<v3)swap(v1,v3);\\n            if(v3>v1)swap(v3,v1);if(v3>v2)swap(v3,v2);\\n            ans=min(ans,v1-v3);\\n            dfs(x,cur,left);\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n=nums.size();\\n        this->nums=nums;\\n        tot=0,ans=INT_MAX;\\n        record.clear(),record.resize(n);\\n        G.clear(),G.resize(n);\\n        for(auto &x:nums)tot^=x;\\n        for(auto &x:edges)G[x[0]].push_back(x[1]),G[x[1]].push_back(x[0]);\\n        cal(0,-1);\\n        for(auto &x:edges)\\n        {\\n            dfs(x[0],x[1],tot^record[x[0]][x[1]]);\\n            dfs(x[1],x[0],tot^record[x[1]][x[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204428,
                "title": "clean-dfs-solution",
                "content": "```\\nint solve(int x,int par,vector<set<int>>&adj,vector<int>&nums)\\n   {    \\n       int now=nums[x];\\n       for(int j:adj[x])\\n       {\\n           if(j!=par)\\n           {\\n              now ^=  solve(j,x,adj,nums);\\n           }\\n       }\\n       \\n       return now;   \\n   }\\n int dfs(int x,int par,int ops1,int ops2,int &ans,vector<set<int>>&adj,vector<int>&nums)\\n {\\n     int now=nums[x];\\n     for(int k:adj[x])\\n     {\\n         if(k!=par)\\n         {\\n             int child= dfs(k,x,ops1,ops2,ans,adj,nums);\\n              int MAX= max(child,max(ops1^child,ops2));\\n               int MIN =min(child,min(ops1^child,ops2));\\n             ans=min(ans,MAX-MIN);\\n                now^=child;\\n         }\\n     } \\n     return now;   \\n }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<set<int>>adj(n);\\n        for(vector<int>&a:edges)\\n        {\\n            int x=a[0];\\n            int y=a[1];\\n            adj[x].insert(y);\\n            adj[y].insert(x);\\n        }\\n   int ans=1e9+7;\\n  for(auto k:edges)\\n  {\\n     int x=k[0];\\n     int y=k[1];\\n     adj[x].erase(y);\\n     adj[y].erase(x);\\n      // 2 trees now do XOR;\\n    int ops1= solve(x,-1,adj,nums);  \\n    int ops2= solve(y,-1,adj,nums); \\n      cout<<ops1<<\" \"<<ops2<<endl;\\n    dfs(x,-1,ops1,ops2,ans,adj,nums); \\n    dfs(y,-1,ops2,ops1,ans,adj,nums); \\n      adj[x].insert(y);\\n      adj[y].insert(x);\\n  }\\n      return ans;  \\n   }",
                "solutionTags": [],
                "code": "```\\nint solve(int x,int par,vector<set<int>>&adj,vector<int>&nums)\\n   {    \\n       int now=nums[x];\\n       for(int j:adj[x])\\n       {\\n           if(j!=par)\\n           {\\n              now ^=  solve(j,x,adj,nums);\\n           }\\n       }\\n       \\n       return now;   \\n   }\\n int dfs(int x,int par,int ops1,int ops2,int &ans,vector<set<int>>&adj,vector<int>&nums)\\n {\\n     int now=nums[x];\\n     for(int k:adj[x])\\n     {\\n         if(k!=par)\\n         {\\n             int child= dfs(k,x,ops1,ops2,ans,adj,nums);\\n              int MAX= max(child,max(ops1^child,ops2));\\n               int MIN =min(child,min(ops1^child,ops2));\\n             ans=min(ans,MAX-MIN);\\n                now^=child;\\n         }\\n     } \\n     return now;   \\n }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<set<int>>adj(n);\\n        for(vector<int>&a:edges)\\n        {\\n            int x=a[0];\\n            int y=a[1];\\n            adj[x].insert(y);\\n            adj[y].insert(x);\\n        }\\n   int ans=1e9+7;\\n  for(auto k:edges)\\n  {\\n     int x=k[0];\\n     int y=k[1];\\n     adj[x].erase(y);\\n     adj[y].erase(x);\\n      // 2 trees now do XOR;\\n    int ops1= solve(x,-1,adj,nums);  \\n    int ops2= solve(y,-1,adj,nums); \\n      cout<<ops1<<\" \"<<ops2<<endl;\\n    dfs(x,-1,ops1,ops2,ans,adj,nums); \\n    dfs(y,-1,ops2,ops1,ans,adj,nums); \\n      adj[x].insert(y);\\n      adj[y].insert(x);\\n  }\\n      return ans;  \\n   }",
                "codeTag": "C++"
            },
            {
                "id": 2203464,
                "title": "c-explained-solution-dfs-bfs",
                "content": "```\\n/*\\n\\nLet two edges that we removing are : a------b, c------d\\n\\nNow there can be two possible cases regarding these two edges\\n\\n 1.\\n\\n     If Both the edges are adjacent or shared any common vertex\\n        \\n                <\\n                <\\n                <\\n   ^^^^^^^a----(b==c)---d^^^^^^\\n                <\\n                <\\n                <\\n                \\nNOTE: ^^^^^^ represents any component of graph\\n      ------ represent an edge\\n      b==c means its a common vertex between two edges\\n                \\n                \\n   so if we break a---b and c---d, 3 components formed are:-\\n   \\n               <\\n               <\\n               <\\n^^^^^^^a     (b==c)      d^^^^^^\\n               <\\n               <\\n               <\\n               \\n  \\n  if total xor = x4 (xor of all vertices)\\n  \\n  xor of 1st component=x1=x4^(xor comes from b\\'s side towards a)\\n  x1=x4^mp[a][b];\\n  \\n  xor of third component=x3=x4^(xor comes from c\\'s side towards d)\\n  x3=x4^mp[d][c];\\n  \\n  xor of second component=x2=x4^x1^x3\\n  \\n  So\\n  \\n  ans= min(ans,max({x1,x2,x3})-min({x1,x2,x3}))\\n  \\n  \\n  2.\\n  \\n   if two edges are not adjacent , try to find two vertices (c1,c2), one from each edge, that will be part of single component after breaking down the graph into 3 components\\n                \\n    ^^^^^a----b^^^^^^^^^^^c-d^^^^^ than , c1=b , c2=c\\n    \\n    HOW to find c1=b and c2=c ?\\n    \\n    NOTE: distance of b from c < distance of a from c\\n          distance of b from c < distance of b from d\\n          \\nSo in O(n*n) we precalculate the distance of each node from all other nodes\\n                \\n Now if we remove the edges a----b and c----d \\n than 3 components formed are \\n ^^^^^a     b^^^^^^^^c    d^^^^^^^\\n \\n if xor of all nodes = x4\\n \\n xor of 1st component= x1 = x4^(xor comes from b\\'s side towards a)\\n x1= x4^(mp[a][b])\\n \\n xor of 3rd component = x3 = x4^(xor comes from c\\'s side towards d)\\n x3=x4^(mp[d][c])\\n \\n xor of 2nd component = x2=x4^x1^x3\\n \\n  */\\n  \\n\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& e) {\\n        \\n        \\n        int n=nums.size();\\n        \\n        vector<int>g[n];\\n        \\n        vector<int>indg(n,0);\\n        \\n        for(auto it:e){\\n            \\n            g[it[0]].push_back(it[1]);\\n            \\n            g[it[1]].push_back(it[0]);\\n            \\n            indg[it[0]]++;\\n            \\n            indg[it[1]]++;\\n\\n        }\\n        \\n        \\n        // xor of all numbers\\n        \\n        int x4=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            x4=nums[i]^x4;\\n        }\\n        \\n        \\n// (u) => (v) directed connected to v, Xor of all values from v\\'s side\\n        \\n        unordered_map<int,unordered_map<int,int>>mp1;\\n        \\n        \\n        \\n        for(int i=0;i<n;i++){\\n                        \\n            unordered_map<int,int>mp2;\\n            \\n            for(int x:g[i]){\\n                \\n                int xr=nums[x];\\n                \\n                vector<bool>vis(n,false);\\n                \\n                vis[i]=true;\\n                \\n                vis[x]=true;\\n                \\n                dfs(x,xr,vis,g,nums);\\n                \\n                mp2[x]=xr;\\n                \\n            }\\n            \\n            mp1[i]=mp2;\\n             \\n        }\\n        \\n// finding distance of each node from all other nodes\\n        \\n        vector<vector<int>>dist(n,vector<int>(n));\\n\\n     for(int i=0;i<n;i++){\\n         vector<int>d(n);\\n        bfs(i,d,g);\\n         dist[i]=d;\\n     }\\n        \\n\\n// For each pair of edges\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<n-1;i++){\\n            \\n            for(int j=i+1;j<n-1;j++){\\n                \\n                int a=e[i][0];\\n                int b=e[i][1];\\n                \\n                \\n                int c=e[j][0];\\n                int d=e[j][1];\\n                \\n       \\n                \\n                int x1,x2,x3;\\n                \\n                if(a==c){\\n                  x1= x4^mp1[b][a];\\n                  x2=x4^mp1[d][a];\\n                  x3=x4^x1^x2;\\n                }\\n                else if(a==d){\\n                 x1= x4^mp1[b][a];\\n                  x2=x4^mp1[c][a];\\n                  x3=x4^x1^x2;\\n                }\\n                else if(b==c){\\n                  x1= x4^mp1[a][b];\\n                  x2=x4^mp1[d][b];\\n                  x3=x4^x1^x2;\\n                }\\n                else if(b==d){\\n                    \\n                  x1= x4^mp1[a][b];\\n                  x2=x4^mp1[c][b];\\n                  x3=x4^x1^x2;\\n                }\\n                \\n                else{\\n                    \\n                    int c1,c2;\\n                    \\n                    int d1=dist[a][c];\\n                    int d2=dist[a][d];\\n                    \\n                    int d3=dist[b][c];\\n                    int d4=dist[b][d];\\n               \\n                    if(d1<d3){\\n                        c1=a;\\n                        if(d1<d2)\\n                            c2=c;\\n                        else\\n                            c2=d;\\n                    }\\n                    else{\\n                        c1=b;\\n                        if(d3<d4)\\n                            c2=c;\\n                        else\\n                            c2=d;\\n                    }\\n                    \\n                    \\n                     if(c1==a){\\n                        \\n                        if(c2==c){  \\n                            x1=x4^mp1[b][a];\\n                            x2=x4^mp1[d][c];\\n                            x3=x4^x1^x2;\\n                        }\\n                        else if(c2==d){\\n                            x1=x4^mp1[b][a];\\n                            x2=x4^mp1[c][d];\\n                            x3=x4^x1^x2; \\n                        }\\n                    }\\n                    else if(c1==b){\\n                        \\n                        if(c2==c){\\n                            x1=x4^mp1[a][b];\\n                            x2=x4^mp1[d][c];\\n                            x3=x4^x1^x2;\\n                        }\\n                        else if(c2==d){\\n                            x1=x4^mp1[a][b];\\n                            x2=x4^mp1[c][d];\\n                            x3=x4^x1^x2;\\n                        }\\n                     }\\n                    \\n                  }\\n                \\n                \\n                int mx=max({x1,x2,x3});\\n                \\n                int mn=min({x1,x2,x3});\\n                \\n                ans=min(ans,mx-mn);\\n                \\n            }\\n        }\\n        \\n    \\n        return ans;\\n        \\n        \\n        \\n    }\\n    \\n\\nvoid dfs(int u,int& xr,vector<bool>&vis,vector<int>g[],vector<int>&nums){\\n                  \\n         for(int v:g[u]){\\n             if(vis[v]==false){\\n                 vis[v]=true;\\n                 xr=xr^nums[v];\\n                 dfs(v,xr,vis,g,nums);\\n             }\\n         }\\n     }\\n    \\n\\nvoid bfs(int node,vector<int>&d,vector<int>g[]){\\n    \\n    int n=d.size();\\n    \\n    queue<int>q;\\n    \\n    vector<int>vis(n,false);\\n    \\n    q.push(node);\\n    \\n    int d1=0;\\n    \\n    while(!q.empty()){\\n        int sz=q.size();\\n        while(sz--){\\n            int u=q.front();\\n            q.pop();\\n            d[u]=d1;\\n            for(int v:g[u]){\\n                if(vis[v]==false){\\n                    vis[v]=true;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        d1++;\\n    }\\n    \\n}\\n    \\n};\\n\\n\\n// T.C = O(n*n)\\n// S.C = O(n*n)\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& e) {\\n        \\n        \\n        int n=nums.size();\\n        \\n        vector<int>g[n];\\n        \\n        vector<int>indg(n,0);\\n        \\n        for(auto it:e){\\n            \\n            g[it[0]].push_back(it[1]);\\n            \\n            g[it[1]].push_back(it[0]);\\n            \\n            indg[it[0]]++;\\n            \\n            indg[it[1]]++;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2201482,
                "title": "easy-java-dfs-code",
                "content": "```\\n// TC : O(nodes*nodes)\\n// SC : O(nodes)\\n\\nclass Solution {\\n    private ArrayList<Integer> tree[];\\n    private int val[];\\n    private int minScore;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        val = nums;\\n        int nodes = nums.length;\\n        int len = edges.length;\\n        tree = new ArrayList[nodes];\\n        \\n        for(int node =0;node<nodes;node++) tree[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            tree[node1].add(node2);\\n            tree[node2].add(node1);\\n        }\\n        \\n        minScore = Integer.MAX_VALUE;\\n        \\n        for(int idx =0;idx<len;idx++){\\n            int node1 = edges[idx][0];\\n            int node2 = edges[idx][1];\\n            \\n            int xor1 = dfs(node1,node2);\\n            int xor2 = dfs(node2,node1);\\n            \\n            dfs(node1,node2,xor1,xor2);\\n            dfs(node2,node1,xor2,xor1);\\n        }\\n        \\n        return minScore;\\n    }\\n    \\n    private int dfs(int parent,int node,int compXor1,int treeXor){\\n        int childXor = 0;\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent){\\n                 int currChildXor = dfs(node,child,compXor1,treeXor);\\n                 int compXor2 = currChildXor;\\n                 int compXor3 = treeXor^compXor2;\\n                \\n                 int maxXor = Math.max(compXor1,Math.max(compXor2,compXor3));\\n                 int minXor = Math.min(compXor1,Math.min(compXor2,compXor3));\\n\\n                 minScore = Math.min(minScore,maxXor-minXor);\\n                 childXor^=currChildXor;\\n            }\\n        }\\n        \\n        return childXor^val[node];\\n    }\\n    \\n    private int dfs(int node,int parent){\\n        int xor = val[node];\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent) xor^=dfs(child,node);\\n        }\\n        \\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n// TC : O(nodes*nodes)\\n// SC : O(nodes)\\n\\nclass Solution {\\n    private ArrayList<Integer> tree[];\\n    private int val[];\\n    private int minScore;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        val = nums;\\n        int nodes = nums.length;\\n        int len = edges.length;\\n        tree = new ArrayList[nodes];\\n        \\n        for(int node =0;node<nodes;node++) tree[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            tree[node1].add(node2);\\n            tree[node2].add(node1);\\n        }\\n        \\n        minScore = Integer.MAX_VALUE;\\n        \\n        for(int idx =0;idx<len;idx++){\\n            int node1 = edges[idx][0];\\n            int node2 = edges[idx][1];\\n            \\n            int xor1 = dfs(node1,node2);\\n            int xor2 = dfs(node2,node1);\\n            \\n            dfs(node1,node2,xor1,xor2);\\n            dfs(node2,node1,xor2,xor1);\\n        }\\n        \\n        return minScore;\\n    }\\n    \\n    private int dfs(int parent,int node,int compXor1,int treeXor){\\n        int childXor = 0;\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent){\\n                 int currChildXor = dfs(node,child,compXor1,treeXor);\\n                 int compXor2 = currChildXor;\\n                 int compXor3 = treeXor^compXor2;\\n                \\n                 int maxXor = Math.max(compXor1,Math.max(compXor2,compXor3));\\n                 int minXor = Math.min(compXor1,Math.min(compXor2,compXor3));\\n\\n                 minScore = Math.min(minScore,maxXor-minXor);\\n                 childXor^=currChildXor;\\n            }\\n        }\\n        \\n        return childXor^val[node];\\n    }\\n    \\n    private int dfs(int node,int parent){\\n        int xor = val[node];\\n        \\n        for(int child : tree[node]){\\n            if(child!=parent) xor^=dfs(child,node);\\n        }\\n        \\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200748,
                "title": "cpp-dfs-map-level-order-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs2(int i,vector<vector<int>>&graph,vector<int>&vis,int prnt)\\n    {\\n        vis[i]=1;\\n        for(auto&p:graph[i])\\n        {\\n            if(p==prnt)continue;\\n            dfs2(p,graph,vis,i);\\n        }\\n    }\\n    int dfs(int i,vector<vector<int>>&graph,vector<int>&tmp,vector<int>&nums,int      prnt,unordered_map<int,int>&mp,int level)\\n    {\\n        mp[i]=level;\\n        int ans=nums[i];\\n        for(auto&p:graph[i])\\n        {\\n            if(p==prnt)continue;\\n            ans=(ans^dfs(p,graph,tmp,nums,i,mp,level+1));\\n        }\\n        return tmp[i]=ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n       \\n         int n=nums.size();\\n         vector<vector<int>>graph(n,vector<int>());\\n             for(auto&p1:edges)\\n             {\\n                 graph[p1[0]].push_back(p1[1]);\\n                 graph[p1[1]].push_back(p1[0]);\\n             } \\n         int sum;\\n         vector<int>tmp(n,-1);\\n         unordered_map<int,int>mp;\\n         sum=dfs(edges[0][0],graph,tmp,nums,-1,mp,0);\\n            int ans=INT_MAX;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            vector<int>p=edges[i];\\n            int sum1=0,sum2=0;\\n            sum2=tmp[p[1]];\\n            int nd=p[1],prnt=p[0];\\n            if(mp[p[0]]>mp[p[1]]){sum2=tmp[p[0]];nd=p[0];prnt=p[1];}\\n            sum1=sum^sum2;\\n            vector<int>vis(n,0);\\n            dfs2(nd,graph,vis,prnt);\\n            for(int j=i+1;j<edges.size();j++)\\n            {\\n                vector<int>p1=edges[j];\\n                if(vis[p1[0]]==0)\\n                {\\n                     int xor1=tmp[p1[1]];\\n                     if(mp[p1[0]]>mp[p1[1]])xor1=tmp[p1[0]];\\n                     int xor2=sum1^(xor1);\\n                     int mn=INT_MAX;mn=min(xor1,xor2);mn=min(sum2,mn);\\n                     int mx=INT_MIN;mx=max(xor1,xor2);mx=max(sum2,mx);\\n                     ans=min(ans,mx-mn);\\n                }\\n                 else \\n                {\\n                     int xor1=tmp[p1[1]];\\n                     if(mp[p1[0]]>mp[p1[1]])xor1=tmp[p1[0]];\\n                     int xor2=sum2^(xor1);\\n                     int mn=INT_MAX;mn=min(xor1,xor2);mn=min(sum1,mn);\\n                     int mx=INT_MIN;mx=max(xor1,xor2);mx=max(sum1,mx);\\n                     ans=min(ans,mx-mn);\\n                }\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs2(int i,vector<vector<int>>&graph,vector<int>&vis,int prnt)\\n    {\\n        vis[i]=1;\\n        for(auto&p:graph[i])\\n        {\\n            if(p==prnt)continue;\\n            dfs2(p,graph,vis,i);\\n        }\\n    }\\n    int dfs(int i,vector<vector<int>>&graph,vector<int>&tmp,vector<int>&nums,int      prnt,unordered_map<int,int>&mp,int level)\\n    {\\n        mp[i]=level;\\n        int ans=nums[i];\\n        for(auto&p:graph[i])\\n        {\\n            if(p==prnt)continue;\\n            ans=(ans^dfs(p,graph,tmp,nums,i,mp,level+1));\\n        }\\n        return tmp[i]=ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n       \\n         int n=nums.size();\\n         vector<vector<int>>graph(n,vector<int>());\\n             for(auto&p1:edges)\\n             {\\n                 graph[p1[0]].push_back(p1[1]);\\n                 graph[p1[1]].push_back(p1[0]);\\n             } \\n         int sum;\\n         vector<int>tmp(n,-1);\\n         unordered_map<int,int>mp;\\n         sum=dfs(edges[0][0],graph,tmp,nums,-1,mp,0);\\n            int ans=INT_MAX;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            vector<int>p=edges[i];\\n            int sum1=0,sum2=0;\\n            sum2=tmp[p[1]];\\n            int nd=p[1],prnt=p[0];\\n            if(mp[p[0]]>mp[p[1]]){sum2=tmp[p[0]];nd=p[0];prnt=p[1];}\\n            sum1=sum^sum2;\\n            vector<int>vis(n,0);\\n            dfs2(nd,graph,vis,prnt);\\n            for(int j=i+1;j<edges.size();j++)\\n            {\\n                vector<int>p1=edges[j];\\n                if(vis[p1[0]]==0)\\n                {\\n                     int xor1=tmp[p1[1]];\\n                     if(mp[p1[0]]>mp[p1[1]])xor1=tmp[p1[0]];\\n                     int xor2=sum1^(xor1);\\n                     int mn=INT_MAX;mn=min(xor1,xor2);mn=min(sum2,mn);\\n                     int mx=INT_MIN;mx=max(xor1,xor2);mx=max(sum2,mx);\\n                     ans=min(ans,mx-mn);\\n                }\\n                 else \\n                {\\n                     int xor1=tmp[p1[1]];\\n                     if(mp[p1[0]]>mp[p1[1]])xor1=tmp[p1[0]];\\n                     int xor2=sum2^(xor1);\\n                     int mn=INT_MAX;mn=min(xor1,xor2);mn=min(sum1,mn);\\n                     int mx=INT_MIN;mx=max(xor1,xor2);mx=max(sum1,mx);\\n                     ans=min(ans,mx-mn);\\n                }\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199710,
                "title": "c-o-nlogn-use-least-common-ancestor",
                "content": "Here I used LCA to check whether one segment is inside another or not.\\n```\\nclass Solution {\\n    \\n    int n;\\n    int arr[1001];\\n    vector<int> adj[1001];\\n    int level[1001], parent[1001], anc[1001][15];\\n    int Xor[1001];\\n    \\n    void dfs(int cur, int p, int l)\\n    {\\n        parent[cur] = p;\\n        Xor[cur] = arr[cur];\\n        level[cur] = l;\\n        \\n        for(auto nxt : adj[cur])\\n        {\\n            if(nxt != p)\\n            {\\n                dfs(nxt, cur, l+1);\\n                Xor[cur] ^= Xor[nxt];\\n            }\\n        }\\n    }\\n    \\n    void LCA_init()\\n    {\\n        dfs(0, 0, 0);\\n        \\n        int i, j;\\n                \\n        for(i = 0; i < n; i++)\\n        {\\n            anc[i][0] = parent[i];\\n            \\n            for(j = 1; j < 15; j++)\\n                anc[i][j] = 0;\\n        }\\n        \\n        for(j = 1; j < 15; j++)\\n        {\\n            for(i = 0; i < n; i++)\\n                anc[i][j] = anc[anc[i][j-1]][j-1];\\n        }\\n    }\\n    \\n    int getLCA(int a, int b)\\n    {\\n        if(level[a] < level[b])\\n            swap(a, b);\\n        \\n        int i;\\n        for(i = 14; i >= 0; i--)\\n        {\\n            if(level[anc[a][i]] >= level[b])\\n                a = anc[a][i];\\n        }\\n        \\n        if(a == b)\\n            return a;\\n        \\n        for(i = 14; i >= 0; i--)\\n        {\\n            if(anc[a][i] != anc[b][i])\\n            {\\n                a = anc[a][i];\\n                b = anc[b][i];\\n            }\\n        }\\n        \\n        return parent[a];\\n    }\\n    \\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int i, j, a, b, c, p1, c1, p2, c2, lca, ans;\\n        n = nums.size();\\n        \\n        for(i = 0; i < n; i++)\\n            arr[i] = nums[i];\\n        \\n        for(i = 0; i < edges.size(); i++)\\n        {\\n            a = edges[i][0];\\n            b = edges[i][1];\\n            \\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        \\n        LCA_init();\\n        \\n        ans = INT_MAX;\\n        for(i = 0; i < edges.size(); i++)\\n        {\\n            for(j = 0; j < i; j++)\\n            {\\n                p1 = edges[i][0];\\n                c1 = edges[i][1];\\n                if(parent[c1] != p1)\\n                    swap(p1, c1);\\n                \\n                p2 = edges[j][0];\\n                c2 = edges[j][1];\\n                if(parent[c2] != p2)\\n                    swap(p2, c2);\\n                \\n                lca = getLCA(c1, c2);\\n                if(lca == c1)\\n                {\\n                    a = Xor[0] ^ Xor[c1];\\n                    b = Xor[c1] ^ Xor[c2];\\n                    c = Xor[c2];\\n                }\\n                else if(lca == c2)\\n                {\\n                    a = Xor[0] ^ Xor[c2];\\n                    b = Xor[c2] ^ Xor[c1];\\n                    c = Xor[c1];\\n                }\\n                else\\n                {\\n                    a = Xor[0] ^ Xor[c1] ^ Xor[c2];\\n                    b = Xor[c1];\\n                    c = Xor[c2];\\n                }\\n                \\n                ans = min(ans, max({a, b, c}) - min({a, b, c}));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int n;\\n    int arr[1001];\\n    vector<int> adj[1001];\\n    int level[1001], parent[1001], anc[1001][15];\\n    int Xor[1001];\\n    \\n    void dfs(int cur, int p, int l)\\n    {\\n        parent[cur] = p;\\n        Xor[cur] = arr[cur];\\n        level[cur] = l;\\n        \\n        for(auto nxt : adj[cur])\\n        {\\n            if(nxt != p)\\n            {\\n                dfs(nxt, cur, l+1);\\n                Xor[cur] ^= Xor[nxt];\\n            }\\n        }\\n    }\\n    \\n    void LCA_init()\\n    {\\n        dfs(0, 0, 0);\\n        \\n        int i, j;\\n                \\n        for(i = 0; i < n; i++)\\n        {\\n            anc[i][0] = parent[i];\\n            \\n            for(j = 1; j < 15; j++)\\n                anc[i][j] = 0;\\n        }\\n        \\n        for(j = 1; j < 15; j++)\\n        {\\n            for(i = 0; i < n; i++)\\n                anc[i][j] = anc[anc[i][j-1]][j-1];\\n        }\\n    }\\n    \\n    int getLCA(int a, int b)\\n    {\\n        if(level[a] < level[b])\\n            swap(a, b);\\n        \\n        int i;\\n        for(i = 14; i >= 0; i--)\\n        {\\n            if(level[anc[a][i]] >= level[b])\\n                a = anc[a][i];\\n        }\\n        \\n        if(a == b)\\n            return a;\\n        \\n        for(i = 14; i >= 0; i--)\\n        {\\n            if(anc[a][i] != anc[b][i])\\n            {\\n                a = anc[a][i];\\n                b = anc[b][i];\\n            }\\n        }\\n        \\n        return parent[a];\\n    }\\n    \\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int i, j, a, b, c, p1, c1, p2, c2, lca, ans;\\n        n = nums.size();\\n        \\n        for(i = 0; i < n; i++)\\n            arr[i] = nums[i];\\n        \\n        for(i = 0; i < edges.size(); i++)\\n        {\\n            a = edges[i][0];\\n            b = edges[i][1];\\n            \\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        \\n        LCA_init();\\n        \\n        ans = INT_MAX;\\n        for(i = 0; i < edges.size(); i++)\\n        {\\n            for(j = 0; j < i; j++)\\n            {\\n                p1 = edges[i][0];\\n                c1 = edges[i][1];\\n                if(parent[c1] != p1)\\n                    swap(p1, c1);\\n                \\n                p2 = edges[j][0];\\n                c2 = edges[j][1];\\n                if(parent[c2] != p2)\\n                    swap(p2, c2);\\n                \\n                lca = getLCA(c1, c2);\\n                if(lca == c1)\\n                {\\n                    a = Xor[0] ^ Xor[c1];\\n                    b = Xor[c1] ^ Xor[c2];\\n                    c = Xor[c2];\\n                }\\n                else if(lca == c2)\\n                {\\n                    a = Xor[0] ^ Xor[c2];\\n                    b = Xor[c2] ^ Xor[c1];\\n                    c = Xor[c1];\\n                }\\n                else\\n                {\\n                    a = Xor[0] ^ Xor[c1] ^ Xor[c2];\\n                    b = Xor[c1];\\n                    c = Xor[c2];\\n                }\\n                \\n                ans = min(ans, max({a, b, c}) - min({a, b, c}));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199309,
                "title": "c-commented-dfs",
                "content": "1. ```children[i]``` will store all the children(including itself) of ```ith``` node.I have used bitset for this.\\n2. ```subX[i]``` will store XOR of all elements rooted at ```ith``` node\\n```\\nclass Solution {\\npublic:\\n    vector<bitset<1001>>children;\\n    vector<vector<int>>graph;\\n    vector<int>subX;\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        graph.resize(n);\\n        subX.resize(n,0);\\n        children.resize(n);\\n        for(auto & i:edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);  \\n        }\\n        \\n        dfs(0,-1,nums);\\n        int ans=INT_MAX;\\n        for(int i=0;i<edges.size()-1;i++)\\n            for(int j=i+1;j<edges.size();j++){\\n                // for edge (a,b) i will make \"a\" as parent \"b\" .Same for (c,d)\\n                int a=edges[i][0],b=edges[i][1],c=edges[j][0],d=edges[j][1];\\n\\t\\t\\t\\t// if b is parent of a then swap the values to make a as parent\\n                if(!children[a][b])\\n                    swap(a,b);\\n                if(!children[c][d])\\n                    swap(c,d);\\n                // now b and d are the root node of two seprated subtrees\\n                int x,y,z;\\n                // if both are two distinct subtrees\\n                if(!children[b][d] && !children[d][b]){\\n                    x=subX[b];y=subX[d];z=subX[0]^x^y;\\n                }\\n                // if b is children of d\\n                else if(!children[b][d] && children[d][b]){\\n                    x=subX[b];y=subX[d]^x;z=subX[0]^subX[d];\\n                }\\n                // if d is children of b\\n                else{\\n                    x=subX[d];y=subX[b]^x;z=subX[0]^subX[b];                    \\n                }\\n                ans=min(ans,max(x,max(y,z))-min(x,min(y,z)));\\n            }\\n        return ans;\\n    }\\n   pair<int,bitset<1001> > dfs(int node,int parent,vector<int>& nums){\\n       int subTreeX=nums[node];\\n       bitset<1001>bits;\\n       bits[node]=1;\\n        for(auto & v:graph[node])\\n            if(v!=parent){\\n                auto ret=dfs(v,node,nums);\\n                subTreeX^=ret.first;\\n                // this line add the children of \"v\" node to current node\\'s children(node)\\n                bits|=ret.second;\\n            }\\n       children[node]=bits;\\n       subX[node]=subTreeX;\\n       return {subTreeX,bits};\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```children[i]```\n```ith```\n```subX[i]```\n```ith```\n```\\nclass Solution {\\npublic:\\n    vector<bitset<1001>>children;\\n    vector<vector<int>>graph;\\n    vector<int>subX;\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        graph.resize(n);\\n        subX.resize(n,0);\\n        children.resize(n);\\n        for(auto & i:edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);  \\n        }\\n        \\n        dfs(0,-1,nums);\\n        int ans=INT_MAX;\\n        for(int i=0;i<edges.size()-1;i++)\\n            for(int j=i+1;j<edges.size();j++){\\n                // for edge (a,b) i will make \"a\" as parent \"b\" .Same for (c,d)\\n                int a=edges[i][0],b=edges[i][1],c=edges[j][0],d=edges[j][1];\\n\\t\\t\\t\\t// if b is parent of a then swap the values to make a as parent\\n                if(!children[a][b])\\n                    swap(a,b);\\n                if(!children[c][d])\\n                    swap(c,d);\\n                // now b and d are the root node of two seprated subtrees\\n                int x,y,z;\\n                // if both are two distinct subtrees\\n                if(!children[b][d] && !children[d][b]){\\n                    x=subX[b];y=subX[d];z=subX[0]^x^y;\\n                }\\n                // if b is children of d\\n                else if(!children[b][d] && children[d][b]){\\n                    x=subX[b];y=subX[d]^x;z=subX[0]^subX[d];\\n                }\\n                // if d is children of b\\n                else{\\n                    x=subX[d];y=subX[b]^x;z=subX[0]^subX[b];                    \\n                }\\n                ans=min(ans,max(x,max(y,z))-min(x,min(y,z)));\\n            }\\n        return ans;\\n    }\\n   pair<int,bitset<1001> > dfs(int node,int parent,vector<int>& nums){\\n       int subTreeX=nums[node];\\n       bitset<1001>bits;\\n       bits[node]=1;\\n        for(auto & v:graph[node])\\n            if(v!=parent){\\n                auto ret=dfs(v,node,nums);\\n                subTreeX^=ret.first;\\n                // this line add the children of \"v\" node to current node\\'s children(node)\\n                bits|=ret.second;\\n            }\\n       children[node]=bits;\\n       subX[node]=subTreeX;\\n       return {subTreeX,bits};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198734,
                "title": "o-n-2-using-tree-traversal-array",
                "content": "\\n![image](https://assets.leetcode.com/users/images/e4ff8887-ce9b-4177-848f-b904c3e5d599_1656218630.6288934.png)\\n\\n\\nFor above given graph we maitain dfs Traversal tree and values correspoinding to dfs traversal tree \\n```\\nindex:              0 1 2 3 4 5\\ndfsTraversalArray:  0 1 2 5 3 4 \\nsubTreeSize:        6 5 2 1 2 1         // corresponding to dfs nodes order\\nnums:               5 5 2 2 4 4         // corresponding to dfs nodes order\\n```\\n\\n\\n\\n```\\nclass Solution {\\n\\nprivate:\\n    vector<vector<int>>tree;\\n    vector<int>dfsTraversal;\\n    vector<int>subTreeSize;\\n\\t\\n\\tint dfs(int s,vector<bool>&vis){\\n        vis[s]=true;\\n        dfsTraversal.push_back(s);\\n        subTreeSize[s]=1;\\n        for(int i=0;i<tree[s].size();++i){\\n            if(!vis[tree[s][i]]){\\n                subTreeSize[s]+=dfs(tree[s][i],vis);\\n            }\\n        }\\n        return subTreeSize[s];\\n    }    \\n\\npublic:\\n    int minimumScore(vector<int>& num, vector<vector<int>>& edges) \\n\\t{\\n        int n=num.size();\\n        tree.resize(n);\\n        subTreeSize.assign(n,0);\\n        for(int i=0;i<edges.size();++i)\\n\\t\\t{\\n            tree[edges[i][0]].push_back(edges[i][1]);\\n            tree[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<bool>vis(n,false);\\n        dfs(0,vis);\\n        \\n        vector<int>temp(n,0);                            // for rearranging subTreeSize corresponding to dfsTreeTraversal array\\n        vector<int>nums(n);                              // for rearranging nums corresponding to dfsTreeTraversall array\\n        for(int i=0;i<n;++i){\\n            nums[i]=num[dfsTraversal[i]];  \\n            temp[i]=subTreeSize[dfsTraversal[i]];\\n        }\\n        subTreeSize=temp;\\n        \\n        \\n        \\n        int all=0;                                      // to store xor of whole tree\\n        for(int i=0;i<n;++i){\\n            all^=nums[i];\\n            if(i!=0) nums[i]^=nums[i-1]; \\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        // let i and j be two two point where we are breaking the tree (removing incoming edges to nodes at these index)\\n        for(int i=1;i<n;++i)\\n        {\\n            int a=nums[i+subTreeSize[i]-1]^nums[i-1];               // first subtree xor\\n            for(int j=i+1;j<n;++j)\\n            {\\n                int b=nums[j+subTreeSize[j]-1]^nums[j-1];           // second component xor\\'s\\n                \\n                int aa=a;                                 // to store first component xor             \\n                if(j<=i+subTreeSize[i]-1){                      // If second component is in subtree of first tree\\n                    aa=b^aa;\\n                }\\n                \\n                int temp=all^aa^b;                       // third component excluding first and second component\\n                int mx=max(temp,max(aa,b));\\n                int mn=min(temp,min(aa,b));\\n                ans=min(ans,mx-mn);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t\\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nindex:              0 1 2 3 4 5\\ndfsTraversalArray:  0 1 2 5 3 4 \\nsubTreeSize:        6 5 2 1 2 1         // corresponding to dfs nodes order\\nnums:               5 5 2 2 4 4         // corresponding to dfs nodes order\\n```\n```\\nclass Solution {\\n\\nprivate:\\n    vector<vector<int>>tree;\\n    vector<int>dfsTraversal;\\n    vector<int>subTreeSize;\\n\\t\\n\\tint dfs(int s,vector<bool>&vis){\\n        vis[s]=true;\\n        dfsTraversal.push_back(s);\\n        subTreeSize[s]=1;\\n        for(int i=0;i<tree[s].size();++i){\\n            if(!vis[tree[s][i]]){\\n                subTreeSize[s]+=dfs(tree[s][i],vis);\\n            }\\n        }\\n        return subTreeSize[s];\\n    }    \\n\\npublic:\\n    int minimumScore(vector<int>& num, vector<vector<int>>& edges) \\n\\t{\\n        int n=num.size();\\n        tree.resize(n);\\n        subTreeSize.assign(n,0);\\n        for(int i=0;i<edges.size();++i)\\n\\t\\t{\\n            tree[edges[i][0]].push_back(edges[i][1]);\\n            tree[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<bool>vis(n,false);\\n        dfs(0,vis);\\n        \\n        vector<int>temp(n,0);                            // for rearranging subTreeSize corresponding to dfsTreeTraversal array\\n        vector<int>nums(n);                              // for rearranging nums corresponding to dfsTreeTraversall array\\n        for(int i=0;i<n;++i){\\n            nums[i]=num[dfsTraversal[i]];  \\n            temp[i]=subTreeSize[dfsTraversal[i]];\\n        }\\n        subTreeSize=temp;\\n        \\n        \\n        \\n        int all=0;                                      // to store xor of whole tree\\n        for(int i=0;i<n;++i){\\n            all^=nums[i];\\n            if(i!=0) nums[i]^=nums[i-1]; \\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        // let i and j be two two point where we are breaking the tree (removing incoming edges to nodes at these index)\\n        for(int i=1;i<n;++i)\\n        {\\n            int a=nums[i+subTreeSize[i]-1]^nums[i-1];               // first subtree xor\\n            for(int j=i+1;j<n;++j)\\n            {\\n                int b=nums[j+subTreeSize[j]-1]^nums[j-1];           // second component xor\\'s\\n                \\n                int aa=a;                                 // to store first component xor             \\n                if(j<=i+subTreeSize[i]-1){                      // If second component is in subtree of first tree\\n                    aa=b^aa;\\n                }\\n                \\n                int temp=all^aa^b;                       // third component excluding first and second component\\n                int mx=max(temp,max(aa,b));\\n                int mn=min(temp,min(aa,b));\\n                ans=min(ans,mx-mn);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198439,
                "title": "c-o-n-2logn-dfs-and-lca",
                "content": "Logic is pretty simple. Root the tree at any node (node 0 in my case), and then find every subtree XOR using DFS. \\n\\nNow for every pair of removed edges, we know which subtrees are being removed since we fixed the tree ordering at node 0. Say these two subtrees are A and B, and the third being rooted at 0. We just need to get the XOR of each subtree, which we precomputed before.\\n\\nTheres an edge case tho, if subtree A is a subtree of B, then the XOR of subtree 0, we must not double XOR out the same tree twice. So use the Lowest Common Ancestor algorithm that works in LogN to determine if Subtree A and subtree B are subtrees of each other, so that when it is, we wont XOR out subtree B twice when computing the XOR of the new tree rooted at 0.\\n\\nTime complexity - O(N^2 LogN) where N is the number of nodes\\n```\\nstruct LCA {\\n    vector<int> height, euler, first, segtree;\\n    vector<bool> visited;\\n    int n;\\n\\n    LCA(vector<vector<int>> &adj, int root = 0) {\\n        n = adj.size();\\n        height.resize(n);\\n        first.resize(n);\\n        euler.reserve(n * 2);\\n        visited.assign(n, false);\\n        dfs(adj, root);\\n        int m = euler.size();\\n        segtree.resize(m * 4);\\n        build(1, 0, m - 1);\\n    }\\n\\n    void dfs(vector<vector<int>> &adj, int node, int h = 0) {\\n        visited[node] = true;\\n        height[node] = h;\\n        first[node] = euler.size();\\n        euler.push_back(node);\\n        for (auto to : adj[node]) {\\n            if (!visited[to]) {\\n                dfs(adj, to, h + 1);\\n                euler.push_back(node);\\n            }\\n        }\\n    }\\n\\n    void build(int node, int b, int e) {\\n        if (b == e) {\\n            segtree[node] = euler[b];\\n        } else {\\n            int mid = (b + e) / 2;\\n            build(node << 1, b, mid);\\n            build(node << 1 | 1, mid + 1, e);\\n            int l = segtree[node << 1], r = segtree[node << 1 | 1];\\n            segtree[node] = (height[l] < height[r]) ? l : r;\\n        }\\n    }\\n\\n    int query(int node, int b, int e, int L, int R) {\\n        if (b > R || e < L)\\n            return -1;\\n        if (b >= L && e <= R)\\n            return segtree[node];\\n        int mid = (b + e) >> 1;\\n\\n        int left = query(node << 1, b, mid, L, R);\\n        int right = query(node << 1 | 1, mid + 1, e, L, R);\\n        if (left == -1) return right;\\n        if (right == -1) return left;\\n        return height[left] < height[right] ? left : right;\\n    }\\n\\n    int lca(int u, int v) {\\n        int left = first[u], right = first[v];\\n        if (left > right)\\n            swap(left, right);\\n        return query(1, 0, euler.size() - 1, left, right);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void dfs(int cur, vector<int> &nums, vector<vector<int>> &adj, vector<bool> &visited, vector<int> &xors, vector<vector<int>> &new_edges) {\\n        visited[cur] = true;\\n        int x = nums[cur];\\n        for (int nxt: adj[cur]) {\\n            if (!visited[nxt]) {\\n                new_edges.push_back({cur, nxt});\\n                dfs(nxt, nums, adj, visited, xors, new_edges);\\n                x = x ^ xors[nxt];\\n            }\\n        }\\n        xors[cur] = x;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int>> adj(n, vector<int>());\\n        \\n        for (vector<int> &e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> xors(n, 0);\\n        vector<bool> visited(n, false);\\n        vector<vector<int>> new_edges;\\n        \\n        \\n        dfs(0, nums, adj, visited, xors, new_edges);\\n        int res = INT_MAX;\\n        LCA my_lca(adj, 0);\\n        for (int i=0; i<new_edges.size(); ++i) {\\n            \\n            vector<int> e1 = new_edges[i];\\n            int a = e1[0];\\n            int b = e1[1];\\n            \\n            for (int j=i+1; j<new_edges.size(); ++j) {\\n                vector<int> e2 = new_edges[j];\\n                int c = e2[0];\\n                int d = e2[1];\\n                \\n                int common_ancestor = my_lca.lca(b, d);\\n                if (common_ancestor == b) {\\n                    int subtree_1 = xors[d];\\n                    int subtree_2 = xors[b] ^ xors[d];\\n                    int subtree_3 = xors[0] ^ xors[b];\\n                    res = min(res, max({subtree_1, subtree_2, subtree_3}) - min({subtree_1, subtree_2, subtree_3}));\\n                } else if (common_ancestor == d) {\\n                    int subtree_1 = xors[b];\\n                    int subtree_2 = xors[d] ^ xors[b];\\n                    int subtree_3 = xors[0] ^ xors[d];\\n                    res = min(res, max({subtree_1, subtree_2, subtree_3}) - min({subtree_1, subtree_2, subtree_3}));\\n                }  else {\\n                    int subtree_1 = xors[d];\\n                    int subtree_2 = xors[b];\\n                    int subtree_3 = xors[0] ^ xors[b] ^ xors[d];\\n                    res = min(res, max({subtree_1, subtree_2, subtree_3}) - min({subtree_1, subtree_2, subtree_3}));\\n                 }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct LCA {\\n    vector<int> height, euler, first, segtree;\\n    vector<bool> visited;\\n    int n;\\n\\n    LCA(vector<vector<int>> &adj, int root = 0) {\\n        n = adj.size();\\n        height.resize(n);\\n        first.resize(n);\\n        euler.reserve(n * 2);\\n        visited.assign(n, false);\\n        dfs(adj, root);\\n        int m = euler.size();\\n        segtree.resize(m * 4);\\n        build(1, 0, m - 1);\\n    }\\n\\n    void dfs(vector<vector<int>> &adj, int node, int h = 0) {\\n        visited[node] = true;\\n        height[node] = h;\\n        first[node] = euler.size();\\n        euler.push_back(node);\\n        for (auto to : adj[node]) {\\n            if (!visited[to]) {\\n                dfs(adj, to, h + 1);\\n                euler.push_back(node);\\n            }\\n        }\\n    }\\n\\n    void build(int node, int b, int e) {\\n        if (b == e) {\\n            segtree[node] = euler[b];\\n        } else {\\n            int mid = (b + e) / 2;\\n            build(node << 1, b, mid);\\n            build(node << 1 | 1, mid + 1, e);\\n            int l = segtree[node << 1], r = segtree[node << 1 | 1];\\n            segtree[node] = (height[l] < height[r]) ? l : r;\\n        }\\n    }\\n\\n    int query(int node, int b, int e, int L, int R) {\\n        if (b > R || e < L)\\n            return -1;\\n        if (b >= L && e <= R)\\n            return segtree[node];\\n        int mid = (b + e) >> 1;\\n\\n        int left = query(node << 1, b, mid, L, R);\\n        int right = query(node << 1 | 1, mid + 1, e, L, R);\\n        if (left == -1) return right;\\n        if (right == -1) return left;\\n        return height[left] < height[right] ? left : right;\\n    }\\n\\n    int lca(int u, int v) {\\n        int left = first[u], right = first[v];\\n        if (left > right)\\n            swap(left, right);\\n        return query(1, 0, euler.size() - 1, left, right);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void dfs(int cur, vector<int> &nums, vector<vector<int>> &adj, vector<bool> &visited, vector<int> &xors, vector<vector<int>> &new_edges) {\\n        visited[cur] = true;\\n        int x = nums[cur];\\n        for (int nxt: adj[cur]) {\\n            if (!visited[nxt]) {\\n                new_edges.push_back({cur, nxt});\\n                dfs(nxt, nums, adj, visited, xors, new_edges);\\n                x = x ^ xors[nxt];\\n            }\\n        }\\n        xors[cur] = x;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int>> adj(n, vector<int>());\\n        \\n        for (vector<int> &e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> xors(n, 0);\\n        vector<bool> visited(n, false);\\n        vector<vector<int>> new_edges;\\n        \\n        \\n        dfs(0, nums, adj, visited, xors, new_edges);\\n        int res = INT_MAX;\\n        LCA my_lca(adj, 0);\\n        for (int i=0; i<new_edges.size(); ++i) {\\n            \\n            vector<int> e1 = new_edges[i];\\n            int a = e1[0];\\n            int b = e1[1];\\n            \\n            for (int j=i+1; j<new_edges.size(); ++j) {\\n                vector<int> e2 = new_edges[j];\\n                int c = e2[0];\\n                int d = e2[1];\\n                \\n                int common_ancestor = my_lca.lca(b, d);\\n                if (common_ancestor == b) {\\n                    int subtree_1 = xors[d];\\n                    int subtree_2 = xors[b] ^ xors[d];\\n                    int subtree_3 = xors[0] ^ xors[b];\\n                    res = min(res, max({subtree_1, subtree_2, subtree_3}) - min({subtree_1, subtree_2, subtree_3}));\\n                } else if (common_ancestor == d) {\\n                    int subtree_1 = xors[b];\\n                    int subtree_2 = xors[d] ^ xors[b];\\n                    int subtree_3 = xors[0] ^ xors[d];\\n                    res = min(res, max({subtree_1, subtree_2, subtree_3}) - min({subtree_1, subtree_2, subtree_3}));\\n                }  else {\\n                    int subtree_1 = xors[d];\\n                    int subtree_2 = xors[b];\\n                    int subtree_3 = xors[0] ^ xors[b] ^ xors[d];\\n                    res = min(res, max({subtree_1, subtree_2, subtree_3}) - min({subtree_1, subtree_2, subtree_3}));\\n                 }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198406,
                "title": "python-o-n-2-dfs",
                "content": "```\\ndef minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n\\tn = len(nums)\\n\\tg = [set() for _ in range(n)]\\n\\tfor u, v in edges:\\n\\t\\tg[u].add(v)\\n\\t\\tg[v].add(u)\\n\\toss = [set() for _ in range(n)] # offsprings of each node with node 0 as the root. \\n\\txs = nums.copy()  # xor of each subtree with node 0 as the root. \\n\\tdef dfs(node, prev):\\n\\t\\tif prev is not None: g[node].remove(prev)\\n\\t\\tfor q in g[node]:\\n\\t\\t\\toss[node].add(q)\\n\\t\\t\\tdfs(q, node)\\n\\t\\t\\toss[node].update(oss[q])\\n\\t\\t\\txs[node] ^= xs[q]\\n\\tdfs(0, None)\\n\\n\\tmn = float(\\'inf\\')\\n\\tfor i, (u1, v1) in enumerate(edges[:-1]):\\n\\t\\tfor u2, v2 in edges[i+1:]:\\n\\t\\t\\tp1, p2 = u1 if u1 in g[v1] else v1, u2 if u2 in g[v2] else v2\\n\\t\\t\\tif p1 in oss[p2]: p1, p2 = p2, p1\\n\\t\\t\\tif p2 in oss[p1]:\\n\\t\\t\\t\\tx0, x1, x2 = xs[0] ^ xs[p1], xs[p1] ^ xs[p2], xs[p2]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx0, x1, x2 = xs[0] ^ xs[p1] ^ xs[p2], xs[p1], xs[p2]\\n\\t\\t\\tmn = min(mn, max(x0, x1, x2) - min(x0, x1, x2))\\n\\treturn mn\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n\\tn = len(nums)\\n\\tg = [set() for _ in range(n)]\\n\\tfor u, v in edges:\\n\\t\\tg[u].add(v)\\n\\t\\tg[v].add(u)\\n\\toss = [set() for _ in range(n)] # offsprings of each node with node 0 as the root. \\n\\txs = nums.copy()  # xor of each subtree with node 0 as the root. \\n\\tdef dfs(node, prev):\\n\\t\\tif prev is not None: g[node].remove(prev)\\n\\t\\tfor q in g[node]:\\n\\t\\t\\toss[node].add(q)\\n\\t\\t\\tdfs(q, node)\\n\\t\\t\\toss[node].update(oss[q])\\n\\t\\t\\txs[node] ^= xs[q]\\n\\tdfs(0, None)\\n\\n\\tmn = float(\\'inf\\')\\n\\tfor i, (u1, v1) in enumerate(edges[:-1]):\\n\\t\\tfor u2, v2 in edges[i+1:]:\\n\\t\\t\\tp1, p2 = u1 if u1 in g[v1] else v1, u2 if u2 in g[v2] else v2\\n\\t\\t\\tif p1 in oss[p2]: p1, p2 = p2, p1\\n\\t\\t\\tif p2 in oss[p1]:\\n\\t\\t\\t\\tx0, x1, x2 = xs[0] ^ xs[p1], xs[p1] ^ xs[p2], xs[p2]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx0, x1, x2 = xs[0] ^ xs[p1] ^ xs[p2], xs[p1], xs[p2]\\n\\t\\t\\tmn = min(mn, max(x0, x1, x2) - min(x0, x1, x2))\\n\\treturn mn\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2198393,
                "title": "c-straight-forward-o-n-2",
                "content": "step 1: chose any pair of edge like [u, v]\\n![image](https://assets.leetcode.com/users/images/536bbf6b-640c-434c-9cb2-5c4d0fcd7d3f_1656216502.9996712.png)\\n\\t- caculate scoreU and scoreV\\n\\t- int area of node u find 2 components have score score A, score B -> the result =min(res, max(A, B, V) - min(A, B, V)).\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint res = INT_MAX;\\n\\t\\tint score(int u, vector<vector<int>>& graph, vector<vector<int>>& check, vector<int>& nums,int parent = -1) {\\n\\t\\t\\tint ans = nums[u];\\n\\t\\t\\tfor(auto& child : graph[u]) {\\n\\t\\t\\t\\tif(!check[u][child] || child == parent)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tans ^= score(child, graph, check, nums, u);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tint dfs(int u, int scoreU, int scoreV, vector<vector<int>>& graph, vector<vector<int>>& check, vector<int>& nums, int x,int parent = -1) {\\n\\t\\t\\tint ans = nums[u];\\n\\t\\t\\tfor(auto& child : graph[u]) {\\n\\t\\t\\t\\tif(!check[u][child] || child == parent)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tans ^= dfs(child, scoreU, scoreV, graph, check, nums, x, u);\\n\\t\\t\\t}\\n\\t\\t\\tint MAX = max(scoreV, max(scoreU ^ ans, ans));\\n\\t\\t\\tint MIN = min(scoreV, min(scoreU ^ ans, ans));\\n\\t\\t\\tif(u != x)\\n\\t\\t\\t\\tres = min(res, MAX - MIN);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tint minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> graph(n);\\n\\t\\t\\tvector<vector<int>>check(1005, vector<int>(1005));\\n\\t\\t\\tfor(auto& e : edges) {\\n\\t\\t\\t\\tgraph[e[0]].push_back(e[1]);\\n\\t\\t\\t\\tgraph[e[1]].push_back(e[0]);\\n\\t\\t\\t\\tcheck[e[0]][e[1]] = true;\\n\\t\\t\\t\\tcheck[e[1]][e[0]] = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(auto& e : edges) {\\n\\t\\t\\t\\tint u = e[0], v = e[1];\\n\\t\\t\\t\\tcheck[u][v] = false;\\n\\t\\t\\t\\tcheck[v][u] = false;\\n\\t\\t\\t\\tint scoreU = score(u, graph, check, nums);\\n\\t\\t\\t\\tint scoreV = score(v, graph, check, nums);\\n\\n\\t\\t\\t\\tif(graph[u].size() > 1)\\n\\t\\t\\t\\t\\tdfs(u, scoreU, scoreV, graph, check, nums, u);\\n\\t\\t\\t\\tif(graph[v].size() > 1)\\n\\t\\t\\t\\t\\tdfs(v, scoreV, scoreU, graph, check, nums, v);\\n\\n\\t\\t\\t\\tcheck[u][v] = true;\\n\\t\\t\\t\\tcheck[v][u] = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint res = INT_MAX;\\n\\t\\tint score(int u, vector<vector<int>>& graph, vector<vector<int>>& check, vector<int>& nums,int parent = -1) {\\n\\t\\t\\tint ans = nums[u];\\n\\t\\t\\tfor(auto& child : graph[u]) {\\n\\t\\t\\t\\tif(!check[u][child] || child == parent)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tans ^= score(child, graph, check, nums, u);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3888202,
                "title": "solution-without-lca-and-actual-edge-deleting-simpler-dfs",
                "content": "# Approach\\n1) Let\\'s fix some edge *x-y*, imaginary delete it and consider two trees with roots *x* and *y*.\\n2) Count subtrees xors for both of them (*xors* array).\\n3) Let\\'s fix some other node *v* - bottom end of second edge we delete.\\n4) If *v* is in *x* tree, xors of components will be *[xors[v], xors[x] ^ xors[v], xors[y]]*. Another case is symmetrical.\\n\\n# Code\\n```\\nINF = 10**9\\n\\nclass Solution:\\n    def minimumScore(self, a: List[int], edges: List[List[int]]) -> int:\\n        n = len(a)\\n        g = [[] for _ in range(n)]\\n        for x, y in edges:\\n            g[x].append(y)\\n            g[y].append(x)\\n\\n        def dfs(v, p):\\n            is_x_comp[v] = is_x_comp_flag\\n            for to in g[v]:\\n                if to == p:\\n                    continue\\n                dfs(to, v)\\n                xors[v] ^= xors[to]\\n\\n        \\n        res = INF\\n\\n        for x, y in edges:\\n            xors = a.copy()\\n            is_x_comp = [False for _ in range(n)]\\n            is_x_comp_flag = True\\n            dfs(x, y)\\n            is_x_comp_flag = False\\n            dfs(y, x)\\n\\n            for v in range(n):\\n                if v == x or v == y:\\n                    continue\\n                vals = [\\n                    xors[v],\\n                    xors[x] ^ (xors[v] if is_x_comp[v] else 0),\\n                    xors[y] ^ (0 if is_x_comp[v] else xors[v]),\\n                ]\\n                vals.sort()\\n                res = min(res, vals[2] - vals[0])\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nINF = 10**9\\n\\nclass Solution:\\n    def minimumScore(self, a: List[int], edges: List[List[int]]) -> int:\\n        n = len(a)\\n        g = [[] for _ in range(n)]\\n        for x, y in edges:\\n            g[x].append(y)\\n            g[y].append(x)\\n\\n        def dfs(v, p):\\n            is_x_comp[v] = is_x_comp_flag\\n            for to in g[v]:\\n                if to == p:\\n                    continue\\n                dfs(to, v)\\n                xors[v] ^= xors[to]\\n\\n        \\n        res = INF\\n\\n        for x, y in edges:\\n            xors = a.copy()\\n            is_x_comp = [False for _ in range(n)]\\n            is_x_comp_flag = True\\n            dfs(x, y)\\n            is_x_comp_flag = False\\n            dfs(y, x)\\n\\n            for v in range(n):\\n                if v == x or v == y:\\n                    continue\\n                vals = [\\n                    xors[v],\\n                    xors[x] ^ (xors[v] if is_x_comp[v] else 0),\\n                    xors[y] ^ (0 if is_x_comp[v] else xors[v]),\\n                ]\\n                vals.sort()\\n                res = min(res, vals[2] - vals[0])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797331,
                "title": "c-dfs-in-time-out-time-concept-of-node-xor-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think in the direction that i need to distribut the tree in 3 parts which can be done if i take two edge(which can be any adjacent or not adjacent) and think like i need to divide those edges.so you could think a o(n^2) solution by traversing edges since you have to check any two edge which gives least difference of max and min xor.TO make it simple i root my tree at 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst i thought to see there are three cases while handle the two edge. lets edge are a----b   and Edge c-----d.((I used in and out timing to know which of a and b is at upper and which at lower by using property that in time of subtree is larger and out time is smaller)) Lets assume you are able to find out a is at upper and b is at lower in tree . Same c is at upper and d is at lower. Think a question if i give you any two edge and told you to find out the xor of three parts if i make a cut between a and b also other cut between c and d. so there could be three cases:\\ncase i)c-d edge is in subtree of a-b edge\\ncase ii)a-b edge is in subtree of c-d edge\\ncase iii) a-b and c-d are not subtree they are  like a is connected to c. whithout being the subtree of b.\\nso i find out the xor in all three cases.\\nOne thing you need to observe here that if you given xor of large array lets say arr=[1,2,3,4,5] and you know xor 1^2^3^4^5 of all array now you want to find out xor of 1^2^3^4  so what you will do you will take all number xor with the number which is remaining so i stored all the xor in my dp array if i rooted my tree at 0 then xor of every node with it all element in subtree i have xor stored in dp array. so i used the same concept as above to find xor of all three parts and see which is minimum.\\n\\n                         \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    \\n    int dfs(int a,vector<int>v[],vector<int>&vis,vector<int>nums,vector<int>&in,vector<int>&out,int &t,vector<int>&dp)\\n    {\\n        vis[a]=1;\\n        int ans=nums[a];\\n        in[a]=t++;\\n        for(int child:v[a])\\n        {\\n              if(!vis[child])\\n              {\\n                  ans=ans^(dfs(child,v,vis,nums,in,out,t,dp));\\n              }\\n        }\\n        dp[a]=ans;\\n        out[a]=t++;\\n        return ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<int>in(n),out(n);\\n        int t;\\n        vector<int>v[n];\\n        t=0;\\n        \\n        //in.push_back(-1);\\n        //out.push_back(-1);\\n        for(int i=0;i<n-1;i++)\\n        {   \\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        vector<int>dp(n);\\n        vector<int>vis(n,0);\\n        int p=dfs(0,v,vis,nums,in,out,t,dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<dp[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n        int final_res=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {   int res=INT_MAX;\\n            for(int j=i+1;j<n-1;j++)\\n            {\\n                  \\n                      int a,b,c,d;\\n                      a=edges[i][0];\\n                      b=edges[i][1];\\n                      c=edges[j][0];\\n                      d=edges[j][1];\\n                      int up1=(out[a]<out[b])?b:a;\\n                      int low1=(out[a]<out[b])?a:b;\\n                      int up2=(out[c]<out[d])?d:c;\\n                      int low2=(out[c]<out[d])?c:d;\\n                      \\n                      if(in[up2]>=in[low1]&&out[up2]<=out[low1])\\n                      {\\n                          int k1,k2,k3;\\n                          k1=dp[low2];\\n                          k2=dp[0]^dp[low1];\\n                          k3=dp[low1]^dp[low2];\\n                          //k3=k3^k2;\\n                            int res1=min(k1,min(k2,k3));\\n                            int res2=max(k1,max(k2,k3));\\n                            res=min(res,res2-res1);\\n\\n                      }\\n                      else if(in[up1]>=in[low2]&&out[up1]<=out[low2])\\n                      {\\n                          int k1,k2,k3;\\n                          k1=dp[low1];\\n                          k2=dp[0]^dp[low2];\\n                          k3=dp[low1]^dp[low2];\\n                            int res1=min(k1,min(k2,k3));\\n                            int res2=max(k1,max(k2,k3));\\n                            res=min(res,res2-res1);\\n                      }\\n                      //else if()\\n                      else\\n                      {\\n                          int k1,k2,k3;\\n                        k1=dp[low1];\\n                        k2=dp[low2];\\n                        k3=(dp[0]^dp[low1])^dp[low2];\\n                           int res1=min(k1,min(k2,k3));\\n                            int res2=max(k1,max(k2,k3));\\n                            res=min(res,res2-res1);\\n                      }\\n                      //cout<<up1<<\" \"<<low1<<\" \"<<up2<<\" \"<<low2<<\" \"<<res<<\"\\\\n\";\\n                  \\n            }\\n            final_res=min(final_res,res);\\n        }\\n        return final_res;\\n        //return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    \\n    int dfs(int a,vector<int>v[],vector<int>&vis,vector<int>nums,vector<int>&in,vector<int>&out,int &t,vector<int>&dp)\\n    {\\n        vis[a]=1;\\n        int ans=nums[a];\\n        in[a]=t++;\\n        for(int child:v[a])\\n        {\\n              if(!vis[child])\\n              {\\n                  ans=ans^(dfs(child,v,vis,nums,in,out,t,dp));\\n              }\\n        }\\n        dp[a]=ans;\\n        out[a]=t++;\\n        return ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<int>in(n),out(n);\\n        int t;\\n        vector<int>v[n];\\n        t=0;\\n        \\n        //in.push_back(-1);\\n        //out.push_back(-1);\\n        for(int i=0;i<n-1;i++)\\n        {   \\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        vector<int>dp(n);\\n        vector<int>vis(n,0);\\n        int p=dfs(0,v,vis,nums,in,out,t,dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<dp[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n        int final_res=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {   int res=INT_MAX;\\n            for(int j=i+1;j<n-1;j++)\\n            {\\n                  \\n                      int a,b,c,d;\\n                      a=edges[i][0];\\n                      b=edges[i][1];\\n                      c=edges[j][0];\\n                      d=edges[j][1];\\n                      int up1=(out[a]<out[b])?b:a;\\n                      int low1=(out[a]<out[b])?a:b;\\n                      int up2=(out[c]<out[d])?d:c;\\n                      int low2=(out[c]<out[d])?c:d;\\n                      \\n                      if(in[up2]>=in[low1]&&out[up2]<=out[low1])\\n                      {\\n                          int k1,k2,k3;\\n                          k1=dp[low2];\\n                          k2=dp[0]^dp[low1];\\n                          k3=dp[low1]^dp[low2];\\n                          //k3=k3^k2;\\n                            int res1=min(k1,min(k2,k3));\\n                            int res2=max(k1,max(k2,k3));\\n                            res=min(res,res2-res1);\\n\\n                      }\\n                      else if(in[up1]>=in[low2]&&out[up1]<=out[low2])\\n                      {\\n                          int k1,k2,k3;\\n                          k1=dp[low1];\\n                          k2=dp[0]^dp[low2];\\n                          k3=dp[low1]^dp[low2];\\n                            int res1=min(k1,min(k2,k3));\\n                            int res2=max(k1,max(k2,k3));\\n                            res=min(res,res2-res1);\\n                      }\\n                      //else if()\\n                      else\\n                      {\\n                          int k1,k2,k3;\\n                        k1=dp[low1];\\n                        k2=dp[low2];\\n                        k3=(dp[0]^dp[low1])^dp[low2];\\n                           int res1=min(k1,min(k2,k3));\\n                            int res2=max(k1,max(k2,k3));\\n                            res=min(res,res2-res1);\\n                      }\\n                      //cout<<up1<<\" \"<<low1<<\" \"<<up2<<\" \"<<low2<<\" \"<<res<<\"\\\\n\";\\n                  \\n            }\\n            final_res=min(final_res,res);\\n        }\\n        return final_res;\\n        //return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3692843,
                "title": "beats-100-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint isAncestor[1001][1001];\\nint subxorr[1001];\\nvoid makeAncestor(int src,int par,const int root,vector <vector<int>> &adj)\\n{\\n    isAncestor[root][src] = true;\\n    for(auto x:adj[src])\\n    {\\n        if(x==par) continue;\\n        makeAncestor(x,src,root,adj);\\n    }\\n}\\nint dfs(int src,int par,vector <vector<int>>&adj,vector<int>& nums)\\n{\\n    subxorr[src] = nums[src];\\n    makeAncestor(src,par,src,adj);\\n    for(auto x:adj[src])\\n    {\\n        if(x==par) continue;\\n\\n        dfs(x,src,adj,nums);\\n        subxorr[src]^=subxorr[x];\\n    }\\n    return subxorr[src];\\n}\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        memset(isAncestor,0,sizeof(isAncestor));\\n        vector <vector<int>> adj(n);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        dfs(0,0,adj,nums);\\n        int ans = INT_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(i==j) continue;\\n\\n                if(isAncestor[i][j])\\n                {\\n                    int c1 = subxorr[j];\\n                    int c2 = subxorr[i]^subxorr[j];\\n                    int c3 = subxorr[0]^subxorr[i];\\n                    int maxx = max(max(c1,c2),c3);\\n                    int minn = min(min(c1,c2),c3);\\n                    ans = min(ans,maxx - minn);\\n                }\\n                else if(isAncestor[j][i])\\n                {\\n                    int c1 = subxorr[i];\\n                    int c2 = subxorr[j]^subxorr[i];\\n                    int c3 = subxorr[0]^subxorr[j];\\n                    int maxx = max(max(c1,c2),c3);\\n                    int minn = min(min(c1,c2),c3);\\n                    ans = min(ans,maxx - minn);\\n                }\\n                else\\n                {\\n                    int c1 = subxorr[i];\\n                    int c2 = subxorr[j];\\n                    int c3 = subxorr[0]^subxorr[i]^subxorr[j];\\n                    int maxx = max(max(c1,c2),c3);\\n                    int minn = min(min(c1,c2),c3);\\n                     ans = min(ans,maxx - minn);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint isAncestor[1001][1001];\\nint subxorr[1001];\\nvoid makeAncestor(int src,int par,const int root,vector <vector<int>> &adj)\\n{\\n    isAncestor[root][src] = true;\\n    for(auto x:adj[src])\\n    {\\n        if(x==par) continue;\\n        makeAncestor(x,src,root,adj);\\n    }\\n}\\nint dfs(int src,int par,vector <vector<int>>&adj,vector<int>& nums)\\n{\\n    subxorr[src] = nums[src];\\n    makeAncestor(src,par,src,adj);\\n    for(auto x:adj[src])\\n    {\\n        if(x==par) continue;\\n\\n        dfs(x,src,adj,nums);\\n        subxorr[src]^=subxorr[x];\\n    }\\n    return subxorr[src];\\n}\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        memset(isAncestor,0,sizeof(isAncestor));\\n        vector <vector<int>> adj(n);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        dfs(0,0,adj,nums);\\n        int ans = INT_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(i==j) continue;\\n\\n                if(isAncestor[i][j])\\n                {\\n                    int c1 = subxorr[j];\\n                    int c2 = subxorr[i]^subxorr[j];\\n                    int c3 = subxorr[0]^subxorr[i];\\n                    int maxx = max(max(c1,c2),c3);\\n                    int minn = min(min(c1,c2),c3);\\n                    ans = min(ans,maxx - minn);\\n                }\\n                else if(isAncestor[j][i])\\n                {\\n                    int c1 = subxorr[i];\\n                    int c2 = subxorr[j]^subxorr[i];\\n                    int c3 = subxorr[0]^subxorr[j];\\n                    int maxx = max(max(c1,c2),c3);\\n                    int minn = min(min(c1,c2),c3);\\n                    ans = min(ans,maxx - minn);\\n                }\\n                else\\n                {\\n                    int c1 = subxorr[i];\\n                    int c2 = subxorr[j];\\n                    int c3 = subxorr[0]^subxorr[i]^subxorr[j];\\n                    int maxx = max(max(c1,c2),c3);\\n                    int minn = min(min(c1,c2),c3);\\n                     ans = min(ans,maxx - minn);\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426699,
                "title": "python-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, nums, edges):\\n        dict1 = defaultdict(list)\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        @lru_cache(None)\\n        def dfs(root,parent):\\n            res = []\\n            val = nums[root]\\n\\n            for neighbor in dict1[root]:\\n                if neighbor != parent:\\n                    cur = dfs(neighbor,root)\\n                    res.extend(cur)\\n                    val ^= cur[-1]\\n\\n            res.append(val)\\n\\n            return res\\n\\n        min_val = float(\"inf\")\\n\\n        for x,y in edges:\\n            left_xors = dfs(x,y)\\n            right_xors = dfs(y,x)\\n            left_val = left_xors[-1]\\n            right_val = right_xors[-1]\\n\\n            for l1 in left_xors[:-1]:\\n                l2 = left_val^l1\\n                min_val = min(min_val,max(l1,l2,right_val)-min(l1,l2,right_val))\\n                \\n            for r1 in right_xors[:-1]:\\n                r2 = right_val^r1\\n                min_val = min(min_val,max(r1,r2,left_val)-min(r1,r2,left_val))\\n\\n        return min_val\\n\\n\\n\\n        \\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums, edges):\\n        dict1 = defaultdict(list)\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        @lru_cache(None)\\n        def dfs(root,parent):\\n            res = []\\n            val = nums[root]\\n\\n            for neighbor in dict1[root]:\\n                if neighbor != parent:\\n                    cur = dfs(neighbor,root)\\n                    res.extend(cur)\\n                    val ^= cur[-1]\\n\\n            res.append(val)\\n\\n            return res\\n\\n        min_val = float(\"inf\")\\n\\n        for x,y in edges:\\n            left_xors = dfs(x,y)\\n            right_xors = dfs(y,x)\\n            left_val = left_xors[-1]\\n            right_val = right_xors[-1]\\n\\n            for l1 in left_xors[:-1]:\\n                l2 = left_val^l1\\n                min_val = min(min_val,max(l1,l2,right_val)-min(l1,l2,right_val))\\n                \\n            for r1 in right_xors[:-1]:\\n                r2 = right_val^r1\\n                min_val = min(min_val,max(r1,r2,left_val)-min(r1,r2,left_val))\\n\\n        return min_val\\n\\n\\n\\n        \\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267170,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_score(nums: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        fn dfs(\\n            dp: &mut Vec<i32>,\\n            last: &mut Vec<i32>,\\n            nums: &Vec<i32>,\\n            al: &Vec<Vec<i32>>,\\n            i: usize,\\n            p: i32,\\n            ids: &mut i32,\\n        ) -> i32 {\\n            let mut res = nums[i];\\n            for j in al[i].iter() {\\n                if *j != p {\\n                    let id = *ids;\\n                    *ids += 1;\\n                    dp[id as usize] = dfs(dp, last, nums, al, *j as usize, i as i32, ids);\\n                    last[id as usize] = *ids;\\n                    res ^= dp[id as usize];\\n                }\\n            }\\n            res\\n        }\\n\\n        let mut dp = vec![0; 1000];\\n        let mut last = vec![0; 1000];\\n        let mut ids = 0;\\n        let mut res = i32::MAX;\\n        let mut al = vec![vec![]; nums.len()];\\n        for e in edges.iter() {\\n            al[e[0] as usize].push(e[1]);\\n            al[e[1] as usize].push(e[0]);\\n        }\\n        let all = dfs(&mut dp, &mut last, &nums, &al, 0, -1, &mut ids);\\n        for i in 0..edges.len() {\\n            for j in i + 1..edges.len() {\\n                let p1 = if j < last[i] as usize {\\n                    all ^ dp[i]\\n                } else {\\n                    all ^ dp[i] ^ dp[j]\\n                };\\n                let p2 = if j < last[i] as usize { dp[i] ^ dp[j] } else { dp[i] };\\n                let arr = [p1, p2, dp[j]];\\n                let max = arr.iter().max().unwrap();\\n                let min = arr.iter().min().unwrap();\\n                res = res.min(max - min);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_score(nums: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        fn dfs(\\n            dp: &mut Vec<i32>,\\n            last: &mut Vec<i32>,\\n            nums: &Vec<i32>,\\n            al: &Vec<Vec<i32>>,\\n            i: usize,\\n            p: i32,\\n            ids: &mut i32,\\n        ) -> i32 {\\n            let mut res = nums[i];\\n            for j in al[i].iter() {\\n                if *j != p {\\n                    let id = *ids;\\n                    *ids += 1;\\n                    dp[id as usize] = dfs(dp, last, nums, al, *j as usize, i as i32, ids);\\n                    last[id as usize] = *ids;\\n                    res ^= dp[id as usize];\\n                }\\n            }\\n            res\\n        }\\n\\n        let mut dp = vec![0; 1000];\\n        let mut last = vec![0; 1000];\\n        let mut ids = 0;\\n        let mut res = i32::MAX;\\n        let mut al = vec![vec![]; nums.len()];\\n        for e in edges.iter() {\\n            al[e[0] as usize].push(e[1]);\\n            al[e[1] as usize].push(e[0]);\\n        }\\n        let all = dfs(&mut dp, &mut last, &nums, &al, 0, -1, &mut ids);\\n        for i in 0..edges.len() {\\n            for j in i + 1..edges.len() {\\n                let p1 = if j < last[i] as usize {\\n                    all ^ dp[i]\\n                } else {\\n                    all ^ dp[i] ^ dp[j]\\n                };\\n                let p2 = if j < last[i] as usize { dp[i] ^ dp[j] } else { dp[i] };\\n                let arr = [p1, p2, dp[j]];\\n                let max = arr.iter().max().unwrap();\\n                let min = arr.iter().min().unwrap();\\n                res = res.min(max - min);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222012,
                "title": "from-brute-force-to-optimized-code-by-caching-xors-of-all-subtree",
                "content": "# Intuition\\nIn the Brute Force Approch, we actully deleting the two edges and then calculating the XORs of all the three components. But we can we imporove this by Caching all the XORs of subtrees.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can easily calculate the XORs of all the subtrees using DFS. We also have to consider one condition, Comp1 (compent by formed c1 node) is the subtree of Comp2(compent formed by C2 node), then we can find Comp1 by subtree_xor[c1] and  for finding Comp2, we have find the part which is left after removing Comp1 subtree from Comp2 subtree. Comp2 = subtree[c1] ^ subtree[c2].\\n\\nNow for finding the third compent, if we remove comp1 and comp2 from Total. Then we get the comp3;\\n\\nTotal = subtree_xor[0];\\n\\nTotal = comp1 ^ comp2 ^ comp3;\\nwe alredy know total, comp1 and comp2;\\n\\nmultiplying by comp1 ^ comp2 on both sides we get,\\nTotal ^ comp1 ^ comp2 = comp3;\\ncomp3 = Total ^ comp1 ^comp3;\\ncomp3 = subtree_xor[0] ^ comp1 ^ comp2;\\n\\nAlso, if comp1 is not the subtree of comp2 and vice versa, then\\ncomp1 = subtree_xor[c1];\\ncomp2 = subtree_xor[c2];\\ncomp3 = subtree_xor[0] ^ comp1 ^ comp2;\\n\\nI learned this approch from codingMohan, [you can watch his video \\nhere.](https://youtu.be/blKFzGYejF0)\\n\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n/////////////////////////////////////////////////// BRUTE FORCE APPROACH /////////////////////////////////////////\\n    \\n    \\n//     void dfs(map<int, set<int>> edj, int curr, vector<bool> &v, int &xorr, vector<int>& nums){\\n//         // cout<<nums[curr]<<\" \";\\n//         for(auto child: edj[curr]){\\n//             if(!v[child]){\\n//                 v[child] = true;\\n//                 xorr = xorr ^ nums[child];\\n//                 dfs(edj,child,v, xorr, nums);\\n//             }\\n//         }\\n//     }\\n    \\n//     int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n//         int n = nums.size();\\n//         map<int, set<int>> edj;\\n//         for(auto e: edges){\\n//             edj[e[0]].insert(e[1]);\\n//             edj[e[1]].insert(e[0]);                \\n//         }\\n         \\n//         int ans =INT_MAX;\\n//         int cnt  =0;\\n//         for(int i=0; i<edges.size(); i++){\\n\\n//             for(int j = i+1; j<edges.size(); j++){\\n//                 if(i!=j){\\n                    \\n                    \\n//                     // cout<<i<<\" \"<<j<<\"\\\\n\";\\n//                     int xorMn =INT_MAX;\\n//                     int xorMx =INT_MIN;\\n                    \\n//                     int e1n1 = edges[i][0];\\n//                     int e1n2 = edges[i][1];\\n                    \\n//                     edj[e1n1].erase(e1n2);\\n//                     edj[e1n2].erase(e1n1);\\n                    \\n//                     int e2n1 = edges[j][0];\\n//                     int e2n2 = edges[j][1];\\n                    \\n                    \\n//                     edj[e2n1].erase(e2n2);\\n//                     edj[e2n2].erase(e2n1);\\n                    \\n                    \\n//                     vector<bool> v(n,false);\\n                    \\n//                     for(int i=0; i<n; i++){\\n//                         if(!v[i]){\\n//                             int xorr = nums[i];\\n//                             v[i] = true;\\n//                             dfs(edj,i, v, xorr, nums);\\n//                             // cout<<\"\\\\n\";\\n//                             // cout<<xorr<<\" \";\\n                            \\n//                             xorMn = min(xorMn,xorr);\\n//                             xorMx = max(xorMx,xorr);\\n//                             // cnt++;\\n//                         }\\n//                     }\\n                    \\n                                             \\n//                     // cout<<xorMn<<\" \";\\n//                     // cout<<xorMx<<\"\\\\n\";\\n//                     // cout<<\"\\\\n\";\\n                    \\n//                     ans = min(xorMx -  xorMn, ans);\\n                    \\n//                     edj[e1n1].insert(e1n2);\\n//                     edj[e1n2].insert(e1n1);\\n                    \\n//                     edj[e2n1].insert(e2n2);\\n//                     edj[e2n2].insert(e2n1);\\n                    \\n                    \\n//                     // cout<<\"\\\\n\";\\n                    \\n//                 }\\n//             }\\n//         }\\n      \\n//         return ans;\\n//     }\\n\\n//////////////////////////////////////////////// OPTIMISED APPROACH //////////////////////////////////////////\\n    \\n    \\n    vector<int> subtree_xor;\\n    vector<vector<bool>> is_ancestor;\\n    vector<vector<int>> edj;\\n    \\n    void ancestor(int s, int p, const int r){\\n        is_ancestor[r][s] = true;\\n        for(auto c: edj[s]){\\n            if(c!=p){\\n                ancestor(c,s,r);\\n            }\\n        }\\n    }\\n    \\n    int getScore(int c1, int c2, int c3){\\n        int mn = min(c1, min(c2, c3));\\n        int mx = max(c1, max(c2, c3));\\n        return mx - mn;\\n    }\\n    \\n    void dfs(int s,int p,vector<int>& nums){\\n        subtree_xor[s] = nums[s];\\n        ancestor(s,p,s);\\n        for(auto c: edj[s]){\\n            if(c != p){\\n                dfs(c,s,nums);\\n                subtree_xor[s]^=subtree_xor[c];\\n            }\\n        }\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        edj.resize(n+1);\\n        subtree_xor.resize(n+1);\\n        is_ancestor.resize(n+1, vector<bool>(n+1,false));\\n        \\n        for(int i=0; i<n; i++){\\n            edj[i].clear();\\n            for(int j=0; j<n; j++) is_ancestor[i][j] = false;\\n        }\\n\\n        \\n        for(auto e: edges){\\n            edj[e[0]].push_back(e[1]);\\n            edj[e[1]].push_back(e[0]);                \\n        }\\n        \\n        dfs(0, 0,nums);\\n        \\n        // cout<<subtree_xor[0]<<\"\\\\n\";\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int c1 = 1; c1< n; c1++){\\n            for(int c2 = c1+1; c2<n; c2++){\\n                if(c1 == c2)\\n                    continue;\\n                \\n                if(is_ancestor[c1][c2]){\\n                    int comp1 = subtree_xor[c2];\\n                    int comp2 = subtree_xor[c2] ^ subtree_xor[c1];\\n                    int comp3 = subtree_xor[0] ^comp1 ^comp2;\\n                    \\n                    ans = min(ans, getScore(comp1,comp2, comp3));\\n                    \\n                }\\n                else if(is_ancestor[c2][c1]){\\n                    int comp1 = subtree_xor[c1];\\n                    int comp2 = subtree_xor[c1] ^ subtree_xor[c2];\\n                    int comp3 = subtree_xor[0] ^ comp1 ^ comp2;\\n                    \\n                    ans = min(ans, getScore(comp1,comp2, comp3));\\n                }\\n                else{\\n                    int comp1 = subtree_xor[c2];\\n                    int comp2 = subtree_xor[c1];\\n                    int comp3 = subtree_xor[0] ^ comp1 ^ comp2;\\n                    \\n                    ans = min(ans, getScore(comp1,comp2, comp3));\\n                    \\n                }\\n            }\\n        }\\n    \\n    \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n/////////////////////////////////////////////////// BRUTE FORCE APPROACH /////////////////////////////////////////\\n    \\n    \\n//     void dfs(map<int, set<int>> edj, int curr, vector<bool> &v, int &xorr, vector<int>& nums){\\n//         // cout<<nums[curr]<<\" \";\\n//         for(auto child: edj[curr]){\\n//             if(!v[child]){\\n//                 v[child] = true;\\n//                 xorr = xorr ^ nums[child];\\n//                 dfs(edj,child,v, xorr, nums);\\n//             }\\n//         }\\n//     }\\n    \\n//     int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n//         int n = nums.size();\\n//         map<int, set<int>> edj;\\n//         for(auto e: edges){\\n//             edj[e[0]].insert(e[1]);\\n//             edj[e[1]].insert(e[0]);                \\n//         }\\n         \\n//         int ans =INT_MAX;\\n//         int cnt  =0;\\n//         for(int i=0; i<edges.size(); i++){\\n\\n//             for(int j = i+1; j<edges.size(); j++){\\n//                 if(i!=j){\\n                    \\n                    \\n//                     // cout<<i<<\" \"<<j<<\"\\\\n\";\\n//                     int xorMn =INT_MAX;\\n//                     int xorMx =INT_MIN;\\n                    \\n//                     int e1n1 = edges[i][0];\\n//                     int e1n2 = edges[i][1];\\n                    \\n//                     edj[e1n1].erase(e1n2);\\n//                     edj[e1n2].erase(e1n1);\\n                    \\n//                     int e2n1 = edges[j][0];\\n//                     int e2n2 = edges[j][1];\\n                    \\n                    \\n//                     edj[e2n1].erase(e2n2);\\n//                     edj[e2n2].erase(e2n1);\\n                    \\n                    \\n//                     vector<bool> v(n,false);\\n                    \\n//                     for(int i=0; i<n; i++){\\n//                         if(!v[i]){\\n//                             int xorr = nums[i];\\n//                             v[i] = true;\\n//                             dfs(edj,i, v, xorr, nums);\\n//                             // cout<<\"\\\\n\";\\n//                             // cout<<xorr<<\" \";\\n                            \\n//                             xorMn = min(xorMn,xorr);\\n//                             xorMx = max(xorMx,xorr);\\n//                             // cnt++;\\n//                         }\\n//                     }\\n                    \\n                                             \\n//                     // cout<<xorMn<<\" \";\\n//                     // cout<<xorMx<<\"\\\\n\";\\n//                     // cout<<\"\\\\n\";\\n                    \\n//                     ans = min(xorMx -  xorMn, ans);\\n                    \\n//                     edj[e1n1].insert(e1n2);\\n//                     edj[e1n2].insert(e1n1);\\n                    \\n//                     edj[e2n1].insert(e2n2);\\n//                     edj[e2n2].insert(e2n1);\\n                    \\n                    \\n//                     // cout<<\"\\\\n\";\\n                    \\n//                 }\\n//             }\\n//         }\\n      \\n//         return ans;\\n//     }\\n\\n//////////////////////////////////////////////// OPTIMISED APPROACH //////////////////////////////////////////\\n    \\n    \\n    vector<int> subtree_xor;\\n    vector<vector<bool>> is_ancestor;\\n    vector<vector<int>> edj;\\n    \\n    void ancestor(int s, int p, const int r){\\n        is_ancestor[r][s] = true;\\n        for(auto c: edj[s]){\\n            if(c!=p){\\n                ancestor(c,s,r);\\n            }\\n        }\\n    }\\n    \\n    int getScore(int c1, int c2, int c3){\\n        int mn = min(c1, min(c2, c3));\\n        int mx = max(c1, max(c2, c3));\\n        return mx - mn;\\n    }\\n    \\n    void dfs(int s,int p,vector<int>& nums){\\n        subtree_xor[s] = nums[s];\\n        ancestor(s,p,s);\\n        for(auto c: edj[s]){\\n            if(c != p){\\n                dfs(c,s,nums);\\n                subtree_xor[s]^=subtree_xor[c];\\n            }\\n        }\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        edj.resize(n+1);\\n        subtree_xor.resize(n+1);\\n        is_ancestor.resize(n+1, vector<bool>(n+1,false));\\n        \\n        for(int i=0; i<n; i++){\\n            edj[i].clear();\\n            for(int j=0; j<n; j++) is_ancestor[i][j] = false;\\n        }\\n\\n        \\n        for(auto e: edges){\\n            edj[e[0]].push_back(e[1]);\\n            edj[e[1]].push_back(e[0]);                \\n        }\\n        \\n        dfs(0, 0,nums);\\n        \\n        // cout<<subtree_xor[0]<<\"\\\\n\";\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int c1 = 1; c1< n; c1++){\\n            for(int c2 = c1+1; c2<n; c2++){\\n                if(c1 == c2)\\n                    continue;\\n                \\n                if(is_ancestor[c1][c2]){\\n                    int comp1 = subtree_xor[c2];\\n                    int comp2 = subtree_xor[c2] ^ subtree_xor[c1];\\n                    int comp3 = subtree_xor[0] ^comp1 ^comp2;\\n                    \\n                    ans = min(ans, getScore(comp1,comp2, comp3));\\n                    \\n                }\\n                else if(is_ancestor[c2][c1]){\\n                    int comp1 = subtree_xor[c1];\\n                    int comp2 = subtree_xor[c1] ^ subtree_xor[c2];\\n                    int comp3 = subtree_xor[0] ^ comp1 ^ comp2;\\n                    \\n                    ans = min(ans, getScore(comp1,comp2, comp3));\\n                }\\n                else{\\n                    int comp1 = subtree_xor[c2];\\n                    int comp2 = subtree_xor[c1];\\n                    int comp3 = subtree_xor[0] ^ comp1 ^ comp2;\\n                    \\n                    ans = min(ans, getScore(comp1,comp2, comp3));\\n                    \\n                }\\n            }\\n        }\\n    \\n    \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3058138,
                "title": "short-o-n-2-java-brute-force-dfs-precompute-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. precompute xor for each subtrees\\n2. then 1st dfs to find the 1st connected component\\n3. then for every 1st component, again do dfs to find the 2nd connected component\\n4. once you know the xor of both component, use them to find xor of 3rd component\\n5. find the optimal answer.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        xor = new int[n];\\n        tree = new ArrayList[n];\\n        for(int i=0;i<n;i++)tree[i] = new ArrayList<>();\\n        for(int[] e : edges){\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n\\n        }\\n        dfs1(0,-1,nums);\\n        // System.out.println(Arrays.toString(xor));\\n        dfs2(0,new HashSet<>(),-1);\\n        return ans;\\n\\n    }  \\n    int ans = (int)1e9;\\n    List<Integer> [] tree;  \\n    int[] xor ;   \\n    private  void dfs1(int x, int p,int[] nums){\\n        xor[x] = nums[x];\\n        for(int y : tree[x]){\\n            if(y!=p){\\n                dfs1(y,x,nums);\\n                xor[x] ^= xor[y];\\n            }\\n            \\n        }\\n    }\\n    private void dfs2(int x, Set<Integer> set, int p){\\n        set.add(x);\\n        dfs3(0,-1,set,x);\\n        for(int y : tree[x])\\n            if(y!=p)dfs2(y,set,x);\\n        set.remove(x);\\n    }\\n    private void dfs3(int x, int p, Set<Integer> ancestor,int a){\\n        if(x == a)return;\\n        int b,c;\\n        if(ancestor.contains(x)){\\n             b = xor[x] ^ xor[a];\\n             c = xor[0] ^ xor[x];\\n        }else{\\n            b = xor[x];\\n            c = xor[0] ^ xor[a] ^ b;\\n        }\\n        int curr = Math.max(xor[a],Math.max(b,c)) - Math.min(xor[a],Math.min(b,c));\\n        if(x!=0)ans = Math.min(ans,curr);\\n        // System.out.println(x+\" \"+a+\" \"+xor[a]+\" \"+b+\" \"+c);\\n        for(int y : tree[x])\\n            if(y!=p)dfs3(y,x,ancestor,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        xor = new int[n];\\n        tree = new ArrayList[n];\\n        for(int i=0;i<n;i++)tree[i] = new ArrayList<>();\\n        for(int[] e : edges){\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n\\n        }\\n        dfs1(0,-1,nums);\\n        // System.out.println(Arrays.toString(xor));\\n        dfs2(0,new HashSet<>(),-1);\\n        return ans;\\n\\n    }  \\n    int ans = (int)1e9;\\n    List<Integer> [] tree;  \\n    int[] xor ;   \\n    private  void dfs1(int x, int p,int[] nums){\\n        xor[x] = nums[x];\\n        for(int y : tree[x]){\\n            if(y!=p){\\n                dfs1(y,x,nums);\\n                xor[x] ^= xor[y];\\n            }\\n            \\n        }\\n    }\\n    private void dfs2(int x, Set<Integer> set, int p){\\n        set.add(x);\\n        dfs3(0,-1,set,x);\\n        for(int y : tree[x])\\n            if(y!=p)dfs2(y,set,x);\\n        set.remove(x);\\n    }\\n    private void dfs3(int x, int p, Set<Integer> ancestor,int a){\\n        if(x == a)return;\\n        int b,c;\\n        if(ancestor.contains(x)){\\n             b = xor[x] ^ xor[a];\\n             c = xor[0] ^ xor[x];\\n        }else{\\n            b = xor[x];\\n            c = xor[0] ^ xor[a] ^ b;\\n        }\\n        int curr = Math.max(xor[a],Math.max(b,c)) - Math.min(xor[a],Math.min(b,c));\\n        if(x!=0)ans = Math.min(ans,curr);\\n        // System.out.println(x+\" \"+a+\" \"+xor[a]+\" \"+b+\" \"+c);\\n        for(int y : tree[x])\\n            if(y!=p)dfs3(y,x,ancestor,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936004,
                "title": "c-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& V, vector<vector<int>>& E) {\\n        unordered_set<int> g[1001];\\n        for(auto & e : E) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        int res = INT_MAX;\\n\\n        function<int(int, int)> calc = [&](int n, int p)->int {\\n            int total = V[n];\\n            for(auto nxt : g[n]) if(nxt != p) total ^= calc(nxt, n);\\n            return total;\\n        };\\n\\n        function<int(int, int, int, int)> final = [&](int a, int b, int r, int p)->int {\\n            int total = V[r];\\n            for(auto nxt : g[r]) {\\n                if(nxt == p) continue;\\n                int c = final(a, b, nxt, r), other = b^c, min_v = min({a, c, other}), max_v = max({a, c, other});\\n                res = min(res, max_v-min_v);\\n                total ^= c;\\n            }\\n            return total;\\n        };\\n\\n        for(auto & e : E) {\\n            g[e[0]].erase(e[1]);\\n            g[e[1]].erase(e[0]);\\n            int A = calc(e[0], -1);\\n            int B = calc(e[1], -1);\\n            final(A, B, e[1], -1);\\n            final(B, A, e[0], -1);\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& V, vector<vector<int>>& E) {\\n        unordered_set<int> g[1001];\\n        for(auto & e : E) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        int res = INT_MAX;\\n\\n        function<int(int, int)> calc = [&](int n, int p)->int {\\n            int total = V[n];\\n            for(auto nxt : g[n]) if(nxt != p) total ^= calc(nxt, n);\\n            return total;\\n        };\\n\\n        function<int(int, int, int, int)> final = [&](int a, int b, int r, int p)->int {\\n            int total = V[r];\\n            for(auto nxt : g[r]) {\\n                if(nxt == p) continue;\\n                int c = final(a, b, nxt, r), other = b^c, min_v = min({a, c, other}), max_v = max({a, c, other});\\n                res = min(res, max_v-min_v);\\n                total ^= c;\\n            }\\n            return total;\\n        };\\n\\n        for(auto & e : E) {\\n            g[e[0]].erase(e[1]);\\n            g[e[1]].erase(e[0]);\\n            int A = calc(e[0], -1);\\n            int B = calc(e[1], -1);\\n            final(A, B, e[1], -1);\\n            final(B, A, e[0], -1);\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844328,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int dfs(int v, int p, vector<vector<int>>& edge, vector<int>& XOR, vector<int>& nums) {\\n        int x = 0;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                x ^= dfs(u, v, edge, XOR, nums);\\n            }\\n        }\\n        x ^= nums[v];\\n        XOR[v] = x;\\n        return x;\\n    }\\n    void dfs1(int v, int p, vector<vector<int>>& edge, vector<int>& XOR, int one, int total, int& sol) {\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                int two = XOR[u];\\n                int three = total ^ two;\\n                int bg = max({one, two, three});\\n                int sm = min({one, two, three});\\n                sol = min(sol, bg - sm);\\n                dfs1(u, v, edge, XOR, one, total, sol);\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        int sol = INF;\\n        int total = 0;\\n        for (int i : nums) {\\n            total ^= i;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector<int> XOR(n);\\n            for (int u : edge[i]) {\\n                dfs(i, u, edge, XOR, nums);\\n                int one = total ^ XOR[i];\\n                int tot = XOR[i];\\n                dfs1(i, u, edge, XOR, one, tot, sol);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int dfs(int v, int p, vector<vector<int>>& edge, vector<int>& XOR, vector<int>& nums) {\\n        int x = 0;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                x ^= dfs(u, v, edge, XOR, nums);\\n            }\\n        }\\n        x ^= nums[v];\\n        XOR[v] = x;\\n        return x;\\n    }\\n    void dfs1(int v, int p, vector<vector<int>>& edge, vector<int>& XOR, int one, int total, int& sol) {\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                int two = XOR[u];\\n                int three = total ^ two;\\n                int bg = max({one, two, three});\\n                int sm = min({one, two, three});\\n                sol = min(sol, bg - sm);\\n                dfs1(u, v, edge, XOR, one, total, sol);\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        int sol = INF;\\n        int total = 0;\\n        for (int i : nums) {\\n            total ^= i;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector<int> XOR(n);\\n            for (int u : edge[i]) {\\n                dfs(i, u, edge, XOR, nums);\\n                int one = total ^ XOR[i];\\n                int tot = XOR[i];\\n                dfs1(i, u, edge, XOR, one, tot, sol);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832392,
                "title": "dfs-o-n-pre-processing-o-n-n-time",
                "content": "# Intuition\\nWe have to delete two edges right?\\nLet\\'s try to delete!\\n\\nI want to you guys to think in how many ways we can delete two edges\\nlet\\'s take and example which is given in question\\n(You can assume any node as rote node that will not change the result)\\n   \\n           1\\n         / | \\\\\\n        3  0  2\\n       /\\n      4\\nok let\\'s say we delete the edge between 1 and 0 and 1 and 2\\nwe will gate some answer by that and that calculation is easy\\n\\nwe can simply xor the xor value of subtrees rooted at 0 and 2 with subtree rooted at 1(if we consider 1 as root)\\n![WhatsApp Image 2022-11-20 at 12.12.29.jpg](https://assets.leetcode.com/users/images/7b3d10af-e9a7-4bf9-b1f8-99b997eb90e7_1668926683.5272024.jpeg)\\n\\n\\nisn\\'t is easy ?\\n\\nbut is there any other case ?\\nYes\\nNow try to delete edge between 3-4 and 1-3 can we xor values of 3 with xor value of subtree rooted at 1 ?\\nNo we can\\'t \\nBecause 4 is in the subtree of 3 which will change the xor value of subtree rooted at 3 itself\\n![WhatsApp Image 2022-11-20 a.jpg](https://assets.leetcode.com/users/images/f388fe7c-35de-46a9-9a33-36f171ae8201_1668926778.648012.jpeg)\\n\\n\\n\\n\\n# Approach\\nSo we have got 2 cases \\nFirst =>\\nwhen we are deleting two different edges such any of two lower nodes in tree doesn\\'t lie in the subtrees of each other\\nIn this Case we can simply xor the xor value of subtree rooted at lower nodes with xor value of subtree rooted at higher value.\\n\\nSecond =>\\n    When one of the lower node lies between subtree of other lower node.\\nIn This case we case can xor the middle node value with lowest node and than xor the higher node value with middle node value.\\n\\nSo how can we check if one node is in the subtree of the other node ?\\nBy using in-out time of dfs.\\n\\n\\nSo what will be the pre-processing ?\\nWe will need xor of every subtree ?\\ncan we calculate this in O(n) time ? yes we can, using dfs\\nWe will need in and out time and dfs ?\\ncan we calculate this in O(n) time ? yes we can, using dfs\\n\\n\\nNow we can check of every pair of edges and try to compare and get optimal answer  .\\nNow we can process both cases in O(1) time!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * n) with O(n) extra pre-processing\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>xor_ ;\\n    int time = 0 ;\\n    vector<int>in , out ;\\n    //calculating in-out time \\n    void inout(vector<vector<int>>&adjList , int source , int parent = -1){\\n        in[source] = ++time ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                inout(adjList , it , source);\\n            }\\n        }\\n        out[source] = ++time ;\\n    }\\n    //calculating xor of every subtree\\n    void precompute(vector<vector<int>>&adjList , int source , vector<int>&nums , int parent = -1){\\n        int ans = nums[source];\\n        \\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                precompute(adjList , it , nums , source);\\n                ans ^= xor_[it];\\n            }\\n        }\\n        \\n        xor_[source] = ans ; \\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int>>adjList(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        xor_.resize(n);\\n        in.resize(n);\\n        out.resize(n);\\n        precompute(adjList , 1 , nums);\\n        inout(adjList , 1 );\\n        int uni = xor_[1];\\n        int res = INT_MAX ;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = i + 1 ; j < n ; j++){\\n                if(i == 1 || j == 1)\\n                    continue;\\n                \\n                int first = xor_[i];\\n                int second = xor_[j];\\n                // if j lies in subtree of i\\n                if(in[i] <= in[j] && out[i] >= out[j]){\\n                    uni ^= first ;\\n                    first ^= second ;\\n                    int mx = max({first , second , uni});\\n                    int mn = min({first , second , uni});\\n                    res = min(res , mx - mn) ;\\n                }\\n                else if(in[j] <= in[i] && out[j] >= out[i]){\\n                    uni ^= second ;\\n                    second ^= first ;\\n                    int mx = max({first , second , uni});\\n                    int mn = min({first , second , uni});\\n                    res = min(res , mx - mn);\\n                }\\n                else{\\n                    uni ^= first ;\\n                    uni ^= second ;\\n                    int mx = max({first , second , uni});\\n                    int mn = min({first , second , uni});\\n                    res = min(res , mx - mn);\\n                }\\n                uni = xor_[1];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nDo comment for suggetions or queries! :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>xor_ ;\\n    int time = 0 ;\\n    vector<int>in , out ;\\n    //calculating in-out time \\n    void inout(vector<vector<int>>&adjList , int source , int parent = -1){\\n        in[source] = ++time ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                inout(adjList , it , source);\\n            }\\n        }\\n        out[source] = ++time ;\\n    }\\n    //calculating xor of every subtree\\n    void precompute(vector<vector<int>>&adjList , int source , vector<int>&nums , int parent = -1){\\n        int ans = nums[source];\\n        \\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                precompute(adjList , it , nums , source);\\n                ans ^= xor_[it];\\n            }\\n        }\\n        \\n        xor_[source] = ans ; \\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int>>adjList(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        xor_.resize(n);\\n        in.resize(n);\\n        out.resize(n);\\n        precompute(adjList , 1 , nums);\\n        inout(adjList , 1 );\\n        int uni = xor_[1];\\n        int res = INT_MAX ;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = i + 1 ; j < n ; j++){\\n                if(i == 1 || j == 1)\\n                    continue;\\n                \\n                int first = xor_[i];\\n                int second = xor_[j];\\n                // if j lies in subtree of i\\n                if(in[i] <= in[j] && out[i] >= out[j]){\\n                    uni ^= first ;\\n                    first ^= second ;\\n                    int mx = max({first , second , uni});\\n                    int mn = min({first , second , uni});\\n                    res = min(res , mx - mn) ;\\n                }\\n                else if(in[j] <= in[i] && out[j] >= out[i]){\\n                    uni ^= second ;\\n                    second ^= first ;\\n                    int mx = max({first , second , uni});\\n                    int mn = min({first , second , uni});\\n                    res = min(res , mx - mn);\\n                }\\n                else{\\n                    uni ^= first ;\\n                    uni ^= second ;\\n                    int mx = max({first , second , uni});\\n                    int mn = min({first , second , uni});\\n                    res = min(res , mx - mn);\\n                }\\n                uni = xor_[1];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792281,
                "title": "python-o-n-2-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst wo choose one edge and split the whole tree into two tree. Then We choose one of tree to split it, which we can calculate the XOR of the two compents with DFS.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = [set() for _ in range(n)]\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        ans = float(\\'inf\\')\\n        def dfs(v, visited, subs):\\n            ret = nums[v]\\n            for u in graph[v]:\\n                if u not in visited:\\n                    visited.add(u)\\n                    cur = dfs(u, visited, subs)\\n                    ret ^= cur\\n                    subs.add(cur)\\n            return ret\\n        for u, v in edges:\\n            graph[u].remove(v)\\n            graph[v].remove(u)\\n            leftsubs, rightsubs = set(), set()\\n            left, right = dfs(u, {u}, leftsubs), dfs(v, {v}, rightsubs)\\n            for c in leftsubs:\\n                parts = [right, c, left ^ c]\\n                ans = min(ans, max(parts) - min(parts))\\n            for c in rightsubs:\\n                parts = [left, c, right ^ c]\\n                ans = min(ans, max(parts) - min(parts))\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = [set() for _ in range(n)]\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        ans = float(\\'inf\\')\\n        def dfs(v, visited, subs):\\n            ret = nums[v]\\n            for u in graph[v]:\\n                if u not in visited:\\n                    visited.add(u)\\n                    cur = dfs(u, visited, subs)\\n                    ret ^= cur\\n                    subs.add(cur)\\n            return ret\\n        for u, v in edges:\\n            graph[u].remove(v)\\n            graph[v].remove(u)\\n            leftsubs, rightsubs = set(), set()\\n            left, right = dfs(u, {u}, leftsubs), dfs(v, {v}, rightsubs)\\n            for c in leftsubs:\\n                parts = [right, c, left ^ c]\\n                ans = min(ans, max(parts) - min(parts))\\n            for c in rightsubs:\\n                parts = [left, c, right ^ c]\\n                ans = min(ans, max(parts) - min(parts))\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765009,
                "title": "java-time-o-n-space-o-n-dfs-time-clock-order-in-dfs",
                "content": "```\\n//learnt the solution to this problem from \\n//@endlesscheng\\n//https://leetcode.cn/u/endlesscheng/\\n\\n//basic idea\\n\\n//first\\n//there are three parts after you remove two edges, they corresponds to three subtrees.\\n//we enumerate the root of those three subtrees.\\n\\n//first root is of course the root of the entire tree,\\n//another two roots, we can enumerate. \\n//lets say the root of the entire tree is 0, and another two roots are x, y\\n//x\\\\in {1,2, ... , n-1}\\n//y\\\\in {1,2,...., n-1} but x!=y\\n\\n//second\\n//how do we caculate the xor of those three subtrees ?\\n//1. calculate xor of every subtree\\n//2. calculate xor of 3 components based on the relationships of their roots.\\n//we already know 0 is father of x and y\\n//so we need to discuss the cases x and y\\n//if x is father of y, then \\n//xor(subtree root at y) = xor(y)\\n//xor(subtree root at x) = xor(x) ^ xor(y)\\n//xor(subtree root at 0) = xor(0) ^ xor(x)\\n\\n//similarly you get the idea of other cases.\\n\\n//third\\n//how do you know if x is father of y or not?\\n//here is where an interesting technique kicks in.\\n//you dfs the entire tree, and record the time you first visit a node,\\n//and the time you leaving a node.\\n\\n//int[] in = new int[n]\\n//int[] out = new int[n]\\n\\n//if in[x] < in[y] <= out[y] <= out[x] : x is father of y\\n\\n\\n\\nclass Solution {\\n    int n, t = 0;\\n    int[] in, out, xor, nums;\\n    List<Integer>[] graph;\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        this.n = nums.length;\\n        this.in = new int[n];\\n        this.out = new int[n];\\n        this.xor = new int[n];\\n        this.nums = nums;\\n        \\n        this.graph = new ArrayList[n];\\n        Arrays.setAll(graph, o->new ArrayList<>());\\n        for(int[] e:edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        dfs(0, -1);\\n        int result = Integer.MAX_VALUE;\\n        for(int i=2, x, y, z; i<n;i++){\\n            for(int j = 1;j<i;j++){\\n                if(in[i]<in[j] && in[j]<=out[i]){\\n                    x = xor[j];\\n                    y = xor[i]^xor[j];\\n                    z = xor[0]^xor[i];\\n                }else if(in[j]<in[i] && in[i] <= out[j]){\\n                    x = xor[i];\\n                    y = xor[j] ^ xor[i];\\n                    z = xor[0] ^ xor[j];\\n                }else{\\n                    x = xor[i];\\n                    y = xor[j];\\n                    z = xor[0] ^ xor[i] ^ xor[j];\\n                }\\n                result = Math.min(result, Math.max(Math.max(x,y),z) - Math.min(Math.min(x,y),z));\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(int node, int parent){\\n        in[node] = ++t;\\n        \\n        xor[node] = nums[node];\\n        for(int nei:graph[node]){\\n            if(nei!=parent){\\n                dfs(nei,node);\\n                xor[node] ^= xor[nei];\\n            }\\n        }\\n        \\n        out[node] = t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//learnt the solution to this problem from \\n//@endlesscheng\\n//https://leetcode.cn/u/endlesscheng/\\n\\n//basic idea\\n\\n//first\\n//there are three parts after you remove two edges, they corresponds to three subtrees.\\n//we enumerate the root of those three subtrees.\\n\\n//first root is of course the root of the entire tree,\\n//another two roots, we can enumerate. \\n//lets say the root of the entire tree is 0, and another two roots are x, y\\n//x\\\\in {1,2, ... , n-1}\\n//y\\\\in {1,2,...., n-1} but x!=y\\n\\n//second\\n//how do we caculate the xor of those three subtrees ?\\n//1. calculate xor of every subtree\\n//2. calculate xor of 3 components based on the relationships of their roots.\\n//we already know 0 is father of x and y\\n//so we need to discuss the cases x and y\\n//if x is father of y, then \\n//xor(subtree root at y) = xor(y)\\n//xor(subtree root at x) = xor(x) ^ xor(y)\\n//xor(subtree root at 0) = xor(0) ^ xor(x)\\n\\n//similarly you get the idea of other cases.\\n\\n//third\\n//how do you know if x is father of y or not?\\n//here is where an interesting technique kicks in.\\n//you dfs the entire tree, and record the time you first visit a node,\\n//and the time you leaving a node.\\n\\n//int[] in = new int[n]\\n//int[] out = new int[n]\\n\\n//if in[x] < in[y] <= out[y] <= out[x] : x is father of y\\n\\n\\n\\nclass Solution {\\n    int n, t = 0;\\n    int[] in, out, xor, nums;\\n    List<Integer>[] graph;\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        this.n = nums.length;\\n        this.in = new int[n];\\n        this.out = new int[n];\\n        this.xor = new int[n];\\n        this.nums = nums;\\n        \\n        this.graph = new ArrayList[n];\\n        Arrays.setAll(graph, o->new ArrayList<>());\\n        for(int[] e:edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        dfs(0, -1);\\n        int result = Integer.MAX_VALUE;\\n        for(int i=2, x, y, z; i<n;i++){\\n            for(int j = 1;j<i;j++){\\n                if(in[i]<in[j] && in[j]<=out[i]){\\n                    x = xor[j];\\n                    y = xor[i]^xor[j];\\n                    z = xor[0]^xor[i];\\n                }else if(in[j]<in[i] && in[i] <= out[j]){\\n                    x = xor[i];\\n                    y = xor[j] ^ xor[i];\\n                    z = xor[0] ^ xor[j];\\n                }else{\\n                    x = xor[i];\\n                    y = xor[j];\\n                    z = xor[0] ^ xor[i] ^ xor[j];\\n                }\\n                result = Math.min(result, Math.max(Math.max(x,y),z) - Math.min(Math.min(x,y),z));\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(int node, int parent){\\n        in[node] = ++t;\\n        \\n        xor[node] = nums[node];\\n        for(int nei:graph[node]){\\n            if(nei!=parent){\\n                dfs(nei,node);\\n                xor[node] ^= xor[nei];\\n            }\\n        }\\n        \\n        out[node] = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694099,
                "title": "clean-c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int XOR = 0;\\n    vector<int>visi;\\n\\n    vector<int> adj[1004];\\n    int ans = 1e9;\\n    int dfs2(int cur,int pa,vector<int>&nums,int xo,int fl=0){\\n        int x = nums[cur];\\n        \\n        // cout<<endl;\\n        for(auto a:adj[cur]){\\n            if(a==pa) continue;\\n            \\n            x ^= dfs2(a,cur,nums,xo);\\n        }\\n\\n        if(fl) return x;\\n\\n        \\n        ans = min(ans, max(x,max(xo,XOR^xo^x)) - min(x,min(xo,XOR^xo^x)));\\n        // cout<<x<<\" \"<<xo<<\" \"<<XOR<<\" \"<<(XOR^xo^x)<<\" => \"<<ans<<endl;\\n\\n        return x;\\n    }\\n\\n    int dfs(int cur,int pa,vector<int>&nums){\\n        int x = nums[cur];\\n        for(auto a:adj[cur]){\\n            if(a==pa) continue;\\n            x ^= dfs(a,cur,nums);\\n        }\\n        // cout<<pa<<\" \"<<cur<<\" =|| \\\\n\";\\n        if(pa!=-1) dfs2(pa,cur,nums,x,1);\\n        return x;\\n    }\\n\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto &a:nums){\\n            XOR ^= a;\\n        }\\n        cout<<XOR<<endl;\\n        for(auto& a:edges){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n\\n        }\\n        int n = nums.size();\\n        visi.assign(n,0);\\n\\n        dfs(0,-1,nums);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int XOR = 0;\\n    vector<int>visi;\\n\\n    vector<int> adj[1004];\\n    int ans = 1e9;\\n    int dfs2(int cur,int pa,vector<int>&nums,int xo,int fl=0){\\n        int x = nums[cur];\\n        \\n        // cout<<endl;\\n        for(auto a:adj[cur]){\\n            if(a==pa) continue;\\n            \\n            x ^= dfs2(a,cur,nums,xo);\\n        }\\n\\n        if(fl) return x;\\n\\n        \\n        ans = min(ans, max(x,max(xo,XOR^xo^x)) - min(x,min(xo,XOR^xo^x)));\\n        // cout<<x<<\" \"<<xo<<\" \"<<XOR<<\" \"<<(XOR^xo^x)<<\" => \"<<ans<<endl;\\n\\n        return x;\\n    }\\n\\n    int dfs(int cur,int pa,vector<int>&nums){\\n        int x = nums[cur];\\n        for(auto a:adj[cur]){\\n            if(a==pa) continue;\\n            x ^= dfs(a,cur,nums);\\n        }\\n        // cout<<pa<<\" \"<<cur<<\" =|| \\\\n\";\\n        if(pa!=-1) dfs2(pa,cur,nums,x,1);\\n        return x;\\n    }\\n\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto &a:nums){\\n            XOR ^= a;\\n        }\\n        cout<<XOR<<endl;\\n        for(auto& a:edges){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n\\n        }\\n        int n = nums.size();\\n        visi.assign(n,0);\\n\\n        dfs(0,-1,nums);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2643346,
                "title": "easy-approach-c-dfs",
                "content": "# Intuition\\ngetting top node of each of three component and store xor of each subtree\\n\\n# Approach\\nstoring ancestor of each node to check later if two subtrees are part of each other\\n\\n# Complexity\\n- Time complexity: (N*N)\\n(N*N)=(taking any two pair of edges at time takes  n*n)\\n(N)=(traveling in a tree)\\noverall time_comlexity=(N*N)\\n\\n- Space complexity:(N*N)\\n (N*N)=(for tree)\\n(N*N)=(for stroring ancestor for every node)\\n(N)=(for depth,curr,rec 1D array that are used)\\nOverall (N*N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int dfs(int i,int p, vector<vector<int>> &graph,vector<int> &nums, vector<int> &rec,vector<int> &depth,vector<vector<int>> &pc,vector<int> &curr)\\n    {  \\n       pc[i]=curr;\\n       curr.push_back(i);\\n        int sbt_xor=0;\\n        for(auto g:graph[i])\\n        {\\n            if(g!=p)\\n              {\\n                  \\n                  depth[g]=depth[i]+1;\\n                  sbt_xor^=dfs(g,i,graph,nums,rec,depth,pc,curr);\\n              }\\n        }\\n        curr.pop_back();\\n         rec[i]=sbt_xor^nums[i];\\n       //cout<<rec[i]<<\" \"<<i<<endl;\\n       return rec[i];\\n    }\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<vector<int>> graph(n),pc(n);\\n        vector<int>rec(n,0),depth(n,1),curr;\\n        \\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n                 graph[edges[i][0]].push_back(edges[i][1]);\\n                 graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,-1,graph,nums,rec,depth,pc,curr);\\n        int ans=1e9;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int a=0,b,c;\\n            for(int j=i+1;j<n-1;j++)\\n            {     \\n                // declare node no.\\n                  int a=0,b,c;\\n\\n                  if(depth[edges[i][0]]>depth[edges[i][1]])\\n                     b=edges[i][0];\\n                  else\\n                     b=edges[i][1];\\n                  if(depth[edges[j][0]]>depth[edges[j][1]])\\n                     c=edges[j][0];\\n                  else\\n                     c=edges[j][1];\\n               \\n                  bool b_c_sbt=false;\\n                  for(auto g:pc[b])\\n                    if(g==c){b_c_sbt=true;break;}\\n                  for(auto g:pc[c])\\n                  if(g==b){b_c_sbt=true;break;}\\n                 // check is b is part of c or c is part of b\\n                 if(b_c_sbt)\\n                 {\\n                       if(depth[b]<depth[c])\\n                       {\\n                     \\n                      a=rec[a]^rec[b];\\n                      b=rec[b]^rec[c];\\n                      c=rec[c];\\n                     \\n                         }\\n                       else\\n                      {\\n                    a=rec[a]^rec[c]; \\n                    c=rec[c]^rec[b];\\n                    b=rec[b];\\n                     }\\n                    \\n                 }\\n                 else\\n                 {\\n                     a=rec[a];\\n                     b=rec[b];\\n                     c=rec[c];\\n                     a=a^b^c;\\n\\n                 }\\n                  \\n\\n                  int l=max(a,max(b,c));\\n                  int s=min(a,min(b,c));\\n                 ans=min(ans,l-s);\\n                 \\n                          \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dfs(int i,int p, vector<vector<int>> &graph,vector<int> &nums, vector<int> &rec,vector<int> &depth,vector<vector<int>> &pc,vector<int> &curr)\\n    {  \\n       pc[i]=curr;\\n       curr.push_back(i);\\n        int sbt_xor=0;\\n        for(auto g:graph[i])\\n        {\\n            if(g!=p)\\n              {\\n                  \\n                  depth[g]=depth[i]+1;\\n                  sbt_xor^=dfs(g,i,graph,nums,rec,depth,pc,curr);\\n              }\\n        }\\n        curr.pop_back();\\n         rec[i]=sbt_xor^nums[i];\\n       //cout<<rec[i]<<\" \"<<i<<endl;\\n       return rec[i];\\n    }\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<vector<int>> graph(n),pc(n);\\n        vector<int>rec(n,0),depth(n,1),curr;\\n        \\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n                 graph[edges[i][0]].push_back(edges[i][1]);\\n                 graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,-1,graph,nums,rec,depth,pc,curr);\\n        int ans=1e9;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int a=0,b,c;\\n            for(int j=i+1;j<n-1;j++)\\n            {     \\n                // declare node no.\\n                  int a=0,b,c;\\n\\n                  if(depth[edges[i][0]]>depth[edges[i][1]])\\n                     b=edges[i][0];\\n                  else\\n                     b=edges[i][1];\\n                  if(depth[edges[j][0]]>depth[edges[j][1]])\\n                     c=edges[j][0];\\n                  else\\n                     c=edges[j][1];\\n               \\n                  bool b_c_sbt=false;\\n                  for(auto g:pc[b])\\n                    if(g==c){b_c_sbt=true;break;}\\n                  for(auto g:pc[c])\\n                  if(g==b){b_c_sbt=true;break;}\\n                 // check is b is part of c or c is part of b\\n                 if(b_c_sbt)\\n                 {\\n                       if(depth[b]<depth[c])\\n                       {\\n                     \\n                      a=rec[a]^rec[b];\\n                      b=rec[b]^rec[c];\\n                      c=rec[c];\\n                     \\n                         }\\n                       else\\n                      {\\n                    a=rec[a]^rec[c]; \\n                    c=rec[c]^rec[b];\\n                    b=rec[b];\\n                     }\\n                    \\n                 }\\n                 else\\n                 {\\n                     a=rec[a];\\n                     b=rec[b];\\n                     c=rec[c];\\n                     a=a^b^c;\\n\\n                 }\\n                  \\n\\n                  int l=max(a,max(b,c));\\n                  int s=min(a,min(b,c));\\n                 ans=min(ans,l-s);\\n                 \\n                          \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2626304,
                "title": "cpp-explained-with-comments-most-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    int timer[1001][2];\\n    long long xoor[1001];\\n    int tim = 0;\\n    vector<int> val;\\n    // function to calculate intime and outtime for every node and xor for every substree and store it\\n    map<int,int> memo;\\n    long long dfs(vector<vector<int>> &adj,int a,int p){\\n        timer[a][0] = tim++;\\n        int xo = 0;\\n        if(xoor[a]!=-1) return xoor[a];\\n        for(auto x:adj[a]){\\n            if(x!=p){\\n                xo ^= dfs(adj,x,a);\\n            }\\n        }\\n        timer[a][1] = tim++;\\n        return xoor[a] = xo^(long long)val[a];\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(nums.size());\\n        memset(xoor,-1,sizeof(xoor));\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        val = nums;\\n        int mini = INT_MAX;\\n        int txor = dfs(adj,0,-1);\\n        \\n        // debug code start\\n        // cout<<txor<<\"\\\\n\";\\n        // for(int i=0;i<nums.size();i++){\\n        //     cout<<timer[i][0]<<\" \"<<timer[i][1]<<\" t\\\\n\";\\n        //     cout<<xoor[i]<<\" xor\\\\n\";\\n        // }\\n            \\n        // debug code ends\\n            \\n            \\n        for(int i=0;i<edges.size();i++){\\n            for(int j=i+1;j<edges.size();j++){\\n                vector<int> first = edges[i];\\n                vector<int> second = edges[j];\\n                \\n                //cases\\n                //first check out pf four nodes, which one are upper ones and whoch ones are lower ones\\n                int fl,fu,sl,su; //firt upper, firt lower and similiarty for second\\n                int v1,v2,v3;\\n                if(max(timer[first[0]][0],timer[first[0]][1])>max(timer[first[1]][0],timer[first[1]][1]) and min(timer[first[0]][0],timer[first[0]][1])<min(timer[first[1]][0],timer[first[1]][1])){\\n                    fu = first[0];\\n                    fl = first[1];\\n                }\\n                else{\\n                    fu = first[1];\\n                    fl = first[0];\\n                }\\n                if(max(timer[second[0]][0],timer[second[0]][1])>max(timer[second[1]][0],timer[second[1]][1]) and min(timer[second[0]][0],timer[second[0]][1])<min(timer[second[1]][0],timer[second[1]][1])){\\n                    su = second[0];\\n                    sl = second[1];\\n                }\\n                else{\\n                    su = second[1];\\n                    sl = second[0];\\n                }\\n                // out of the two parts there can be three cases\\n                //  when 1st is subtree of 2nd\\n                //  when 2nd is subtree of 1st\\n                // when they are not related anyhow\\n                if(max(timer[fl][0],timer[fl][1])>max(timer[sl][0],timer[sl][1]) and min(timer[fl][0],timer[fl][1])<min(timer[sl][0],timer[sl][1])){\\n                    // second is the subtree of 1st\\n                    \\n                    v1 = xoor[sl];//of second subtree\\n                    v2 = txor^xoor[fl]; //remianing in main tree\\n                    v3 = xoor[fl]^v1;\\n                    mini = min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                }\\n                else if(max(timer[fl][0],timer[fl][1])<max(timer[sl][0],timer[sl][1]) and min(timer[fl][0],timer[fl][1])>min(timer[sl][0],timer[sl][1])){\\n                    //first is the subtree of second\\n                    v1 = xoor[fl]; //of fisrt subtree\\n                    v2 = txor^xoor[sl]; //remianing in main tree\\n                    v3 = xoor[sl]^v1;\\n                    mini = min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                }\\n                else{\\n                    v1 = xoor[fl];\\n                    v2 = xoor[sl];\\n                    v3 = txor^v1^v2;\\n                    mini = min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                }\\n                \\n                \\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timer[1001][2];\\n    long long xoor[1001];\\n    int tim = 0;\\n    vector<int> val;\\n    // function to calculate intime and outtime for every node and xor for every substree and store it\\n    map<int,int> memo;\\n    long long dfs(vector<vector<int>> &adj,int a,int p){\\n        timer[a][0] = tim++;\\n        int xo = 0;\\n        if(xoor[a]!=-1) return xoor[a];\\n        for(auto x:adj[a]){\\n            if(x!=p){\\n                xo ^= dfs(adj,x,a);\\n            }\\n        }\\n        timer[a][1] = tim++;\\n        return xoor[a] = xo^(long long)val[a];\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(nums.size());\\n        memset(xoor,-1,sizeof(xoor));\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        val = nums;\\n        int mini = INT_MAX;\\n        int txor = dfs(adj,0,-1);\\n        \\n        // debug code start\\n        // cout<<txor<<\"\\\\n\";\\n        // for(int i=0;i<nums.size();i++){\\n        //     cout<<timer[i][0]<<\" \"<<timer[i][1]<<\" t\\\\n\";\\n        //     cout<<xoor[i]<<\" xor\\\\n\";\\n        // }\\n            \\n        // debug code ends\\n            \\n            \\n        for(int i=0;i<edges.size();i++){\\n            for(int j=i+1;j<edges.size();j++){\\n                vector<int> first = edges[i];\\n                vector<int> second = edges[j];\\n                \\n                //cases\\n                //first check out pf four nodes, which one are upper ones and whoch ones are lower ones\\n                int fl,fu,sl,su; //firt upper, firt lower and similiarty for second\\n                int v1,v2,v3;\\n                if(max(timer[first[0]][0],timer[first[0]][1])>max(timer[first[1]][0],timer[first[1]][1]) and min(timer[first[0]][0],timer[first[0]][1])<min(timer[first[1]][0],timer[first[1]][1])){\\n                    fu = first[0];\\n                    fl = first[1];\\n                }\\n                else{\\n                    fu = first[1];\\n                    fl = first[0];\\n                }\\n                if(max(timer[second[0]][0],timer[second[0]][1])>max(timer[second[1]][0],timer[second[1]][1]) and min(timer[second[0]][0],timer[second[0]][1])<min(timer[second[1]][0],timer[second[1]][1])){\\n                    su = second[0];\\n                    sl = second[1];\\n                }\\n                else{\\n                    su = second[1];\\n                    sl = second[0];\\n                }\\n                // out of the two parts there can be three cases\\n                //  when 1st is subtree of 2nd\\n                //  when 2nd is subtree of 1st\\n                // when they are not related anyhow\\n                if(max(timer[fl][0],timer[fl][1])>max(timer[sl][0],timer[sl][1]) and min(timer[fl][0],timer[fl][1])<min(timer[sl][0],timer[sl][1])){\\n                    // second is the subtree of 1st\\n                    \\n                    v1 = xoor[sl];//of second subtree\\n                    v2 = txor^xoor[fl]; //remianing in main tree\\n                    v3 = xoor[fl]^v1;\\n                    mini = min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                }\\n                else if(max(timer[fl][0],timer[fl][1])<max(timer[sl][0],timer[sl][1]) and min(timer[fl][0],timer[fl][1])>min(timer[sl][0],timer[sl][1])){\\n                    //first is the subtree of second\\n                    v1 = xoor[fl]; //of fisrt subtree\\n                    v2 = txor^xoor[sl]; //remianing in main tree\\n                    v3 = xoor[sl]^v1;\\n                    mini = min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                }\\n                else{\\n                    v1 = xoor[fl];\\n                    v2 = xoor[sl];\\n                    v3 = txor^v1^v2;\\n                    mini = min(mini,max({v1,v2,v3})-min({v1,v2,v3}));\\n                }\\n                \\n                \\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2624199,
                "title": "o-n-2-3-different-approaches-fully-explained-python",
                "content": "```\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        #there are n-1 edges, and u have to choose a pair, so there are (n-1)(n-2)/2 edge combinations\\n        #n <= 1000, so O(n^2) is feasible, but we have to make sure full solution is in O(n^2)\\n        #cool thing about xor is that, (a^x^c^d)^x == (a^c^d)^(x^x) == (a^c^d), which will be useful\\n        \\n        #Approach:\\n        #choose two nodes (cant be the root of the tree)\\n        #imagine the node and all of its children to be a group, so now we have two groups (group1, & group2)\\n        #Notice: one group may or may not be inside the other group (if node1 is ancestor of node2, group2 will be inside group1)\\n        #the third group = rootGroup - group1 - group2\\n        #realise that making three groups is same as breaking two edges\\n        #using brute force, compare every pair of node groups\\n        \\n        n = len(nums)\\n        g = [[] for _ in range(n)]\\n        for x, y in edges:\\n            g[x].append(y)\\n            g[y].append(x)\\n        \\n        #using the in/out time, u can check if one node is ancestor of the other one\\n        xor, in_, out= [0] * n, [0] * n, [0] * n\\n        clock = 0\\n        #treat 0 as the root of the tree\\n        def dfs(x: int, fa: int) -> None:\\n            nonlocal clock\\n            clock += 1\\n            in_[x] = clock\\n            xor[x] = nums[x]\\n            for y in g[x]:\\n                if y != fa:\\n                    dfs(y, x)\\n                    xor[x] ^= xor[y]\\n            clock += 1\\n            out[x] = clock\\n        dfs(0, -1)\\n        \\n        res = inf\\n        #checking every node group combination\\n        for i in range(2, n):\\n            for j in range(1, i):\\n                #if i is ancestor of j: group_j is inside group_i\\n                if in_[i] < in_[j] < out[i]:\\n                    x, y, z = xor[j], xor[i] ^ xor[j], xor[0] ^ xor[i]\\n                #if j is ancestor of i: group_i is inside group_j\\n                elif in_[j] < in_[i] < out[j]:\\n                    x, y, z = xor[i], xor[i] ^ xor[j], xor[0] ^ xor[j]\\n                #if the groups are separate\\n                else:\\n                    x, y, z = xor[i], xor[j], xor[0] ^ xor[i] ^ xor[j]\\n                res = min(res, max(x, y, z) - min(x, y, z))\\n\\n                if res == 0: #breaking out early\\n                    return 0\\n        return res\\n        \\n    #2 approach is also Time->O(n^2) but Space->O(n^2).\\n\\t#in this sol u store every children a node has\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = defaultdict(set)\\n        for a,b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        root = 0\\n        xorVals = [0]*n\\n        #while u r making the tree also save the total xor values\\n        def makeTree(c_node=root):\\n            c_val = nums[c_node]\\n            for child in graph[c_node]:\\n                graph[child].remove(c_node)\\n                c_val ^= makeTree(child)\\n            xorVals[c_node] = c_val\\n            return c_val\\n        makeTree()\\n        \\n        ans = math.inf\\n        children = defaultdict(set)\\n        def groupChildren(c_node):\\n            babies = set()\\n            \\n            for neigh in graph[c_node]:\\n                babies |= groupChildren(neigh) | set([neigh])\\n            \\n            children[c_node] = babies\\n            return babies\\n        groupChildren(root)\\n        \\n            \\n        for i in range(1, n):\\n            for j in range(i+1, n):\\n                if i in children[j]:\\n                    group1 = xorVals[i]; group2 = xorVals[j] ^ group1\\n                elif j in children[i]:\\n                    group1 = xorVals[j]; group2 = xorVals[i] ^ group1\\n                else:\\n                    group1 = xorVals[i]; group2 = xorVals[j]\\n                group3 = xorVals[0] ^ group1 ^ group2\\n                ans = min(ans, max(group1, group2, group3) - min(group1, group2, group3))\\n                    \\n        return ans\\n\\t\\t\\n\\t#3 Approach is also Time->O(n^2), Space->O(n) but calling dfs n times is slower and sometime TLE\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = defaultdict(set)\\n        for a,b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        root = 0\\n        visited = set()\\n        xorVals = [0]*n\\n        def makeTree(c_node=root):\\n            c_val = nums[c_node]\\n            for child in graph[c_node]:\\n                graph[child].remove(c_node)\\n                c_val ^= makeTree(child)\\n            xorVals[c_node] = c_val\\n            return c_val\\n        makeTree()\\n        \\n        ans = math.inf\\n        def dfs(c_node):\\n            nonlocal ans\\n                        \\n            childInC_node = 0\\n            \\n            if c_node != child:\\n                for c in graph[c_node]:\\n                    childInC_node |= dfs(c)\\n            \\n            if c_node not in [child, root]:\\n                group1 = xorVals[c_node]\\n                group2 = xorVals[child]\\n                \\n                if childInC_node: group1 ^= group2\\n                    \\n                group3 = xorVals[root] ^ group1 ^ group2\\n\\n                ans = min(ans, max(group1, group2, group3) - min(group1, group2, group3))\\n            \\n            return childInC_node or c_node==child\\n        \\n        #Time->O(n^2)\\n        for i in range(1, n):\\n            child = i\\n            dfs(root)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        #there are n-1 edges, and u have to choose a pair, so there are (n-1)(n-2)/2 edge combinations\\n        #n <= 1000, so O(n^2) is feasible, but we have to make sure full solution is in O(n^2)\\n        #cool thing about xor is that, (a^x^c^d)^x == (a^c^d)^(x^x) == (a^c^d), which will be useful\\n        \\n        #Approach:\\n        #choose two nodes (cant be the root of the tree)\\n        #imagine the node and all of its children to be a group, so now we have two groups (group1, & group2)\\n        #Notice: one group may or may not be inside the other group (if node1 is ancestor of node2, group2 will be inside group1)\\n        #the third group = rootGroup - group1 - group2\\n        #realise that making three groups is same as breaking two edges\\n        #using brute force, compare every pair of node groups\\n        \\n        n = len(nums)\\n        g = [[] for _ in range(n)]\\n        for x, y in edges:\\n            g[x].append(y)\\n            g[y].append(x)\\n        \\n        #using the in/out time, u can check if one node is ancestor of the other one\\n        xor, in_, out= [0] * n, [0] * n, [0] * n\\n        clock = 0\\n        #treat 0 as the root of the tree\\n        def dfs(x: int, fa: int) -> None:\\n            nonlocal clock\\n            clock += 1\\n            in_[x] = clock\\n            xor[x] = nums[x]\\n            for y in g[x]:\\n                if y != fa:\\n                    dfs(y, x)\\n                    xor[x] ^= xor[y]\\n            clock += 1\\n            out[x] = clock\\n        dfs(0, -1)\\n        \\n        res = inf\\n        #checking every node group combination\\n        for i in range(2, n):\\n            for j in range(1, i):\\n                #if i is ancestor of j: group_j is inside group_i\\n                if in_[i] < in_[j] < out[i]:\\n                    x, y, z = xor[j], xor[i] ^ xor[j], xor[0] ^ xor[i]\\n                #if j is ancestor of i: group_i is inside group_j\\n                elif in_[j] < in_[i] < out[j]:\\n                    x, y, z = xor[i], xor[i] ^ xor[j], xor[0] ^ xor[j]\\n                #if the groups are separate\\n                else:\\n                    x, y, z = xor[i], xor[j], xor[0] ^ xor[i] ^ xor[j]\\n                res = min(res, max(x, y, z) - min(x, y, z))\\n\\n                if res == 0: #breaking out early\\n                    return 0\\n        return res\\n        \\n    #2 approach is also Time->O(n^2) but Space->O(n^2).\\n\\t#in this sol u store every children a node has\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = defaultdict(set)\\n        for a,b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        root = 0\\n        xorVals = [0]*n\\n        #while u r making the tree also save the total xor values\\n        def makeTree(c_node=root):\\n            c_val = nums[c_node]\\n            for child in graph[c_node]:\\n                graph[child].remove(c_node)\\n                c_val ^= makeTree(child)\\n            xorVals[c_node] = c_val\\n            return c_val\\n        makeTree()\\n        \\n        ans = math.inf\\n        children = defaultdict(set)\\n        def groupChildren(c_node):\\n            babies = set()\\n            \\n            for neigh in graph[c_node]:\\n                babies |= groupChildren(neigh) | set([neigh])\\n            \\n            children[c_node] = babies\\n            return babies\\n        groupChildren(root)\\n        \\n            \\n        for i in range(1, n):\\n            for j in range(i+1, n):\\n                if i in children[j]:\\n                    group1 = xorVals[i]; group2 = xorVals[j] ^ group1\\n                elif j in children[i]:\\n                    group1 = xorVals[j]; group2 = xorVals[i] ^ group1\\n                else:\\n                    group1 = xorVals[i]; group2 = xorVals[j]\\n                group3 = xorVals[0] ^ group1 ^ group2\\n                ans = min(ans, max(group1, group2, group3) - min(group1, group2, group3))\\n                    \\n        return ans\\n\\t\\t\\n\\t#3 Approach is also Time->O(n^2), Space->O(n) but calling dfs n times is slower and sometime TLE\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = defaultdict(set)\\n        for a,b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        root = 0\\n        visited = set()\\n        xorVals = [0]*n\\n        def makeTree(c_node=root):\\n            c_val = nums[c_node]\\n            for child in graph[c_node]:\\n                graph[child].remove(c_node)\\n                c_val ^= makeTree(child)\\n            xorVals[c_node] = c_val\\n            return c_val\\n        makeTree()\\n        \\n        ans = math.inf\\n        def dfs(c_node):\\n            nonlocal ans\\n                        \\n            childInC_node = 0\\n            \\n            if c_node != child:\\n                for c in graph[c_node]:\\n                    childInC_node |= dfs(c)\\n            \\n            if c_node not in [child, root]:\\n                group1 = xorVals[c_node]\\n                group2 = xorVals[child]\\n                \\n                if childInC_node: group1 ^= group2\\n                    \\n                group3 = xorVals[root] ^ group1 ^ group2\\n\\n                ans = min(ans, max(group1, group2, group3) - min(group1, group2, group3))\\n            \\n            return childInC_node or c_node==child\\n        \\n        #Time->O(n^2)\\n        for i in range(1, n):\\n            child = i\\n            dfs(root)\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2585219,
                "title": "using-binary-lifting-to-find-lca-space-o-nlogn-time-o-n-2logn",
                "content": "Found kind of same question in an OA was\\'t able to solve it that time.\\n\\nFor knowing more about binary lifting you can refer to pepcoding binary lifting playlist on YT, first 2 videos of that playlist will do the job.\\n```\\nclass Solution {\\n    ArrayList<Integer>[] graph;\\n    int[] values;\\n    int[] level;\\n    int[] xors;\\n    int[] parent;\\n    int[][] table;\\n    int MAXBIT=9;\\n    \\n    public int f(int src,int par,int lvl){\\n        xors[src]=values[src];\\n        level[src]=lvl;\\n        parent[src]=par;\\n        \\n        for(int nbr:graph[src]){\\n            if(nbr!=par){\\n                xors[src]^=f(nbr,src,lvl+1);\\n            }\\n        }\\n        return xors[src];\\n    }\\n    \\n    public void fillTable(){\\n        table[0]=parent;\\n        int n=table[0].length;\\n        \\n        for(int i=1;i<=MAXBIT;i++){\\n            for(int j=1;j<n;j++){\\n                table[i][j]=table[i-1][table[i-1][j]];\\n            }\\n        }\\n    }\\n    \\n    public int getLca(int x,int y){\\n        if(level[y]>level[x]){\\n            int t=x;\\n            x=y;\\n            y=t;\\n        }\\n        \\n        int k=level[x]-level[y];\\n        for(int i=0;i<=MAXBIT;i++){\\n            if((k & (1<<i)) > 0){\\n                x=table[i][x];\\n            }\\n        }\\n\\n        if(x==y) return x;\\n        \\n        for(int i=MAXBIT;i>=0;i--){\\n            int nx=table[i][x];\\n            int ny=table[i][y];\\n            if(nx!=ny){\\n                x=nx;\\n                y=ny;\\n            }\\n        }\\n        \\n        return parent[x];\\n    }\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int n=nums.length;\\n        int m=edges.length;\\n        graph=new ArrayList[n];\\n        xors=new int[n];\\n        level=new int[n];\\n        parent=new int[n];\\n        table=new int[MAXBIT+1][n];\\n        values=nums;        \\n        \\n        for(int i=0;i<n;i++) graph[i]=new ArrayList<>();\\n        \\n        for(int i=0;i<m;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        f(0,0,1);\\n        \\n        fillTable();\\n        \\n        int score=Integer.MAX_VALUE;\\n        int a,b,c;\\n        for(int i=1;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                \\n                int lca=getLca(i,j);\\n\\n                if(lca==i){\\n                    a=xors[0]^xors[i];\\n                    b=xors[i]^xors[j];\\n                    c=xors[j];\\n                } \\n                else if(lca==j){\\n                    a=xors[0]^xors[j];\\n                    b=xors[j]^xors[i];\\n                    c=xors[i];\\n                }\\n                else{\\n                    a=xors[0]^xors[i]^xors[j];\\n                    b=xors[i];\\n                    c=xors[j];\\n                }\\n                score=Math.min(score, Math.max(a,Math.max(b,c))-Math.min(a,Math.min(b,c)));\\n            }\\n        }\\n        \\n        return score;\\n    }\\n}\\n```\\nThank You (:  :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer>[] graph;\\n    int[] values;\\n    int[] level;\\n    int[] xors;\\n    int[] parent;\\n    int[][] table;\\n    int MAXBIT=9;\\n    \\n    public int f(int src,int par,int lvl){\\n        xors[src]=values[src];\\n        level[src]=lvl;\\n        parent[src]=par;\\n        \\n        for(int nbr:graph[src]){\\n            if(nbr!=par){\\n                xors[src]^=f(nbr,src,lvl+1);\\n            }\\n        }\\n        return xors[src];\\n    }\\n    \\n    public void fillTable(){\\n        table[0]=parent;\\n        int n=table[0].length;\\n        \\n        for(int i=1;i<=MAXBIT;i++){\\n            for(int j=1;j<n;j++){\\n                table[i][j]=table[i-1][table[i-1][j]];\\n            }\\n        }\\n    }\\n    \\n    public int getLca(int x,int y){\\n        if(level[y]>level[x]){\\n            int t=x;\\n            x=y;\\n            y=t;\\n        }\\n        \\n        int k=level[x]-level[y];\\n        for(int i=0;i<=MAXBIT;i++){\\n            if((k & (1<<i)) > 0){\\n                x=table[i][x];\\n            }\\n        }\\n\\n        if(x==y) return x;\\n        \\n        for(int i=MAXBIT;i>=0;i--){\\n            int nx=table[i][x];\\n            int ny=table[i][y];\\n            if(nx!=ny){\\n                x=nx;\\n                y=ny;\\n            }\\n        }\\n        \\n        return parent[x];\\n    }\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int n=nums.length;\\n        int m=edges.length;\\n        graph=new ArrayList[n];\\n        xors=new int[n];\\n        level=new int[n];\\n        parent=new int[n];\\n        table=new int[MAXBIT+1][n];\\n        values=nums;        \\n        \\n        for(int i=0;i<n;i++) graph[i]=new ArrayList<>();\\n        \\n        for(int i=0;i<m;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        f(0,0,1);\\n        \\n        fillTable();\\n        \\n        int score=Integer.MAX_VALUE;\\n        int a,b,c;\\n        for(int i=1;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                \\n                int lca=getLca(i,j);\\n\\n                if(lca==i){\\n                    a=xors[0]^xors[i];\\n                    b=xors[i]^xors[j];\\n                    c=xors[j];\\n                } \\n                else if(lca==j){\\n                    a=xors[0]^xors[j];\\n                    b=xors[j]^xors[i];\\n                    c=xors[i];\\n                }\\n                else{\\n                    a=xors[0]^xors[i]^xors[j];\\n                    b=xors[i];\\n                    c=xors[j];\\n                }\\n                score=Math.min(score, Math.max(a,Math.max(b,c))-Math.min(a,Math.min(b,c)));\\n            }\\n        }\\n        \\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576756,
                "title": "python3-dfs-dp",
                "content": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        hmap=defaultdict(int)\\n        pc,par=[],[]\\n        n=len(nums)\\n        childs=[[False for i in range(n)] for j in range(n)]\\n        graph=[[] for i in range(n)]\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        vis=set()\\n        def dfs(curr):\\n            for p in par:childs[p][curr]=True\\n            par.append(curr)\\n            currXor=nums[curr]\\n            for it in graph[curr]:\\n                if it not in vis:\\n                    vis.add(it)\\n                    pc.append((curr,it))\\n                    val=dfs(it)\\n                    currXor^=val\\n            par.pop()\\n            hmap[curr]=currXor\\n            return currXor\\n        vis.add(0)\\n        dfs(0)\\n        m=len(pc)\\n        ans=float(\\'inf\\')\\n        for a in range(m):\\n            for b in range(a+1,m):\\n                f,s=pc[a][1],pc[b][1]\\n                xf,xs,xp=hmap[f],hmap[s],hmap[0]\\n                if childs[f][s]:\\n                    xp^=xf\\n                    xf^=xs\\n                else:\\n                    xp^=xf\\n                    xp^=xs\\n                ans=min(ans,max(xp,xf,xs)-min(xp,xf,xs))\\n        return ans\\n```\\nReference -> https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/discuss/2198534/Simple-DFS",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        hmap=defaultdict(int)\\n        pc,par=[],[]\\n        n=len(nums)\\n        childs=[[False for i in range(n)] for j in range(n)]\\n        graph=[[] for i in range(n)]\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        vis=set()\\n        def dfs(curr):\\n            for p in par:childs[p][curr]=True\\n            par.append(curr)\\n            currXor=nums[curr]\\n            for it in graph[curr]:\\n                if it not in vis:\\n                    vis.add(it)\\n                    pc.append((curr,it))\\n                    val=dfs(it)\\n                    currXor^=val\\n            par.pop()\\n            hmap[curr]=currXor\\n            return currXor\\n        vis.add(0)\\n        dfs(0)\\n        m=len(pc)\\n        ans=float(\\'inf\\')\\n        for a in range(m):\\n            for b in range(a+1,m):\\n                f,s=pc[a][1],pc[b][1]\\n                xf,xs,xp=hmap[f],hmap[s],hmap[0]\\n                if childs[f][s]:\\n                    xp^=xf\\n                    xf^=xs\\n                else:\\n                    xp^=xf\\n                    xp^=xs\\n                ans=min(ans,max(xp,xf,xs)-min(xp,xf,xs))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538820,
                "title": "c-bfs-dfs-detailed-explanation-similar-to-problem-834-asked-in-coding-rounds",
                "content": "```\\n // Intuition -> store the xor for each subtree (containing that node)\\n    \\n    // all the nodes below it , including it \\n\\n    \\n    void find_xor_subtree(vector<int> adj[] , vector<int> &nums , int sv , int parent , vector<int> &xor_subtree)\\n    {\\n        // here we are taking node 0 as root node \\n        \\n        int xor_val=nums[sv]; // xor of curr_val \\n            \\n        for(auto x : adj[sv])\\n        {\\n            if(x!=parent)\\n            {\\n               \\n                find_xor_subtree(adj , nums , x , sv , xor_subtree);\\n                 xor_val ^= xor_subtree[x]; // xor of the its children\\n            }\\n        }\\n        \\n         xor_subtree[sv]=xor_val; // store the xor value in the respective node index\\n    }\\n    \\n    int find_another_xor(vector<int> adj[] , vector<int> &nums , int xor_of_second_component , int sv , int parent , int first_xor , int n , int &ans )\\n    {\\n        int curr_xor=nums[sv];\\n        \\n        // Find xor for this newly formed tree i.e 2nd component \\n        \\n        // at each time find the 2nd xor & 3rd xor , we have first xor calculated \\n        \\n        // make comparisions accordingly \\n        \\n        for(auto x : adj[sv])\\n        {\\n            if(x!=parent)\\n            {\\n               int child_xor = find_another_xor(adj , nums , xor_of_second_component , x , sv , first_xor , n , ans);\\n                \\n                curr_xor^=child_xor; // we are making xor for this current \\n                \\n                // sv node , having calculated its child\\'s xor\\n                \\n                int second_xor=child_xor , third_xor=(xor_of_second_component ^ second_xor);\\n                \\n                int maxe=max({first_xor , second_xor , third_xor});\\n                int mine=min({first_xor , second_xor , third_xor});\\n                \\n                ans=min(ans , maxe-mine);\\n            }\\n        }\\n        \\n        return curr_xor;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> subtree_xor(n , 0);\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        find_xor_subtree(adj , nums , 0 ,-1 , subtree_xor);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<subtree_xor[i]<<\" \";\\n        }\\n        \\n        // Now we have to take one edge from all the edge \\n        \\n        // we will use bfs to take one \\n        \\n        // Taking one edge from it , will take another edge from divided component\\n        \\n        queue<int> q;\\n        \\n        q.push(0);\\n        \\n        vector<bool> visited(n , false);\\n        visited[0]=true;\\n        \\n        int ans=INT_MAX;\\n        \\n        int total_xor=subtree_xor[0];\\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            \\n            q.pop();\\n            \\n            for(auto x : adj[node])\\n            {\\n                if(visited[x]==false)\\n                {\\n                    int curr_xor=subtree_xor[x]; // xor of first component\\n                    int rem_xor=subtree_xor[0] ^ subtree_xor[x]; // xor of 2nd component\\n                    \\n                    // Now we will divide the rem_xor i.e 2nd component into \\n                    \\n                    // one more component , call function find_another_xor\\n                    \\n                    int parent=x; // making node as root node for finding another \\n                    \\n                    // component , we must not visit the subtree containing x \\n                    \\n                    // so we will make it as parent \\n                    \\n                 int xo=   find_another_xor(adj , nums , rem_xor , node , parent , curr_xor , n , ans);\\n                    \\n                     cout<<endl;\\n                    cout<<xo<<\" \";\\n                        \\n                    visited[x]=true;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n // Intuition -> store the xor for each subtree (containing that node)\\n    \\n    // all the nodes below it , including it \\n\\n    \\n    void find_xor_subtree(vector<int> adj[] , vector<int> &nums , int sv , int parent , vector<int> &xor_subtree)\\n    {\\n        // here we are taking node 0 as root node \\n        \\n        int xor_val=nums[sv]; // xor of curr_val \\n            \\n        for(auto x : adj[sv])\\n        {\\n            if(x!=parent)\\n            {\\n               \\n                find_xor_subtree(adj , nums , x , sv , xor_subtree);\\n                 xor_val ^= xor_subtree[x]; // xor of the its children\\n            }\\n        }\\n        \\n         xor_subtree[sv]=xor_val; // store the xor value in the respective node index\\n    }\\n    \\n    int find_another_xor(vector<int> adj[] , vector<int> &nums , int xor_of_second_component , int sv , int parent , int first_xor , int n , int &ans )\\n    {\\n        int curr_xor=nums[sv];\\n        \\n        // Find xor for this newly formed tree i.e 2nd component \\n        \\n        // at each time find the 2nd xor & 3rd xor , we have first xor calculated \\n        \\n        // make comparisions accordingly \\n        \\n        for(auto x : adj[sv])\\n        {\\n            if(x!=parent)\\n            {\\n               int child_xor = find_another_xor(adj , nums , xor_of_second_component , x , sv , first_xor , n , ans);\\n                \\n                curr_xor^=child_xor; // we are making xor for this current \\n                \\n                // sv node , having calculated its child\\'s xor\\n                \\n                int second_xor=child_xor , third_xor=(xor_of_second_component ^ second_xor);\\n                \\n                int maxe=max({first_xor , second_xor , third_xor});\\n                int mine=min({first_xor , second_xor , third_xor});\\n                \\n                ans=min(ans , maxe-mine);\\n            }\\n        }\\n        \\n        return curr_xor;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> subtree_xor(n , 0);\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        find_xor_subtree(adj , nums , 0 ,-1 , subtree_xor);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<subtree_xor[i]<<\" \";\\n        }\\n        \\n        // Now we have to take one edge from all the edge \\n        \\n        // we will use bfs to take one \\n        \\n        // Taking one edge from it , will take another edge from divided component\\n        \\n        queue<int> q;\\n        \\n        q.push(0);\\n        \\n        vector<bool> visited(n , false);\\n        visited[0]=true;\\n        \\n        int ans=INT_MAX;\\n        \\n        int total_xor=subtree_xor[0];\\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            \\n            q.pop();\\n            \\n            for(auto x : adj[node])\\n            {\\n                if(visited[x]==false)\\n                {\\n                    int curr_xor=subtree_xor[x]; // xor of first component\\n                    int rem_xor=subtree_xor[0] ^ subtree_xor[x]; // xor of 2nd component\\n                    \\n                    // Now we will divide the rem_xor i.e 2nd component into \\n                    \\n                    // one more component , call function find_another_xor\\n                    \\n                    int parent=x; // making node as root node for finding another \\n                    \\n                    // component , we must not visit the subtree containing x \\n                    \\n                    // so we will make it as parent \\n                    \\n                 int xo=   find_another_xor(adj , nums , rem_xor , node , parent , curr_xor , n , ans);\\n                    \\n                     cout<<endl;\\n                    cout<<xo<<\" \";\\n                        \\n                    visited[x]=true;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455599,
                "title": "c-solution",
                "content": "```\\nint dfs(int node,int par,vector<int>& v,vector<int> &xo,vector<vector<int>> &ad)\\n{\\n    int x=v[node];\\n    for(auto c: ad[node])\\n    {\\n        if(c!=par) x^=dfs(c,node,v,xo,ad);\\n    }\\n    return xo[node]=x;\\n}\\n\\nint f(int node,int p,int &pro,int &a,int &ans,int &txor,vector<int> &v,vector<vector<int>> &ad)\\n{\\n    int x=v[node];\\n    for(auto c: ad[node])\\n    {\\n        if(c!=p && c!=pro) x^=f(c,node,pro,a,ans,txor,v,ad);\\n    }\\n    if(node!=0)\\n    {\\n        int rx=txor^a^x;\\n        int ma=max(a,max(x,rx));\\n        int mi=min(a,min(x,rx));\\n        ans=min(ans,ma-mi);\\n    }\\n    return x;\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& v, vector<vector<int>>& e) {\\n        int n=v.size();\\n        vector<vector<int>> ad(n);\\n        for(int i=0;i<e.size();i++)\\n        {\\n            ad[e[i][0]].push_back(e[i][1]);\\n            ad[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int> xo(n);\\n        int txor=dfs(0,-1,v,xo,ad);\\n        int ans=INT_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            int a=xo[i];\\n            //int b=-1;\\n            int b=f(0,-1,i,a,ans,txor,v,ad);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nint dfs(int node,int par,vector<int>& v,vector<int> &xo,vector<vector<int>> &ad)\\n{\\n    int x=v[node];\\n    for(auto c: ad[node])\\n    {\\n        if(c!=par) x^=dfs(c,node,v,xo,ad);\\n    }\\n    return xo[node]=x;\\n}\\n\\nint f(int node,int p,int &pro,int &a,int &ans,int &txor,vector<int> &v,vector<vector<int>> &ad)\\n{\\n    int x=v[node];\\n    for(auto c: ad[node])\\n    {\\n        if(c!=p && c!=pro) x^=f(c,node,pro,a,ans,txor,v,ad);\\n    }\\n    if(node!=0)\\n    {\\n        int rx=txor^a^x;\\n        int ma=max(a,max(x,rx));\\n        int mi=min(a,min(x,rx));\\n        ans=min(ans,ma-mi);\\n    }\\n    return x;\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& v, vector<vector<int>>& e) {\\n        int n=v.size();\\n        vector<vector<int>> ad(n);\\n        for(int i=0;i<e.size();i++)\\n        {\\n            ad[e[i][0]].push_back(e[i][1]);\\n            ad[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int> xo(n);\\n        int txor=dfs(0,-1,v,xo,ad);\\n        int ans=INT_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            int a=xo[i];\\n            //int b=-1;\\n            int b=f(0,-1,i,a,ans,txor,v,ad);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408773,
                "title": "python3-probably-the-best-question-of-my-life",
                "content": "```\\nclass Solution:\\n    from collections import defaultdict\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        m = len(edges)\\n        \\n        graph = defaultdict(list)\\n        children = defaultdict(set)\\n        arr = nums[:]\\n        degree = [0]*n\\n        \\n        for x,y in edges :\\n            graph[x].append(y)\\n            graph[y].append(x)\\n            degree[x]+=1\\n            degree[y]+=1\\n        \\n        v=0\\n        seen = set()\\n        q = deque()\\n        for i in range(n):\\n            v^=nums[i]\\n            if degree[i]==1 :\\n                q.append(i)\\n                seen.add(i)\\n        \\n        while q :\\n            curr = q.popleft()\\n            for nxt in graph[curr]:\\n                if nxt not in seen :\\n                    children[nxt].add(curr)\\n                    children[nxt]|=children[curr]\\n                    arr[nxt]^=arr[curr]\\n                degree[nxt]-=1\\n                if degree[nxt]==1 :\\n                    seen.add(nxt)\\n                    q.append(nxt)\\n        \\n        ans = float(\\'inf\\')\\n        for i in range(m-1):\\n            for j in range(i+1,m):\\n                a,b = edges[i]\\n                if b in children[a] :\\n                    a,b=b,a\\n                c,d = edges[j]\\n                if d in children[c] :\\n                    c,d=d,c\\n                \\n                if c in children[a]:\\n                    curr = [arr[c],arr[c]^arr[a],v^arr[a]]\\n                elif a in children[c]:\\n                    curr = [arr[a],arr[c]^arr[a],v^arr[c]]\\n                else :\\n                    curr = [arr[a],arr[c],v^arr[a]^arr[c]]\\n                ans = min(ans,max(curr)-min(curr))\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    from collections import defaultdict\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        m = len(edges)\\n        \\n        graph = defaultdict(list)\\n        children = defaultdict(set)\\n        arr = nums[:]\\n        degree = [0]*n\\n        \\n        for x,y in edges :\\n            graph[x].append(y)\\n            graph[y].append(x)\\n            degree[x]+=1\\n            degree[y]+=1\\n        \\n        v=0\\n        seen = set()\\n        q = deque()\\n        for i in range(n):\\n            v^=nums[i]\\n            if degree[i]==1 :\\n                q.append(i)\\n                seen.add(i)\\n        \\n        while q :\\n            curr = q.popleft()\\n            for nxt in graph[curr]:\\n                if nxt not in seen :\\n                    children[nxt].add(curr)\\n                    children[nxt]|=children[curr]\\n                    arr[nxt]^=arr[curr]\\n                degree[nxt]-=1\\n                if degree[nxt]==1 :\\n                    seen.add(nxt)\\n                    q.append(nxt)\\n        \\n        ans = float(\\'inf\\')\\n        for i in range(m-1):\\n            for j in range(i+1,m):\\n                a,b = edges[i]\\n                if b in children[a] :\\n                    a,b=b,a\\n                c,d = edges[j]\\n                if d in children[c] :\\n                    c,d=d,c\\n                \\n                if c in children[a]:\\n                    curr = [arr[c],arr[c]^arr[a],v^arr[a]]\\n                elif a in children[c]:\\n                    curr = [arr[a],arr[c]^arr[a],v^arr[c]]\\n                else :\\n                    curr = [arr[a],arr[c],v^arr[a]^arr[c]]\\n                ans = min(ans,max(curr)-min(curr))\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407352,
                "title": "c-code-for-beginners-simple-dfs-graph",
                "content": "# BRUTE FORCE\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int,unordered_set<int>> adj;\\npublic:\\n    int dfs(vector<int> &nums, int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=nums[node];\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res=res^dfs(nums,nei,vis);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        for(auto edge: edges){\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                vector<bool> vis(nums.size(),false);   \\n                \\n                adj[edges[j][0]].erase(edges[j][1]);\\n                adj[edges[j][1]].erase(edges[j][0]);                \\n                adj[edges[i][0]].erase(edges[i][1]);\\n                adj[edges[i][1]].erase(edges[i][0]);\\n                \\n                int mx=INT_MIN;\\n                int mn=INT_MAX;\\n                for(int i=0;i<nums.size();i++){\\n                    if(vis[i]==false){\\n                        int temp=dfs(nums,i,vis);\\n                        mx=max(mx,temp);\\n                        mn=min(mn,temp);\\n                    }\\n                }\\n                res=min(res,mx-mn);\\n                \\n                adj[edges[j][0]].insert(edges[j][1]);\\n                adj[edges[j][1]].insert(edges[j][0]);                \\n                adj[edges[i][0]].insert(edges[i][1]);\\n                adj[edges[i][1]].insert(edges[i][0]);\\n            }\\n        };\\n        return res;\\n    }\\n};\\n```\\n\\n# USING PRECOMPUTED RESULTS\\n![image](https://assets.leetcode.com/users/images/0dd8f447-0c24-49ec-b0e7-44daaaa653cb_1660143215.2285511.png)\\nImage- @Bakerston\\n\\nUSE XOR IN CALCULATION\\nint total=a^b^c^......\\na=total^b^c^.....\\n```\\nclass Solution {\\nprivate:\\n    vector<int> adj[100001];\\n    vector<vector<bool>> children; \\npublic:\\n    vector<bool> dfs(int node, vector<int> &XOR, int par){\\n        vector<bool> vis(XOR.size(),false);\\n        vis[node]=true;\\n        for(auto nei: adj[node]){\\n            if(par!=nei){\\n                vector<bool> temp=dfs(nei,XOR,node);\\n                XOR[node]^=XOR[nei];\\n                for(int i=0;i<XOR.size();i++){\\n                    vis[i]=vis[i] | temp[i];\\n                }\\n            }\\n        }\\n        children[node]=vis;\\n        return vis;\\n    }\\n    \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto edge: edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int V=nums.size();\\n        children.resize(1001,vector<bool>(1001,false));\\n        vector<int> XOR=nums;\\n        \\n        dfs(0,XOR,-1);\\n        \\n        int res=INT_MAX;\\n        int totalXOR=XOR[0];\\n\\n        for(int i=0;i<edges.size();i++){\\n            for(int j=i+1;j<edges.size();j++){\\n                int u1=edges[i][0];\\n                int v1=edges[i][1];\\n                \\n                int u2=edges[j][0];\\n                int v2=edges[j][1];\\n                \\n                if(children[v1][u1]==true){ // u1 is a children of v1, which should not happen, swap\\n                    swap(u1,v1);\\n                }\\n                if(children[v2][u2]==true){\\n                    swap(u2,v2);\\n                }\\n                \\n                int C1,C2,C3; // considering v1, v2 as root of the subtrees, because when you break a graph the lower node of the edge becomes the root of the subtree\\n                if(children[v1][v2]==false && children[v2][v1]==false){ // both are different and do not lie in one another\\'s subtree\\n                    C1=XOR[v1];\\n                    C2=XOR[v2];\\n                    C3=totalXOR ^ C1 ^ C2;\\n                }\\n                else if(children[v2][v1]==true){  // if v1 is residing inside v2\\n                    C1=XOR[v1];\\n                    C2=XOR[v2] ^ C1;\\n                    C3=totalXOR ^ XOR[v2];\\n                }\\n                else{  // if v2 is residing inside v1\\n                    C1=XOR[v2];\\n                    C2=XOR[v1] ^ C1;\\n                    C3=totalXOR ^ XOR[v1];                    \\n                }\\n                res=min(res,max({C1,C2,C3})-min({C1,C2,C3}));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,unordered_set<int>> adj;\\npublic:\\n    int dfs(vector<int> &nums, int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=nums[node];\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res=res^dfs(nums,nei,vis);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=edges.size();\\n        for(auto edge: edges){\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                vector<bool> vis(nums.size(),false);   \\n                \\n                adj[edges[j][0]].erase(edges[j][1]);\\n                adj[edges[j][1]].erase(edges[j][0]);                \\n                adj[edges[i][0]].erase(edges[i][1]);\\n                adj[edges[i][1]].erase(edges[i][0]);\\n                \\n                int mx=INT_MIN;\\n                int mn=INT_MAX;\\n                for(int i=0;i<nums.size();i++){\\n                    if(vis[i]==false){\\n                        int temp=dfs(nums,i,vis);\\n                        mx=max(mx,temp);\\n                        mn=min(mn,temp);\\n                    }\\n                }\\n                res=min(res,mx-mn);\\n                \\n                adj[edges[j][0]].insert(edges[j][1]);\\n                adj[edges[j][1]].insert(edges[j][0]);                \\n                adj[edges[i][0]].insert(edges[i][1]);\\n                adj[edges[i][1]].insert(edges[i][0]);\\n            }\\n        };\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> adj[100001];\\n    vector<vector<bool>> children; \\npublic:\\n    vector<bool> dfs(int node, vector<int> &XOR, int par){\\n        vector<bool> vis(XOR.size(),false);\\n        vis[node]=true;\\n        for(auto nei: adj[node]){\\n            if(par!=nei){\\n                vector<bool> temp=dfs(nei,XOR,node);\\n                XOR[node]^=XOR[nei];\\n                for(int i=0;i<XOR.size();i++){\\n                    vis[i]=vis[i] | temp[i];\\n                }\\n            }\\n        }\\n        children[node]=vis;\\n        return vis;\\n    }\\n    \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto edge: edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int V=nums.size();\\n        children.resize(1001,vector<bool>(1001,false));\\n        vector<int> XOR=nums;\\n        \\n        dfs(0,XOR,-1);\\n        \\n        int res=INT_MAX;\\n        int totalXOR=XOR[0];\\n\\n        for(int i=0;i<edges.size();i++){\\n            for(int j=i+1;j<edges.size();j++){\\n                int u1=edges[i][0];\\n                int v1=edges[i][1];\\n                \\n                int u2=edges[j][0];\\n                int v2=edges[j][1];\\n                \\n                if(children[v1][u1]==true){ // u1 is a children of v1, which should not happen, swap\\n                    swap(u1,v1);\\n                }\\n                if(children[v2][u2]==true){\\n                    swap(u2,v2);\\n                }\\n                \\n                int C1,C2,C3; // considering v1, v2 as root of the subtrees, because when you break a graph the lower node of the edge becomes the root of the subtree\\n                if(children[v1][v2]==false && children[v2][v1]==false){ // both are different and do not lie in one another\\'s subtree\\n                    C1=XOR[v1];\\n                    C2=XOR[v2];\\n                    C3=totalXOR ^ C1 ^ C2;\\n                }\\n                else if(children[v2][v1]==true){  // if v1 is residing inside v2\\n                    C1=XOR[v1];\\n                    C2=XOR[v2] ^ C1;\\n                    C3=totalXOR ^ XOR[v2];\\n                }\\n                else{  // if v2 is residing inside v1\\n                    C1=XOR[v2];\\n                    C2=XOR[v1] ^ C1;\\n                    C3=totalXOR ^ XOR[v1];                    \\n                }\\n                res=min(res,max({C1,C2,C3})-min({C1,C2,C3}));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392988,
                "title": "c-dfs-arrival-and-departure-times",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;//arrival time\\n    vector<int> dep;//departure time\\n    vector<int> visited;\\n    vector<int> subtree;//to store XOR of all nodes in subtree rooted at idx\\n    int time;\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n = nums.size();\\n        arr = vector<int> (n, -1);\\n        dep = vector<int> (n, -1);\\n        visited = vector<int> (n, 0);\\n        subtree = vector<int> (n, -1);\\n        \\n        time = 0;\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        for (auto &e : edges){\\n            \\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        DFS(0, adj, nums);\\n        \\n        int score = INT_MAX;\\n        \\n        for (int i=0; i<edges.size(); i++){\\n            for (int j = i+1; j<edges.size(); j++){\\n                \\n                int a = arr[edges[i][0]] < arr[edges[i][1]] ? edges[i][0] : edges[i][1];\\n                int b = arr[edges[i][0]] < arr[edges[i][1]] ? edges[i][1] : edges[i][0];\\n                \\n                int c = arr[edges[j][0]] < arr[edges[j][1]] ? edges[j][0] : edges[j][1];\\n                int d = arr[edges[j][0]] < arr[edges[j][1]] ? edges[j][1] : edges[j][0];\\n                \\n                \\n                if (arr[b] <= arr[c] && dep[b] >= dep[c]){\\n                    \\n                    // edge c---d lies in the branch extended by a---b\\n                    \\n                    int x1 = subtree[0]^subtree[b];\\n                    int x2 = subtree[b]^subtree[d];\\n                    int x3 = subtree[d];\\n                    \\n                    int ans = max({x1,x2,x3}) - min({x1,x2,x3});\\n                    score = min(score, ans);\\n                    \\n                }\\n                else if (arr[d] <= arr[a] && dep[d] >= dep[a]){\\n                    \\n                    // edge a---b lies in the branch extended by c---d\\n                    \\n                    int x1 = subtree[0]^subtree[d];\\n                    int x2 = subtree[d]^subtree[b];\\n                    int x3 = subtree[b];\\n                    \\n                    int ans = max({x1,x2,x3}) - min({x1,x2,x3});\\n                    score = min(score, ans);\\n                }\\n                else{\\n                    int x1 = subtree[0]^subtree[b]^subtree[d];\\n                    int x2 = subtree[b];\\n                    int x3 = subtree[d];\\n                    \\n                    int ans = max({x1,x2,x3}) - min({x1,x2,x3});\\n                    score = min(score, ans);\\n                }\\n            }\\n        }\\n        \\n        return score;\\n    }\\n    \\n    int DFS(int idx, vector<vector<int>> &adj, vector<int> &nums){\\n        \\n        visited[idx] = 1;\\n        arr[idx] = time++;\\n        \\n        int ans = nums[idx];\\n        \\n        for (int i=0; i<adj[idx].size(); i++){\\n            \\n            if (visited[adj[idx][i]] == 0){\\n                ans ^= DFS(adj[idx][i], adj, nums);\\n            }\\n        }\\n        \\n        dep[idx] = time++;\\n        \\n        return subtree[idx] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;//arrival time\\n    vector<int> dep;//departure time\\n    vector<int> visited;\\n    vector<int> subtree;//to store XOR of all nodes in subtree rooted at idx\\n    int time;\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n = nums.size();\\n        arr = vector<int> (n, -1);\\n        dep = vector<int> (n, -1);\\n        visited = vector<int> (n, 0);\\n        subtree = vector<int> (n, -1);\\n        \\n        time = 0;\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        for (auto &e : edges){\\n            \\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        DFS(0, adj, nums);\\n        \\n        int score = INT_MAX;\\n        \\n        for (int i=0; i<edges.size(); i++){\\n            for (int j = i+1; j<edges.size(); j++){\\n                \\n                int a = arr[edges[i][0]] < arr[edges[i][1]] ? edges[i][0] : edges[i][1];\\n                int b = arr[edges[i][0]] < arr[edges[i][1]] ? edges[i][1] : edges[i][0];\\n                \\n                int c = arr[edges[j][0]] < arr[edges[j][1]] ? edges[j][0] : edges[j][1];\\n                int d = arr[edges[j][0]] < arr[edges[j][1]] ? edges[j][1] : edges[j][0];\\n                \\n                \\n                if (arr[b] <= arr[c] && dep[b] >= dep[c]){\\n                    \\n                    // edge c---d lies in the branch extended by a---b\\n                    \\n                    int x1 = subtree[0]^subtree[b];\\n                    int x2 = subtree[b]^subtree[d];\\n                    int x3 = subtree[d];\\n                    \\n                    int ans = max({x1,x2,x3}) - min({x1,x2,x3});\\n                    score = min(score, ans);\\n                    \\n                }\\n                else if (arr[d] <= arr[a] && dep[d] >= dep[a]){\\n                    \\n                    // edge a---b lies in the branch extended by c---d\\n                    \\n                    int x1 = subtree[0]^subtree[d];\\n                    int x2 = subtree[d]^subtree[b];\\n                    int x3 = subtree[b];\\n                    \\n                    int ans = max({x1,x2,x3}) - min({x1,x2,x3});\\n                    score = min(score, ans);\\n                }\\n                else{\\n                    int x1 = subtree[0]^subtree[b]^subtree[d];\\n                    int x2 = subtree[b];\\n                    int x3 = subtree[d];\\n                    \\n                    int ans = max({x1,x2,x3}) - min({x1,x2,x3});\\n                    score = min(score, ans);\\n                }\\n            }\\n        }\\n        \\n        return score;\\n    }\\n    \\n    int DFS(int idx, vector<vector<int>> &adj, vector<int> &nums){\\n        \\n        visited[idx] = 1;\\n        arr[idx] = time++;\\n        \\n        int ans = nums[idx];\\n        \\n        for (int i=0; i<adj[idx].size(); i++){\\n            \\n            if (visited[adj[idx][i]] == 0){\\n                ans ^= DFS(adj[idx][i], adj, nums);\\n            }\\n        }\\n        \\n        dep[idx] = time++;\\n        \\n        return subtree[idx] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386556,
                "title": "c",
                "content": "\\nconst int N=1e3+1;\\nvector<int> g[N];\\nvector<int> x(N),val(N);\\nvector<vector<bool>> p(N,vector<bool>(N,0));\\nclass Solution {\\n\\npublic:\\n\\n    void anc(int s,int pr,int r){\\n        p[r][s]=1;\\n        for(auto i: g[s]){\\n            if(i==pr) continue;\\n            anc(i,s,r);\\n        }\\n    }\\n    void dfs(int u,int pr){\\n        \\n        x[u]=val[u];\\n        anc(u,pr,u);\\n        for(auto v : g[u]){\\n            if(v!=pr){\\n                dfs(v,u);\\n                x[u]^=x[v];\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& a, vector<vector<int>>& e) {\\n        int n=a.size();\\n        for(int i=0;i<n;i++){\\n            g[i].clear();\\n            for(int j=0;j<n;j++){\\n                p[i][j]=0;\\n            }\\n        }\\n        x.clear();\\n        val.clear();\\n        x.resize(n);\\n        val.resize(n);\\n        val=a;\\n        for(auto i: e){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        dfs(0,-1);\\n        // for(auto i: x){\\n        //     cout<<i<<\" \";\\n        // }\\n        int ans=INT_MAX;\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(i==j) continue;\\n                if(p[i][j]){\\n                    int c1=x[j];\\n                    int c2=x[i]^x[j];\\n                    int c3=x[0]^x[i];\\n                    ans=min(ans,max({c1,c2,c3})-min({c1,c2,c3}));\\n                }\\n                else if(p[j][i]){\\n                    int c1=x[i];\\n                    int c2=x[j]^x[i];\\n                    int c3=x[0]^x[j];\\n                    ans=min(ans,max({c1,c2,c3})-min({c1,c2,c3}));\\n                }\\n                else{\\n                    int c1=x[i];\\n                    int c2=x[j];\\n                    int c3=x[0]^c1^c2;\\n                    ans=min(ans,max({c1,c2,c3})-min({c1,c2,c3}));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    void anc(int s,int pr,int r){\\n        p[r][s]=1;\\n        for(auto i: g[s]){\\n            if(i==pr) continue;\\n            anc(i,s,r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2365529,
                "title": "c-dfs-easy-to-understand",
                "content": "Tips;\\n\\n1.DFS the graph from node 0 or any other nodes;\\n2.Select any two edges, and choose childs of two edges as root points of thes parts;\\n3.There are 3 sub-graphs parts : vertex 0 as root, redge[i]\\'s child node as root,  root-edge[j]\\'s child node as root\\n\\n```\\n        public int MinimumScore(int[] nums, int[][] edges)\\n        {\\n            int res = int.MaxValue;\\n            int n = nums.Length;\\n            List<int>[] graph = new List<int>[n];\\n            for (int i = 0; i < n; i++)\\n                graph[i] = new List<int>();\\n            foreach(var e in edges)\\n            {\\n                graph[e[0]].Add(e[1]);\\n                graph[e[1]].Add(e[0]);\\n            }\\n            Dictionary<int, int> dict = new Dictionary<int, int>();//store {vertexId, totalXorFromThisNode}\\n            Dictionary<int, HashSet<int>> map = new Dictionary<int, HashSet<int>>();//store {vertexId, allChildsIdSet}\\n            MinimumScore_DFS(nums, 0, -1, graph, dict, map);\\n            for(int i = 0; i <edges.Length-1; i++)\\n            {\\n                int[] edge1 = edges[i];\\n                int p = map[edge1[0]].Contains(edge1[1]) ? edge1[1] : edge1[0];\\n                for (int j = i + 1; j < edges.Length; j++)\\n                {\\n                    int[] edge2= edges[j];\\n                    int q = map[edge2[0]].Contains(edge2[1]) ? edge2[1] : edge2[0];\\n                    int a=0, b=0, c=0;\\n                    //3 parts, start at 0, p and q,\\n                    //because p,q always select childs, so 0 will never be p/q\\n                    if (map[p].Contains(q))\\n                    {\\n                        a = dict[q];\\n                        b = dict[p] ^ dict[q];\\n                        c = dict[0] ^ dict[p];\\n                    }\\n                    else if (map[q].Contains(p))\\n                    {\\n                        a = dict[p];\\n                        b = dict[q] ^ dict[p];\\n                        c = dict[0] ^ dict[q];\\n                    }\\n                    else\\n                    {\\n                        a= dict[p];\\n                        b = dict[q];\\n                        c = dict[0] ^ dict[q] ^ dict[p];\\n                    }\\n                    int max = Math.Max(a, Math.Max(b, c));\\n                    int min = Math.Min(a, Math.Min(b, c));\\n                    res = Math.Min(res, max - min);\\n                }\\n            }\\n            return res;\\n        }\\n\\n        private int MinimumScore_DFS(int[] nums,int curr, int prev, List<int>[] graph, Dictionary<int, int> dict, Dictionary<int, HashSet<int>> map)\\n        {\\n            int res = nums[curr];\\n            if (!map.ContainsKey(curr))\\n                map.Add(curr, new HashSet<int>());\\n            foreach (var i in graph[curr])\\n            {\\n                if (i == prev) continue;\\n                int xor = MinimumScore_DFS(nums, i, curr, graph, dict, map);\\n                res ^= xor;\\n                foreach (var sub in map[i])\\n                    map[curr].Add(sub);\\n                map[curr].Add(i);\\n            }\\n            dict.Add(curr, res);\\n            return res;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MinimumScore(int[] nums, int[][] edges)\\n        {\\n            int res = int.MaxValue;\\n            int n = nums.Length;\\n            List<int>[] graph = new List<int>[n];\\n            for (int i = 0; i < n; i++)\\n                graph[i] = new List<int>();\\n            foreach(var e in edges)\\n            {\\n                graph[e[0]].Add(e[1]);\\n                graph[e[1]].Add(e[0]);\\n            }\\n            Dictionary<int, int> dict = new Dictionary<int, int>();//store {vertexId, totalXorFromThisNode}\\n            Dictionary<int, HashSet<int>> map = new Dictionary<int, HashSet<int>>();//store {vertexId, allChildsIdSet}\\n            MinimumScore_DFS(nums, 0, -1, graph, dict, map);\\n            for(int i = 0; i <edges.Length-1; i++)\\n            {\\n                int[] edge1 = edges[i];\\n                int p = map[edge1[0]].Contains(edge1[1]) ? edge1[1] : edge1[0];\\n                for (int j = i + 1; j < edges.Length; j++)\\n                {\\n                    int[] edge2= edges[j];\\n                    int q = map[edge2[0]].Contains(edge2[1]) ? edge2[1] : edge2[0];\\n                    int a=0, b=0, c=0;\\n                    //3 parts, start at 0, p and q,\\n                    //because p,q always select childs, so 0 will never be p/q\\n                    if (map[p].Contains(q))\\n                    {\\n                        a = dict[q];\\n                        b = dict[p] ^ dict[q];\\n                        c = dict[0] ^ dict[p];\\n                    }\\n                    else if (map[q].Contains(p))\\n                    {\\n                        a = dict[p];\\n                        b = dict[q] ^ dict[p];\\n                        c = dict[0] ^ dict[q];\\n                    }\\n                    else\\n                    {\\n                        a= dict[p];\\n                        b = dict[q];\\n                        c = dict[0] ^ dict[q] ^ dict[p];\\n                    }\\n                    int max = Math.Max(a, Math.Max(b, c));\\n                    int min = Math.Min(a, Math.Min(b, c));\\n                    res = Math.Min(res, max - min);\\n                }\\n            }\\n            return res;\\n        }\\n\\n        private int MinimumScore_DFS(int[] nums,int curr, int prev, List<int>[] graph, Dictionary<int, int> dict, Dictionary<int, HashSet<int>> map)\\n        {\\n            int res = nums[curr];\\n            if (!map.ContainsKey(curr))\\n                map.Add(curr, new HashSet<int>());\\n            foreach (var i in graph[curr])\\n            {\\n                if (i == prev) continue;\\n                int xor = MinimumScore_DFS(nums, i, curr, graph, dict, map);\\n                res ^= xor;\\n                foreach (var sub in map[i])\\n                    map[curr].Add(sub);\\n                map[curr].Add(i);\\n            }\\n            dict.Add(curr, res);\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2342618,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> v[1001];\\n    int x[1001];\\n    vector<int> a;\\n    int h[1001];\\n    int pp[1001][12];\\n    \\n    void f(int node, int p, int d){\\n        pp[node][0] = p;\\n        h[node] = d;\\n        int s = a[node];\\n        for(auto e : v[node]){\\n            if(e != p){\\n                f(e, node,d+1);\\n                s = s ^ x[e];\\n            }\\n        }\\n        x[node] = s;\\n        return ;\\n    }\\n    \\n    \\n    int check(int ii, int jj){\\n        // this will return 1 if jj th node is child of ii th\\n        // return 2 if ii th node is child of jj th\\n        // else 0\\n        int h1 = h[ii];\\n        int h2 = h[jj];\\n        int x = 1;\\n        \\n        if(h1 == h2)\\n            return 0;\\n        if(h1 > h2){\\n            swap(h2,h1);\\n            swap(ii,jj);\\n            x = 2;\\n        }\\n            \\n            \\n        int diff = h2 - h1;\\n            \\n        for(int i=0; i < 10 && jj != -1; i ++){\\n            if(diff & (1 << i)){\\n                jj = pp[jj][i];           \\n            }\\n        }\\n        if(jj == ii)\\n            return x;\\n        return 0;\\n        \\n    }\\n   \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        a = nums;\\n        for(int i=0; i < n-1; i ++){\\n            v[edges[i][0]].push_back(edges[i][1]);        \\n            v[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        f(0,-1, 0);\\n\\n        for(int i=1; i < 10; i ++){\\n            \\n            for(int j=0; j <= n; j ++){\\n                pp[j][i] = -1;\\n                if( j == 0)\\n                    continue;\\n                \\n                int md = pp[j][i-1];\\n                if(md != -1 ){\\n                    if(pp[md][i-1] != -1){\\n                        pp[j][i] = pp[md][i-1];\\n                    }\\n                }\\n            }\\n        }                                      \\n                                      \\n        int res = 1e9 + 9;\\n        int s = x[0];\\n        for(int i=1; i < n; i ++){\\n            for(int j=i+1; j < n; j ++){\\n                int t = check(i, j);\\n                if(t == 1){\\n                    int a1 = x[j];\\n                    int a2 = x[i] ^ x[j];\\n                    int a3 = x[0] ^ a2 ^ a1;\\n                    int amax = max(a1, max(a2,a3));\\n                    int amin = min(a1, min(a2,a3));\\n                    \\n                    res = min(amax - amin, res);\\n                }\\n                else if(t == 2){\\n                    int a1 = x[i];\\n                    int a2 = x[j] ^ x[i];\\n                    int a3 = x[0] ^ a2 ^ a1;\\n                    int amax = max(a1, max(a2,a3));\\n                    int amin = min(a1, min(a2,a3));\\n                    res = min(amax - amin, res);\\n                }\\n                else{\\n                    int a1 = x[i];\\n                    int a2 = x[j];\\n                    int a3 = x[0] ^ a2 ^ a1;\\n                    int amax = max(a1, max(a2,a3));\\n                    int amin = min(a1, min(a2,a3));\\n                    \\n                    res = min(amax - amin, res);\\n                }\\n            }\\n        }                              \\n        return res;\\n                                      \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> v[1001];\\n    int x[1001];\\n    vector<int> a;\\n    int h[1001];\\n    int pp[1001][12];\\n    \\n    void f(int node, int p, int d){\\n        pp[node][0] = p;\\n        h[node] = d;\\n        int s = a[node];\\n        for(auto e : v[node]){\\n            if(e != p){\\n                f(e, node,d+1);\\n                s = s ^ x[e];\\n            }\\n        }\\n        x[node] = s;\\n        return ;\\n    }\\n    \\n    \\n    int check(int ii, int jj){\\n        // this will return 1 if jj th node is child of ii th\\n        // return 2 if ii th node is child of jj th\\n        // else 0\\n        int h1 = h[ii];\\n        int h2 = h[jj];\\n        int x = 1;\\n        \\n        if(h1 == h2)\\n            return 0;\\n        if(h1 > h2){\\n            swap(h2,h1);\\n            swap(ii,jj);\\n            x = 2;\\n        }\\n            \\n            \\n        int diff = h2 - h1;\\n            \\n        for(int i=0; i < 10 && jj != -1; i ++){\\n            if(diff & (1 << i)){\\n                jj = pp[jj][i];           \\n            }\\n        }\\n        if(jj == ii)\\n            return x;\\n        return 0;\\n        \\n    }\\n   \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        a = nums;\\n        for(int i=0; i < n-1; i ++){\\n            v[edges[i][0]].push_back(edges[i][1]);        \\n            v[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        f(0,-1, 0);\\n\\n        for(int i=1; i < 10; i ++){\\n            \\n            for(int j=0; j <= n; j ++){\\n                pp[j][i] = -1;\\n                if( j == 0)\\n                    continue;\\n                \\n                int md = pp[j][i-1];\\n                if(md != -1 ){\\n                    if(pp[md][i-1] != -1){\\n                        pp[j][i] = pp[md][i-1];\\n                    }\\n                }\\n            }\\n        }                                      \\n                                      \\n        int res = 1e9 + 9;\\n        int s = x[0];\\n        for(int i=1; i < n; i ++){\\n            for(int j=i+1; j < n; j ++){\\n                int t = check(i, j);\\n                if(t == 1){\\n                    int a1 = x[j];\\n                    int a2 = x[i] ^ x[j];\\n                    int a3 = x[0] ^ a2 ^ a1;\\n                    int amax = max(a1, max(a2,a3));\\n                    int amin = min(a1, min(a2,a3));\\n                    \\n                    res = min(amax - amin, res);\\n                }\\n                else if(t == 2){\\n                    int a1 = x[i];\\n                    int a2 = x[j] ^ x[i];\\n                    int a3 = x[0] ^ a2 ^ a1;\\n                    int amax = max(a1, max(a2,a3));\\n                    int amin = min(a1, min(a2,a3));\\n                    res = min(amax - amin, res);\\n                }\\n                else{\\n                    int a1 = x[i];\\n                    int a2 = x[j];\\n                    int a3 = x[0] ^ a2 ^ a1;\\n                    int amax = max(a1, max(a2,a3));\\n                    int amin = min(a1, min(a2,a3));\\n                    \\n                    res = min(amax - amin, res);\\n                }\\n            }\\n        }                              \\n        return res;\\n                                      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279492,
                "title": "python-solution-dfs-but-tedious",
                "content": "I tried [Leetcode 834](https://leetcode.com/problems/sum-of-distances-in-tree/), and found it similar to this contest question. That\\'s why I decide to write a similar DFS-based solution that traverse from a fixed root (0), but still, this question remains tedious.... Need to keep track of a few quantities during the traversal (subtree sum, parent-childhood of edges, which node in the edges are children etc.)\\n```\\nclass Solution:\\n    # This problem is a good followup to Leetcode 834. Sum of Distances in Tree\\n    # I will use DFS to solve the problem, and set 0 as root\\n    # First we will build the graph. Because we will be manipulating the edges in the process, we also save the edge id in the graph\\n    # Then we compute the subtree xors in a separate array by the postorder traversal\\n    # When we reach the end of path, we record the edge using post order:\\n    # For example in Example 1 given, edge [1,3] and edge [3,4]\\'s parent\\n    # Additional, we need to save the children id of the edge\\n    # After we compute all the subtree xors, we have to pick any two edges and ask:\\n    # Do their child node belong to different subtrees?\\n    # If not, who is upstream?\\n    # According to the scenarios, we can get minimum score by comparing all edges\\n    \\n    def dfs(self, node, parent, path):\\n        end_of_path = True\\n        for child in self.graph[node]:\\n            if child[0] != parent:\\n                end_of_path = False\\n                self.subtree_xor[node] ^= self.dfs(child[0], node, path + [child[1]])\\n                self.path_children[child[1]] = child[0]\\n        if end_of_path:\\n            for i in range(1,len(path)-1):\\n                for j in range(i+1, len(path)):\\n                    self.edges_children[path[i]].add(path[j])\\n        return self.subtree_xor[node]\\n    \\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        self.graph = [[] for i in range(n)]\\n        for i, edge in enumerate(edges):\\n            self.graph[edge[0]].append([edge[1], i])\\n            self.graph[edge[1]].append([edge[0], i])\\n        self.edges_children = [set() for i in range(n-1)]\\n        self.subtree_xor = nums[:]\\n        self.path_children = [0 for i in range(n-1)]\\n        xor_all = self.dfs(0, -1, [n-1])\\n        # pick two edges and ask if they are parents of each other\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n            for j in range(i+1,n-1):\\n                if j in self.edges_children[i]:\\n                    A = self.subtree_xor[self.path_children[i]]^self.subtree_xor[self.path_children[j]]\\n                    B = self.subtree_xor[self.path_children[j]]\\n                    C = self.subtree_xor[0]^self.subtree_xor[self.path_children[i]]\\n                elif i in self.edges_children[j]:\\n                    A = self.subtree_xor[self.path_children[i]]^self.subtree_xor[self.path_children[j]]\\n                    B = self.subtree_xor[self.path_children[i]]\\n                    C = self.subtree_xor[0]^self.subtree_xor[self.path_children[j]]                \\n                else:\\n                    A = self.subtree_xor[self.path_children[i]]\\n                    B = self.subtree_xor[self.path_children[j]]\\n                    C = self.subtree_xor[0]^self.subtree_xor[self.path_children[i]]^  self.subtree_xor[self.path_children[j]]\\n                result = min(result, max(A,B,C) - min(A,B,C))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This problem is a good followup to Leetcode 834. Sum of Distances in Tree\\n    # I will use DFS to solve the problem, and set 0 as root\\n    # First we will build the graph. Because we will be manipulating the edges in the process, we also save the edge id in the graph\\n    # Then we compute the subtree xors in a separate array by the postorder traversal\\n    # When we reach the end of path, we record the edge using post order:\\n    # For example in Example 1 given, edge [1,3] and edge [3,4]\\'s parent\\n    # Additional, we need to save the children id of the edge\\n    # After we compute all the subtree xors, we have to pick any two edges and ask:\\n    # Do their child node belong to different subtrees?\\n    # If not, who is upstream?\\n    # According to the scenarios, we can get minimum score by comparing all edges\\n    \\n    def dfs(self, node, parent, path):\\n        end_of_path = True\\n        for child in self.graph[node]:\\n            if child[0] != parent:\\n                end_of_path = False\\n                self.subtree_xor[node] ^= self.dfs(child[0], node, path + [child[1]])\\n                self.path_children[child[1]] = child[0]\\n        if end_of_path:\\n            for i in range(1,len(path)-1):\\n                for j in range(i+1, len(path)):\\n                    self.edges_children[path[i]].add(path[j])\\n        return self.subtree_xor[node]\\n    \\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        self.graph = [[] for i in range(n)]\\n        for i, edge in enumerate(edges):\\n            self.graph[edge[0]].append([edge[1], i])\\n            self.graph[edge[1]].append([edge[0], i])\\n        self.edges_children = [set() for i in range(n-1)]\\n        self.subtree_xor = nums[:]\\n        self.path_children = [0 for i in range(n-1)]\\n        xor_all = self.dfs(0, -1, [n-1])\\n        # pick two edges and ask if they are parents of each other\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n            for j in range(i+1,n-1):\\n                if j in self.edges_children[i]:\\n                    A = self.subtree_xor[self.path_children[i]]^self.subtree_xor[self.path_children[j]]\\n                    B = self.subtree_xor[self.path_children[j]]\\n                    C = self.subtree_xor[0]^self.subtree_xor[self.path_children[i]]\\n                elif i in self.edges_children[j]:\\n                    A = self.subtree_xor[self.path_children[i]]^self.subtree_xor[self.path_children[j]]\\n                    B = self.subtree_xor[self.path_children[i]]\\n                    C = self.subtree_xor[0]^self.subtree_xor[self.path_children[j]]                \\n                else:\\n                    A = self.subtree_xor[self.path_children[i]]\\n                    B = self.subtree_xor[self.path_children[j]]\\n                    C = self.subtree_xor[0]^self.subtree_xor[self.path_children[i]]^  self.subtree_xor[self.path_children[j]]\\n                result = min(result, max(A,B,C) - min(A,B,C))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273328,
                "title": "euler-path-using-dfs-c-tc-o-n-n-sc-o-n-n",
                "content": "class Solution {\\npublic:\\n    vector<int>adj[1005];\\n    int vis[1005];\\n    vector<int>v;\\n    vector<int>xr;  //precalculate the xor of every subtree starting with that particular node\\n    vector<int>lev; // level of each node is also required such that we are able to conclude that \\n    //out of two nodes of a edge which is at lower level\\n    int dfs(int s,int level,vector<int>& a)\\n    {\\n        vis[s]=1;\\n        lev[s]=level;\\n        v.push_back(s);\\n        xr[s]=a[s];\\n        for(auto x:adj[s])\\n        {\\n            if(!vis[x])\\n            {\\n                lev[x]=lev[s]+1;\\n                xr[s]^=dfs(x,lev[x],a);\\n                \\n            }\\n        }\\n        \\n        v.push_back(s);\\n        return xr[s];\\n    }\\n    int minimumScore(vector<int>& a, vector<vector<int>>& edges) {\\n        int n=a.size();\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        xr.resize(n,0);\\n        lev.resize(n,0);\\n        dfs(0,0,a);\\n        int top=xr[0];\\n        int ans=INT_MAX;\\n        unordered_map<int,int>s;\\n        unordered_map<int,int>e;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(s.find(v[i])==s.end())\\n            {\\n                s[v[i]]=i;\\n            }\\n            e[v[i]]=i;\\n        }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            for(int j=0;j<edges.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int node1=edges[i][0];\\n                    if(lev[edges[i][1]]>lev[edges[i][0]])\\n                        node1=edges[i][1];\\n                    \\n                    int node2=edges[j][0];\\n                    if(lev[edges[j][1]]>lev[edges[j][0]])\\n                    node2=edges[j][1];\\n                    \\n                    \\n                    if(lev[node1]>lev[node2])\\n                    {\\n                        swap(node1,node2);\\n                    }\\n                    \\n                    if(s[node1]<s[node2] && e[node2]<e[node1])\\n                    {\\n                        \\n                        int x2=xr[node2];\\n                        int x1=xr[node1]^x2;\\n                        int temp=top^xr[node1];\\n                        \\n                        int mx=max(temp,max(x1,x2));\\n                        int mn=min(temp,min(x1,x2));\\n                        ans=min(ans,mx-mn);\\n                    }\\n                    else\\n                    {\\n                        int temp=top^xr[node1]^xr[node2];\\n                        int mx=max(temp,max(xr[node1],xr[node2]));\\n                        int mn=min(temp,min(xr[node1],xr[node2]));\\n                        ans=min(ans,mx-mn);\\n                    }\\n\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int>adj[1005];\\n    int vis[1005];\\n    vector<int>v;\\n    vector<int>xr;  //precalculate the xor of every subtree starting with that particular node\\n    vector<int>lev; // level of each node is also required such that we are able to conclude that \\n    //out of two nodes of a edge which is at lower level\\n    int dfs(int s,int level,vector<int>& a)\\n    {\\n        vis[s]=1;\\n        lev[s]=level;\\n        v.push_back(s);\\n        xr[s]=a[s];\\n        for(auto x:adj[s])\\n        {\\n            if(!vis[x])\\n            {\\n                lev[x]=lev[s]+1;\\n                xr[s]^=dfs(x,lev[x],a);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2231704,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>xor_stored;\\n    vector<int>vis1;\\n    vector<vector<int>>dp;\\n\\n    vector<int>vis2;\\n   void make_parent(int node, int parent, vector<vector<int>>& adj)\\n    {\\n       \\n        dp[parent][node] = true;\\n       vis2[node]  = true;\\n       for(auto it: adj[node])\\n       {\\n           if(vis2[it])\\n               continue;\\n           make_parent(it, parent, adj);\\n       }\\n    }\\n    int find_xor( vector<vector<int>>& adj, int node, vector<int>& nums )\\n    {\\n        xor_stored[node] = nums[node];\\n        vis1[node]  = true;\\n        \\n        for(auto it: adj[node])\\n        {\\n            if(vis1[it])\\n                continue;\\n            vis2.clear();\\n            vis2.resize(nums.size(), 0);\\n            vis2[node] = 1;\\n            make_parent(it, node, adj);\\n            \\n         \\n           int ans =  find_xor(adj, it, nums);\\n            xor_stored[node] ^= ans;\\n            \\n        }\\n        return xor_stored[node];\\n        \\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges)\\n    {\\n       int n  = nums.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it: edges)\\n        {\\n            int x  = it[0]; int  y = it[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        xor_stored.resize(n,0);\\n         dp.resize(n, vector<int>(n,false));\\n        vis1.resize(n, 0);\\n        int  total=    find_xor(adj, 0 , nums);\\n        int an   =INT_MAX;\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            for(int  j = i+1;j<edges.size();j++)\\n            {\\n                 int x1  = edges[i][0];\\n                 int y1 = edges[i][1];\\n                 int x2 = edges[j][0];\\n                 int y2 = edges[j][1];\\n                \\n                int a1, a2, a3;\\n                if(dp[x1][y1])\\n                {\\n                    // x1 is parent of y1\\n                    int sub1 = xor_stored[y1];\\n                    int  bigger  = total ^ sub1;\\n                    \\n                    if(dp[x2][y2])\\n                    {\\n                        // x2 is parent of y2\\n                        if(dp[y1][y2])\\n                        {\\n                              a1  = bigger;\\n                            a2 =  xor_stored[y2];\\n                             a3= sub1^a2;\\n                          \\n                        }\\n                        else if(dp[y2][y1])\\n                        {\\n                            \\n                             a2 = xor_stored[y2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                          \\n                          \\n                        }\\n                        else\\n                        {\\n                              a1 = bigger^ xor_stored[y2];\\n                             a2 = xor_stored[y2];\\n                             a3 = sub1;\\n                        }\\n                    }\\n                    else   \\n                    {\\n                        // y2 is parent of x2\\n                         if(dp[y1][x2])\\n                        {\\n                             a1  = bigger;\\n                           a2 =  xor_stored[x2];\\n                         a3= sub1^a2;\\n                      \\n                        }\\n                        else if(dp[x2][y1])\\n                        {\\n                              a2 = xor_stored[x2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                        }\\n                        else\\n                        {\\n                             a1 = bigger^ xor_stored[x2];\\n                         a2 = xor_stored[x2];\\n                             a3 = sub1;\\n                        }\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    // y1 isparent of x1\\n                     int sub1 = xor_stored[x1];\\n                    int  bigger  = total ^ sub1;\\n                    \\n                    \\n                     if(dp[x2][y2])\\n                    {\\n                        // x2 is parent of y2\\n                        if(dp[x1][y2])\\n                        {\\n                              a1  = bigger;\\n                         a2 =  xor_stored[y2];\\n                             a3= sub1^a2;\\n                            \\n                        }\\n                         else if(dp[y2][x1])\\n                         {\\n                               a2 = xor_stored[y2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                         }\\n                        else\\n                        {\\n                          a1 = bigger^ xor_stored[y2];\\n                          a2 = xor_stored[y2];\\n                            a3 = sub1;\\n                            \\n                        }\\n                    }\\n                    else   \\n                    {\\n                        // y2 is parent of x2\\n                         if(dp[x1][x2])\\n                        {\\n                              a1  = bigger;\\n                            a2 =  xor_stored[x2];\\n                             a3= sub1^a2;\\n                        \\n                        }\\n                        else if(dp[x2][x1])\\n                        {\\n                              a2 = xor_stored[x2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                        }\\n                        else\\n                        {\\n                             a1 = bigger^ xor_stored[x2];\\n                             a2 = xor_stored[x2];\\n                             a3 = sub1;\\n                        }\\n                    }    \\n                }\\n               \\n                   int maa  = max(max(a1,a2), a3);\\n                         int mii   = min(min(a1,a2), a3);\\n                         an = min(an, (maa-mii)); \\n            }\\n        }\\n      return an;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>xor_stored;\\n    vector<int>vis1;\\n    vector<vector<int>>dp;\\n\\n    vector<int>vis2;\\n   void make_parent(int node, int parent, vector<vector<int>>& adj)\\n    {\\n       \\n        dp[parent][node] = true;\\n       vis2[node]  = true;\\n       for(auto it: adj[node])\\n       {\\n           if(vis2[it])\\n               continue;\\n           make_parent(it, parent, adj);\\n       }\\n    }\\n    int find_xor( vector<vector<int>>& adj, int node, vector<int>& nums )\\n    {\\n        xor_stored[node] = nums[node];\\n        vis1[node]  = true;\\n        \\n        for(auto it: adj[node])\\n        {\\n            if(vis1[it])\\n                continue;\\n            vis2.clear();\\n            vis2.resize(nums.size(), 0);\\n            vis2[node] = 1;\\n            make_parent(it, node, adj);\\n            \\n         \\n           int ans =  find_xor(adj, it, nums);\\n            xor_stored[node] ^= ans;\\n            \\n        }\\n        return xor_stored[node];\\n        \\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges)\\n    {\\n       int n  = nums.size();\\n        vector<vector<int>>adj(n);\\n        for(auto it: edges)\\n        {\\n            int x  = it[0]; int  y = it[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        xor_stored.resize(n,0);\\n         dp.resize(n, vector<int>(n,false));\\n        vis1.resize(n, 0);\\n        int  total=    find_xor(adj, 0 , nums);\\n        int an   =INT_MAX;\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            for(int  j = i+1;j<edges.size();j++)\\n            {\\n                 int x1  = edges[i][0];\\n                 int y1 = edges[i][1];\\n                 int x2 = edges[j][0];\\n                 int y2 = edges[j][1];\\n                \\n                int a1, a2, a3;\\n                if(dp[x1][y1])\\n                {\\n                    // x1 is parent of y1\\n                    int sub1 = xor_stored[y1];\\n                    int  bigger  = total ^ sub1;\\n                    \\n                    if(dp[x2][y2])\\n                    {\\n                        // x2 is parent of y2\\n                        if(dp[y1][y2])\\n                        {\\n                              a1  = bigger;\\n                            a2 =  xor_stored[y2];\\n                             a3= sub1^a2;\\n                          \\n                        }\\n                        else if(dp[y2][y1])\\n                        {\\n                            \\n                             a2 = xor_stored[y2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                          \\n                          \\n                        }\\n                        else\\n                        {\\n                              a1 = bigger^ xor_stored[y2];\\n                             a2 = xor_stored[y2];\\n                             a3 = sub1;\\n                        }\\n                    }\\n                    else   \\n                    {\\n                        // y2 is parent of x2\\n                         if(dp[y1][x2])\\n                        {\\n                             a1  = bigger;\\n                           a2 =  xor_stored[x2];\\n                         a3= sub1^a2;\\n                      \\n                        }\\n                        else if(dp[x2][y1])\\n                        {\\n                              a2 = xor_stored[x2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                        }\\n                        else\\n                        {\\n                             a1 = bigger^ xor_stored[x2];\\n                         a2 = xor_stored[x2];\\n                             a3 = sub1;\\n                        }\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    // y1 isparent of x1\\n                     int sub1 = xor_stored[x1];\\n                    int  bigger  = total ^ sub1;\\n                    \\n                    \\n                     if(dp[x2][y2])\\n                    {\\n                        // x2 is parent of y2\\n                        if(dp[x1][y2])\\n                        {\\n                              a1  = bigger;\\n                         a2 =  xor_stored[y2];\\n                             a3= sub1^a2;\\n                            \\n                        }\\n                         else if(dp[y2][x1])\\n                         {\\n                               a2 = xor_stored[y2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                         }\\n                        else\\n                        {\\n                          a1 = bigger^ xor_stored[y2];\\n                          a2 = xor_stored[y2];\\n                            a3 = sub1;\\n                            \\n                        }\\n                    }\\n                    else   \\n                    {\\n                        // y2 is parent of x2\\n                         if(dp[x1][x2])\\n                        {\\n                              a1  = bigger;\\n                            a2 =  xor_stored[x2];\\n                             a3= sub1^a2;\\n                        \\n                        }\\n                        else if(dp[x2][x1])\\n                        {\\n                              a2 = xor_stored[x2]^sub1;\\n                             a1 = bigger^ a2;\\n                             a3 = sub1;\\n                        }\\n                        else\\n                        {\\n                             a1 = bigger^ xor_stored[x2];\\n                             a2 = xor_stored[x2];\\n                             a3 = sub1;\\n                        }\\n                    }    \\n                }\\n               \\n                   int maa  = max(max(a1,a2), a3);\\n                         int mii   = min(min(a1,a2), a3);\\n                         an = min(an, (maa-mii)); \\n            }\\n        }\\n      return an;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227604,
                "title": "racket-solution-and-explanation",
                "content": "Idea based [Tlatoani\\'s solution](https://leetcode.com/contest/weekly-contest-299/ranking/2/).\\n\\nWe can iterate all possibilities and calculate the three xor of components.\\n\\nThere are two strategies:\\n\\n1. iterate pair of edges, or\\n2. iterate pair of nodes\\n\\nHere, strategy 2 is easier to understand in concept.\\n\\nFirstly, we build the tree from any node as root. We choose node `0`.\\nThen, the edge becomes directed (from father to child).\\nWe iterate every pair of nodes as children nodes of the two removed edges.\\n\\nLet\\'s say node `a` and `b` is a pair of nodes, if\\n\\n1. `a` is not `b`\\'s ancestor and `b` is not `a`\\'s ancestor, then we get three xor values are\\n\\t`x = xor_subtree(a)`, `y = xor_subtree(b)`, `xor_subtree(0) xor x xor y`.\\n2. `a` is `b`\\'s ancestor, then we get `x = xor_subtree(a) xor y`, `y = xor_subtree(b)`, `xor_subtree(0) xor x xor y`\\n3. `b` is `a`\\'s ancestor ...\\n\\nWe use a special information to recognize if `a` is `b`\\'s ancestor, see below.\\n\\n```scheme\\n(define/contract (minimum-score nums edges)\\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\\n\\n  (define n (length nums))\\n  (define adjacent (make-array n \\'()))\\n\\n  (for ([e edges])\\n    (let ([a (car e)]\\n          [b (cadr e)])\\n      (aset! adjacent a\\n             (cons b (aref adjacent a)))\\n      (aset! adjacent b\\n             (cons a (aref adjacent b)))))\\n  \\n  (define id-preorder (make-array n 0)) ; the number of elements before `i` in preorder tree-walk\\n  (define maxid-in-subtree (make-array n 0))\\n  (define xor-subtree (list->vector nums)) ; partial xor in the subtree that root is `i`\\n\\n  (define k 0)\\n\\n  (define (walk-tree a parent)\\n    (aset! id-preorder a k)\\n    (set! k (add1 k))\\n    (for ([b (aref adjacent a)])\\n      (when (not (= b parent))\\n        (walk-tree b a)\\n        (aset! xor-subtree a\\n               (bitwise-xor (aref xor-subtree a)\\n                            (aref xor-subtree b)))))\\n    (aset! maxid-in-subtree a k))\\n\\n  (define (ancestor? a b)\\n    (and (<= (aref id-preorder a)\\n             (aref id-preorder b))\\n         (<= (aref maxid-in-subtree b)\\n             (aref maxid-in-subtree a))))\\n\\n  (let ([answer #e1e10])\\n    (walk-tree 0 -1)\\n    (for* ([a (range 1 n)]\\n           [b (range 1 a)])\\n      (let ([x (aref xor-subtree a)]\\n            [y (aref xor-subtree b)])\\n        (cond [(ancestor? a b) (set! x (bitwise-xor x y))]\\n              [(ancestor? b a) (set! y (bitwise-xor x y))])\\n        (define z (bitwise-xor (aref xor-subtree 0) x y))\\n        (set! answer (min answer (- (max x y z)\\n                                    (min x y z))))))\\n    answer))\\n\\t\\n;; helpers ;;\\n\\n(define (make-array . dims)\\n  (if (= (length dims) 1) (car dims)\\n      (build-vector (car dims) (lambda _ (apply make-array (cdr dims))))))\\n\\n(define (aref arr . dims)\\n  (if (= (length dims) 0) arr\\n      (apply aref (vector-ref arr (car dims)) (cdr dims))))\\n\\n(define (aset! arr . dims)\\n  (if (= (length dims) 2) (vector-set! arr (car dims) (cadr dims))\\n      (apply aset! (vector-ref arr (car dims)) (cdr dims))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(define/contract (minimum-score nums edges)\\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\\n\\n  (define n (length nums))\\n  (define adjacent (make-array n \\'()))\\n\\n  (for ([e edges])\\n    (let ([a (car e)]\\n          [b (cadr e)])\\n      (aset! adjacent a\\n             (cons b (aref adjacent a)))\\n      (aset! adjacent b\\n             (cons a (aref adjacent b)))))\\n  \\n  (define id-preorder (make-array n 0)) ; the number of elements before `i` in preorder tree-walk\\n  (define maxid-in-subtree (make-array n 0))\\n  (define xor-subtree (list->vector nums)) ; partial xor in the subtree that root is `i`\\n\\n  (define k 0)\\n\\n  (define (walk-tree a parent)\\n    (aset! id-preorder a k)\\n    (set! k (add1 k))\\n    (for ([b (aref adjacent a)])\\n      (when (not (= b parent))\\n        (walk-tree b a)\\n        (aset! xor-subtree a\\n               (bitwise-xor (aref xor-subtree a)\\n                            (aref xor-subtree b)))))\\n    (aset! maxid-in-subtree a k))\\n\\n  (define (ancestor? a b)\\n    (and (<= (aref id-preorder a)\\n             (aref id-preorder b))\\n         (<= (aref maxid-in-subtree b)\\n             (aref maxid-in-subtree a))))\\n\\n  (let ([answer #e1e10])\\n    (walk-tree 0 -1)\\n    (for* ([a (range 1 n)]\\n           [b (range 1 a)])\\n      (let ([x (aref xor-subtree a)]\\n            [y (aref xor-subtree b)])\\n        (cond [(ancestor? a b) (set! x (bitwise-xor x y))]\\n              [(ancestor? b a) (set! y (bitwise-xor x y))])\\n        (define z (bitwise-xor (aref xor-subtree 0) x y))\\n        (set! answer (min answer (- (max x y z)\\n                                    (min x y z))))))\\n    answer))\\n\\t\\n;; helpers ;;\\n\\n(define (make-array . dims)\\n  (if (= (length dims) 1) (car dims)\\n      (build-vector (car dims) (lambda _ (apply make-array (cdr dims))))))\\n\\n(define (aref arr . dims)\\n  (if (= (length dims) 0) arr\\n      (apply aref (vector-ref arr (car dims)) (cdr dims))))\\n\\n(define (aset! arr . dims)\\n  (if (= (length dims) 2) (vector-set! arr (car dims) (cadr dims))\\n      (apply aset! (vector-ref arr (car dims)) (cdr dims))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2223009,
                "title": "c-dfs-root-shifting-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int re = INT_MAX;\\n    int dfs(vector<vector<int>> &nums,vector<int> &sub,vector<int> &val,int in,int p){\\n        sub[in] = val[in];\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p) sub[in]= sub[in]^dfs(nums,sub,val,j,in);\\n        }\\n        return sub[in];\\n    }\\n    void find(vector<vector<int>>& nums,vector<int>& sub,int in,int p,int x,int &c){\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p){\\n                int a = sub[j]^sub[in]^x, b = sub[j];\\n                int min_ = min(a,min(b,c)), max_ = max(a,max(b,c));\\n                re = min(re,max_-min_);\\n                find(nums,sub,j,in,(sub[in]^sub[j]^x),c); // shift the root to child\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& val, vector<vector<int>>& arr) {\\n        int n = val.size();   re = INT_MAX;\\n        vector<vector<int>> nums(n);\\n        for(int i = 0; i<arr.size(); ++i){\\n            nums[arr[i][0]].push_back(arr[i][1]);\\n            nums[arr[i][1]].push_back(arr[i][0]);\\n        }\\n        vector<int> sub(n,0);\\n        for(int i = 0; i<arr.size();++i){\\n            int a = arr[i][0], b = arr[i][1];  // break the tree from edge arr[i]\\n            fill(sub.begin(),sub.end(),0);\\n            dfs(nums,sub,val,a,b);  dfs(nums,sub,val,b,a);  // calculated the XOR of Subtrees of tree rooted at `a` and `b`.\\n            find(nums,sub,a,b,0,sub[b]);  find(nums,sub,b,a,0,sub[a]); // try to break each edge from tree rooted at \\'a\\' and \\'b\\'\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int re = INT_MAX;\\n    int dfs(vector<vector<int>> &nums,vector<int> &sub,vector<int> &val,int in,int p){\\n        sub[in] = val[in];\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p) sub[in]= sub[in]^dfs(nums,sub,val,j,in);\\n        }\\n        return sub[in];\\n    }\\n    void find(vector<vector<int>>& nums,vector<int>& sub,int in,int p,int x,int &c){\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p){\\n                int a = sub[j]^sub[in]^x, b = sub[j];\\n                int min_ = min(a,min(b,c)), max_ = max(a,max(b,c));\\n                re = min(re,max_-min_);\\n                find(nums,sub,j,in,(sub[in]^sub[j]^x),c); // shift the root to child\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& val, vector<vector<int>>& arr) {\\n        int n = val.size();   re = INT_MAX;\\n        vector<vector<int>> nums(n);\\n        for(int i = 0; i<arr.size(); ++i){\\n            nums[arr[i][0]].push_back(arr[i][1]);\\n            nums[arr[i][1]].push_back(arr[i][0]);\\n        }\\n        vector<int> sub(n,0);\\n        for(int i = 0; i<arr.size();++i){\\n            int a = arr[i][0], b = arr[i][1];  // break the tree from edge arr[i]\\n            fill(sub.begin(),sub.end(),0);\\n            dfs(nums,sub,val,a,b);  dfs(nums,sub,val,b,a);  // calculated the XOR of Subtrees of tree rooted at `a` and `b`.\\n            find(nums,sub,a,b,0,sub[b]);  find(nums,sub,b,a,0,sub[a]); // try to break each edge from tree rooted at \\'a\\' and \\'b\\'\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222986,
                "title": "java-easy-solution-dfs-brute-force-o-n-2",
                "content": "For every subTree calculate XOR, and store in a variable \"xor\"\\n![image](https://assets.leetcode.com/users/images/b0417da1-9e52-41ad-9ce0-b28098299ec0_1656679157.2266648.png)\\n\\nIterate, for every subtree and try to break the bond, after that\\nparent -> child\\nxor1 = xor[child]\\nremain = total^xor1\\nSo, we have found xor1 => now we need to find 2 more xor value .\\nFor that we will iterate in the remaning 1 of subtree starting from \"parent\".\\n3. While we iterate in the subtree, we will try all possible breaks, and \\nxor2 = xor[child]\\nxor3 = remain^xor2\\nmin1 = min(xor1, xor2, xor3);\\nmax = max(xor1, xor2, xor3)\\nmin = Math.min(min, max1 - min1)\\n\\n![image](https://assets.leetcode.com/users/images/a6641d79-8ca3-4341-8e12-51f6650abdc9_1656679281.7563465.png)\\n\\n```\\nclass Solution {\\n    int[] xor;\\n    ArrayList<ArrayList<Integer>> gr;\\n    int[] nums;\\n    int dfs(int i, int parent){\\n        \\n        int childXor = 0;\\n        for(int j : gr.get(i)){\\n            if(j != parent){\\n                childXor ^= dfs(j, i);\\n            }\\n        }\\n        \\n        xor[i] = childXor^nums[i];\\n        return xor[i];\\n    }\\n    \\n    int  min;\\n    void dfs1(int i, int parent, int total){\\n        \\n        for(int j : gr.get(i)){\\n            if(j != parent){\\n                 int childXor = xor[j];\\n                // we break this bond\\n                int remain = total^childXor;\\n                // gr[i][j] = 0;\\n                // gr[j][i] = 0;\\n                calculate(i, j, remain, childXor);\\n                // gr[i][j] = 1;\\n                // gr[j][i] = 1;\\n                \\n                dfs1(j, i, total);\\n            }\\n        }\\n    }\\n    \\n    int calculate(int i, int parent, int remain, int xor1){\\n       \\n        int childXor = 0;\\n        for(int j : gr.get(i)){\\n            if(j != parent){\\n                int child = calculate(j, i, remain, xor1);\\n                // if we break this bond\\n                int xor2 = remain^child;\\n                int min1 = Math.min(child, Math.min(xor1, xor2));\\n                int max1 = Math.max(child, Math.max(xor1, xor2));\\n                // System.out.println(min + \" \" + max1 + \" \" + min1);\\n                min = Math.min(min, max1 - min1);\\n                childXor ^= child; \\n            }\\n        }\\n        \\n        return childXor^nums[i];\\n    }\\n    \\n    public int minimumScore(int[] arr, int[][] edges) {\\n        \\n        nums = arr;\\n        int n = nums.length;\\n        xor = new int[n];\\n        min = Integer.MAX_VALUE;\\n        gr = new ArrayList<>();\\n        for(int i = 0; i < arr.length; i++){\\n            gr.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < edges.length; i++){\\n            int to = edges[i][0];\\n            int from = edges[i][1];\\n            gr.get(to).add(from);\\n            gr.get(from).add(to);\\n            // gr[to][from] = 1;\\n            // gr[from][to] = 1;\\n        }\\n        \\n        int total = dfs(1, -1);\\n        // System.out.println(Arrays.toString(xor));\\n        dfs1(1, -1, total);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] xor;\\n    ArrayList<ArrayList<Integer>> gr;\\n    int[] nums;\\n    int dfs(int i, int parent){\\n        \\n        int childXor = 0;\\n        for(int j : gr.get(i)){\\n            if(j != parent){\\n                childXor ^= dfs(j, i);\\n            }\\n        }\\n        \\n        xor[i] = childXor^nums[i];\\n        return xor[i];\\n    }\\n    \\n    int  min;\\n    void dfs1(int i, int parent, int total){\\n        \\n        for(int j : gr.get(i)){\\n            if(j != parent){\\n                 int childXor = xor[j];\\n                // we break this bond\\n                int remain = total^childXor;\\n                // gr[i][j] = 0;\\n                // gr[j][i] = 0;\\n                calculate(i, j, remain, childXor);\\n                // gr[i][j] = 1;\\n                // gr[j][i] = 1;\\n                \\n                dfs1(j, i, total);\\n            }\\n        }\\n    }\\n    \\n    int calculate(int i, int parent, int remain, int xor1){\\n       \\n        int childXor = 0;\\n        for(int j : gr.get(i)){\\n            if(j != parent){\\n                int child = calculate(j, i, remain, xor1);\\n                // if we break this bond\\n                int xor2 = remain^child;\\n                int min1 = Math.min(child, Math.min(xor1, xor2));\\n                int max1 = Math.max(child, Math.max(xor1, xor2));\\n                // System.out.println(min + \" \" + max1 + \" \" + min1);\\n                min = Math.min(min, max1 - min1);\\n                childXor ^= child; \\n            }\\n        }\\n        \\n        return childXor^nums[i];\\n    }\\n    \\n    public int minimumScore(int[] arr, int[][] edges) {\\n        \\n        nums = arr;\\n        int n = nums.length;\\n        xor = new int[n];\\n        min = Integer.MAX_VALUE;\\n        gr = new ArrayList<>();\\n        for(int i = 0; i < arr.length; i++){\\n            gr.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < edges.length; i++){\\n            int to = edges[i][0];\\n            int from = edges[i][1];\\n            gr.get(to).add(from);\\n            gr.get(from).add(to);\\n            // gr[to][from] = 1;\\n            // gr[from][to] = 1;\\n        }\\n        \\n        int total = dfs(1, -1);\\n        // System.out.println(Arrays.toString(xor));\\n        dfs1(1, -1, total);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222467,
                "title": "easy-to-understand",
                "content": "class Solution {\\npublic:\\n   int dfs(int src,vector<vector<int>>&adj,vector<bool>&visited,vector<int>&xor_of,vector<unordered_set<int>>&anscester,vector<int>& nums)\\n   {\\n       visited[src] = true;\\n       int xor_of_child = 0;\\n       for(auto &x:adj[src])\\n       {\\n           if(visited[x]==false)\\n           {\\n               xor_of_child^= dfs(x,adj,visited,xor_of,anscester,nums);\\n               for(auto  y:anscester[x])\\n               {\\n                   anscester[src].insert(y);\\n               }\\n           }\\n       }\\n       anscester[src].insert(src);\\n       xor_of[src] = nums[src]^xor_of_child;\\n       return xor_of[src];\\n   }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector<vector<int>>adj(n);\\n        vector<unordered_set<int>>anscester(n);\\n        for(auto &x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<bool>visited(n,false);\\n        vector<int>xor_of(n,0);\\n        int total = dfs(0,adj,visited,xor_of,anscester,nums);\\n        int ans = INT_MAX;\\n        \\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n            {\\n                if(anscester[i].find(j)!=anscester[i].end())\\n                {\\n                    int parent = xor_of[i]^xor_of[j];\\n                    int maxi = max(parent,max(xor_of[j],total^xor_of[i]));\\n                    int mini = min(parent,min(xor_of[j],total^xor_of[i]));\\n                    ans = min(ans,maxi-mini);\\n                   \\n                }\\n                else if(anscester[j].find(i)!=anscester[j].end())\\n                {\\n                    int parent = xor_of[i]^xor_of[j];\\n                    int maxi = max(parent,max(xor_of[i],total^xor_of[j]));\\n                    int mini = min(parent,min(xor_of[i],total^xor_of[j]));\\n                    ans = min(ans,maxi-mini);\\n                    \\n                }\\n                else\\n                {\\n                     int maxi = max(xor_of[j],max(xor_of[i],total^xor_of[i]^xor_of[j]));\\n                    int mini = min(xor_of[j],min(xor_of[i],total^xor_of[i]^xor_of[j]));\\n                    ans = min(ans,maxi-mini);\\n                     \\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n   int dfs(int src,vector<vector<int>>&adj,vector<bool>&visited,vector<int>&xor_of,vector<unordered_set<int>>&anscester,vector<int>& nums)\\n   {\\n       visited[src] = true;\\n       int xor_of_child = 0;\\n       for(auto &x:adj[src])\\n       {\\n           if(visited[x]==false)\\n           {\\n               xor_of_child^= dfs(x,adj,visited,xor_of,anscester,nums);\\n               for(auto  y:anscester[x])\\n               {\\n                   anscester[src].insert(y);\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2215568,
                "title": "o-n-2-brute-force",
                "content": "```cpp\\nconst int MAXN = 1005;\\n\\nint val[MAXN];\\nint depth[MAXN];\\nunordered_set<int> sons[MAXN];\\nvector<int> adj[MAXN];\\n\\ninline void generate(vector<int> &nums, int x, int p) {\\n    depth[x] = depth[p] + 1;\\n    val[x] = nums[x];\\n    for (auto &y : adj[x]) {\\n        if (y == p) {\\n            continue;\\n        }\\n        generate(nums, y, x);\\n        \\n        val[x] ^= val[y];\\n        \\n        for (auto &k: sons[y]) {\\n            sons[x].insert(k);\\n        }\\n    }\\n    sons[x].insert(x);\\n}\\n\\ntemplate<typename ...Args>\\ninline constexpr auto maxof(Args &&...args) {\\n    return max({args...});\\n}\\n\\ntemplate<typename ...Args>\\ninline constexpr auto minof(Args &&...args) {\\n    return min({args...});\\n}\\nvector<int> vals;\\n\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int N = nums.size();\\n        for (int i = 1; i <= N; i ++) {\\n            sons[i].clear();\\n            adj[i].clear();\\n        }\\n        nums.insert(nums.begin(), 0);\\n        for (auto &vec: edges) {\\n            adj[vec[0] + 1].push_back(vec[1] + 1);\\n            adj[vec[1] + 1].push_back(vec[0] + 1);\\n        }\\n        generate(nums, 1, 0);\\n        int ans = INT_MAX;\\n        \\n        vals.clear();\\n        \\n        for (int i = 0; i <= N; i ++) {\\n            vals.push_back(i);\\n        }\\n        sort(vals.begin(), vals.end(), [&](const auto a, const auto b) {\\n            return depth[a] < depth[b];\\n        });\\n        \\n        for (int x = 2, y, i, j; x <= N; x ++) {\\n            for (y = x + 1; y <= N; y ++) {\\n                i = vals[x];\\n                j = vals[y];\\n                if (sons[i].count(j)) {\\n                    ans = min(ans, \\n                        maxof(val[1] ^ val[i], val[i] ^ val[j], val[j]) -\\n                        minof(val[1] ^ val[i], val[i] ^ val[j], val[j])\\n                    );\\n                } else {\\n                    ans = min(ans,\\n                        maxof(val[1] ^ val[i] ^ val[j], val[i], val[j]) -\\n                        minof(val[1] ^ val[i] ^ val[j], val[i], val[j])\\n                    );\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThe key of xor is when you xor it again the influence brought by original xor would be eliminated.\\n",
                "solutionTags": [],
                "code": "```cpp\\nconst int MAXN = 1005;\\n\\nint val[MAXN];\\nint depth[MAXN];\\nunordered_set<int> sons[MAXN];\\nvector<int> adj[MAXN];\\n\\ninline void generate(vector<int> &nums, int x, int p) {\\n    depth[x] = depth[p] + 1;\\n    val[x] = nums[x];\\n    for (auto &y : adj[x]) {\\n        if (y == p) {\\n            continue;\\n        }\\n        generate(nums, y, x);\\n        \\n        val[x] ^= val[y];\\n        \\n        for (auto &k: sons[y]) {\\n            sons[x].insert(k);\\n        }\\n    }\\n    sons[x].insert(x);\\n}\\n\\ntemplate<typename ...Args>\\ninline constexpr auto maxof(Args &&...args) {\\n    return max({args...});\\n}\\n\\ntemplate<typename ...Args>\\ninline constexpr auto minof(Args &&...args) {\\n    return min({args...});\\n}\\nvector<int> vals;\\n\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int N = nums.size();\\n        for (int i = 1; i <= N; i ++) {\\n            sons[i].clear();\\n            adj[i].clear();\\n        }\\n        nums.insert(nums.begin(), 0);\\n        for (auto &vec: edges) {\\n            adj[vec[0] + 1].push_back(vec[1] + 1);\\n            adj[vec[1] + 1].push_back(vec[0] + 1);\\n        }\\n        generate(nums, 1, 0);\\n        int ans = INT_MAX;\\n        \\n        vals.clear();\\n        \\n        for (int i = 0; i <= N; i ++) {\\n            vals.push_back(i);\\n        }\\n        sort(vals.begin(), vals.end(), [&](const auto a, const auto b) {\\n            return depth[a] < depth[b];\\n        });\\n        \\n        for (int x = 2, y, i, j; x <= N; x ++) {\\n            for (y = x + 1; y <= N; y ++) {\\n                i = vals[x];\\n                j = vals[y];\\n                if (sons[i].count(j)) {\\n                    ans = min(ans, \\n                        maxof(val[1] ^ val[i], val[i] ^ val[j], val[j]) -\\n                        minof(val[1] ^ val[i], val[i] ^ val[j], val[j])\\n                    );\\n                } else {\\n                    ans = min(ans,\\n                        maxof(val[1] ^ val[i] ^ val[j], val[i], val[j]) -\\n                        minof(val[1] ^ val[i] ^ val[j], val[i], val[j])\\n                    );\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215380,
                "title": "java-dfs-intutive-solution",
                "content": "```\\n    // This solution is highly intutive in nature\\n    // TC = O(n2)\\n    /*\\n    Property ->  a^a=0, 0^a=a\\n\\n    The idea is to use this property via below algorithm\\n    - Do dfs from root and strore xor for each node\\'s subtree\\n    - Store ancestors for each node\\n    - Now for each pair of edges there are couple of ways to select them\\n        1. both edges can be part of same side\\n            like :-   / -> edge1\\n                     /  -> edge2\\n\\n        2. edges are part of diffent side\\n              like :-    |\\n                (edge1) / \\\\ (edge2)\\n\\n    - For the above 2 cases calculate XOR of each of 3 segmemnt via XOR property\\n    and minimise ans.\\n    \\n    - Return minimum ans.\\n     */\\n    class Solution {\\n        int[] nums;\\n        Map<Integer, List<Integer>> adj;\\n        int[] xor;\\n        Set<Integer>[] ancestors;\\n\\n        public int minimumScore(int[] nums, int[][] edges) {\\n\\n            this.nums = nums;\\n            adj = new HashMap<>();\\n            xor = new int[nums.length];\\n            ancestors = new Set[nums.length];\\n\\n\\n            int ans = Integer.MAX_VALUE;\\n            for (int[] edge : edges) {\\n                if (adj.containsKey(edge[0])) {\\n                    List<Integer> exist = adj.get(edge[0]);\\n                    exist.add(edge[1]);\\n                    adj.put(edge[0], exist);\\n                } else adj.put(edge[0], new ArrayList<>(Arrays.asList(edge[1])));\\n\\n                if (adj.containsKey(edge[1])) {\\n                    List<Integer> exist = adj.get(edge[1]);\\n                    exist.add(edge[0]);\\n                    adj.put(edge[1], exist);\\n                } else adj.put(edge[1], new ArrayList<>(Arrays.asList(edge[0])));\\n            }\\n\\n\\n            dfs(0, -1, new ArrayList<>());\\n\\n\\n            for (int i = 0; i < edges.length; i++) {\\n                for (int j = i + 1; j < edges.length; j++) {\\n                    int subNode1 = getSubRoot(edges[i]), subNode2 = getSubRoot(edges[j]);\\n                    int xc = xor[0], xa = xor[subNode1], xb = xor[subNode2];\\n                    // if both child subTree lies under same side\\n                    if (ancestors[subNode2].contains(subNode1)) {\\n                        xc ^= xa;\\n                        xa ^= xb;\\n                    } else if (ancestors[subNode1].contains(subNode2)) {\\n                        xc ^= xb;\\n                        xb ^= xa;\\n                    }\\n                    // They lies under different subtree\\n                    else {\\n                        xc ^= xa;\\n                        xc ^= xb;\\n                    }\\n\\n                    int min = Math.min(xc, Math.min(xa, xb));\\n                    int max = Math.max(xc, Math.max(xa, xb));\\n                    ans = Math.min(ans, max - min);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        private int dfs(int i, int parent, List<Integer> path) {\\n            int ans = nums[i];\\n            ancestors[i] = new HashSet<>();\\n            ancestors[i].addAll(path);\\n            path.add(i);\\n\\n            for (int child : adj.get(i)) {\\n                if (child != parent) {\\n                    ans ^= dfs(child, i, path);\\n                }\\n            }\\n\\n            path.remove(path.size() - 1);\\n            return xor[i] = ans;\\n\\n        }\\n\\n        private int getSubRoot(int[] edge) {\\n            int i = edge[0];\\n            int j = edge[1];\\n            if (ancestors[i].contains(j)) return i;\\n            return j;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // This solution is highly intutive in nature\\n    // TC = O(n2)\\n    /*\\n    Property ->  a^a=0, 0^a=a\\n\\n    The idea is to use this property via below algorithm\\n    - Do dfs from root and strore xor for each node\\'s subtree\\n    - Store ancestors for each node\\n    - Now for each pair of edges there are couple of ways to select them\\n        1. both edges can be part of same side\\n            like :-   / -> edge1\\n                     /  -> edge2\\n\\n        2. edges are part of diffent side\\n              like :-    |\\n                (edge1) / \\\\ (edge2)\\n\\n    - For the above 2 cases calculate XOR of each of 3 segmemnt via XOR property\\n    and minimise ans.\\n    \\n    - Return minimum ans.\\n     */\\n    class Solution {\\n        int[] nums;\\n        Map<Integer, List<Integer>> adj;\\n        int[] xor;\\n        Set<Integer>[] ancestors;\\n\\n        public int minimumScore(int[] nums, int[][] edges) {\\n\\n            this.nums = nums;\\n            adj = new HashMap<>();\\n            xor = new int[nums.length];\\n            ancestors = new Set[nums.length];\\n\\n\\n            int ans = Integer.MAX_VALUE;\\n            for (int[] edge : edges) {\\n                if (adj.containsKey(edge[0])) {\\n                    List<Integer> exist = adj.get(edge[0]);\\n                    exist.add(edge[1]);\\n                    adj.put(edge[0], exist);\\n                } else adj.put(edge[0], new ArrayList<>(Arrays.asList(edge[1])));\\n\\n                if (adj.containsKey(edge[1])) {\\n                    List<Integer> exist = adj.get(edge[1]);\\n                    exist.add(edge[0]);\\n                    adj.put(edge[1], exist);\\n                } else adj.put(edge[1], new ArrayList<>(Arrays.asList(edge[0])));\\n            }\\n\\n\\n            dfs(0, -1, new ArrayList<>());\\n\\n\\n            for (int i = 0; i < edges.length; i++) {\\n                for (int j = i + 1; j < edges.length; j++) {\\n                    int subNode1 = getSubRoot(edges[i]), subNode2 = getSubRoot(edges[j]);\\n                    int xc = xor[0], xa = xor[subNode1], xb = xor[subNode2];\\n                    // if both child subTree lies under same side\\n                    if (ancestors[subNode2].contains(subNode1)) {\\n                        xc ^= xa;\\n                        xa ^= xb;\\n                    } else if (ancestors[subNode1].contains(subNode2)) {\\n                        xc ^= xb;\\n                        xb ^= xa;\\n                    }\\n                    // They lies under different subtree\\n                    else {\\n                        xc ^= xa;\\n                        xc ^= xb;\\n                    }\\n\\n                    int min = Math.min(xc, Math.min(xa, xb));\\n                    int max = Math.max(xc, Math.max(xa, xb));\\n                    ans = Math.min(ans, max - min);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        private int dfs(int i, int parent, List<Integer> path) {\\n            int ans = nums[i];\\n            ancestors[i] = new HashSet<>();\\n            ancestors[i].addAll(path);\\n            path.add(i);\\n\\n            for (int child : adj.get(i)) {\\n                if (child != parent) {\\n                    ans ^= dfs(child, i, path);\\n                }\\n            }\\n\\n            path.remove(path.size() - 1);\\n            return xor[i] = ans;\\n\\n        }\\n\\n        private int getSubRoot(int[] edge) {\\n            int i = edge[0];\\n            int j = edge[1];\\n            if (ancestors[i].contains(j)) return i;\\n            return j;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214500,
                "title": "dfs-with-ancestors-concept",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    bool is_ancestor(int u, int v,vector<int> &tin,vector<int> &tout)\\n    {\\n        return tin[u] <= tin[v] && tout[u] >= tout[v];\\n    }    \\n\\n    int dfs(int i,int par,vector<int> adj[],vector<int> &x,vector<int> &parent,vector<int>& v,int &timer,vector<int> &tin,vector<int> &tout){\\n        parent[i]=par;\\n        if(x[0] != -1) return x[0];\\n        tin[i] = ++timer;\\n        int xorr = v[i];\\n        for(auto nbr:adj[i]){\\n            if(nbr != par){\\n                xorr ^= dfs(nbr,i,adj,x,parent,v,timer,tin,tout);\\n            }\\n        }\\n        tout[i] = ++timer;\\n        return x[i] = xorr;\\n    }\\n    \\n    int minimumScore(vector<int>& v, vector<vector<int>>& edges) {     \\n        int n=v.size();\\n        vector<int> adj[n];\\n        for(auto v:edges){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        int timer=0;\\n        vector<int> tin(n), tout(n);\\n        vector<int> x(n,-1);//x[i] -> store the xor of subtree rooted at node i\\n        vector<int> parent(n);//parent[i] -> store the parent of node i\\n        //let\\'s root the tree at 0\\n        x[0] = dfs(0,-1,adj,x,parent,v,timer,tin,tout);\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                int node1,node2;\\n                int xor1,xor2,xor3;\\n                if(parent[edges[i][0]]==edges[i][1]) node1=edges[i][0];\\n                else node1=edges[i][1];\\n                if(parent[edges[j][0]]==edges[j][1]) node2=edges[j][0];\\n                else node2=edges[j][1];  \\n                if(is_ancestor(node1,node2,tin,tout)){\\n                    xor2 = x[node2];\\n                    xor1 = x[node1]^xor2;\\n                }else if(is_ancestor(node2,node1,tin,tout)){\\n                    xor1 = x[node1];\\n                    xor2 = x[node2]^xor1;\\n                }else{\\n                    xor1 = x[node1];\\n                    xor2 = x[node2];                 \\n                }\\n                xor3 = x[0]^xor1^xor2;\\n                int mx = max(xor1,max(xor2,xor3));\\n                int mn = min(xor1,min(xor2,xor3));\\n                ans = min(ans,mx-mn);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool is_ancestor(int u, int v,vector<int> &tin,vector<int> &tout)\\n    {\\n        return tin[u] <= tin[v] && tout[u] >= tout[v];\\n    }    \\n\\n    int dfs(int i,int par,vector<int> adj[],vector<int> &x,vector<int> &parent,vector<int>& v,int &timer,vector<int> &tin,vector<int> &tout){\\n        parent[i]=par;\\n        if(x[0] != -1) return x[0];\\n        tin[i] = ++timer;\\n        int xorr = v[i];\\n        for(auto nbr:adj[i]){\\n            if(nbr != par){\\n                xorr ^= dfs(nbr,i,adj,x,parent,v,timer,tin,tout);\\n            }\\n        }\\n        tout[i] = ++timer;\\n        return x[i] = xorr;\\n    }\\n    \\n    int minimumScore(vector<int>& v, vector<vector<int>>& edges) {     \\n        int n=v.size();\\n        vector<int> adj[n];\\n        for(auto v:edges){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        int timer=0;\\n        vector<int> tin(n), tout(n);\\n        vector<int> x(n,-1);//x[i] -> store the xor of subtree rooted at node i\\n        vector<int> parent(n);//parent[i] -> store the parent of node i\\n        //let\\'s root the tree at 0\\n        x[0] = dfs(0,-1,adj,x,parent,v,timer,tin,tout);\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                int node1,node2;\\n                int xor1,xor2,xor3;\\n                if(parent[edges[i][0]]==edges[i][1]) node1=edges[i][0];\\n                else node1=edges[i][1];\\n                if(parent[edges[j][0]]==edges[j][1]) node2=edges[j][0];\\n                else node2=edges[j][1];  \\n                if(is_ancestor(node1,node2,tin,tout)){\\n                    xor2 = x[node2];\\n                    xor1 = x[node1]^xor2;\\n                }else if(is_ancestor(node2,node1,tin,tout)){\\n                    xor1 = x[node1];\\n                    xor2 = x[node2]^xor1;\\n                }else{\\n                    xor1 = x[node1];\\n                    xor2 = x[node2];                 \\n                }\\n                xor3 = x[0]^xor1^xor2;\\n                int mx = max(xor1,max(xor2,xor3));\\n                int mn = min(xor1,min(xor2,xor3));\\n                ans = min(ans,mx-mn);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212451,
                "title": "python-simpler-implementation-o-e-2",
                "content": "based on https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/discuss/2198665/Python-3-Explanation-with-pictures\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        m = len(edges)\\n        children = defaultdict(set)\\n        xor = [0]*len(nums)\\n        G = defaultdict(list)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        visited = set()\\n        def dfs(v):\\n            visited.add(v)\\n            curxor = nums[v]\\n            children[v].add(v)\\n            for w in G[v]:\\n                if w not in visited:\\n                    curxor ^= dfs(w)\\n                    children[v] |= children[w]\\n            xor[v] = curxor\\n            return xor[v]\\n        root = 0\\n        dfs(root)\\n        res = float(\\'inf\\')\\n        for i in range(m - 1):\\n            for j in range(i + 1, m):\\n                a, b = edges[i]\\n                if b in children[a]:\\n                    a, b = b, a\\n                c,d = edges[j]\\n                if d in children[c]:\\n                    c, d = d, c\\n                if c in children[a]:\\n                    cur = [xor[c], xor[a]^xor[c], xor[root]^xor[a]]\\n                elif a in children[c]:\\n                    cur = [xor[a], xor[c]^xor[a], xor[root]^xor[c]]\\n                else:\\n                    cur = [xor[a], xor[c], xor[root]^xor[a]^xor[c]]\\n                res = min(res, max(cur) - min(cur))\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "based on https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/discuss/2198665/Python-3-Explanation-with-pictures\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        m = len(edges)\\n        children = defaultdict(set)\\n        xor = [0]*len(nums)\\n        G = defaultdict(list)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        visited = set()\\n        def dfs(v):\\n            visited.add(v)\\n            curxor = nums[v]\\n            children[v].add(v)\\n            for w in G[v]:\\n                if w not in visited:\\n                    curxor ^= dfs(w)\\n                    children[v] |= children[w]\\n            xor[v] = curxor\\n            return xor[v]\\n        root = 0\\n        dfs(root)\\n        res = float(\\'inf\\')\\n        for i in range(m - 1):\\n            for j in range(i + 1, m):\\n                a, b = edges[i]\\n                if b in children[a]:\\n                    a, b = b, a\\n                c,d = edges[j]\\n                if d in children[c]:\\n                    c, d = d, c\\n                if c in children[a]:\\n                    cur = [xor[c], xor[a]^xor[c], xor[root]^xor[a]]\\n                elif a in children[c]:\\n                    cur = [xor[a], xor[c]^xor[a], xor[root]^xor[c]]\\n                else:\\n                    cur = [xor[a], xor[c], xor[root]^xor[a]^xor[c]]\\n                res = min(res, max(cur) - min(cur))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2211843,
                "title": "java-o-n-2-still-why-tle",
                "content": "I am not able to find out why this code is giving TLE, even though approach is O(n^2). Can you please help me.\\n\\n```\\nclass Solution {\\n    \\n    boolean debug = false;\\n    \\n    HashMap<Integer, List<Integer>> graph;\\n    int parent[];\\n    HashMap<Integer, Integer> xor;\\n    HashSet<String> vis;\\n    \\n    int ans = Integer.MAX_VALUE/2;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        \\n        int n = nums.length;\\n        int m = edges.length;\\n        parent = new int[n];\\n        vis = new HashSet<>();\\n        \\n        xor = new HashMap<>();\\n        graph = new HashMap<>();\\n        \\n        for(int i=0;i<m;i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            \\n            graph.computeIfAbsent(a, k->new ArrayList<>()).add(b);\\n            graph.computeIfAbsent(b, k->new ArrayList<>()).add(a);\\n\\n        }\\n        \\n        \\n        int root = 0;\\n        buildXor(root, -1, nums); // o(n)\\n        \\n        if(debug) System.out.println(\"xor:\"+xor);\\n        \\n        HashMap<Integer, HashSet<Integer>> children = new HashMap<>();\\n        \\n         for(int i=1;i<n;i++){\\n            checkInternal(root, i, children); //o(n^2)\\n         }\\n        \\n        for(int i=1;i<n;i++){\\n            checkExternal(root, i, children, n);      //o(n^2)      \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void checkExternal(int root, int i, HashMap<Integer, HashSet<Integer>> children, int n){\\n        \\n        for(int j=1;j<n;j++){\\n            if(!children.get(i).contains(j) && j!=i){\\n                \\n                int a = i;\\n                int b = j;  \\n                \\n                updateAnsExternal(root, a, b);\\n                \\n            }\\n        }\\n        \\n    }\\n    \\n    \\n    public void checkInternal(int root, int u, HashMap<Integer, HashSet<Integer>> children){\\n        HashSet<Integer> child = new HashSet<>();\\n        for(int v: graph.get(u)){\\n            if(parent[u] == v) continue;\\n            checkInternalUtil(root, u, v, u, child);\\n        }\\n        children.put(u, child);\\n    }\\n    \\n    public void checkInternalUtil(int root, int i, int u, int p, HashSet<Integer> children){\\n        //check for current root, i, u\\n        \\n        children.add(u);\\n        updateAnsInternal(root, i, u);\\n        for(int v: graph.get(u)){\\n            if(v == p) continue;\\n            checkInternalUtil(root, i, v, u, children);\\n        }\\n    }\\n    \\n    public void updateAnsExternal(int root, int u, int v){\\n        \\n        String key = getKey(root, u, v);\\n        \\n        if(vis.contains(key)) return;\\n        \\n        int a = xor.get(root);\\n        int b = xor.get(u);\\n        int c = xor.get(v);\\n        \\n        a = a^b;\\n        a = a^c;\\n        if(debug) System.out.println(\"Ext:\"+root+\" \"+u+\" \"+v+\" =\"+(max(a,b,c)-min(a,b,c))+\" a:\"+a+\" b:\"+b+\" c:\"+c);\\n\\n        ans = Math.min(ans, max(a,b,c)-min(a,b,c));\\n        \\n    }\\n    \\n    public void updateAnsInternal(int root, int u, int v){\\n        int a = xor.get(root);\\n        int b = xor.get(u);\\n        a = a^b;\\n        int c = xor.get(v);\\n        b = b^c;\\n        if(debug) System.out.println(\"Int:\"+root+\" \"+u+\" \"+v+\" =\"+(max(a,b,c)-min(a,b,c)));\\n        String key = getKey(root, u, v);\\n        vis.add(key);\\n        ans = Math.min(ans, max(a,b,c)-min(a,b,c));\\n    }\\n    \\n    private String getKey(int a, int b, int c){\\n        \\n        int[] num = new int[3];\\n        num[0] = a;\\n        num[1] = b;\\n        num[2] = c;\\n        Arrays.sort(num);\\n        return num[0]+\" \"+num[1]+\" \"+num[2];\\n    }\\n    \\n    \\n    public int max(int a, int b, int c){\\n        return Math.max(a, Math.max(b, c));\\n    }\\n    public int min(int a, int b, int c){\\n        return Math.min(a, Math.min(b, c));\\n    }\\n    \\n    \\n    public int buildXor(int u, int p, int[] nums){\\n        parent[u] = p;\\n        int x = nums[u];\\n        for(int v: graph.get(u)){\\n            if(v==p) continue;\\n            x = x^buildXor(v, u, nums);\\n        }\\n        xor.put(u, x);\\n        return x;\\n    }\\n    \\n}\\n\\n\\n        \\n        /*\\n        \\n        root, i, \\n        \\n        */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    boolean debug = false;\\n    \\n    HashMap<Integer, List<Integer>> graph;\\n    int parent[];\\n    HashMap<Integer, Integer> xor;\\n    HashSet<String> vis;\\n    \\n    int ans = Integer.MAX_VALUE/2;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        \\n        int n = nums.length;\\n        int m = edges.length;\\n        parent = new int[n];\\n        vis = new HashSet<>();\\n        \\n        xor = new HashMap<>();\\n        graph = new HashMap<>();\\n        \\n        for(int i=0;i<m;i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            \\n            graph.computeIfAbsent(a, k->new ArrayList<>()).add(b);\\n            graph.computeIfAbsent(b, k->new ArrayList<>()).add(a);\\n\\n        }\\n        \\n        \\n        int root = 0;\\n        buildXor(root, -1, nums); // o(n)\\n        \\n        if(debug) System.out.println(\"xor:\"+xor);\\n        \\n        HashMap<Integer, HashSet<Integer>> children = new HashMap<>();\\n        \\n         for(int i=1;i<n;i++){\\n            checkInternal(root, i, children); //o(n^2)\\n         }\\n        \\n        for(int i=1;i<n;i++){\\n            checkExternal(root, i, children, n);      //o(n^2)      \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void checkExternal(int root, int i, HashMap<Integer, HashSet<Integer>> children, int n){\\n        \\n        for(int j=1;j<n;j++){\\n            if(!children.get(i).contains(j) && j!=i){\\n                \\n                int a = i;\\n                int b = j;  \\n                \\n                updateAnsExternal(root, a, b);\\n                \\n            }\\n        }\\n        \\n    }\\n    \\n    \\n    public void checkInternal(int root, int u, HashMap<Integer, HashSet<Integer>> children){\\n        HashSet<Integer> child = new HashSet<>();\\n        for(int v: graph.get(u)){\\n            if(parent[u] == v) continue;\\n            checkInternalUtil(root, u, v, u, child);\\n        }\\n        children.put(u, child);\\n    }\\n    \\n    public void checkInternalUtil(int root, int i, int u, int p, HashSet<Integer> children){\\n        //check for current root, i, u\\n        \\n        children.add(u);\\n        updateAnsInternal(root, i, u);\\n        for(int v: graph.get(u)){\\n            if(v == p) continue;\\n            checkInternalUtil(root, i, v, u, children);\\n        }\\n    }\\n    \\n    public void updateAnsExternal(int root, int u, int v){\\n        \\n        String key = getKey(root, u, v);\\n        \\n        if(vis.contains(key)) return;\\n        \\n        int a = xor.get(root);\\n        int b = xor.get(u);\\n        int c = xor.get(v);\\n        \\n        a = a^b;\\n        a = a^c;\\n        if(debug) System.out.println(\"Ext:\"+root+\" \"+u+\" \"+v+\" =\"+(max(a,b,c)-min(a,b,c))+\" a:\"+a+\" b:\"+b+\" c:\"+c);\\n\\n        ans = Math.min(ans, max(a,b,c)-min(a,b,c));\\n        \\n    }\\n    \\n    public void updateAnsInternal(int root, int u, int v){\\n        int a = xor.get(root);\\n        int b = xor.get(u);\\n        a = a^b;\\n        int c = xor.get(v);\\n        b = b^c;\\n        if(debug) System.out.println(\"Int:\"+root+\" \"+u+\" \"+v+\" =\"+(max(a,b,c)-min(a,b,c)));\\n        String key = getKey(root, u, v);\\n        vis.add(key);\\n        ans = Math.min(ans, max(a,b,c)-min(a,b,c));\\n    }\\n    \\n    private String getKey(int a, int b, int c){\\n        \\n        int[] num = new int[3];\\n        num[0] = a;\\n        num[1] = b;\\n        num[2] = c;\\n        Arrays.sort(num);\\n        return num[0]+\" \"+num[1]+\" \"+num[2];\\n    }\\n    \\n    \\n    public int max(int a, int b, int c){\\n        return Math.max(a, Math.max(b, c));\\n    }\\n    public int min(int a, int b, int c){\\n        return Math.min(a, Math.min(b, c));\\n    }\\n    \\n    \\n    public int buildXor(int u, int p, int[] nums){\\n        parent[u] = p;\\n        int x = nums[u];\\n        for(int v: graph.get(u)){\\n            if(v==p) continue;\\n            x = x^buildXor(v, u, nums);\\n        }\\n        xor.put(u, x);\\n        return x;\\n    }\\n    \\n}\\n\\n\\n        \\n        /*\\n        \\n        root, i, \\n        \\n        */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211204,
                "title": "python-code-accepted-minimum-score-after-removals-on-a-tree",
                "content": "\\tclass TreeNode:\\n\\t\\tdef __init__(self, val=0, left=None, right=None):\\n\\t\\t\\tself.val = val\\n\\t\\t\\tself.childrens = []\\n\\t\\t\\tself.subTrees = []\\n\\tclass Solution:\\n\\t\\tdef minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n\\t\\t\\tarr = [[] for j in range(len(nums))]\\n\\n\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tarr[i[0]].append(i[1])\\n\\t\\t\\t\\tarr[i[1]].append(i[0])\\n        \\n        # for i in range(len(nums)):\\n        #     arr[i].sort()\\n        \\n        arrStatus = [False for j in range(len(nums))]\\n        \\n        def createTree(index):\\n            arrStatus[index]=True\\n            node = TreeNode(index)\\n            for i in arr[index]:\\n                if not arrStatus[i]:\\n                    node.childrens.append(createTree(i))\\n            return node\\n        tree = createTree(0)\\n        \\n        arrSub = [[] for j in range(len(nums))]\\n        \\n        def getSub(node):\\n            ans = [set([node.val]),nums[node.val]]\\n            for i in node.childrens:\\n                temp = getSub(i)\\n                ans[0] |= temp[0]\\n                ans[1]^=temp[1]\\n            arrSub[node.val] = ans\\n            return ans\\n        getSub(tree)\\n        \\n                \\n        ans = float(\"inf\")\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if i in arrSub[j][0]:\\n                    x = arrSub[0][1]^arrSub[j][1]\\n                    y = arrSub[j][1]^arrSub[i][1]\\n                    z = arrSub[i][1]\\n                elif j in arrSub[i][0]:\\n                    x = arrSub[0][1]^arrSub[i][1]\\n                    y = arrSub[i][1]^arrSub[j][1]\\n                    z = arrSub[j][1]\\n                else:\\n                    x = arrSub[0][1]^arrSub[i][1]^arrSub[j][1]\\n                    y = arrSub[i][1]\\n                    z = arrSub[j][1]\\n                ans = min(ans, max(x,y,z)-min(x,y,z))\\n        return ans",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "\\tclass TreeNode:\\n\\t\\tdef __init__(self, val=0, left=None, right=None):\\n\\t\\t\\tself.val = val\\n\\t\\t\\tself.childrens = []\\n\\t\\t\\tself.subTrees = []\\n\\tclass Solution:\\n\\t\\tdef minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n\\t\\t\\tarr = [[] for j in range(len(nums))]\\n\\n\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tarr[i[0]].append(i[1])\\n\\t\\t\\t\\tarr[i[1]].append(i[0])\\n        \\n        # for i in range(len(nums)):\\n        #     arr[i].sort()\\n        \\n        arrStatus = [False for j in range(len(nums))]\\n        \\n        def createTree(index):\\n            arrStatus[index]=True\\n            node = TreeNode(index)\\n            for i in arr[index]:\\n                if not arrStatus[i]:\\n                    node.childrens.append(createTree(i))\\n            return node\\n        tree = createTree(0)\\n        \\n        arrSub = [[] for j in range(len(nums))]\\n        \\n        def getSub(node):\\n            ans = [set([node.val]),nums[node.val]]\\n            for i in node.childrens:\\n                temp = getSub(i)\\n                ans[0] |= temp[0]\\n                ans[1]^=temp[1]\\n            arrSub[node.val] = ans\\n            return ans\\n        getSub(tree)\\n        \\n                \\n        ans = float(\"inf\")\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if i in arrSub[j][0]:\\n                    x = arrSub[0][1]^arrSub[j][1]\\n                    y = arrSub[j][1]^arrSub[i][1]\\n                    z = arrSub[i][1]\\n                elif j in arrSub[i][0]:\\n                    x = arrSub[0][1]^arrSub[i][1]\\n                    y = arrSub[i][1]^arrSub[j][1]\\n                    z = arrSub[j][1]\\n                else:\\n                    x = arrSub[0][1]^arrSub[i][1]^arrSub[j][1]\\n                    y = arrSub[i][1]\\n                    z = arrSub[j][1]\\n                ans = min(ans, max(x,y,z)-min(x,y,z))\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2210995,
                "title": "intuitive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int N;\\n    void dfs(int u,vector<vector<int>>&adj,vector<vector<int>>&child,vector<int>&vis){\\n        vis[u] = 1;\\n        for(int nbr:adj[u]){\\n            if(!vis[nbr]){\\n                vis[nbr] = 1;\\n                dfs(nbr,adj,child,vis);\\n                for(int i=0;i<N;i++){\\n                    if(child[nbr][i]){\\n                        child[u][i] = 1;\\n                    }\\n                }\\n                child[u][nbr] = 1;                \\n            }\\n        }\\n    }\\n    void fill_xor(int u,vector<vector<int>>&adj,vector<int>&vis,vector<int>&XOR,vector<int>&val){\\n        vis[u] = 1;\\n        XOR[u] = val[u];\\n        for(int nbr:adj[u]){\\n            if(!vis[nbr]){\\n                vis[nbr] = 1;\\n                fill_xor(nbr,adj,vis,XOR,val);\\n                XOR[u] ^= XOR[nbr];\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        N = n;\\n        vector<vector<int>>child(n+1,vector<int>(n+1,0));\\n        vector<vector<int>>adj(n+1);\\n        map<int,int>mp;\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n            mp[i[0]] = i[1];\\n        }\\n        vector<int>XOR(n+1,0);\\n        vector<int>vis1(n+1,0);\\n        vector<int>vis2(n+1,0);\\n        fill_xor(0,adj,vis2,XOR,nums);\\n        dfs(0,adj,child,vis1);\\n\\n        int ans = INT_MAX;\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                \\n                if(child[i][j] ){\\n                    int a = XOR[i]^XOR[0];\\n                    int b = XOR[i]^XOR[j];\\n                    int c = XOR[j];\\n                    ans = min(max(a,max(b,c)) - min(a,min(b,c)) , ans);\\n                }\\n                else if(child[j][i]){\\n                    int a = XOR[j]^XOR[0];\\n                    int b = XOR[i]^XOR[j];\\n                    int c = XOR[i];\\n                    ans = min(max(a,max(b,c)) - min(a,min(b,c)) , ans);\\n                }\\n                else{\\n                    int a = XOR[0]^XOR[i]^XOR[j];\\n                    int b = XOR[i];\\n                    int c = XOR[j];\\n                    ans = min(max(a,max(b,c)) - min(a,min(b,c)) , ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N;\\n    void dfs(int u,vector<vector<int>>&adj,vector<vector<int>>&child,vector<int>&vis){\\n        vis[u] = 1;\\n        for(int nbr:adj[u]){\\n            if(!vis[nbr]){\\n                vis[nbr] = 1;\\n                dfs(nbr,adj,child,vis);\\n                for(int i=0;i<N;i++){\\n                    if(child[nbr][i]){\\n                        child[u][i] = 1;\\n                    }\\n                }\\n                child[u][nbr] = 1;                \\n            }\\n        }\\n    }\\n    void fill_xor(int u,vector<vector<int>>&adj,vector<int>&vis,vector<int>&XOR,vector<int>&val){\\n        vis[u] = 1;\\n        XOR[u] = val[u];\\n        for(int nbr:adj[u]){\\n            if(!vis[nbr]){\\n                vis[nbr] = 1;\\n                fill_xor(nbr,adj,vis,XOR,val);\\n                XOR[u] ^= XOR[nbr];\\n            }\\n        }\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        N = n;\\n        vector<vector<int>>child(n+1,vector<int>(n+1,0));\\n        vector<vector<int>>adj(n+1);\\n        map<int,int>mp;\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n            mp[i[0]] = i[1];\\n        }\\n        vector<int>XOR(n+1,0);\\n        vector<int>vis1(n+1,0);\\n        vector<int>vis2(n+1,0);\\n        fill_xor(0,adj,vis2,XOR,nums);\\n        dfs(0,adj,child,vis1);\\n\\n        int ans = INT_MAX;\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                \\n                if(child[i][j] ){\\n                    int a = XOR[i]^XOR[0];\\n                    int b = XOR[i]^XOR[j];\\n                    int c = XOR[j];\\n                    ans = min(max(a,max(b,c)) - min(a,min(b,c)) , ans);\\n                }\\n                else if(child[j][i]){\\n                    int a = XOR[j]^XOR[0];\\n                    int b = XOR[i]^XOR[j];\\n                    int c = XOR[i];\\n                    ans = min(max(a,max(b,c)) - min(a,min(b,c)) , ans);\\n                }\\n                else{\\n                    int a = XOR[0]^XOR[i]^XOR[j];\\n                    int b = XOR[i];\\n                    int c = XOR[j];\\n                    ans = min(max(a,max(b,c)) - min(a,min(b,c)) , ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208839,
                "title": "o-n-2-solution-giving-tle",
                "content": "```\\n// Same code, my version, not working!\\n\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9;\\nvi(bool) primes;\\n\\nclass Solution {\\n    ll ans = INT_MAX;\\n    vi(ll)xos;\\n    ll doxo(const vi(ll)& val, const vi(vi(ll))& g, ll in = 0, ll par = -1) {\\n        xos[in] = val[in];\\n        for (const ll& it : g[in])\\n            if (it != par)\\n                xos[in] ^= doxo(val, g, it, in);\\n        return xos[in];\\n    }\\n    ll func(const vi(vi(ll))& g, const vi(ll)& val, ll it, ll ti, ll rem, ll first) {\\n        ll xo = val[it];\\n        for (const ll& in : g[it]) {\\n            if (in != ti) {\\n                ll third = func(g, val, in, it, rem, first);\\n                xo ^= third;\\n                ll second = rem ^ third;\\n                ans = min(ans, max({ first, second, third }) - min({ first, second, third }));\\n            }\\n        }\\n        return xo;\\n    }\\npublic:\\n    int minimumScore(const vector<ll>& val, const vector<vector<ll>>& e) {\\n        ll n = val.size();\\n        vi(vi(ll))g(n);\\n        for (const vi(ll)& it : e) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        xos.resize(n);\\n        doxo(val, g);\\n        vi(bool)vis(n);\\n        queue<ll>q;\\n        q.push(0);\\n        vis[0] = true;\\n        while (!q.empty()) {\\n            ll it = q.front();\\n            q.pop();\\n            for (const ll& ti : g[it]) {\\n                if (!vis[ti]) {\\n                    vis[ti] = true;\\n                    q.push(ti);\\n                    func(g, val, it, ti, xos[0] ^ xos[ti], xos[ti]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Same code, my version, not working!\\n\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9;\\nvi(bool) primes;\\n\\nclass Solution {\\n    ll ans = INT_MAX;\\n    vi(ll)xos;\\n    ll doxo(const vi(ll)& val, const vi(vi(ll))& g, ll in = 0, ll par = -1) {\\n        xos[in] = val[in];\\n        for (const ll& it : g[in])\\n            if (it != par)\\n                xos[in] ^= doxo(val, g, it, in);\\n        return xos[in];\\n    }\\n    ll func(const vi(vi(ll))& g, const vi(ll)& val, ll it, ll ti, ll rem, ll first) {\\n        ll xo = val[it];\\n        for (const ll& in : g[it]) {\\n            if (in != ti) {\\n                ll third = func(g, val, in, it, rem, first);\\n                xo ^= third;\\n                ll second = rem ^ third;\\n                ans = min(ans, max({ first, second, third }) - min({ first, second, third }));\\n            }\\n        }\\n        return xo;\\n    }\\npublic:\\n    int minimumScore(const vector<ll>& val, const vector<vector<ll>>& e) {\\n        ll n = val.size();\\n        vi(vi(ll))g(n);\\n        for (const vi(ll)& it : e) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        xos.resize(n);\\n        doxo(val, g);\\n        vi(bool)vis(n);\\n        queue<ll>q;\\n        q.push(0);\\n        vis[0] = true;\\n        while (!q.empty()) {\\n            ll it = q.front();\\n            q.pop();\\n            for (const ll& ti : g[it]) {\\n                if (!vis[ti]) {\\n                    vis[ti] = true;\\n                    q.push(ti);\\n                    func(g, val, it, ti, xos[0] ^ xos[ti], xos[ti]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208256,
                "title": "swift-dfs",
                "content": "```\\n// https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/\\nclass Solution {\\n    private typealias Edge = (from: Int,to:Int)\\n    func minimumScore(_ nums: [Int], _ edges: [[Int]]) -> Int {\\n\\n        let N = nums.count\\n        ///\\u5EFA\\u6811\\n        var tree = [[Int]](repeating: [], count: N)\\n        for e in edges {\\n            tree[e[0]].append(e[1])\\n            tree[e[1]].append(e[0])\\n        }\\n\\n\\n        ///\\u4EE50\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u7ED3\\u5408\\u5C42\\u7EA7\\u4FE1\\u606F\\uFF0C\\u53EF\\u4EE5\\u5F97\\u5230\\u6709\\u5411\\u6811\\n        let root = 0\\n        ///\\u4FDD\\u5B58\\u5404\\u4E2A\\u8282\\u70B9\\u7684\\u76F8\\u5173\\u6570\\u636E\\uFF1A\\u5F02\\u6216\\u503C\\uFF0C\\u5F53\\u524D\\u5B50\\u6811\\u7684\\u6240\\u6709\\u8282\\u70B9\\u96C6\\u5408\\uFF0C\\u4EE5\\u53CA\\u5404\\u4E2A\\u8282\\u70B9\\u7684\\u5C42\\u7EA7\\n        var xorSum = [Int](repeating: 0, count:N )\\n        var subTrees = [Set<Int>](repeating: [], count: N)\\n        var level = [Int](repeating: -1, count: N)\\n        func dfs(_ parent: Int,_ node: Int, _ curLel:Int) {\\n\\n            xorSum[node] = nums[node]\\n            subTrees[node].insert(node)\\n            level[node] = curLel\\n            for next in tree[node] {\\n                guard next != parent else {\\n                    continue\\n                }\\n                dfs(node, next, curLel + 1)\\n                xorSum[node] ^= xorSum[next]\\n                subTrees[node] = subTrees[node].union(subTrees[next])\\n            }\\n        }\\n        dfs(-1, root,0)\\n\\n        ///\\u8F6C\\u5316\\u4E3A\\u6709\\u5411\\u8FB9\\u5E76\\u6392\\u5E8F\\uFF1A\\u4F9D\\u636E\\u5C42\\u7EA7\\u4FE1\\u606F\\n        let sortedDirectedEdges:[Edge] = edges.map({ e in\\n            if level[e[0]] < level[e[1]] {\\n                return (e[0],e[1])\\n            } else {\\n                return (e[1],e[0])\\n            }\\n        }).sorted { e1, e2 in\\n            level[e1.from] < level[e2.from]\\n        }\\n\\n        ///\\u679A\\u4E3E\\u5220\\u9664\\u7684\\u4E24\\u6761\\u8FB9\\n        var ans = Int.max\\n        let M = edges.count\\n        for i in 0..<M {\\n            var j = i + 1\\n            while j < M {\\n\\n                let fe = sortedDirectedEdges[i]\\n                let se = sortedDirectedEdges[j]\\n                let nodes = [fe.from,fe.to,se.from,se.to]\\n                var (f,s,t) = (0,0,0)\\n                ///\\u5206\\u60C5\\u51B5\\u8BA8\\u8BBA\\n                if subTrees[nodes[1]].contains(nodes[2]) {\\n                    (f,s,t) = (xorSum[root] ^ xorSum[nodes[1]],xorSum[nodes[1]] ^ xorSum[nodes[3]],xorSum[nodes[3]])\\n\\n                } else {\\n                    (f,s,t) = (xorSum[root] ^ xorSum[nodes[1]] ^ xorSum[nodes[3]],xorSum[nodes[1]],xorSum[nodes[3]])\\n                }\\n                ans = min(ans, max(f,s,t) - min(f,s,t))\\n                j += 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\n// https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/\\nclass Solution {\\n    private typealias Edge = (from: Int,to:Int)\\n    func minimumScore(_ nums: [Int], _ edges: [[Int]]) -> Int {\\n\\n        let N = nums.count\\n        ///\\u5EFA\\u6811\\n        var tree = [[Int]](repeating: [], count: N)\\n        for e in edges {\\n            tree[e[0]].append(e[1])\\n            tree[e[1]].append(e[0])\\n        }\\n\\n\\n        ///\\u4EE50\\u4E3A\\u6839\\u8282\\u70B9\\uFF0C\\u7ED3\\u5408\\u5C42\\u7EA7\\u4FE1\\u606F\\uFF0C\\u53EF\\u4EE5\\u5F97\\u5230\\u6709\\u5411\\u6811\\n        let root = 0\\n        ///\\u4FDD\\u5B58\\u5404\\u4E2A\\u8282\\u70B9\\u7684\\u76F8\\u5173\\u6570\\u636E\\uFF1A\\u5F02\\u6216\\u503C\\uFF0C\\u5F53\\u524D\\u5B50\\u6811\\u7684\\u6240\\u6709\\u8282\\u70B9\\u96C6\\u5408\\uFF0C\\u4EE5\\u53CA\\u5404\\u4E2A\\u8282\\u70B9\\u7684\\u5C42\\u7EA7\\n        var xorSum = [Int](repeating: 0, count:N )\\n        var subTrees = [Set<Int>](repeating: [], count: N)\\n        var level = [Int](repeating: -1, count: N)\\n        func dfs(_ parent: Int,_ node: Int, _ curLel:Int) {\\n\\n            xorSum[node] = nums[node]\\n            subTrees[node].insert(node)\\n            level[node] = curLel\\n            for next in tree[node] {\\n                guard next != parent else {\\n                    continue\\n                }\\n                dfs(node, next, curLel + 1)\\n                xorSum[node] ^= xorSum[next]\\n                subTrees[node] = subTrees[node].union(subTrees[next])\\n            }\\n        }\\n        dfs(-1, root,0)\\n\\n        ///\\u8F6C\\u5316\\u4E3A\\u6709\\u5411\\u8FB9\\u5E76\\u6392\\u5E8F\\uFF1A\\u4F9D\\u636E\\u5C42\\u7EA7\\u4FE1\\u606F\\n        let sortedDirectedEdges:[Edge] = edges.map({ e in\\n            if level[e[0]] < level[e[1]] {\\n                return (e[0],e[1])\\n            } else {\\n                return (e[1],e[0])\\n            }\\n        }).sorted { e1, e2 in\\n            level[e1.from] < level[e2.from]\\n        }\\n\\n        ///\\u679A\\u4E3E\\u5220\\u9664\\u7684\\u4E24\\u6761\\u8FB9\\n        var ans = Int.max\\n        let M = edges.count\\n        for i in 0..<M {\\n            var j = i + 1\\n            while j < M {\\n\\n                let fe = sortedDirectedEdges[i]\\n                let se = sortedDirectedEdges[j]\\n                let nodes = [fe.from,fe.to,se.from,se.to]\\n                var (f,s,t) = (0,0,0)\\n                ///\\u5206\\u60C5\\u51B5\\u8BA8\\u8BBA\\n                if subTrees[nodes[1]].contains(nodes[2]) {\\n                    (f,s,t) = (xorSum[root] ^ xorSum[nodes[1]],xorSum[nodes[1]] ^ xorSum[nodes[3]],xorSum[nodes[3]])\\n\\n                } else {\\n                    (f,s,t) = (xorSum[root] ^ xorSum[nodes[1]] ^ xorSum[nodes[3]],xorSum[nodes[1]],xorSum[nodes[3]])\\n                }\\n                ans = min(ans, max(f,s,t) - min(f,s,t))\\n                j += 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207262,
                "title": "nested-dfs-java-comments",
                "content": "**Ideas**\\n- XOR all the node\\'s values, then we only have to care about 2 components because the 3rd one can be found via `all_xor^a_xor^b_xor`.\\n\\n- Saw that `O(n^2)` solution is acceptable because `n<=1000`, this gives me an idea of trying to remove all the pairs of edges.\\n\\n- I then think, we can build a tree graph, we probably don\\'t want to actually remove the edge, but we can ban a node.\\n\\n- How to ban a node? Hm.. we can just pass it to the inner `dfs2()`  function and return 0 whenever it is the ban node.\\n\\n- Now, we can write the first `dfs()` function, then do a post-order traversal, before we return the `xor` value, we call `dfs2()`.\\n\\n- It should work - with `dfs()` chooses a ban node, then `dfs2()` explores the rest of the tree.\\n- But there is an edge case, we can\\'t ban the root node, but what\\'s the root node? I chose it to be 0 (shouldn\\'t matter)\\n\\n- I used a global variable `ans` so it is easier to implement.\\n\\n*Note: I was timing myself doing this contest. (took me 60 minutes to do all 4 Qs with 1 WA). So codes may be a bit messy. I think Q2 and Q4 are the hardest.*\\n\\n```Java\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int xor = 0;\\n        Node[] nodes = new Node[nums.length];\\n        Arrays.setAll(nodes, o -> new Node(nums[o]));\\n        for (int[] e : edges){\\n            nodes[e[0]].children.add(e[1]);\\n            nodes[e[1]].children.add(e[0]);\\n        }\\n        for (int n : nums){ // xor all the values \\n            xor ^= n;\\n        }\\n        dfs(0, -1, xor, nodes);\\n        return ans;\\n    }\\n\\n    private int dfs(int cur, int parent, int xor, Node[] nodes){\\n        int val = nodes[cur].val;  // val -> current xor value for this component\\n        for (int next : nodes[cur].children){\\n            if (parent != next){\\n                val ^= dfs(next, cur, xor, nodes);\\n            }\\n        }\\n        if (cur != 0){ // ban node chosen, do dfs again for the other component.\\n            dfs2(0, -1, cur, xor, val, nodes);\\n        }\\n        return val;\\n    }\\n\\n    private int dfs2(int cur, int parent, int ban, int xor, int axor, Node[] nodes){\\n        if (cur==ban)\\n            return 0;\\n        int val = nodes[cur].val; // val -> current xor value for this component\\n        for (int next : nodes[cur].children){\\n            if (parent != next){\\n                val ^= dfs2(next, cur, ban, xor, axor, nodes);\\n            }\\n        }\\n        if (cur != 0){ // if it is not a root node, we have a valid 3 components. Update ans.\\n            int bxor = xor^val^axor;\\n            ans = Math.min(ans, Math.max(val, Math.max(bxor, axor)) - Math.min(val, Math.min(bxor, axor)));\\n        }\\n        return val;\\n    }\\n\\n    private class Node {\\n        int val;\\n        List<Integer> children = new ArrayList<>();\\n        Node (int val){\\n            this.val = val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int xor = 0;\\n        Node[] nodes = new Node[nums.length];\\n        Arrays.setAll(nodes, o -> new Node(nums[o]));\\n        for (int[] e : edges){\\n            nodes[e[0]].children.add(e[1]);\\n            nodes[e[1]].children.add(e[0]);\\n        }\\n        for (int n : nums){ // xor all the values \\n            xor ^= n;\\n        }\\n        dfs(0, -1, xor, nodes);\\n        return ans;\\n    }\\n\\n    private int dfs(int cur, int parent, int xor, Node[] nodes){\\n        int val = nodes[cur].val;  // val -> current xor value for this component\\n        for (int next : nodes[cur].children){\\n            if (parent != next){\\n                val ^= dfs(next, cur, xor, nodes);\\n            }\\n        }\\n        if (cur != 0){ // ban node chosen, do dfs again for the other component.\\n            dfs2(0, -1, cur, xor, val, nodes);\\n        }\\n        return val;\\n    }\\n\\n    private int dfs2(int cur, int parent, int ban, int xor, int axor, Node[] nodes){\\n        if (cur==ban)\\n            return 0;\\n        int val = nodes[cur].val; // val -> current xor value for this component\\n        for (int next : nodes[cur].children){\\n            if (parent != next){\\n                val ^= dfs2(next, cur, ban, xor, axor, nodes);\\n            }\\n        }\\n        if (cur != 0){ // if it is not a root node, we have a valid 3 components. Update ans.\\n            int bxor = xor^val^axor;\\n            ans = Math.min(ans, Math.max(val, Math.max(bxor, axor)) - Math.min(val, Math.min(bxor, axor)));\\n        }\\n        return val;\\n    }\\n\\n    private class Node {\\n        int val;\\n        List<Integer> children = new ArrayList<>();\\n        Node (int val){\\n            this.val = val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207222,
                "title": "dfs-lca",
                "content": "Multiple calls to LCA can be solved using binary lifting. When removing edges, we have two cases. `Edge2 removed is part of the subtree which got cut in removing edge1` or `it isn\\'t`. First testcase provided in the problem lies in the first case when we root the tree at `0`. In this case, we must xor the value from the subtree cut off initially. Otherwise, we can follow the standard procedure. We only need to check if root1 is lca of root2 or vice versa. If they are, then case1, else case2\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n, l  = len(nums), math.ceil(math.log(len(nums), 2))\\n        subtreeSum = [x for x in nums]\\n        levels = [0] * n # defines depth rather than \"level\"\\n        graph = defaultdict(list)\\n        up = [[0] * (l+1) for _ in range(n)]\\n        \\n        for x, y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        def dfs(x, par, level):\\n            up[x][0] = par\\n            for y in graph[x]:\\n                if y != par:\\n                    subtreeSum[x] ^= dfs(y, x, level + 1)\\n            levels[x] = level\\n            return subtreeSum[x]\\n        \\n        def lca(u, v):\\n            if levels[u] < levels[v]:\\n                u, v = v, u\\n            diff = levels[u] - levels[v]\\n            for i in range(l+1):\\n                if(diff&(1<<i)):\\n                    u = up[u][i]\\n            return u == v # we only need to check if u is lca of v. Don\\'t need to find their lca\\n        \\n        dfs(0, -1, 0)\\n        for i in range(1, l+1):\\n            for x in range(1, n):\\n                up[x][i] = up[up[x][i-1]][i-1]\\n                \\n        for edge in edges:\\n            if levels[edge[0]] < levels[edge[1]]: # easy to identify which node gets separated\\n                edge[0], edge[1] = edge[1], edge[0]\\n        \\n        ans = float(\"inf\")\\n        for i in range(n-2):\\n            edge1 = edges[i]\\n            for j in range(i+1, n-1):\\n                rem1 = edge1[0]\\n                edge2 = edges[j]\\n                rem2 = edge2[0]\\n                if levels[rem1] > levels[rem2]: # deeper node needs to go up to find the lca\\n                    rem1, rem2 = rem2, rem1\\n                if lca(rem1, rem2):\\n                    val1 = subtreeSum[rem2]\\n                    val2 = subtreeSum[rem1] ^ subtreeSum[rem2]\\n                    val3 = subtreeSum[0] ^ subtreeSum[rem1]\\n                else:\\n                    val1 = subtreeSum[rem1]\\n                    val2 = subtreeSum[rem2]\\n                    val3 = subtreeSum[0] ^ val1 ^ val2\\n                ans = min(ans, max(val1, val2, val3) - min(val1, val2, val3))\\n        return ans\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n, l  = len(nums), math.ceil(math.log(len(nums), 2))\\n        subtreeSum = [x for x in nums]\\n        levels = [0] * n # defines depth rather than \"level\"\\n        graph = defaultdict(list)\\n        up = [[0] * (l+1) for _ in range(n)]\\n        \\n        for x, y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        def dfs(x, par, level):\\n            up[x][0] = par\\n            for y in graph[x]:\\n                if y != par:\\n                    subtreeSum[x] ^= dfs(y, x, level + 1)\\n            levels[x] = level\\n            return subtreeSum[x]\\n        \\n        def lca(u, v):\\n            if levels[u] < levels[v]:\\n                u, v = v, u\\n            diff = levels[u] - levels[v]\\n            for i in range(l+1):\\n                if(diff&(1<<i)):\\n                    u = up[u][i]\\n            return u == v # we only need to check if u is lca of v. Don\\'t need to find their lca\\n        \\n        dfs(0, -1, 0)\\n        for i in range(1, l+1):\\n            for x in range(1, n):\\n                up[x][i] = up[up[x][i-1]][i-1]\\n                \\n        for edge in edges:\\n            if levels[edge[0]] < levels[edge[1]]: # easy to identify which node gets separated\\n                edge[0], edge[1] = edge[1], edge[0]\\n        \\n        ans = float(\"inf\")\\n        for i in range(n-2):\\n            edge1 = edges[i]\\n            for j in range(i+1, n-1):\\n                rem1 = edge1[0]\\n                edge2 = edges[j]\\n                rem2 = edge2[0]\\n                if levels[rem1] > levels[rem2]: # deeper node needs to go up to find the lca\\n                    rem1, rem2 = rem2, rem1\\n                if lca(rem1, rem2):\\n                    val1 = subtreeSum[rem2]\\n                    val2 = subtreeSum[rem1] ^ subtreeSum[rem2]\\n                    val3 = subtreeSum[0] ^ subtreeSum[rem1]\\n                else:\\n                    val1 = subtreeSum[rem1]\\n                    val2 = subtreeSum[rem2]\\n                    val3 = subtreeSum[0] ^ val1 ^ val2\\n                ans = min(ans, max(val1, val2, val3) - min(val1, val2, val3))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207205,
                "title": "python-go-fast-1dfs-w-rlca-and-3xor-o-n",
                "content": "*reverse Lowest Common Ancestor = Highest Common Descendant*\\n\\n*Python* solution w/ recursive DFS in 2360ms beat 98% :)\\n\\n```python\\ndef minimumScore(self, nums, edges):\\n    def dfs(u, p, i):\\n        j, xor[i] = i, nums[u]\\n        for v in adj[u]:\\n            if v != p:\\n                j, xor[i] = dfs(v, u, j + 1), xor[i] ^ xor[j + 1]\\n        hcd[i] = j\\n        return j\\n\\n    res, n = math.inf, len(nums)\\n    hcd, xor, adj = [0] * n, [0] * n, [[] for _ in range(n)]\\n    for u, v in edges:\\n        adj[u].append(v)\\n        adj[v].append(u)\\n    dfs(0, -1, 0)\\n    for i in range(1, n):\\n        for j in range(i + 1, n):\\n            anc = [xor[0] ^ xor[i] ^ xor[j], xor[i]] if hcd[i] < j else [xor[0] ^ xor[i], xor[i] ^ xor[j]]\\n            res = min(res, max(*anc, xor[j]) - min(*anc, xor[j]))\\n    return res\\n```\\n\\n*Python* solution w/ iterative DFS\\n\\n```python\\ndef minimumScore(self, nums, edges):\\n    class node:\\n        def __init__(self, key, hcd, xor):\\n            self.key, self.hcd, self.xor = key, hcd, xor\\n\\n    n = len(nums)\\n    adj = [[] for _ in range(n)]\\n    for u, v in edges:\\n        adj[u].append(v)\\n        adj[v].append(u)\\n\\n    A, N = [0, 0], [node(0, 0, nums[0])]\\n    while True:\\n        u = N[A[-1]].key\\n        if adj[u]:\\n            v = adj[u].pop()\\n            if v != N[A[-2]].key:\\n                k=len(N)\\n                A.append(k)\\n                N.append(node(v, k, nums[v]))\\n        elif len(A) > 2:\\n            i, j = A[-2], A.pop()\\n            N[i].hcd = k\\n            N[i].xor ^= N[j].xor\\n        else: break\\n\\n    res, k = math.inf, 0\\n    for i, j in itertools.combinations(range(1, n), 2):\\n        anc = [N[0].xor ^ N[i].xor ^ N[j].xor, N[i].xor] if N[i].hcd < j else [N[0].xor ^ N[i].xor, N[i].xor ^ N[j].xor]\\n        res = min(res, max(*anc, N[j].xor) - min(*anc, N[j].xor))\\n    return res\\n```\\n\\n*Go* solution w/ recursive DFS in 26ms :)\\n\\n```go\\ntype graph struct {\\n\\tj        int\\n\\thcd, xor [1000]int\\n\\tnums     []int\\n\\tadj      [][]int\\n}\\n\\nfunc (G *graph) dfs(u, p int) {\\n\\ti := G.j\\n\\tG.xor[i] = G.nums[u]\\n\\tfor _, v := range G.adj[u] {\\n\\t\\tif v != p {\\n\\t\\t\\tG.j++\\n\\t\\t\\tj := G.j\\n\\t\\t\\tG.dfs(v, u)\\n\\t\\t\\tG.xor[i] ^= G.xor[j]\\n\\t\\t}\\n\\t}\\n\\tG.hcd[i] = G.j\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tvar (\\n\\t\\tres        = math.MaxInt\\n\\t\\tanc1, anc2 int\\n\\t\\tn          = len(nums)\\n\\t\\tG          = graph{nums: nums, adj: make([][]int, n)}\\n\\t)\\n\\tfor _, edge := range edges {\\n\\t\\tu, v := edge[0], edge[1]\\n\\t\\tG.adj[u] = append(G.adj[u], v)\\n\\t\\tG.adj[v] = append(G.adj[v], u)\\n\\t}\\n\\tG.dfs(0, -1)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tif G.hcd[i] < j {\\n\\t\\t\\t\\tanc1, anc2 = G.xor[0]^G.xor[i]^G.xor[j], G.xor[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tanc1, anc2 = G.xor[0]^G.xor[i], G.xor[i]^G.xor[j]\\n\\t\\t\\t}\\n\\t\\t\\tres = min(res, max(max(anc1, anc2), G.xor[j])-min(min(anc1, anc2), G.xor[j]))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\\n\\n*Go* solution w/ iterative DFS in 15ms beat 100% :)\\n\\n```go\\ntype node struct{ key, hcd, xor int }\\n\\ntype stack []int\\n\\nfunc (s stack) top() int    { return s[len(s)-1] }\\nfunc (s stack) penul() int  { return s[len(s)-2] }\\nfunc (s *stack) push(x int) { *s = append(*s, x) }\\nfunc (s *stack) pop() int {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tn := len(nums)\\n\\tadj := make([]stack, n)\\n\\tfor _, edge := range edges {\\n\\t\\tu, v := edge[0], edge[1]\\n\\t\\tadj[u].push(v)\\n\\t\\tadj[v].push(u)\\n\\t}\\n\\n\\tvar (\\n\\t\\tk int\\n\\t\\tA = make(stack, 2)\\n\\t\\tN = []node{node{0, 0, nums[0]}}\\n\\t)\\n\\tfor {\\n\\t\\tu := N[A.top()].key\\n\\t\\tif len(adj[u]) > 0 {\\n\\t\\t\\tv := adj[u].pop()\\n\\t\\t\\tif v != N[A.penul()].key {\\n\\t\\t\\t\\tk = len(N)\\n\\t\\t\\t\\tA.push(k)\\n\\t\\t\\t\\tN = append(N, node{v, k, nums[v]})\\n\\t\\t\\t}\\n\\t\\t} else if len(A) > 2 {\\n\\t\\t\\ti, j := A.penul(), A.pop()\\n\\t\\t\\tN[i].hcd = k\\n\\t\\t\\tN[i].xor ^= N[j].xor\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tvar (\\n\\t\\tres        = math.MaxInt\\n\\t\\tanc1, anc2 int\\n\\t)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tif N[i].hcd < j {\\n\\t\\t\\t\\tanc1, anc2 = N[0].xor^N[i].xor^N[j].xor, N[i].xor\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tanc1, anc2 = N[0].xor^N[i].xor, N[i].xor^N[j].xor\\n\\t\\t\\t}\\n\\t\\t\\tres = min(res, max(max(anc1, anc2), N[j].xor)-min(min(anc1, anc2), N[j].xor))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumScore(self, nums, edges):\\n    def dfs(u, p, i):\\n        j, xor[i] = i, nums[u]\\n        for v in adj[u]:\\n            if v != p:\\n                j, xor[i] = dfs(v, u, j + 1), xor[i] ^ xor[j + 1]\\n        hcd[i] = j\\n        return j\\n\\n    res, n = math.inf, len(nums)\\n    hcd, xor, adj = [0] * n, [0] * n, [[] for _ in range(n)]\\n    for u, v in edges:\\n        adj[u].append(v)\\n        adj[v].append(u)\\n    dfs(0, -1, 0)\\n    for i in range(1, n):\\n        for j in range(i + 1, n):\\n            anc = [xor[0] ^ xor[i] ^ xor[j], xor[i]] if hcd[i] < j else [xor[0] ^ xor[i], xor[i] ^ xor[j]]\\n            res = min(res, max(*anc, xor[j]) - min(*anc, xor[j]))\\n    return res\\n```\n```python\\ndef minimumScore(self, nums, edges):\\n    class node:\\n        def __init__(self, key, hcd, xor):\\n            self.key, self.hcd, self.xor = key, hcd, xor\\n\\n    n = len(nums)\\n    adj = [[] for _ in range(n)]\\n    for u, v in edges:\\n        adj[u].append(v)\\n        adj[v].append(u)\\n\\n    A, N = [0, 0], [node(0, 0, nums[0])]\\n    while True:\\n        u = N[A[-1]].key\\n        if adj[u]:\\n            v = adj[u].pop()\\n            if v != N[A[-2]].key:\\n                k=len(N)\\n                A.append(k)\\n                N.append(node(v, k, nums[v]))\\n        elif len(A) > 2:\\n            i, j = A[-2], A.pop()\\n            N[i].hcd = k\\n            N[i].xor ^= N[j].xor\\n        else: break\\n\\n    res, k = math.inf, 0\\n    for i, j in itertools.combinations(range(1, n), 2):\\n        anc = [N[0].xor ^ N[i].xor ^ N[j].xor, N[i].xor] if N[i].hcd < j else [N[0].xor ^ N[i].xor, N[i].xor ^ N[j].xor]\\n        res = min(res, max(*anc, N[j].xor) - min(*anc, N[j].xor))\\n    return res\\n```\n```go\\ntype graph struct {\\n\\tj        int\\n\\thcd, xor [1000]int\\n\\tnums     []int\\n\\tadj      [][]int\\n}\\n\\nfunc (G *graph) dfs(u, p int) {\\n\\ti := G.j\\n\\tG.xor[i] = G.nums[u]\\n\\tfor _, v := range G.adj[u] {\\n\\t\\tif v != p {\\n\\t\\t\\tG.j++\\n\\t\\t\\tj := G.j\\n\\t\\t\\tG.dfs(v, u)\\n\\t\\t\\tG.xor[i] ^= G.xor[j]\\n\\t\\t}\\n\\t}\\n\\tG.hcd[i] = G.j\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tvar (\\n\\t\\tres        = math.MaxInt\\n\\t\\tanc1, anc2 int\\n\\t\\tn          = len(nums)\\n\\t\\tG          = graph{nums: nums, adj: make([][]int, n)}\\n\\t)\\n\\tfor _, edge := range edges {\\n\\t\\tu, v := edge[0], edge[1]\\n\\t\\tG.adj[u] = append(G.adj[u], v)\\n\\t\\tG.adj[v] = append(G.adj[v], u)\\n\\t}\\n\\tG.dfs(0, -1)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tif G.hcd[i] < j {\\n\\t\\t\\t\\tanc1, anc2 = G.xor[0]^G.xor[i]^G.xor[j], G.xor[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tanc1, anc2 = G.xor[0]^G.xor[i], G.xor[i]^G.xor[j]\\n\\t\\t\\t}\\n\\t\\t\\tres = min(res, max(max(anc1, anc2), G.xor[j])-min(min(anc1, anc2), G.xor[j]))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\n```go\\ntype node struct{ key, hcd, xor int }\\n\\ntype stack []int\\n\\nfunc (s stack) top() int    { return s[len(s)-1] }\\nfunc (s stack) penul() int  { return s[len(s)-2] }\\nfunc (s *stack) push(x int) { *s = append(*s, x) }\\nfunc (s *stack) pop() int {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tn := len(nums)\\n\\tadj := make([]stack, n)\\n\\tfor _, edge := range edges {\\n\\t\\tu, v := edge[0], edge[1]\\n\\t\\tadj[u].push(v)\\n\\t\\tadj[v].push(u)\\n\\t}\\n\\n\\tvar (\\n\\t\\tk int\\n\\t\\tA = make(stack, 2)\\n\\t\\tN = []node{node{0, 0, nums[0]}}\\n\\t)\\n\\tfor {\\n\\t\\tu := N[A.top()].key\\n\\t\\tif len(adj[u]) > 0 {\\n\\t\\t\\tv := adj[u].pop()\\n\\t\\t\\tif v != N[A.penul()].key {\\n\\t\\t\\t\\tk = len(N)\\n\\t\\t\\t\\tA.push(k)\\n\\t\\t\\t\\tN = append(N, node{v, k, nums[v]})\\n\\t\\t\\t}\\n\\t\\t} else if len(A) > 2 {\\n\\t\\t\\ti, j := A.penul(), A.pop()\\n\\t\\t\\tN[i].hcd = k\\n\\t\\t\\tN[i].xor ^= N[j].xor\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tvar (\\n\\t\\tres        = math.MaxInt\\n\\t\\tanc1, anc2 int\\n\\t)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tif N[i].hcd < j {\\n\\t\\t\\t\\tanc1, anc2 = N[0].xor^N[i].xor^N[j].xor, N[i].xor\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tanc1, anc2 = N[0].xor^N[i].xor, N[i].xor^N[j].xor\\n\\t\\t\\t}\\n\\t\\t\\tres = min(res, max(max(anc1, anc2), N[j].xor)-min(min(anc1, anc2), N[j].xor))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206696,
                "title": "c-dfs-isancestor",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<int> sub_xor;\\n\\tvector<vector<int>> g;\\n\\n\\tvector<int> a;\\n\\tint t = 0;\\n\\tvector<int> t_in;\\n\\tvector<int> t_out;\\n\\tvector<int> parent;\\n\\n\\n\\tbool isAncestor(int u, int v) {\\n\\t\\tbool res = t_in[u] < t_in[v] && t_out[u] >= t_out[v];\\n        return res;\\n\\t}\\n\\n\\tint XOR(int u, int par) {\\n\\t\\tsub_xor[u] = a[u];\\n\\t\\tt_in[u] = ++t;\\n\\t\\tfor (int v : g[u]) {\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\tif (v != par) sub_xor[u] ^= XOR(v, u);\\n\\t\\t}\\n\\t\\tt_out[u] = t;\\n\\t\\treturn sub_xor[u];\\n\\t}\\n\\n\\tint minimumScore(vector<int>& a, vector<vector<int>>& edges) {\\n\\t\\tint n = a.size();\\n\\t\\tsub_xor.resize(n, 0);\\n\\t\\tt_in.resize(n, 0);\\n\\t\\tt_out.resize(n, 0);\\n\\t\\tparent.resize(n, -1);\\n\\n\\t\\tthis->a = a;\\n\\t\\tg.resize(n);\\n\\n\\t\\tint T = 0;\\n\\t\\tfor (int x : a) T ^= x;\\n\\n\\t\\tfor (auto e : edges) {\\n\\t\\t\\tg[e[0]].push_back(e[1]);\\n\\t\\t\\tg[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\n\\t\\tXOR(0, -1);\\n\\t\\tint ans = INT_MAX;\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < n; j++) {\\n                // if(i == j) continue;\\n\\t\\t\\t\\tif (isAncestor(i, j)) {\\n\\t\\t\\t\\t\\tint u = i, v = j;\\n\\t\\t\\t\\t\\tint u_xor = sub_xor[u];\\n\\t\\t\\t\\t\\tint v_xor = sub_xor[v];\\n\\t\\t\\t\\t\\tu_xor ^= v_xor;\\n\\t\\t\\t\\t\\tint t = T ^ u_xor ^ v_xor;\\n\\t\\t\\t\\t\\tans = min(ans, max(u_xor, max(v_xor, t)) - min(u_xor, min(v_xor, t)));\\n\\n\\t\\t\\t\\t} else if (isAncestor(j, i)) {\\n\\t\\t\\t\\t\\tint u = j, v = i;\\n\\n\\t\\t\\t\\t\\tint u_xor = sub_xor[u];\\n\\t\\t\\t\\t\\tint v_xor = sub_xor[v];\\n\\t\\t\\t\\t\\tu_xor ^= v_xor;\\n\\t\\t\\t\\t\\tint t = T ^ u_xor ^ v_xor;\\n\\t\\t\\t\\t\\tans = min(ans, max(u_xor, max(v_xor, t)) - min(u_xor, min(v_xor, t)));\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tint u = i, v = j;\\n\\t\\t\\t\\t\\tint u_xor = sub_xor[u];\\n\\t\\t\\t\\t\\tint v_xor = sub_xor[v];\\n\\t\\t\\t\\t\\tint t = T ^ u_xor ^ v_xor;\\n\\t\\t\\t\\t\\tans = min(ans, max(u_xor, max(v_xor, t)) - min(u_xor, min(v_xor, t)));\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> sub_xor;\\n\\tvector<vector<int>> g;\\n\\n\\tvector<int> a;\\n\\tint t = 0;\\n\\tvector<int> t_in;\\n\\tvector<int> t_out;\\n\\tvector<int> parent;\\n\\n\\n\\tbool isAncestor(int u, int v) {\\n\\t\\tbool res = t_in[u] < t_in[v] && t_out[u] >= t_out[v];\\n        return res;\\n\\t}\\n\\n\\tint XOR(int u, int par) {\\n\\t\\tsub_xor[u] = a[u];\\n\\t\\tt_in[u] = ++t;\\n\\t\\tfor (int v : g[u]) {\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\tif (v != par) sub_xor[u] ^= XOR(v, u);\\n\\t\\t}\\n\\t\\tt_out[u] = t;\\n\\t\\treturn sub_xor[u];\\n\\t}\\n\\n\\tint minimumScore(vector<int>& a, vector<vector<int>>& edges) {\\n\\t\\tint n = a.size();\\n\\t\\tsub_xor.resize(n, 0);\\n\\t\\tt_in.resize(n, 0);\\n\\t\\tt_out.resize(n, 0);\\n\\t\\tparent.resize(n, -1);\\n\\n\\t\\tthis->a = a;\\n\\t\\tg.resize(n);\\n\\n\\t\\tint T = 0;\\n\\t\\tfor (int x : a) T ^= x;\\n\\n\\t\\tfor (auto e : edges) {\\n\\t\\t\\tg[e[0]].push_back(e[1]);\\n\\t\\t\\tg[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\n\\t\\tXOR(0, -1);\\n\\t\\tint ans = INT_MAX;\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < n; j++) {\\n                // if(i == j) continue;\\n\\t\\t\\t\\tif (isAncestor(i, j)) {\\n\\t\\t\\t\\t\\tint u = i, v = j;\\n\\t\\t\\t\\t\\tint u_xor = sub_xor[u];\\n\\t\\t\\t\\t\\tint v_xor = sub_xor[v];\\n\\t\\t\\t\\t\\tu_xor ^= v_xor;\\n\\t\\t\\t\\t\\tint t = T ^ u_xor ^ v_xor;\\n\\t\\t\\t\\t\\tans = min(ans, max(u_xor, max(v_xor, t)) - min(u_xor, min(v_xor, t)));\\n\\n\\t\\t\\t\\t} else if (isAncestor(j, i)) {\\n\\t\\t\\t\\t\\tint u = j, v = i;\\n\\n\\t\\t\\t\\t\\tint u_xor = sub_xor[u];\\n\\t\\t\\t\\t\\tint v_xor = sub_xor[v];\\n\\t\\t\\t\\t\\tu_xor ^= v_xor;\\n\\t\\t\\t\\t\\tint t = T ^ u_xor ^ v_xor;\\n\\t\\t\\t\\t\\tans = min(ans, max(u_xor, max(v_xor, t)) - min(u_xor, min(v_xor, t)));\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tint u = i, v = j;\\n\\t\\t\\t\\t\\tint u_xor = sub_xor[u];\\n\\t\\t\\t\\t\\tint v_xor = sub_xor[v];\\n\\t\\t\\t\\t\\tint t = T ^ u_xor ^ v_xor;\\n\\t\\t\\t\\t\\tans = min(ans, max(u_xor, max(v_xor, t)) - min(u_xor, min(v_xor, t)));\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205363,
                "title": "c-dfs-xorsubtree-markancestor-o-n-2",
                "content": "```\\nclass Solution {\\n   void markAncestor(int node,int parent,int source,vector<int>adj[],int anc[][1001]){\\n       anc[source][node] = 1;\\n       for(auto &it:adj[node]){\\n           if(it!=parent){\\n               markAncestor(it,node,source,adj,anc);\\n           }\\n       }\\n   }\\n    void dfsPar(int node,int parent,int par[],vector<int>adj[],int anc[][1001]){\\n        par[node] = parent;\\n        markAncestor(node,parent,node,adj,anc);\\n        for(auto&it:adj[node]){\\n            if(par[it]==-1){\\n                dfsPar(it,node,par,adj,anc);\\n            }\\n        }\\n    }\\n    int dfsXor(int node,int parent,int sub[],vector<int>&nums,vector<int>adj[]){\\n        sub[node] = nums[node];\\n        for(auto&it:adj[node]){\\n            if(it!=parent){\\n                sub[node]^=dfsXor(it,node,sub,nums,adj);\\n            }\\n        }\\n        return sub[node];\\n    }\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        int par[n];\\n        int sub[n];//xor of subtree\\n        int anc[1001][1001];\\n        memset(anc,-1,sizeof(anc));\\n        for(int i = 0;i<n;++i){\\n            par[i] = -1;\\n            sub[i] = 0;\\n        }\\n        int root = 0;\\n        vector<int>adj[n];\\n        for(auto&it:edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfsPar(0,0,par,adj,anc);\\n        dfsXor(0,0,sub,nums,adj);\\n\\n        int ans = INT_MAX;\\n        for(int i = 0;i<n-1;++i){\\n            for(int j = i+1;j<n-1;++j){\\n                int x1,x2,x3;\\n                int u1 = edges[i][0];\\n                int v1 = edges[i][1];\\n                int u2 = edges[j][0];\\n                int v2 = edges[j][1];\\n                int ch1,ch2;\\n                if(par[u1]==v1){\\n                    ch1 =u1;\\n                }\\n                else{\\n                    ch1 = v1;\\n                }\\n                if(par[u2]==v2){\\n                    ch2 = u2;\\n                }\\n                else{\\n                    ch2 = v2;\\n                }\\n                if(anc[ch2][ch1]==1){\\n                    //ch1 is child of ch2\\n                     x3 = sub[0]^sub[ch2];\\n                     x2 = sub[ch2]^sub[ch1];\\n                    x1 = sub[ch1];\\n                }\\n                else if (anc[ch1][ch2]==1){\\n                    //ch2 is child of ch1\\n                    x3 = sub[0]^sub[ch1];\\n                    x2 = sub[ch1]^sub[ch2];\\n                    x1 = sub[ch2];\\n                }\\n                else{\\n                    x1 = sub[ch1];\\n                    x2 = sub[ch2];\\n                    x3 = sub[0]^x1^x2;\\n                }\\n                ans = min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhttps://www.youtube.com/watch?v=blKFzGYejF0&ab_channel=codingMohan\\nreference:_-------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   void markAncestor(int node,int parent,int source,vector<int>adj[],int anc[][1001]){\\n       anc[source][node] = 1;\\n       for(auto &it:adj[node]){\\n           if(it!=parent){\\n               markAncestor(it,node,source,adj,anc);\\n           }\\n       }\\n   }\\n    void dfsPar(int node,int parent,int par[],vector<int>adj[],int anc[][1001]){\\n        par[node] = parent;\\n        markAncestor(node,parent,node,adj,anc);\\n        for(auto&it:adj[node]){\\n            if(par[it]==-1){\\n                dfsPar(it,node,par,adj,anc);\\n            }\\n        }\\n    }\\n    int dfsXor(int node,int parent,int sub[],vector<int>&nums,vector<int>adj[]){\\n        sub[node] = nums[node];\\n        for(auto&it:adj[node]){\\n            if(it!=parent){\\n                sub[node]^=dfsXor(it,node,sub,nums,adj);\\n            }\\n        }\\n        return sub[node];\\n    }\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        int par[n];\\n        int sub[n];//xor of subtree\\n        int anc[1001][1001];\\n        memset(anc,-1,sizeof(anc));\\n        for(int i = 0;i<n;++i){\\n            par[i] = -1;\\n            sub[i] = 0;\\n        }\\n        int root = 0;\\n        vector<int>adj[n];\\n        for(auto&it:edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfsPar(0,0,par,adj,anc);\\n        dfsXor(0,0,sub,nums,adj);\\n\\n        int ans = INT_MAX;\\n        for(int i = 0;i<n-1;++i){\\n            for(int j = i+1;j<n-1;++j){\\n                int x1,x2,x3;\\n                int u1 = edges[i][0];\\n                int v1 = edges[i][1];\\n                int u2 = edges[j][0];\\n                int v2 = edges[j][1];\\n                int ch1,ch2;\\n                if(par[u1]==v1){\\n                    ch1 =u1;\\n                }\\n                else{\\n                    ch1 = v1;\\n                }\\n                if(par[u2]==v2){\\n                    ch2 = u2;\\n                }\\n                else{\\n                    ch2 = v2;\\n                }\\n                if(anc[ch2][ch1]==1){\\n                    //ch1 is child of ch2\\n                     x3 = sub[0]^sub[ch2];\\n                     x2 = sub[ch2]^sub[ch1];\\n                    x1 = sub[ch1];\\n                }\\n                else if (anc[ch1][ch2]==1){\\n                    //ch2 is child of ch1\\n                    x3 = sub[0]^sub[ch1];\\n                    x2 = sub[ch1]^sub[ch2];\\n                    x1 = sub[ch2];\\n                }\\n                else{\\n                    x1 = sub[ch1];\\n                    x2 = sub[ch2];\\n                    x3 = sub[0]^x1^x2;\\n                }\\n                ans = min(ans,max({x1,x2,x3})-min({x1,x2,x3}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204744,
                "title": "amazon-oat-12-june-2022",
                "content": ":/\\n\\n\\nnrjeuenehdueiwnsbdjend",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2204520,
                "title": "please-help-why-does-my-code-show-tle",
                "content": "my idea is to store in such a way that the nodes are captured. \\n\\nExample : if we look at example 1 given in the question, I store dp[node1][node2][side], which means that for the edge 3---4, I store the dp[3][4][0] for the xor of all elements on the 3,0,1,2 side and dp[3][4][1] for the xor of all elements on the other side.\\n\\nI made 2 dfs functions below dfsxor for populating the dp, dfs for calculating the answer. I calculate it by saying that if I remove this edge e, I\\'ll be left with 2 components, I dfs them both, checking for each edge. I did this to ensure that I know that on which side I am removing the 2nd edge. Here is my code, please help me which does it show tle, as if the 1st loop is n^2, the next one should be n^2 too\\n\\nclass Solution {\\npublic:\\n    \\n    int dfsxor(vector<int>& nums,int node, vector<vector<int>>& adj, int exclude,vector<bool>& visited){\\n        visited[node] = true;\\n        if(node==exclude) return 0;\\n        if(adj[node].empty()) return nums[node];\\n        \\n        int ansxor=0;\\n        for(auto i : adj[node]){\\n            if(!visited[i]){\\n                ansxor ^= dfsxor(nums,i,adj,exclude,visited);\\n            }   \\n        }\\n        return nums[node]^ansxor;\\n    }\\n    \\n    int ans=INT_MAX;\\n    \\n    void dfs(int node, int exclude, int xorrest, vector<vector<int>>& adj, vector<vector<vector<int>>>& dp,vector<bool>& visited){\\n        visited[node] = true;\\n        for(auto i : adj[node]){\\n            if(!visited[i] and i!=exclude){\\n                int xor1 = dp[i][node][0];\\n                int xor2 = dp[i][node][1];\\n                int xor3=xor2^xorrest;\\n                ans=min(ans,(max({xor1,xorrest,xor3})-min({xor1,xorrest,xor3})));\\n                dfs(i,exclude,xorrest,adj,dp,visited);\\n            }\\n            \\n        }\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(n,vector<int>(2,0)));\\n        vector<bool> visited(n,false);\\n        for(auto e : edges){\\n            visited=vector<bool>(n,false);\\n\\n            int xor0=dfsxor(nums,e[0],adj,e[1],visited);\\n            // gets xor of all elements in the side of e[0];\\n            dp[e[0]][e[1]][0]=xor0;\\n            dp[e[1]][e[0]][1]=xor0;\\n            \\n            visited = vector<bool>(n,false);\\n            int xor1=dfsxor(nums,e[1],adj,e[0],visited);\\n            // gets xor of all elements in the side of e[1];\\n            dp[e[0]][e[1]][1]=xor1;\\n            dp[e[1]][e[0]][0]=xor1;\\n            \\n        }\\n        \\n        \\n        \\n        for(auto e : edges){\\n            // remove in the side of e[0];\\n            visited=vector<bool>(n,false);\\n            dfs(e[0],e[1],dp[e[0]][e[1]][1],adj,dp,visited);\\n            // remove in the side of e[1];\\n            visited=vector<bool>(n,false);\\n            dfs(e[1],e[0],dp[e[0]][e[1]][0],adj,dp,visited);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int dfsxor(vector<int>& nums,int node, vector<vector<int>>& adj, int exclude,vector<bool>& visited){\\n        visited[node] = true;\\n        if(node==exclude) return 0;\\n        if(adj[node].empty()) return nums[node];\\n        \\n        int ansxor=0;\\n        for(auto i : adj[node]){\\n            if(!visited[i]){\\n                ansxor ^= dfsxor(nums,i,adj,exclude,visited);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2204304,
                "title": "c-solution-dfs-and-path-marker-with-time",
                "content": "EXPLANATION : We assume 0 to be the root of the tree. We pre-compute the xor values of all subtrees and store the value in the corresponding parent of that subtree. We have also precomputed the visiting time and leaving time of every node in the tree. This is useful to find if any two nodes are a part of the same subtree or not.\\n\\nThen to choose two edges, we iterate over a nested loop and choose two nodes where we will cut-off the tree. Since we have cut the subtree initiating from it, we have to remove the xor value of the subtree from the root. For Ex -  Let the value of a subtree is p and the rest of the whole tree is q. So the value of xor for the entire tree, i.e. xor value at root(0)  = p^q. So if we cut that subtree from the rest of the tree we can simply xor it\\'s value again with the xor value at root to get the xor value of the remaining tree i.e. p^q^p = q.\\n\\nSo now, if two nodes belong to different subtrees OR simply saying, if one node doesn\\'t fall in the path of the other, then we can simply remove the subtrees by xoring their value from the root. But if it does, then we have to remove the xor value of the larger subtree from the whole tree, and the xor value of the smaller subtree from the larger subtree.\\n\\nTo check if one of the two nodes falls in the path of the other, we can see their invisiting time and outing time. If Node i is visited before Node j and Node i is left after Node j, then i lies in the path of j. There would be a vice versa condition too.\\n\\nBelow is the implementation of the above logic.\\n\\n```\\nclass Solution {\\npublic:\\n    int time=0;\\n    int dfs(map<int, vector<int>> &graph, int vertex, int parent, vector<int> &xors, vector<int> &nums, vector<int> &parents, vector<int>& intime, vector<int>& outtime){\\n        intime[vertex] = time++;\\n        int val = nums[vertex];\\n        parents[vertex] = parent;\\n        for(auto child: graph[vertex]){\\n            if(child != parent){\\n                val = val ^ dfs(graph, child, vertex, xors, nums, parents, intime, outtime);\\n            }\\n        }\\n        xors[vertex] = val;\\n        outtime[vertex] = time++;\\n        return val;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        time = 0;\\n        map<int, vector<int>> graph;\\n        int n = nums.size();\\n        for(int i=0; i<edges.size(); i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> parents(nums.size(), 0);\\n        vector<int> xors(nums.size(), 0);\\n        vector<int> intime(n),outtime(n);\\n        dfs(graph, 0, -1, xors, nums, parents, intime, outtime);\\n        int root = 0;\\n        \\n        int minimum = INT_MAX;\\n        for(int i=1; i < n; i++)\\n        {\\n            for(int j=1; j < n; j++)\\n            {\\n                if(i==j) continue;\\n                else if(intime[i] < intime[j] && outtime[i]>outtime[j])\\n                {\\n                    int x = xors[j];\\n                    int y = xors[i] ^ xors[j];\\n                    int z = xors[root] ^ xors[i];\\n                    int mini = min(x, min(y,z));\\n                    int maxi = max(x, max(y,z));\\n                    minimum = min(minimum, maxi - mini);\\n                }\\n                else if(intime[i] > intime[j] && outtime[i] < outtime[j])\\n                {\\n                    int x = xors[i];\\n                    int y = xors[i] ^ xors[j];\\n                    int z = xors[root] ^ xors[j];\\n                    int mini = min(x, min(y,z));\\n                    int maxi = max(x, max(y,z));\\n                    minimum = min(minimum, maxi - mini);\\n                }\\n                else \\n                {\\n                    int x = xors[i];\\n                    int y = xors[j];\\n                    int z = xors[root] ^ xors[i] ^ xors[j];\\n                    int mini = min(x, min(y,z));\\n                    int maxi = max(x, max(y,z));\\n                    minimum = min(minimum, maxi - mini);\\n                }\\n            }\\n        }\\n        return minimum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int time=0;\\n    int dfs(map<int, vector<int>> &graph, int vertex, int parent, vector<int> &xors, vector<int> &nums, vector<int> &parents, vector<int>& intime, vector<int>& outtime){\\n        intime[vertex] = time++;\\n        int val = nums[vertex];\\n        parents[vertex] = parent;\\n        for(auto child: graph[vertex]){\\n            if(child != parent){\\n                val = val ^ dfs(graph, child, vertex, xors, nums, parents, intime, outtime);\\n            }\\n        }\\n        xors[vertex] = val;\\n        outtime[vertex] = time++;\\n        return val;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        time = 0;\\n        map<int, vector<int>> graph;\\n        int n = nums.size();\\n        for(int i=0; i<edges.size(); i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> parents(nums.size(), 0);\\n        vector<int> xors(nums.size(), 0);\\n        vector<int> intime(n),outtime(n);\\n        dfs(graph, 0, -1, xors, nums, parents, intime, outtime);\\n        int root = 0;\\n        \\n        int minimum = INT_MAX;\\n        for(int i=1; i < n; i++)\\n        {\\n            for(int j=1; j < n; j++)\\n            {\\n                if(i==j) continue;\\n                else if(intime[i] < intime[j] && outtime[i]>outtime[j])\\n                {\\n                    int x = xors[j];\\n                    int y = xors[i] ^ xors[j];\\n                    int z = xors[root] ^ xors[i];\\n                    int mini = min(x, min(y,z));\\n                    int maxi = max(x, max(y,z));\\n                    minimum = min(minimum, maxi - mini);\\n                }\\n                else if(intime[i] > intime[j] && outtime[i] < outtime[j])\\n                {\\n                    int x = xors[i];\\n                    int y = xors[i] ^ xors[j];\\n                    int z = xors[root] ^ xors[j];\\n                    int mini = min(x, min(y,z));\\n                    int maxi = max(x, max(y,z));\\n                    minimum = min(minimum, maxi - mini);\\n                }\\n                else \\n                {\\n                    int x = xors[i];\\n                    int y = xors[j];\\n                    int z = xors[root] ^ xors[i] ^ xors[j];\\n                    int mini = min(x, min(y,z));\\n                    int maxi = max(x, max(y,z));\\n                    minimum = min(minimum, maxi - mini);\\n                }\\n            }\\n        }\\n        return minimum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204044,
                "title": "c-dfs-based-solution-with-comments",
                "content": "```\\nclass Solution {\\n  struct Edge {\\n    int src;\\n    int dst;\\n    Edge(int src, int dst) : src(src), dst(dst) {}\\n  };\\n  \\n  struct Node {\\n    int idx;\\n    int val;\\n    int xorFrom = 0; // XOR of the subtree rooted at this node.\\n    vector<int> edgeIdcs; // All the edges on this node (stored in a separate vector).\\n    Node(int idx, int val) : idx(idx), val(val) {}\\n  };\\n  \\npublic:\\n  // Returns the XOR of the subtree rooted at node at index nodeIdx.\\n  int computeSubtreeXOR(int nodeIdx, int xorSoFar, vector<vector<bool>>& ancestor,\\n                 vector<bool>& visited, vector<Node>& graph, vector<Edge>& edges) {\\n    auto& node = graph[nodeIdx];\\n    visited[nodeIdx] = true;\\n    \\n    // Find all the ancestors of this node (including itself).\\n    for (int n = 0; n < graph.size(); ++n) {\\n      if (visited[n]) ancestor[nodeIdx][n] = true;\\n    }\\n    \\n    // The xor of everything in the path so far (including this node).\\n    int xorNow = xorSoFar ^ node.val;\\n    // Initialize node.xorFrom.\\n    node.xorFrom = node.val;\\n    \\n    for (int edgeIdx : node.edgeIdcs) {\\n      auto& edge = edges[edgeIdx];\\n      // Skip already visited neighbors.\\n      if (edge.src == nodeIdx && visited[edge.dst]) {\\n        continue;\\n      }\\n      if (edge.dst == nodeIdx && visited[edge.src]) {\\n        continue;\\n      }\\n      \\n      // We define src to be the one closer to 0, so swap if needed.\\n      if (edge.dst == nodeIdx) {\\n        swap(edge.src, edge.dst);\\n      }\\n      \\n      int dstXOR = computeSubtreeXOR(edge.dst, xorNow, ancestor,  \\n                                     visited, graph, edges);\\n      node.xorFrom ^= dstXOR;\\n    }\\n    \\n    visited[nodeIdx] = false;\\n    return node.xorFrom;\\n  }\\n  \\n  int minimumScore(vector<int>& nums, vector<vector<int>>& edgeInfo) {\\n    int n = nums.size();\\n    int overallXOR = 0;\\n    vector<Node> graph;\\n    for (int i = 0; i < n; ++i) {\\n      graph.push_back(Node(i, nums[i]));\\n      overallXOR ^= nums[i];\\n    }\\n    \\n    vector<Edge> edges;\\n    for (int i = 0; i < n - 1; ++i) {\\n      Edge e(edgeInfo[i][0], edgeInfo[i][1]);\\n      graph[e.src].edgeIdcs.push_back(edges.size());\\n      graph[e.dst].edgeIdcs.push_back(edges.size());\\n      edges.push_back(e);\\n    }\\n    \\n    vector<bool> visited(n, false);\\n    // ancestor[i][j] means that j is an ancestor of i.\\n    vector<vector<bool>> ancestor(n, vector<bool>(n, false));\\n    // DFS and reach every node using 0 as the root.\\n    computeSubtreeXOR(0, 0, ancestor, visited, graph, edges);\\n\\n    int minDiff = -1;\\n    for (int i = 0; i < n - 1; ++i) {\\n      auto& e1 = edges[i];\\n      for (int j = 0; j < n - 1; ++j) {\\n        auto& e2 = edges[j];\\n        if (i == j) continue;\\n        int x1, x2, x3;\\n        \\n        if (ancestor[e2.src][e1.dst]) { // e2 comes after e1 in the same path.\\n          // x1 is for the part between e1 and e2.\\n          x1 = graph[e1.dst].xorFrom ^ graph[e2.dst].xorFrom;\\n          // x2 is for the part after e2.\\n          x2 = graph[e2.dst].xorFrom;\\n        } else if (ancestor[e1.src][e2.dst]) { // e1 comes after e2 in the same path.\\n          // x1 is for the part after e1.\\n          x1 = graph[e1.dst].xorFrom;\\n          // x2 is for the part between e2 and e1.\\n          x2 = graph[e2.dst].xorFrom ^ graph[e1.dst].xorFrom;\\n        } else { // e1 and e2 are not in the same path.\\n          // x1 is for the path after e1.\\n          x1 = graph[e1.dst].xorFrom;\\n          // x2 is for the path after e2.\\n          x2 = graph[e2.dst].xorFrom;\\n        }\\n        \\n        // Calculate x3 using the overallXOR.\\n        x3 = overallXOR ^ x1 ^ x2;\\n        int largestXOR = max(x1, max(x2, x3));\\n        int smallestXOR = min(x1, min(x2, x3));\\n        \\n        if (minDiff == -1) {\\n          minDiff = largestXOR - smallestXOR;\\n        } else {\\n          minDiff = min(minDiff, largestXOR - smallestXOR);\\n        }\\n      }\\n    }\\n    \\n    return minDiff;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  struct Edge {\\n    int src;\\n    int dst;\\n    Edge(int src, int dst) : src(src), dst(dst) {}\\n  };\\n  \\n  struct Node {\\n    int idx;\\n    int val;\\n    int xorFrom = 0; // XOR of the subtree rooted at this node.\\n    vector<int> edgeIdcs; // All the edges on this node (stored in a separate vector).\\n    Node(int idx, int val) : idx(idx), val(val) {}\\n  };\\n  \\npublic:\\n  // Returns the XOR of the subtree rooted at node at index nodeIdx.\\n  int computeSubtreeXOR(int nodeIdx, int xorSoFar, vector<vector<bool>>& ancestor,\\n                 vector<bool>& visited, vector<Node>& graph, vector<Edge>& edges) {\\n    auto& node = graph[nodeIdx];\\n    visited[nodeIdx] = true;\\n    \\n    // Find all the ancestors of this node (including itself).\\n    for (int n = 0; n < graph.size(); ++n) {\\n      if (visited[n]) ancestor[nodeIdx][n] = true;\\n    }\\n    \\n    // The xor of everything in the path so far (including this node).\\n    int xorNow = xorSoFar ^ node.val;\\n    // Initialize node.xorFrom.\\n    node.xorFrom = node.val;\\n    \\n    for (int edgeIdx : node.edgeIdcs) {\\n      auto& edge = edges[edgeIdx];\\n      // Skip already visited neighbors.\\n      if (edge.src == nodeIdx && visited[edge.dst]) {\\n        continue;\\n      }\\n      if (edge.dst == nodeIdx && visited[edge.src]) {\\n        continue;\\n      }\\n      \\n      // We define src to be the one closer to 0, so swap if needed.\\n      if (edge.dst == nodeIdx) {\\n        swap(edge.src, edge.dst);\\n      }\\n      \\n      int dstXOR = computeSubtreeXOR(edge.dst, xorNow, ancestor,  \\n                                     visited, graph, edges);\\n      node.xorFrom ^= dstXOR;\\n    }\\n    \\n    visited[nodeIdx] = false;\\n    return node.xorFrom;\\n  }\\n  \\n  int minimumScore(vector<int>& nums, vector<vector<int>>& edgeInfo) {\\n    int n = nums.size();\\n    int overallXOR = 0;\\n    vector<Node> graph;\\n    for (int i = 0; i < n; ++i) {\\n      graph.push_back(Node(i, nums[i]));\\n      overallXOR ^= nums[i];\\n    }\\n    \\n    vector<Edge> edges;\\n    for (int i = 0; i < n - 1; ++i) {\\n      Edge e(edgeInfo[i][0], edgeInfo[i][1]);\\n      graph[e.src].edgeIdcs.push_back(edges.size());\\n      graph[e.dst].edgeIdcs.push_back(edges.size());\\n      edges.push_back(e);\\n    }\\n    \\n    vector<bool> visited(n, false);\\n    // ancestor[i][j] means that j is an ancestor of i.\\n    vector<vector<bool>> ancestor(n, vector<bool>(n, false));\\n    // DFS and reach every node using 0 as the root.\\n    computeSubtreeXOR(0, 0, ancestor, visited, graph, edges);\\n\\n    int minDiff = -1;\\n    for (int i = 0; i < n - 1; ++i) {\\n      auto& e1 = edges[i];\\n      for (int j = 0; j < n - 1; ++j) {\\n        auto& e2 = edges[j];\\n        if (i == j) continue;\\n        int x1, x2, x3;\\n        \\n        if (ancestor[e2.src][e1.dst]) { // e2 comes after e1 in the same path.\\n          // x1 is for the part between e1 and e2.\\n          x1 = graph[e1.dst].xorFrom ^ graph[e2.dst].xorFrom;\\n          // x2 is for the part after e2.\\n          x2 = graph[e2.dst].xorFrom;\\n        } else if (ancestor[e1.src][e2.dst]) { // e1 comes after e2 in the same path.\\n          // x1 is for the part after e1.\\n          x1 = graph[e1.dst].xorFrom;\\n          // x2 is for the part between e2 and e1.\\n          x2 = graph[e2.dst].xorFrom ^ graph[e1.dst].xorFrom;\\n        } else { // e1 and e2 are not in the same path.\\n          // x1 is for the path after e1.\\n          x1 = graph[e1.dst].xorFrom;\\n          // x2 is for the path after e2.\\n          x2 = graph[e2.dst].xorFrom;\\n        }\\n        \\n        // Calculate x3 using the overallXOR.\\n        x3 = overallXOR ^ x1 ^ x2;\\n        int largestXOR = max(x1, max(x2, x3));\\n        int smallestXOR = min(x1, min(x2, x3));\\n        \\n        if (minDiff == -1) {\\n          minDiff = largestXOR - smallestXOR;\\n        } else {\\n          minDiff = min(minDiff, largestXOR - smallestXOR);\\n        }\\n      }\\n    }\\n    \\n    return minDiff;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203861,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public int dfs1(int cur, int par, int[] xor, List<List<Integer>> edg, int[] nums, LinkedList<Integer> pars, boolean[][] parent) {\\n        int curXor = nums[cur];\\n        for(int i : pars) {\\n            parent[i][cur] = true;\\n        }\\n        pars.addFirst(cur);\\n        for(int i : edg.get(cur)) {\\n            if(i == par)\\n                continue;\\n            curXor ^= dfs1(i, cur, xor, edg, nums, pars, parent);\\n        }\\n        pars.pollFirst();\\n        xor[cur] = curXor;\\n        return curXor;\\n    }\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int[] xor = new int[nums.length];\\n        List<List<Integer>> edg = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            edg.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.length; i++) {\\n            edg.get(edges[i][0]).add(edges[i][1]);\\n            edg.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        boolean[][] parents = new boolean[nums.length][nums.length];\\n        dfs1(0, -1, xor, edg, nums, new LinkedList<>(), parents);\\n        for(int i=0; i<edges.length; i++) {\\n            for(int j=i+1; j<edges.length; j++) {\\n                int p1 = 0, p2 = edges[i][1], p3 = edges[j][1];\\n                if(parents[edges[i][1]][edges[i][0]]) {\\n                    p2 = edges[i][0];\\n                }\\n                if(parents[edges[j][1]][edges[j][0]]) {\\n                    p3 = edges[j][0];\\n                }\\n                if(p2 == 0 || p3 == 0 || p2 == p3)\\n                    continue;\\n                if(!parents[p2][p3] && !parents[p3][p2]) {\\n                    int x1 = xor[0] ^ xor[p2] ^ xor[p3];\\n                    int x2 = xor[p2];\\n                    int x3 = xor[p3];\\n                    ans = Math.min(ans, Math.max(x1, Math.max(x2, x3)) - Math.min(x1, Math.min(x2, x3)));\\n                } else if(parents[p2][p3]) {\\n                    int x1 = xor[0] ^ xor[p2];\\n                    int x2 = xor[p2] ^ xor[p3];\\n                    int x3 = xor[p3];\\n                    ans = Math.min(ans, Math.max(x1, Math.max(x2, x3)) - Math.min(x1, Math.min(x2, x3))); \\n                } else {\\n                    int x1 = xor[0] ^ xor[p3];\\n                    int x2 = xor[p2];\\n                    int x3 = xor[p3] ^ xor[p2];\\n                    ans = Math.min(ans, Math.max(x1, Math.max(x2, x3)) - Math.min(x1, Math.min(x2, x3)));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int dfs1(int cur, int par, int[] xor, List<List<Integer>> edg, int[] nums, LinkedList<Integer> pars, boolean[][] parent) {\\n        int curXor = nums[cur];\\n        for(int i : pars) {\\n            parent[i][cur] = true;\\n        }\\n        pars.addFirst(cur);\\n        for(int i : edg.get(cur)) {\\n            if(i == par)\\n                continue;\\n            curXor ^= dfs1(i, cur, xor, edg, nums, pars, parent);\\n        }\\n        pars.pollFirst();\\n        xor[cur] = curXor;\\n        return curXor;\\n    }\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int[] xor = new int[nums.length];\\n        List<List<Integer>> edg = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            edg.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.length; i++) {\\n            edg.get(edges[i][0]).add(edges[i][1]);\\n            edg.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        boolean[][] parents = new boolean[nums.length][nums.length];\\n        dfs1(0, -1, xor, edg, nums, new LinkedList<>(), parents);\\n        for(int i=0; i<edges.length; i++) {\\n            for(int j=i+1; j<edges.length; j++) {\\n                int p1 = 0, p2 = edges[i][1], p3 = edges[j][1];\\n                if(parents[edges[i][1]][edges[i][0]]) {\\n                    p2 = edges[i][0];\\n                }\\n                if(parents[edges[j][1]][edges[j][0]]) {\\n                    p3 = edges[j][0];\\n                }\\n                if(p2 == 0 || p3 == 0 || p2 == p3)\\n                    continue;\\n                if(!parents[p2][p3] && !parents[p3][p2]) {\\n                    int x1 = xor[0] ^ xor[p2] ^ xor[p3];\\n                    int x2 = xor[p2];\\n                    int x3 = xor[p3];\\n                    ans = Math.min(ans, Math.max(x1, Math.max(x2, x3)) - Math.min(x1, Math.min(x2, x3)));\\n                } else if(parents[p2][p3]) {\\n                    int x1 = xor[0] ^ xor[p2];\\n                    int x2 = xor[p2] ^ xor[p3];\\n                    int x3 = xor[p3];\\n                    ans = Math.min(ans, Math.max(x1, Math.max(x2, x3)) - Math.min(x1, Math.min(x2, x3))); \\n                } else {\\n                    int x1 = xor[0] ^ xor[p3];\\n                    int x2 = xor[p2];\\n                    int x3 = xor[p3] ^ xor[p2];\\n                    ans = Math.min(ans, Math.max(x1, Math.max(x2, x3)) - Math.min(x1, Math.min(x2, x3)));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203820,
                "title": "c-easy-explaination-dfs",
                "content": "`We have to divide the graph into 3 components . We can start by dividing the graph into 2 components and then try to divide one of the component into 2 parts`\\n\\n**Algorithm**:\\n1. Iterate through each edge and try removing it. We can use set to store edges for easy deletion\\n2. Now in each component , for each node , we will calculate the xor of its subtree. Can be easily done you can check subtreeXores function in the code below.\\n3. Now we can dfs each component and for each node we will try to remove a edge to one of its neighbour, by doing this we will have 2 subcomponent - removed subtree , remaining component\\n```\\n\\txor of removed subtree has already been calculated in point no 2.\\n\\txor of remaining component = xor of entire component ^ xor of removed subtree\\n```\\n4. We will try removing each edge from each node. While doing so record the minimum.\\n\\nHope it helps :) Do upvote\\n```\\nclass Solution {\\npublic:\\n    int score=INT_MAX;\\n    vector<int> values;\\n    vector<bool> visited;\\n    vector<int> xores;\\n    \\n    int subtreeXores(int node,unordered_set<int> adj[]){\\n        visited[node]=true;\\n        int zor = values[node];\\n        for(auto to:adj[node]){\\n            if(!visited[to])  zor ^= subtreeXores(to,adj);\\n        }\\n        return xores[node]=zor;\\n    }\\n    \\n    void divide(int node , unordered_set<int> adj[] , int xor3, int root){\\n        visited[node]=true;\\n        int zor_entire = xores[root];  //xor of entire component\\n            \\n        for(auto to:adj[node]){\\n            if(!visited[to]){\\n                int xor2 = xores[to]; //xor of new component after removal\\n                int xor1 = zor_entire ^ xor2;//remaining component\\n                int maxi = max({xor1,xor2,xor3});\\n                int mini = min({xor1,xor2,xor3});\\n                score = min(score , maxi-mini);\\n                divide(to,adj,xor3,root);\\n            }\\n        }\\n        \\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int N=nums.size();\\n        values=nums;\\n        /***********************************Create adjacency***************************************/\\n        unordered_set<int>  adj[N];\\n        for(auto &edge:edges){\\n            adj[edge[0]].insert(edge[1]); adj[edge[1]].insert(edge[0]);\\n        }\\n        /*****************************************************************************************/\\n        \\n        for(auto &edge:edges){\\n            adj[edge[0]].erase(edge[1]);\\n            adj[edge[1]].erase(edge[0]);\\n        \\n            visited.assign(N,false);\\n            xores.assign(N,0);\\n            \\n            //get subtree xores\\n            subtreeXores(edge[0],adj);\\n            subtreeXores(edge[1],adj);\\n\\t\\t\\t\\n            //try dividing the components\\n            visited.assign(N,false);\\n            divide(edge[0],adj,xores[edge[1]],edge[0]);\\n\\t\\t\\t\\n            visited.assign(N,false);\\n            divide(edge[1],adj,xores[edge[0]],edge[1]);\\n\\t\\t\\t\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\txor of removed subtree has already been calculated in point no 2.\\n\\txor of remaining component = xor of entire component ^ xor of removed subtree\\n```\n```\\nclass Solution {\\npublic:\\n    int score=INT_MAX;\\n    vector<int> values;\\n    vector<bool> visited;\\n    vector<int> xores;\\n    \\n    int subtreeXores(int node,unordered_set<int> adj[]){\\n        visited[node]=true;\\n        int zor = values[node];\\n        for(auto to:adj[node]){\\n            if(!visited[to])  zor ^= subtreeXores(to,adj);\\n        }\\n        return xores[node]=zor;\\n    }\\n    \\n    void divide(int node , unordered_set<int> adj[] , int xor3, int root){\\n        visited[node]=true;\\n        int zor_entire = xores[root];  //xor of entire component\\n            \\n        for(auto to:adj[node]){\\n            if(!visited[to]){\\n                int xor2 = xores[to]; //xor of new component after removal\\n                int xor1 = zor_entire ^ xor2;//remaining component\\n                int maxi = max({xor1,xor2,xor3});\\n                int mini = min({xor1,xor2,xor3});\\n                score = min(score , maxi-mini);\\n                divide(to,adj,xor3,root);\\n            }\\n        }\\n        \\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int N=nums.size();\\n        values=nums;\\n        /***********************************Create adjacency***************************************/\\n        unordered_set<int>  adj[N];\\n        for(auto &edge:edges){\\n            adj[edge[0]].insert(edge[1]); adj[edge[1]].insert(edge[0]);\\n        }\\n        /*****************************************************************************************/\\n        \\n        for(auto &edge:edges){\\n            adj[edge[0]].erase(edge[1]);\\n            adj[edge[1]].erase(edge[0]);\\n        \\n            visited.assign(N,false);\\n            xores.assign(N,0);\\n            \\n            //get subtree xores\\n            subtreeXores(edge[0],adj);\\n            subtreeXores(edge[1],adj);\\n\\t\\t\\t\\n            //try dividing the components\\n            visited.assign(N,false);\\n            divide(edge[0],adj,xores[edge[1]],edge[0]);\\n\\t\\t\\t\\n            visited.assign(N,false);\\n            divide(edge[1],adj,xores[edge[0]],edge[1]);\\n\\t\\t\\t\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203616,
                "title": "using-dfs-and-intime-outtime-at-a-node-to-know-about-ancestor-relations",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> arr;\\n    vector<int> dp;    \\n    vector<int> inTime;\\n    vector<int> outTime;\\n    int timer;\\n    \\n    int dfs1(int v, int p, vector<int>& nums){\\n        int sum=nums[v];\\n        \\n        inTime[v]=timer++;\\n        \\n        for(int u: arr[v]){\\n            if(u!=p){\\n                int childSum=dfs1(u, v, nums);\\n                sum^=childSum;\\n            }\\n        }\\n        \\n        outTime[v]=timer++;\\n\\n        return dp[v]=sum;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        arr.resize(n, vector<int>());\\n        dp.resize(n, 0);\\n        inTime.resize(n,0);\\n        outTime.resize(n,0);\\n        timer=0;\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            int a=edges[i][0], b=edges[i][1];\\n            arr[a].push_back(b);\\n            arr[b].push_back(a);\\n        }\\n        \\n        dfs1(0, -1, nums);\\n        \\n        int totalSum=dp[0];\\n        int ans=INT_MAX;\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                int a=dp[i];\\n                int b=dp[j];\\n                \\n                bool iParofj=inTime[i]<inTime[j] && outTime[i]>outTime[j];\\n                bool jParofi=inTime[j]<inTime[i] && outTime[j]>outTime[i];\\n                \\n                if(iParofj){\\n                    a^=b;\\n                }\\n                \\n                if(jParofi){\\n                    b^=a;\\n                }\\n                \\n                int c=totalSum^a^b;\\n                \\n                int minE=min({a, b, c});\\n                int maxE=max({a, b, c});\\n                \\n                ans=min(ans, maxE-minE);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> arr;\\n    vector<int> dp;    \\n    vector<int> inTime;\\n    vector<int> outTime;\\n    int timer;\\n    \\n    int dfs1(int v, int p, vector<int>& nums){\\n        int sum=nums[v];\\n        \\n        inTime[v]=timer++;\\n        \\n        for(int u: arr[v]){\\n            if(u!=p){\\n                int childSum=dfs1(u, v, nums);\\n                sum^=childSum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2202440,
                "title": "c-rooted-tree-and-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        const int num_nodes = nums.size();\\n        const auto &values = nums;\\n        std::vector<std::vector<int>> neighbors(num_nodes);\\n        for (auto &&edge : edges) {\\n            neighbors[edge[0]].push_back(edge[1]);\\n            neighbors[edge[1]].push_back(edge[0]);            \\n        }\\n        \\n        std::vector<int> parent(num_nodes);\\n        parent[0] = -1; // root\\n        std::queue<int> curr_nodes, next_nodes;\\n        curr_nodes.push(0);\\n        std::vector<std::vector<int>> forward_edges(num_nodes);\\n        while (!curr_nodes.empty()) {            \\n            for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                const int root = curr_nodes.front();\\n                const int visited_from = parent[root];                \\n                for (const int node : neighbors[root]) {\\n                    if (node == visited_from) {\\n                        continue;\\n                    }\\n                    parent[node] = root;\\n                    forward_edges[root].push_back(node);\\n                    next_nodes.push(node);                    \\n                }\\n            }\\n            std::swap(curr_nodes, next_nodes);\\n        }\\n     \\n        std::vector<int> rooted_xor(num_nodes, 0);\\n        fill_rooted_xor_table(0, values, forward_edges, rooted_xor);\\n        return find(0, forward_edges, rooted_xor);\\n    }\\nprivate:\\n    inline int get_diff(int v1, int v2, int v3) const {\\n        return std::max(v1, std::max(v2, v3)) - std::min(v1, std::min(v2, v3));\\n    }\\n    \\n    int find(\\n        const int root, \\n        const std::vector<std::vector<int>> &forward_edges, \\n        const std::vector<int> &rooted_xor) const {\\n        int min_diff = INT_MAX;\\n        \\n        // Skip this node entirely.\\n        for (const int node : forward_edges[root]) {\\n            min_diff = std::min(find(node, forward_edges, rooted_xor), min_diff);\\n        }\\n        \\n        // Cut at this node (only if this is not the original root of the tree, i.e. \"0\").\\n        if (root != 0) {\\n            for (const int node : forward_edges[root]) {\\n                const auto values = get_node_values(node, forward_edges, rooted_xor);\\n                for (const int value : values) {\\n                    min_diff = std::min(\\n                        get_diff(\\n                            rooted_xor[0] ^ rooted_xor[root],\\n                            rooted_xor[root] ^ value,\\n                            value\\n                        ),\\n                        min_diff\\n                    );\\n                }\\n            }\\n        }\\n        \\n        // The root node is least common ancestor of the cuts.\\n        for (const int lhs : forward_edges[root]) {\\n            for (const int rhs : forward_edges[root]) {\\n                if (lhs == rhs) {\\n                    continue;\\n                }\\n                const auto lhs_values = get_node_values(lhs, forward_edges, rooted_xor);\\n                const auto rhs_values = get_node_values(rhs, forward_edges, rooted_xor);\\n                for (const int lhs_val : lhs_values) {\\n                    for (const int rhs_val : rhs_values) {\\n                        min_diff = std::min(\\n                            get_diff(\\n                                rooted_xor[0] ^ lhs_val ^ rhs_val,\\n                                lhs_val,\\n                                rhs_val\\n                            ),\\n                            min_diff\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return min_diff;\\n    }\\n    \\n    std::vector<int> get_node_values(\\n        const int root,\\n        const std::vector<std::vector<int>> &forward_edges,\\n        const std::vector<int> &rooted_xor) const {\\n        std::vector<int> node_values;\\n        std::queue<int> next_nodes;\\n        next_nodes.push(root);\\n        for (; !next_nodes.empty(); next_nodes.pop()) {\\n            const int source = next_nodes.front();\\n            node_values.push_back(rooted_xor[source]);\\n            for (const int node : forward_edges[source]) {\\n                next_nodes.push(node);\\n            }\\n        }\\n        return node_values;\\n    }\\n    \\n    void fill_rooted_xor_table(\\n        const int root, \\n        const std::vector<int> values,\\n        const std::vector<std::vector<int>> &forward_edges,\\n        std::vector<int> &rooted_xor) const {\\n        int val = values[root];\\n        for (const int node : forward_edges[root]) {\\n            fill_rooted_xor_table(node, values, forward_edges, rooted_xor);\\n            val ^= rooted_xor[node];\\n        }\\n        rooted_xor[root] = val;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        const int num_nodes = nums.size();\\n        const auto &values = nums;\\n        std::vector<std::vector<int>> neighbors(num_nodes);\\n        for (auto &&edge : edges) {\\n            neighbors[edge[0]].push_back(edge[1]);\\n            neighbors[edge[1]].push_back(edge[0]);            \\n        }\\n        \\n        std::vector<int> parent(num_nodes);\\n        parent[0] = -1; // root\\n        std::queue<int> curr_nodes, next_nodes;\\n        curr_nodes.push(0);\\n        std::vector<std::vector<int>> forward_edges(num_nodes);\\n        while (!curr_nodes.empty()) {            \\n            for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                const int root = curr_nodes.front();\\n                const int visited_from = parent[root];                \\n                for (const int node : neighbors[root]) {\\n                    if (node == visited_from) {\\n                        continue;\\n                    }\\n                    parent[node] = root;\\n                    forward_edges[root].push_back(node);\\n                    next_nodes.push(node);                    \\n                }\\n            }\\n            std::swap(curr_nodes, next_nodes);\\n        }\\n     \\n        std::vector<int> rooted_xor(num_nodes, 0);\\n        fill_rooted_xor_table(0, values, forward_edges, rooted_xor);\\n        return find(0, forward_edges, rooted_xor);\\n    }\\nprivate:\\n    inline int get_diff(int v1, int v2, int v3) const {\\n        return std::max(v1, std::max(v2, v3)) - std::min(v1, std::min(v2, v3));\\n    }\\n    \\n    int find(\\n        const int root, \\n        const std::vector<std::vector<int>> &forward_edges, \\n        const std::vector<int> &rooted_xor) const {\\n        int min_diff = INT_MAX;\\n        \\n        // Skip this node entirely.\\n        for (const int node : forward_edges[root]) {\\n            min_diff = std::min(find(node, forward_edges, rooted_xor), min_diff);\\n        }\\n        \\n        // Cut at this node (only if this is not the original root of the tree, i.e. \"0\").\\n        if (root != 0) {\\n            for (const int node : forward_edges[root]) {\\n                const auto values = get_node_values(node, forward_edges, rooted_xor);\\n                for (const int value : values) {\\n                    min_diff = std::min(\\n                        get_diff(\\n                            rooted_xor[0] ^ rooted_xor[root],\\n                            rooted_xor[root] ^ value,\\n                            value\\n                        ),\\n                        min_diff\\n                    );\\n                }\\n            }\\n        }\\n        \\n        // The root node is least common ancestor of the cuts.\\n        for (const int lhs : forward_edges[root]) {\\n            for (const int rhs : forward_edges[root]) {\\n                if (lhs == rhs) {\\n                    continue;\\n                }\\n                const auto lhs_values = get_node_values(lhs, forward_edges, rooted_xor);\\n                const auto rhs_values = get_node_values(rhs, forward_edges, rooted_xor);\\n                for (const int lhs_val : lhs_values) {\\n                    for (const int rhs_val : rhs_values) {\\n                        min_diff = std::min(\\n                            get_diff(\\n                                rooted_xor[0] ^ lhs_val ^ rhs_val,\\n                                lhs_val,\\n                                rhs_val\\n                            ),\\n                            min_diff\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return min_diff;\\n    }\\n    \\n    std::vector<int> get_node_values(\\n        const int root,\\n        const std::vector<std::vector<int>> &forward_edges,\\n        const std::vector<int> &rooted_xor) const {\\n        std::vector<int> node_values;\\n        std::queue<int> next_nodes;\\n        next_nodes.push(root);\\n        for (; !next_nodes.empty(); next_nodes.pop()) {\\n            const int source = next_nodes.front();\\n            node_values.push_back(rooted_xor[source]);\\n            for (const int node : forward_edges[source]) {\\n                next_nodes.push(node);\\n            }\\n        }\\n        return node_values;\\n    }\\n    \\n    void fill_rooted_xor_table(\\n        const int root, \\n        const std::vector<int> values,\\n        const std::vector<std::vector<int>> &forward_edges,\\n        std::vector<int> &rooted_xor) const {\\n        int val = values[root];\\n        for (const int node : forward_edges[root]) {\\n            fill_rooted_xor_table(node, values, forward_edges, rooted_xor);\\n            val ^= rooted_xor[node];\\n        }\\n        rooted_xor[root] = val;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202388,
                "title": "go-dfs-with-brief-explanation",
                "content": "There\\'s no Go solution yet so I\\'ll post mine here.\\n\\nThere can be up to 1000 edges.\\nConsidering all pairs of edges is feasible if the XOR of each\\nnew tree can be calculated in O(1) or O(logN).\\n\\nPersonally, I found it easier to consider nodes rather than edges.\\nCutting a node\\'s edge means chopping of its connecting parent edge,\\nwhich creates a new subtree rooted at the node.\\n\\nConsider chopping of a single subtree from the root.\\nThe XOR of the tree after losing its subtree is `xor[root] ^ xor[subtree]`.\\n\\nConsider chopping a second subtree.\\nIf the subtree is independent from the first, then the XOR of the tree becomes\\n`xor[root] ^ xor[subtree1] ^ xor[subtree2]`.\\n\\nThe tricky part is when a subtree is part of another subtree.\\nThen the root becomes `xor[root] ^ xor[subRoot]`,\\nand the subroot XOR becomes `xor[subRoot] ^ xor[subChild]`.\\n\\nThis leads us to the solution:\\n1. Calculate XOR of each subtree rooted in each node\\n2. Visit each node, consider it a \"subroot\", i.e. the root of a subtree\\n3. Visit each child of the \"subroot\". Add it to a list of children for the subroot.\\n4. Check whether chopping of the subroot and subroot child trees is optimal\\n5. Once all children have been visited for the subroot, consider every non-child and non-parent of the subroot.\\n6. Done!\\n\\n```go\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tn := len(nums)\\n\\n\\t// Create bi-directional adjacency list\\n\\tbidiAdj := make([][]int, n)\\n\\tfor _, e := range edges {\\n\\t\\tif e[0] > e[1] {\\n\\t\\t\\te[0], e[1] = e[1], e[0]\\n\\t\\t}\\n\\t\\tbidiAdj[e[0]] = append(bidiAdj[e[0]], e[1])\\n\\t\\tbidiAdj[e[1]] = append(bidiAdj[e[1]], e[0])\\n\\t}\\n\\n\\t// Convert into regular adjacency list\\n\\tcurr := []int{0}\\n\\tnext := []int{}\\n\\tseen := make([]bool, n)\\n\\tadj := make([][]int, n)\\n\\tseen[0] = true\\n\\tfor len(curr) > 0 {\\n\\t\\tnext = next[:0]\\n\\t\\tfor _, i := range curr {\\n\\t\\t\\tfor _, j := range bidiAdj[i] {\\n\\t\\t\\t\\tif seen[j] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tseen[j] = true\\n\\t\\t\\t\\tnext = append(next, j)\\n\\t\\t\\t\\tadj[i] = append(adj[i], j)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr, next = next, curr\\n\\t}\\n\\n\\t// Capture the XOR value of each subtree rooted in a node\\n\\txors := make([]int, n)\\n\\tcopy(xors, nums)\\n\\tvar calcXOR func(i int) int\\n\\tcalcXOR = func(i int) int {\\n\\t\\tfor _, nei := range adj[i] {\\n\\t\\t\\txors[i] ^= calcXOR(nei)\\n\\t\\t}\\n\\t\\treturn xors[i]\\n\\t}\\n\\tcalcXOR(0)\\n\\n\\t// isParent[i] is true if the node is a isParent of the current node\\n\\tisParent := make([]bool, n)\\n\\tisParent[0] = true\\n\\t// isChild[i] is true if the node is a isChild of the current node\\n\\t// isChild is reset once traversal of all children for a node has finished\\n\\tisChild := make([]bool, n)\\n\\n\\tres := math.MaxInt64\\n\\n\\t// Visit each subchild, marking it as a child and comparing it with its\\n\\t// subtree parent.\\n\\tvar visitSubChild func(subRoot, child int)\\n\\tvisitSubChild = func(subRoot, child int) {\\n\\t\\tsubRootXOR := xors[subRoot] ^ xors[child]\\n\\t\\tchildXOR := xors[child]\\n\\t\\ttreeXOR := xors[0] ^ xors[subRoot]\\n\\t\\tmaxXOR := max(subRootXOR, max(childXOR, treeXOR))\\n\\t\\tminXOR := min(subRootXOR, min(childXOR, treeXOR))\\n\\t\\tres = min(res, maxXOR-minXOR)\\n\\t\\tisChild[child] = true\\n\\t\\tfor _, nei := range adj[child] {\\n\\t\\t\\tvisitSubChild(subRoot, nei)\\n\\t\\t}\\n\\t}\\n\\n\\tvar visitSubRoot func(subRoot int)\\n\\tvisitSubRoot = func(subRoot int) {\\n\\t\\t// Collect children for this node and evaluate cutting the two subtrees\\n\\t\\t// rooted in subRoot and the child.\\n\\t\\tfor i := range isChild {\\n\\t\\t\\tisChild[i] = false\\n\\t\\t}\\n\\t\\tfor _, child := range adj[subRoot] {\\n\\t\\t\\tvisitSubChild(subRoot, child)\\n\\t\\t}\\n\\t\\tisParent[subRoot] = true\\n\\n\\t\\t// XOR with every node that is not a child or parent of the current one\\n\\t\\tfor other := 1; other < len(xors); other++ {\\n\\t\\t\\tif isParent[other] || isChild[other] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\ta := xors[other]\\n\\t\\t\\tb := xors[subRoot]\\n\\t\\t\\tc := xors[0] ^ a ^ b\\n\\t\\t\\tres = min(res, max(a, max(b, c))-min(a, min(b, c)))\\n\\t\\t}\\n\\n\\t\\t// Consider each child as the root of a subtree\\n\\t\\tfor _, child := range adj[subRoot] {\\n\\t\\t\\tvisitSubRoot(child)\\n\\t\\t}\\n\\t\\tisParent[subRoot] = false\\n\\t}\\n\\n\\tfor _, subRoot := range adj[0] {\\n\\t\\tvisitSubRoot(subRoot)\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimumScore(nums []int, edges [][]int) int {\\n\\tn := len(nums)\\n\\n\\t// Create bi-directional adjacency list\\n\\tbidiAdj := make([][]int, n)\\n\\tfor _, e := range edges {\\n\\t\\tif e[0] > e[1] {\\n\\t\\t\\te[0], e[1] = e[1], e[0]\\n\\t\\t}\\n\\t\\tbidiAdj[e[0]] = append(bidiAdj[e[0]], e[1])\\n\\t\\tbidiAdj[e[1]] = append(bidiAdj[e[1]], e[0])\\n\\t}\\n\\n\\t// Convert into regular adjacency list\\n\\tcurr := []int{0}\\n\\tnext := []int{}\\n\\tseen := make([]bool, n)\\n\\tadj := make([][]int, n)\\n\\tseen[0] = true\\n\\tfor len(curr) > 0 {\\n\\t\\tnext = next[:0]\\n\\t\\tfor _, i := range curr {\\n\\t\\t\\tfor _, j := range bidiAdj[i] {\\n\\t\\t\\t\\tif seen[j] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tseen[j] = true\\n\\t\\t\\t\\tnext = append(next, j)\\n\\t\\t\\t\\tadj[i] = append(adj[i], j)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr, next = next, curr\\n\\t}\\n\\n\\t// Capture the XOR value of each subtree rooted in a node\\n\\txors := make([]int, n)\\n\\tcopy(xors, nums)\\n\\tvar calcXOR func(i int) int\\n\\tcalcXOR = func(i int) int {\\n\\t\\tfor _, nei := range adj[i] {\\n\\t\\t\\txors[i] ^= calcXOR(nei)\\n\\t\\t}\\n\\t\\treturn xors[i]\\n\\t}\\n\\tcalcXOR(0)\\n\\n\\t// isParent[i] is true if the node is a isParent of the current node\\n\\tisParent := make([]bool, n)\\n\\tisParent[0] = true\\n\\t// isChild[i] is true if the node is a isChild of the current node\\n\\t// isChild is reset once traversal of all children for a node has finished\\n\\tisChild := make([]bool, n)\\n\\n\\tres := math.MaxInt64\\n\\n\\t// Visit each subchild, marking it as a child and comparing it with its\\n\\t// subtree parent.\\n\\tvar visitSubChild func(subRoot, child int)\\n\\tvisitSubChild = func(subRoot, child int) {\\n\\t\\tsubRootXOR := xors[subRoot] ^ xors[child]\\n\\t\\tchildXOR := xors[child]\\n\\t\\ttreeXOR := xors[0] ^ xors[subRoot]\\n\\t\\tmaxXOR := max(subRootXOR, max(childXOR, treeXOR))\\n\\t\\tminXOR := min(subRootXOR, min(childXOR, treeXOR))\\n\\t\\tres = min(res, maxXOR-minXOR)\\n\\t\\tisChild[child] = true\\n\\t\\tfor _, nei := range adj[child] {\\n\\t\\t\\tvisitSubChild(subRoot, nei)\\n\\t\\t}\\n\\t}\\n\\n\\tvar visitSubRoot func(subRoot int)\\n\\tvisitSubRoot = func(subRoot int) {\\n\\t\\t// Collect children for this node and evaluate cutting the two subtrees\\n\\t\\t// rooted in subRoot and the child.\\n\\t\\tfor i := range isChild {\\n\\t\\t\\tisChild[i] = false\\n\\t\\t}\\n\\t\\tfor _, child := range adj[subRoot] {\\n\\t\\t\\tvisitSubChild(subRoot, child)\\n\\t\\t}\\n\\t\\tisParent[subRoot] = true\\n\\n\\t\\t// XOR with every node that is not a child or parent of the current one\\n\\t\\tfor other := 1; other < len(xors); other++ {\\n\\t\\t\\tif isParent[other] || isChild[other] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\ta := xors[other]\\n\\t\\t\\tb := xors[subRoot]\\n\\t\\t\\tc := xors[0] ^ a ^ b\\n\\t\\t\\tres = min(res, max(a, max(b, c))-min(a, min(b, c)))\\n\\t\\t}\\n\\n\\t\\t// Consider each child as the root of a subtree\\n\\t\\tfor _, child := range adj[subRoot] {\\n\\t\\t\\tvisitSubRoot(child)\\n\\t\\t}\\n\\t\\tisParent[subRoot] = false\\n\\t}\\n\\n\\tfor _, subRoot := range adj[0] {\\n\\t\\tvisitSubRoot(subRoot)\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202350,
                "title": "dfs",
                "content": "```\\nclass Solution {\\n    int n,t;\\n    int tin[1001],tout[1001],xs[1001],val[1001];\\n    //tin[i] -> stores the time of entry of node i\\n    //tout[i] -> stores the time when node i is retuned in dfs function\\n    // val[i] -> stores the value associated with node i\\n    // xs[i] -> stores the xor of the subtree below node i(including i)\\n    array<vector<int>,1001>adj;\\n    void dfs(int &node,int &p){\\n        tin[node]=t++;\\n        xs[node]=val[node];\\n        for(auto t:adj[node]){\\n            if(t!=p){\\n                dfs(t,node);\\n                xs[node]^=xs[t];\\n            }\\n        }\\n        tout[node]=t++;\\n    }\\n    \\n    bool samesubtree(int &u,int &v){ //used to check whether u and v are on same subtree(or u is parent of v)\\n        return tin[u]<=tin[v] && tout[u]>=tout[v];\\n    }\\n    \\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        n = nums.size();\\n        for(auto&edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        int j = 0,u=0,v=-1;\\n        for(auto&i:nums)val[j++]=i;\\n        dfs(u,v);\\n        int ans = INT_MAX;\\n        for(int i = 1;i<n;i++){\\n            for(j  = i+1;j<n;j++){\\n                u=i;v=j;\\n                if(samesubtree(v,u)) swap(v,u); //if v is parent of u, swap u and v;\\n                if(samesubtree(u,v)){ \\n                    int a = xs[v],b = xs[u]^xs[v], c= xs[0]^xs[u];\\n                    ans = min(ans,max({a,b,c})-min({a,b,c}));\\n                }\\n                else{ // when u and v lie on other side of the branch like in example 1, node 2 and node 3\\n                    int a = xs[v], b = xs[u], c = xs[0]^xs[u]^xs[v];\\n                    ans = min(ans,max({a,b,c})-min({a,b,c}));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    int n,t;\\n    int tin[1001],tout[1001],xs[1001],val[1001];\\n    //tin[i] -> stores the time of entry of node i\\n    //tout[i] -> stores the time when node i is retuned in dfs function\\n    // val[i] -> stores the value associated with node i\\n    // xs[i] -> stores the xor of the subtree below node i(including i)\\n    array<vector<int>,1001>adj;\\n    void dfs(int &node,int &p){\\n        tin[node]=t++;\\n        xs[node]=val[node];\\n        for(auto t:adj[node]){\\n            if(t!=p){\\n                dfs(t,node);\\n                xs[node]^=xs[t];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2202208,
                "title": "dfs-o-n-2",
                "content": "\\'\\'\\'\\n\\n\\n\\tint dfsi(int loc_sr, int sr, vector<vector<int>>& graph, int par, vector<int>& xOr, vector<int>& nums, int opp)\\n    {\\n        int ans=0;\\n        for(int child: graph[loc_sr])\\n        {\\n            if(child!=par && child!=opp)\\n            {\\n                ans^=dfsi(child, sr, graph, loc_sr,  xOr, nums, opp);\\n            }\\n        }\\n        if(loc_sr!=sr)\\n        {\\n            xOr.push_back(ans^nums[loc_sr]);\\n        }\\n        return ans^nums[loc_sr];\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(nums.size());\\n        for(auto e: edges)\\n        {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(auto e: edges)\\n        {\\n            vector<int> xOr1;\\n            vector<int> xOr2;\\n            int x1 = dfsi(e[0], e[0], graph, -1, xOr1, nums, e[1]);\\n            int x2= dfsi(e[1], e[1], graph, -1, xOr2, nums, e[0]);\\n            \\n            for(int p_1 : xOr2)\\n            {\\n                int p_2= x2^p_1;\\n                int mini= min(x1, min(p_1, p_2));\\n                int maxi= max(x1, max(p_1, p_2));\\n                ans = min(ans, maxi-mini);\\n            }\\n            for(int p_1 : xOr1)\\n            {\\n                int p_2= x1^p_1;\\n                int mini= min(x2, min(p_1, p_2));\\n                int maxi= max(x2, max(p_1, p_2));\\n                ans = min(ans, maxi-mini);\\n            }   \\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "\\'\\'\\'\\n\\n\\n\\tint dfsi(int loc_sr, int sr, vector<vector<int>>& graph, int par, vector<int>& xOr, vector<int>& nums, int opp)\\n    {\\n        int ans=0;\\n        for(int child: graph[loc_sr])\\n        {\\n            if(child!=par && child!=opp)\\n            {\\n                ans^=dfsi(child, sr, graph, loc_sr,  xOr, nums, opp);\\n            }\\n        }\\n        if(loc_sr!=sr)\\n        {\\n            xOr.push_back(ans^nums[loc_sr]);\\n        }\\n        return ans^nums[loc_sr];\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(nums.size());\\n        for(auto e: edges)\\n        {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(auto e: edges)\\n        {\\n            vector<int> xOr1;\\n            vector<int> xOr2;\\n            int x1 = dfsi(e[0], e[0], graph, -1, xOr1, nums, e[1]);\\n            int x2= dfsi(e[1], e[1], graph, -1, xOr2, nums, e[0]);\\n            \\n            for(int p_1 : xOr2)\\n            {\\n                int p_2= x2^p_1;\\n                int mini= min(x1, min(p_1, p_2));\\n                int maxi= max(x1, max(p_1, p_2));\\n                ans = min(ans, maxi-mini);\\n            }\\n            for(int p_1 : xOr1)\\n            {\\n                int p_2= x1^p_1;\\n                int mini= min(x2, min(p_1, p_2));\\n                int maxi= max(x2, max(p_1, p_2));\\n                ans = min(ans, maxi-mini);\\n            }   \\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2202013,
                "title": "java-dfs-with-detailed-comments",
                "content": "```\\n/**\\n\\n1. dfs return every substree xor sum \\n2. iterator one removed edge before building graph\\n3. remove another edge during bfs\\n\\n*/\\n\\nclass Solution {\\n    \\n    int INF = 0x3f3f3f3f;\\n    int[] e, ne, h;\\n    int[] dp;\\n    int[] w;\\n    int idx;\\n    int ans = INF;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        \\n        int n = nums.length;\\n        w = nums;\\n        e = new int[n * 2 + 1]; ne = new int[n * 2 + 1]; h = new int[n + 1];\\n                \\n        \\n        \\n        // Iterator removed edge, and construct graph again\\n        for(int i = 0; i < n - 1; i++){\\n            \\n            Arrays.fill(h, -1);\\n            idx = 0;\\n            \\n            for(int j = 0; j < n - 1; j++){ // construct graph again\\n                if(j == i) continue; // skip\\n                int a = edges[j][0];\\n                int b = edges[j][1];\\n                add(a, b);\\n                add(b, a);\\n            }\\n            \\n            // get the node of removed edges\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            \\n            // get xor sum of subtree which root is x\\n            int sumx = dfs(x, -1, -1, -1); // no sense for last two parameters\\n            \\n            // get xor sum of subtree which root is y\\n            int sumy = dfs(y, -1, -1, -1);\\n            \\n            // select one of x and y substree to remove another one edges\\n            \\n            dfs(x, -1, sumx, sumy); // [IMPORTANT] In the every step of dfs, we can see root as deleted node.\\n            \\n            dfs(y, -1, sumy, sumx);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    // dfs will return sum xor of these tree which root is u\\n    int dfs(int u, int fa, int sumx, int sumy){\\n        \\n        int res = w[u];\\n                \\n        for(int i = h[u]; i != - 1; i = ne[i]){\\n            int j = e[i];\\n            if(fa == j) continue;\\n            int t = dfs(j, u, sumx, sumy);\\n            res = res ^ t;\\n            \\n            // need to calculate three parts sum xor, current we removed t which we just got from dfs\\n            if(sumx != -1){\\n                int t1 = sumy;\\n                int t2 = t;\\n                int t3 = sumx ^ t; // \"sumx - t\" in xor\\n                ans = Math.min(ans,  Math.max(t3, Math.max(t1, t2)) - Math.min(t3, Math.min(t1, t2)) );\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    void add(int a, int b){ // a -> b\\n        e[idx] = b;\\n        ne[idx] = h[a];\\n        h[a] = idx++;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\n/**\\n\\n1. dfs return every substree xor sum \\n2. iterator one removed edge before building graph\\n3. remove another edge during bfs\\n\\n*/\\n\\nclass Solution {\\n    \\n    int INF = 0x3f3f3f3f;\\n    int[] e, ne, h;\\n    int[] dp;\\n    int[] w;\\n    int idx;\\n    int ans = INF;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        \\n        int n = nums.length;\\n        w = nums;\\n        e = new int[n * 2 + 1]; ne = new int[n * 2 + 1]; h = new int[n + 1];\\n                \\n        \\n        \\n        // Iterator removed edge, and construct graph again\\n        for(int i = 0; i < n - 1; i++){\\n            \\n            Arrays.fill(h, -1);\\n            idx = 0;\\n            \\n            for(int j = 0; j < n - 1; j++){ // construct graph again\\n                if(j == i) continue; // skip\\n                int a = edges[j][0];\\n                int b = edges[j][1];\\n                add(a, b);\\n                add(b, a);\\n            }\\n            \\n            // get the node of removed edges\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            \\n            // get xor sum of subtree which root is x\\n            int sumx = dfs(x, -1, -1, -1); // no sense for last two parameters\\n            \\n            // get xor sum of subtree which root is y\\n            int sumy = dfs(y, -1, -1, -1);\\n            \\n            // select one of x and y substree to remove another one edges\\n            \\n            dfs(x, -1, sumx, sumy); // [IMPORTANT] In the every step of dfs, we can see root as deleted node.\\n            \\n            dfs(y, -1, sumy, sumx);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    // dfs will return sum xor of these tree which root is u\\n    int dfs(int u, int fa, int sumx, int sumy){\\n        \\n        int res = w[u];\\n                \\n        for(int i = h[u]; i != - 1; i = ne[i]){\\n            int j = e[i];\\n            if(fa == j) continue;\\n            int t = dfs(j, u, sumx, sumy);\\n            res = res ^ t;\\n            \\n            // need to calculate three parts sum xor, current we removed t which we just got from dfs\\n            if(sumx != -1){\\n                int t1 = sumy;\\n                int t2 = t;\\n                int t3 = sumx ^ t; // \"sumx - t\" in xor\\n                ans = Math.min(ans,  Math.max(t3, Math.max(t1, t2)) - Math.min(t3, Math.min(t1, t2)) );\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    void add(int a, int b){ // a -> b\\n        e[idx] = b;\\n        ne[idx] = h[a];\\n        h[a] = idx++;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200894,
                "title": "dfs-subtreexor-c-o-n-2",
                "content": "- Rooted tree on node 0 .\\n- Calculated Subtree xor and level of each node and stored in stx and level vector respectively.\\n- Also calculated in and out time for identifying whether a node is in subtree of another.\\n- Iterated on edges vector and choosed two edges i,j and my idea is to choose two nodes node1,node2 which are in edges i and j having greater level (ie, node1 = max(level[edges[i][0]],level[edges[i][1]]) and same for node2).\\n- Now as we have our node1,node2 , node3 will be the root node ie, node 0 and then we will calculate xor of respective nodes and their subtree after detatching\\n- xor0 = xor0 ^ with stx of min level among node1 and node2\\n- xor1 = xor1 ^ p , where p=0 if node 2 is not its child else p=stx[node2]\\n- xor2= xor2 ^p , where p=0 if node 1 is not its child else p=stx[node1]\\n- Note that only three of the condition will be true ie, either node1 is in node2 subtree or node2 is in node1 subtree or both are in different subtree (so p=0 for both)\\n\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int node,int par,int lvl,int &t,vector<int>& nums,vector<vector<int>>&ed,vector<int>&level,vector<int>&stx,vector<int>&in,vector<int>&ot)\\n    {\\n        level[node]=lvl;                 // assigning level \\n        stx[node]=nums[node];   \\n        in[node]=t++;                 // in time of node \\n    \\n        for(auto ch : ed[node])\\n        {\\n            if(ch!=par)\\n            {\\n                dfs(ch,node,lvl+1,t,nums,ed,level,stx,in,ot);\\n                stx[node]=stx[node]^stx[ch];                        // calculating subtree xor\\n            }\\n        }\\n        \\n        ot[node]=t++;\\n    }\\n    \\n    bool isInSub(int node1,int node2,vector<int>&in,vector<int>&ot)\\n    {\\n        // check if node1 is ancestor/parent of node2\\n        if(in[node1]<in[node2] && ot[node1]>ot[node2])\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int i,j,n=nums.size(),m=edges.size(),ans=INT_MAX;\\n        vector<int>level(n+1,0);\\n        vector<int>in(n+1,0);\\n        vector<int>ot(n+1,0);\\n        \\n        vector<int>stx(n+1,0);\\n        vector<vector<int>>ed(n+1);\\n        for(i=0;i<m;i++)\\n        {\\n            ed[edges[i][0]].push_back(edges[i][1]);\\n            ed[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        int t=0;\\n        dfs(0,-1,0,t,nums,ed,level,stx,in,ot);\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=i+1;j<m;j++)\\n            {\\n                int node1=0,node2=0;\\n                \\n                if(level[edges[i][0]]>level[edges[i][1]])\\n                {\\n                    node1=edges[i][0];\\n                }\\n                else\\n                {\\n                    node1=edges[i][1];\\n                }\\n                \\n                if(level[edges[j][0]]>level[edges[j][1]])\\n                {\\n                    node2=edges[j][0];\\n                }\\n                else\\n                {\\n                    node2=edges[j][1];\\n                }\\n                \\n                int x1=stx[node1],x2=stx[node2],x3=stx[0];\\n                \\n                if(level[node1]<level[node2])\\n                {\\n                    if(isInSub(node1,node2,in,ot))\\n                    {\\n                        x3=x3^stx[node1];\\n                        x1=x1^stx[node2];\\n                    }\\n                    else\\n                    {\\n                        x3=x3^stx[node1];\\n                        x3=x3^stx[node2];\\n                    }\\n                }\\n                else\\n                {\\n                    if(isInSub(node2,node1,in,ot))\\n                    {\\n                        x3=x3^stx[node2];\\n                        x2=x2^stx[node1];\\n                    }\\n                    else\\n                    {\\n                        x3=x3^stx[node1];\\n                        x3=x3^stx[node2];\\n                    }\\n                }\\n                \\n                int mn=min(x1,min(x2,x3));\\n                int mx=max(x1,max(x2,x3));\\n                \\n                ans=min(ans,mx-mn);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\nUpvote if u like",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int node,int par,int lvl,int &t,vector<int>& nums,vector<vector<int>>&ed,vector<int>&level,vector<int>&stx,vector<int>&in,vector<int>&ot)\\n    {\\n        level[node]=lvl;                 // assigning level \\n        stx[node]=nums[node];   \\n        in[node]=t++;                 // in time of node \\n    \\n        for(auto ch : ed[node])\\n        {\\n            if(ch!=par)\\n            {\\n                dfs(ch,node,lvl+1,t,nums,ed,level,stx,in,ot);\\n                stx[node]=stx[node]^stx[ch];                        // calculating subtree xor\\n            }\\n        }\\n        \\n        ot[node]=t++;\\n    }\\n    \\n    bool isInSub(int node1,int node2,vector<int>&in,vector<int>&ot)\\n    {\\n        // check if node1 is ancestor/parent of node2\\n        if(in[node1]<in[node2] && ot[node1]>ot[node2])\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int i,j,n=nums.size(),m=edges.size(),ans=INT_MAX;\\n        vector<int>level(n+1,0);\\n        vector<int>in(n+1,0);\\n        vector<int>ot(n+1,0);\\n        \\n        vector<int>stx(n+1,0);\\n        vector<vector<int>>ed(n+1);\\n        for(i=0;i<m;i++)\\n        {\\n            ed[edges[i][0]].push_back(edges[i][1]);\\n            ed[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        int t=0;\\n        dfs(0,-1,0,t,nums,ed,level,stx,in,ot);\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=i+1;j<m;j++)\\n            {\\n                int node1=0,node2=0;\\n                \\n                if(level[edges[i][0]]>level[edges[i][1]])\\n                {\\n                    node1=edges[i][0];\\n                }\\n                else\\n                {\\n                    node1=edges[i][1];\\n                }\\n                \\n                if(level[edges[j][0]]>level[edges[j][1]])\\n                {\\n                    node2=edges[j][0];\\n                }\\n                else\\n                {\\n                    node2=edges[j][1];\\n                }\\n                \\n                int x1=stx[node1],x2=stx[node2],x3=stx[0];\\n                \\n                if(level[node1]<level[node2])\\n                {\\n                    if(isInSub(node1,node2,in,ot))\\n                    {\\n                        x3=x3^stx[node1];\\n                        x1=x1^stx[node2];\\n                    }\\n                    else\\n                    {\\n                        x3=x3^stx[node1];\\n                        x3=x3^stx[node2];\\n                    }\\n                }\\n                else\\n                {\\n                    if(isInSub(node2,node1,in,ot))\\n                    {\\n                        x3=x3^stx[node2];\\n                        x2=x2^stx[node1];\\n                    }\\n                    else\\n                    {\\n                        x3=x3^stx[node1];\\n                        x3=x3^stx[node2];\\n                    }\\n                }\\n                \\n                int mn=min(x1,min(x2,x3));\\n                int mx=max(x1,max(x2,x3));\\n                \\n                ans=min(ans,mx-mn);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200823,
                "title": "too-tight-time-limit-for-c",
                "content": "why This code is giving tle? even though the time complexity of the code is O(N^2). \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void pre(int node,int par,vector<int> adj[],int &timer,int in[],int maxin[],int x[],vector<int> &nums){\\n        \\n        in[node]=maxin[node]=++timer;\\n        x[node]=nums[node];\\n        \\n        for(auto child:adj[node]){\\n            \\n            if(child!=par){\\n                \\n                pre(child,node,adj,timer,in,maxin,x,nums);\\n                x[node]^=x[child];\\n                maxin[node]=max(maxin[node],maxin[child]);\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<int> arrange(int u,int v,int in[]){\\n         \\n        vector<int> a({u,v});\\n        vector<int> b({v,u});\\n        \\n        return in[u]<in[v] ? a : b;\\n        \\n    }\\n    \\n    bool underSubtree(int v,int u,int in[],int maxin[]){\\n        \\n        return (in[v]>=in[u] && in[v]<=maxin[u]);\\n        \\n    }\\n    \\n    int calc(int x1,int x2,int x3){\\n        \\n        return max({x1,x2,x3}) - min({x1,x2,x3});\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n    \\n        \\n        int n = nums.size();\\n        \\n        int in[n],x[n],maxin[n];\\n        \\n        for(int i=0;i<n;i++){\\n            x[i]=in[i]=maxin[i]=0;\\n        }\\n        \\n        int timer = 0;\\n        \\n        vector<int> adj[n];\\n        \\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        \\n        pre(0,-1,adj,timer,in,maxin,x,nums);\\n        \\n        int xall = x[0];\\n        \\n        \\n        int ans = (int)(1e8+10);\\n        \\n        int m = n-1;\\n\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=i+1;j<m;j++){\\n                \\n               auto edge1 = arrange(edges[i][0],edges[i][1],in);\\n               auto edge2 = arrange(edges[j][0],edges[j][1],in);\\n                \\n               int u1=edge1[0],v1 = edge1[1];\\n               int u2 = edge2[0],v2 = edge2[1];\\n                \\n                int x1,x2,x3;\\n                if(underSubtree(v2,v1,in,maxin)){\\n                    \\n                    int xc = x[v2];\\n                    int xp = (x[v1]^xc);\\n                    int xr = (xall ^ xp ^ xc);\\n                    \\n                    ans = min(ans,calc(xc,xp,xr));\\n                    \\n                }else if(underSubtree(v1,v2,in,maxin)){\\n                    \\n                    \\n                   int xc = x[v1];\\n                    int xp = (x[v2]^xc);\\n                    int xr = (xall ^ xp ^ xc);\\n                    \\n                    ans = min(ans,calc(xc,xp,xr)); \\n                    \\n                    \\n                }else{\\n                    \\n                    \\n                    int x1 = x[v1];\\n                    int x2 = x[v2];\\n                    int x3 = (xall^x1^x2);\\n               \\n                    \\n                    ans = min(ans,calc(x1,x2,x3));\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```\\n\\nBut this code is passing which is almost similar to the above code but just removed utility functions.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void pre(int node,int par,vector<int> adj[],int &timer,int in[],int maxin[],int x[],vector<int> &nums){\\n        \\n        in[node]=maxin[node]=++timer;\\n        x[node]=nums[node];\\n        \\n        for(auto child:adj[node]){\\n            \\n            if(child!=par){\\n                \\n                pre(child,node,adj,timer,in,maxin,x,nums);\\n                x[node]^=x[child];\\n                maxin[node]=max(maxin[node],maxin[child]);\\n            }\\n    \\n        }\\n        \\n        \\n    }\\n    \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n    \\n        \\n        int n = nums.size();\\n        \\n        int in[n],x[n],maxin[n];\\n        \\n        int timer = 0;\\n        \\n        vector<int> adj[n];\\n        \\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        \\n        pre(0,-1,adj,timer,in,maxin,x,nums);\\n        \\n        \\n        int ans = (int)(1e8+10);\\n        \\n        int m = n-1;\\n        int i=0;\\n        \\n       while(i<m-1){\\n            int j=i+1;\\n            while(j<m){\\n                \\n                auto edge1 = edges[i];\\n                auto edge2 = edges[j];\\n                \\n                if(in[edge1[0]] > in[edge1[1]]) swap(edge1[0],edge1[1]);\\n                if(in[edge2[0]]>in[edge2[1]]) swap(edge2[0],edge2[1]);\\n              \\n               int u1 = edge1[0],v1 = edge1[1];\\n               int u2 = edge2[0],v2 = edge2[1];\\n                \\n                int x1,x2,x3;\\n                \\n                if(in[v2]>=in[v1] && in[v2]<=maxin[v1]){\\n                    \\n                    \\n                    \\n                     x1 = x[v2];\\n                     x2 = (x[v1]^x1);\\n                     x3 = (x[0] ^ x1 ^ x2);\\n                    \\n                    \\n                }else if(in[v1]>=in[v2] && in[v1]<=maxin[v2]){\\n                    \\n                    \\n                     x1 = x[v1];\\n                     x2 = (x[v2]^x1);\\n                     x3 = (x[0] ^ x1 ^ x2);\\n                    \\n                    \\n                    \\n                }else{\\n                    \\n                    \\n                    x1 = x[v1];\\n                    x2 = x[v2];\\n                    x3 = (x[0]^x1^x2);\\n                    \\n                }\\n                \\n                \\n                ans = min(ans,max({x1,x2,x3}) - min({x1,x2,x3}));\\n                j++;\\n                \\n                \\n            }\\n            \\n            i++;\\n            \\n        }\\n        \\n        \\n        return ans;\\n\\n    }\\n};\\n\\n\\n```\\n\\nPlease can someone tell me why did this happened is something wrong with my code or is leetcode time limit was too tight? Please leetcode admin re-evaluate my code on 4th one if my code was running within the limit.\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void pre(int node,int par,vector<int> adj[],int &timer,int in[],int maxin[],int x[],vector<int> &nums){\\n        \\n        in[node]=maxin[node]=++timer;\\n        x[node]=nums[node];\\n        \\n        for(auto child:adj[node]){\\n            \\n            if(child!=par){\\n                \\n                pre(child,node,adj,timer,in,maxin,x,nums);\\n                x[node]^=x[child];\\n                maxin[node]=max(maxin[node],maxin[child]);\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<int> arrange(int u,int v,int in[]){\\n         \\n        vector<int> a({u,v});\\n        vector<int> b({v,u});\\n        \\n        return in[u]<in[v] ? a : b;\\n        \\n    }\\n    \\n    bool underSubtree(int v,int u,int in[],int maxin[]){\\n        \\n        return (in[v]>=in[u] && in[v]<=maxin[u]);\\n        \\n    }\\n    \\n    int calc(int x1,int x2,int x3){\\n        \\n        return max({x1,x2,x3}) - min({x1,x2,x3});\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n    \\n        \\n        int n = nums.size();\\n        \\n        int in[n],x[n],maxin[n];\\n        \\n        for(int i=0;i<n;i++){\\n            x[i]=in[i]=maxin[i]=0;\\n        }\\n        \\n        int timer = 0;\\n        \\n        vector<int> adj[n];\\n        \\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        \\n        pre(0,-1,adj,timer,in,maxin,x,nums);\\n        \\n        int xall = x[0];\\n        \\n        \\n        int ans = (int)(1e8+10);\\n        \\n        int m = n-1;\\n\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=i+1;j<m;j++){\\n                \\n               auto edge1 = arrange(edges[i][0],edges[i][1],in);\\n               auto edge2 = arrange(edges[j][0],edges[j][1],in);\\n                \\n               int u1=edge1[0],v1 = edge1[1];\\n               int u2 = edge2[0],v2 = edge2[1];\\n                \\n                int x1,x2,x3;\\n                if(underSubtree(v2,v1,in,maxin)){\\n                    \\n                    int xc = x[v2];\\n                    int xp = (x[v1]^xc);\\n                    int xr = (xall ^ xp ^ xc);\\n                    \\n                    ans = min(ans,calc(xc,xp,xr));\\n                    \\n                }else if(underSubtree(v1,v2,in,maxin)){\\n                    \\n                    \\n                   int xc = x[v1];\\n                    int xp = (x[v2]^xc);\\n                    int xr = (xall ^ xp ^ xc);\\n                    \\n                    ans = min(ans,calc(xc,xp,xr)); \\n                    \\n                    \\n                }else{\\n                    \\n                    \\n                    int x1 = x[v1];\\n                    int x2 = x[v2];\\n                    int x3 = (xall^x1^x2);\\n               \\n                    \\n                    ans = min(ans,calc(x1,x2,x3));\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void pre(int node,int par,vector<int> adj[],int &timer,int in[],int maxin[],int x[],vector<int> &nums){\\n        \\n        in[node]=maxin[node]=++timer;\\n        x[node]=nums[node];\\n        \\n        for(auto child:adj[node]){\\n            \\n            if(child!=par){\\n                \\n                pre(child,node,adj,timer,in,maxin,x,nums);\\n                x[node]^=x[child];\\n                maxin[node]=max(maxin[node],maxin[child]);\\n            }\\n    \\n        }\\n        \\n        \\n    }\\n    \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n    \\n        \\n        int n = nums.size();\\n        \\n        int in[n],x[n],maxin[n];\\n        \\n        int timer = 0;\\n        \\n        vector<int> adj[n];\\n        \\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        \\n        pre(0,-1,adj,timer,in,maxin,x,nums);\\n        \\n        \\n        int ans = (int)(1e8+10);\\n        \\n        int m = n-1;\\n        int i=0;\\n        \\n       while(i<m-1){\\n            int j=i+1;\\n            while(j<m){\\n                \\n                auto edge1 = edges[i];\\n                auto edge2 = edges[j];\\n                \\n                if(in[edge1[0]] > in[edge1[1]]) swap(edge1[0],edge1[1]);\\n                if(in[edge2[0]]>in[edge2[1]]) swap(edge2[0],edge2[1]);\\n              \\n               int u1 = edge1[0],v1 = edge1[1];\\n               int u2 = edge2[0],v2 = edge2[1];\\n                \\n                int x1,x2,x3;\\n                \\n                if(in[v2]>=in[v1] && in[v2]<=maxin[v1]){\\n                    \\n                    \\n                    \\n                     x1 = x[v2];\\n                     x2 = (x[v1]^x1);\\n                     x3 = (x[0] ^ x1 ^ x2);\\n                    \\n                    \\n                }else if(in[v1]>=in[v2] && in[v1]<=maxin[v2]){\\n                    \\n                    \\n                     x1 = x[v1];\\n                     x2 = (x[v2]^x1);\\n                     x3 = (x[0] ^ x1 ^ x2);\\n                    \\n                    \\n                    \\n                }else{\\n                    \\n                    \\n                    x1 = x[v1];\\n                    x2 = x[v2];\\n                    x3 = (x[0]^x1^x2);\\n                    \\n                }\\n                \\n                \\n                ans = min(ans,max({x1,x2,x3}) - min({x1,x2,x3}));\\n                j++;\\n                \\n                \\n            }\\n            \\n            i++;\\n            \\n        }\\n        \\n        \\n        return ans;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200701,
                "title": "explanation-of-using-dfs-c",
                "content": "explaination:-\\n\\nExample 1;-\\n\\nnums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]\\n\\nwho to form 3 connected components after removing edges  1-3  and 1-0\\n\\nlet remove 1-3  ==> 2 components  ==> { 3,4 } and { 1,0,2 }\\nset x=  [  { 3,4 } , { 1,0,2 } ]\\nlet remove 1-0  ==> 2 components  ==> { 0 } and { 1,2,3,4 }\\nset y= [  { 0 } , { 1,2,3,4 } ]\\n      \\nthe 3 components on removing both 1-3 and 1-0 together\\n\\nset z=  [ {0}  , {1,2} , {3,4} ]\\n\\nwho we can find set z using set x and set y;\\n\\nstep 1;-\\nlet us find which component of set y have edge 1-3 in it\\n\\n{0 }  -> no don,t have edge 1-3 in it  so this component {0} will we in set z\\n\\n{ 1,2,3,4 } -> yes have edge 1-3 in it  \\n\\nstep 2 ;-\\n\\nlet us find which component of set y have edge 1-0 in it\\n\\n{3 4 }  -> no don,t have edge 1-0 in it  so this component {3,4} will we in set z\\n\\n{ 1,0,2} -> yes have edge 1-0 in it  \\n\\nstep 3;- we have found 2 component of z \\nthe 3rd will we\\n\\n{1,2,3,4} xor {3,4}  ===> { 1,2 }\\n or\\n {1,0,2} xor { 0 }  ===> {1,2 }\\n \\n```\\n class Solution {\\npublic:\\n    int solver(vector<int>& vis,vector<vector<int>>& ed,int i,vector<int>& nums,vector<int>gr[])\\n    {\\n        vis[i]=true;\\n        \\n        int ans=nums[i];\\n        for(int j=0;j<gr[i].size();j++)\\n        {\\n            if(!vis[gr[i][j]] && ed[i][gr[i][j]])\\n            {\\n                ans=ans ^ solver(vis,ed,gr[i][j],nums,gr);\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int>gr[n];\\n        \\n        vector<vector<int>>ed(n,vector<int>(n,0));  //o(n^2)\\n        \\n        \\n        for(auto & x:edges) //o(n)\\n        {\\n            gr[x[0]].push_back(x[1]);\\n            gr[x[1]].push_back(x[0]);\\n            ed[x[0]][x[1]]=1;\\n            ed[x[1]][x[0]]=1;\\n        }\\n        \\n        int m=edges.size();\\n        \\n        vector<int>res; // stores the result of xor of 2 components formed\\n        vector<vector<int>>comp; // stores the node present in 2 components\\n        \\n        for(int i=0;i<m;i++)  //O(8 n^2)\\n        {\\n            \\n            \\n                ed[edges[i][0]][edges[i][1]]=0;\\n                ed[edges[i][1]][edges[i][0]]=0;\\n              \\n                vector<int>vis1(n,0);\\n                vector<int>vis2(n,0);\\n            \\n                int val1=solver(vis1,ed,edges[i][0],nums,gr);\\n                \\n                int val2=solver(vis2,ed,edges[i][1],nums,gr);\\n               \\n                res.push_back(val1);\\n                res.push_back(val2);\\n            \\n                comp.push_back(vis1);\\n                comp.push_back(vis2);\\n                \\n                ed[edges[i][0]][edges[i][1]]=1;\\n                ed[edges[i][1]][edges[i][0]]=1;\\n               \\n\\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<m;i++)  //O(n^2)\\n        {\\n            for(int j=i+1;j<m;j++)\\n            {\\n                \\n                int ma=INT_MIN;\\n                int mi=INT_MAX;\\n                \\n                if(comp[2*j][edges[i][0]] && comp[2*j][edges[i][1]])\\n                {\\n                    if(comp[2*i][edges[j][0]] && comp[2*i][edges[j][1]])\\n                    {\\n                        ma=max(ma,res[2*j+1]);\\n                        ma=max(ma,res[2*i+1]);\\n                        ma=max(ma,(res[2*j+1]^res[2*i]));\\n                        \\n                        mi=min(mi,res[2*j+1]);\\n                        mi=min(mi,res[2*i+1]);\\n                        mi=min(mi,(res[2*j+1]^res[2*i]));\\n                  \\n                    }\\n                    else\\n                    {\\n                        ma=max(ma,res[2*j+1]);\\n                        ma=max(ma,res[2*i]);\\n                        ma=max(ma,(res[2*j+1]^res[2*i+1]));\\n                        \\n                        mi=min(mi,res[2*j+1]);\\n                        mi=min(mi,res[2*i]);\\n                        mi=min(mi,(res[2*j+1]^res[2*i+1]));\\n                        \\n                      \\n                    }\\n                }\\n                else\\n                {\\n                    if(comp[2*i][edges[j][0]] && comp[2*i][edges[j][1]])\\n                    {\\n                        ma=max(ma,res[2*j]);\\n                        ma=max(ma,res[2*i+1]);\\n                        ma=max(ma,(res[2*j]^res[2*i]));\\n                        \\n                        mi=min(mi,res[2*j]);\\n                        mi=min(mi,res[2*i+1]);\\n                        mi=min(mi,(res[2*j]^res[2*i]));\\n                       \\n                    }\\n                    else\\n                    {\\n                        ma=max(ma,res[2*j]);\\n                        ma=max(ma,res[2*i]);\\n                        ma=max(ma,(res[2*j]^res[2*i+1]));\\n                        \\n                        mi=min(mi,res[2*j]);\\n                        mi=min(mi,res[2*i]);\\n                        mi=min(mi,(res[2*j]^res[2*i+1]));\\n                        \\n                       \\n                    }\\n                }\\n                \\n    \\n            ans=min(ans,ma-mi);\\n            }\\n          \\n           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n \\n\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int solver(vector<int>& vis,vector<vector<int>>& ed,int i,vector<int>& nums,vector<int>gr[])\\n    {\\n        vis[i]=true;\\n        \\n        int ans=nums[i];\\n        for(int j=0;j<gr[i].size();j++)\\n        {\\n            if(!vis[gr[i][j]] && ed[i][gr[i][j]])\\n            {\\n                ans=ans ^ solver(vis,ed,gr[i][j],nums,gr);\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int>gr[n];\\n        \\n        vector<vector<int>>ed(n,vector<int>(n,0));  //o(n^2)\\n        \\n        \\n        for(auto & x:edges) //o(n)\\n        {\\n            gr[x[0]].push_back(x[1]);\\n            gr[x[1]].push_back(x[0]);\\n            ed[x[0]][x[1]]=1;\\n            ed[x[1]][x[0]]=1;\\n        }\\n        \\n        int m=edges.size();\\n        \\n        vector<int>res; // stores the result of xor of 2 components formed\\n        vector<vector<int>>comp; // stores the node present in 2 components\\n        \\n        for(int i=0;i<m;i++)  //O(8 n^2)\\n        {\\n            \\n            \\n                ed[edges[i][0]][edges[i][1]]=0;\\n                ed[edges[i][1]][edges[i][0]]=0;\\n              \\n                vector<int>vis1(n,0);\\n                vector<int>vis2(n,0);\\n            \\n                int val1=solver(vis1,ed,edges[i][0],nums,gr);\\n                \\n                int val2=solver(vis2,ed,edges[i][1],nums,gr);\\n               \\n                res.push_back(val1);\\n                res.push_back(val2);\\n            \\n                comp.push_back(vis1);\\n                comp.push_back(vis2);\\n                \\n                ed[edges[i][0]][edges[i][1]]=1;\\n                ed[edges[i][1]][edges[i][0]]=1;\\n               \\n\\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<m;i++)  //O(n^2)\\n        {\\n            for(int j=i+1;j<m;j++)\\n            {\\n                \\n                int ma=INT_MIN;\\n                int mi=INT_MAX;\\n                \\n                if(comp[2*j][edges[i][0]] && comp[2*j][edges[i][1]])\\n                {\\n                    if(comp[2*i][edges[j][0]] && comp[2*i][edges[j][1]])\\n                    {\\n                        ma=max(ma,res[2*j+1]);\\n                        ma=max(ma,res[2*i+1]);\\n                        ma=max(ma,(res[2*j+1]^res[2*i]));\\n                        \\n                        mi=min(mi,res[2*j+1]);\\n                        mi=min(mi,res[2*i+1]);\\n                        mi=min(mi,(res[2*j+1]^res[2*i]));\\n                  \\n                    }\\n                    else\\n                    {\\n                        ma=max(ma,res[2*j+1]);\\n                        ma=max(ma,res[2*i]);\\n                        ma=max(ma,(res[2*j+1]^res[2*i+1]));\\n                        \\n                        mi=min(mi,res[2*j+1]);\\n                        mi=min(mi,res[2*i]);\\n                        mi=min(mi,(res[2*j+1]^res[2*i+1]));\\n                        \\n                      \\n                    }\\n                }\\n                else\\n                {\\n                    if(comp[2*i][edges[j][0]] && comp[2*i][edges[j][1]])\\n                    {\\n                        ma=max(ma,res[2*j]);\\n                        ma=max(ma,res[2*i+1]);\\n                        ma=max(ma,(res[2*j]^res[2*i]));\\n                        \\n                        mi=min(mi,res[2*j]);\\n                        mi=min(mi,res[2*i+1]);\\n                        mi=min(mi,(res[2*j]^res[2*i]));\\n                       \\n                    }\\n                    else\\n                    {\\n                        ma=max(ma,res[2*j]);\\n                        ma=max(ma,res[2*i]);\\n                        ma=max(ma,(res[2*j]^res[2*i+1]));\\n                        \\n                        mi=min(mi,res[2*j]);\\n                        mi=min(mi,res[2*i]);\\n                        mi=min(mi,(res[2*j]^res[2*i+1]));\\n                        \\n                       \\n                    }\\n                }\\n                \\n    \\n            ans=min(ans,ma-mi);\\n            }\\n          \\n           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200195,
                "title": "leetcode-is-acting-weird",
                "content": "first run- it says 60 test cases passed TLE\\nsecond run- ....61 .....TLE\\nthird run- ....62....TLE\\nwtf xD, should i continue running\\nEdit- If someone can figure anything wrong about my code, plz do let me know...thnx!\\n```class Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n            long long n=nums.size();\\n        vector<long long>adj[n+2];\\n        for(long long i=1;i<n;i++){\\n            long long a =edges[i-1][0]+1;\\n            long long b =edges[i-1][1]+1;\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        \\n        \\n        long long x[n+2];long long tin[n+2],tout[n+2];memset(x,0,sizeof x);\\n        memset(tin,0,sizeof tin);\\n        memset(tout,0,sizeof tout);long long t=0;\\n    function<long long(long long,long long)> dfs = [&](long long v,long long par)->long long{\\n          // if(v<1||v>n)return -69;\\n            long long cur=nums[v-1];tin[v]=t++;\\n            for(auto x:adj[v]){\\n                if(x!=par){\\n                    cur^=dfs(x,v);\\n                }\\n            }\\n            tout[v]=t++;\\n             x[v]=cur;\\n        return x[v];\\n        };\\n       long long temp= dfs(1,-1);\\n                                                                                                                                  \\n        long long result=1e18+2;long long cur=0;\\n            for(long long i=2;i<=n;i++){\\n                \\n                for(long long j=i+1;j<=n;j++){\\n                    set<long long>s;\\n                    if((tin[i]<tin[j]&&tout[i]>tout[j]))\\n                    {\\n                        s.insert(x[1]^x[i]);\\n                        s.insert(x[i]^x[j]);\\n                        s.insert(x[j]);\\n                    }\\n                    else if(tin[i]>tin[j]&&tout[i]<tout[j]){\\n                        s.insert(x[1]^x[j]);\\n                        s.insert(x[i]^x[j]);\\n                        s.insert(x[i]);\\n                    }\\n                    else{\\n                        s.insert(x[1]^x[i]^x[j]);\\n                        s.insert(x[i]);\\n                        s.insert(x[j]);\\n                    }\\n                        result=min(result,*s.rbegin()-*s.begin());\\n                    // if(result==15)return i*1000+j;\\n                \\n            }\\n            }\\n        return result;\\n    }\\n};```\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```class Solution {\\npublic:\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n            long long n=nums.size();\\n        vector<long long>adj[n+2];\\n        for(long long i=1;i<n;i++){\\n            long long a =edges[i-1][0]+1;\\n            long long b =edges[i-1][1]+1;\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        \\n        \\n        long long x[n+2];long long tin[n+2],tout[n+2];memset(x,0,sizeof x);\\n        memset(tin,0,sizeof tin);\\n        memset(tout,0,sizeof tout);long long t=0;\\n    function<long long(long long,long long)> dfs = [&](long long v,long long par)->long long{\\n          // if(v<1||v>n)return -69;\\n            long long cur=nums[v-1];tin[v]=t++;\\n            for(auto x:adj[v]){\\n                if(x!=par){\\n                    cur^=dfs(x,v);\\n                }\\n            }\\n            tout[v]=t++;\\n             x[v]=cur;\\n        return x[v];\\n        };\\n       long long temp= dfs(1,-1);\\n                                                                                                                                  \\n        long long result=1e18+2;long long cur=0;\\n            for(long long i=2;i<=n;i++){\\n                \\n                for(long long j=i+1;j<=n;j++){\\n                    set<long long>s;\\n                    if((tin[i]<tin[j]&&tout[i]>tout[j]))\\n                    {\\n                        s.insert(x[1]^x[i]);\\n                        s.insert(x[i]^x[j]);\\n                        s.insert(x[j]);\\n                    }\\n                    else if(tin[i]>tin[j]&&tout[i]<tout[j]){\\n                        s.insert(x[1]^x[j]);\\n                        s.insert(x[i]^x[j]);\\n                        s.insert(x[i]);\\n                    }\\n                    else{\\n                        s.insert(x[1]^x[i]^x[j]);\\n                        s.insert(x[i]);\\n                        s.insert(x[j]);\\n                    }\\n                        result=min(result,*s.rbegin()-*s.begin());\\n                    // if(result==15)return i*1000+j;\\n                \\n            }\\n            }\\n        return result;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2200077,
                "title": "video-explanation-with-intuition",
                "content": "https://www.youtube.com/watch?v=blKFzGYejF0",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "https://www.youtube.com/watch?v=blKFzGYejF0",
                "codeTag": "Unknown"
            },
            {
                "id": 2199979,
                "title": "my-solution",
                "content": "```\\n/**\\n * iterate all possible combinations of the two edges to be removed,\\n * get the minimum score among the scores of all combinations.\\n *\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the number of the nodes, that is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minimumScore(const vector<int> &nums, const vector<vector<int>> &edges) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge[0]].emplace_back(edge[1]);\\n      graph[edge[1]].emplace_back(edge[0]);\\n    }\\n    \\n    /**\\n     * `xors[i]` stands for the xor value of the values of all nodes of the subtree\\n     * rooted by the node labeled `i`\\n     * where `i` is in the range [0, n), `0` inclusive, `n` exclusive\\n     */\\n    int xors[n];\\n    memset(xors, 0, sizeof(xors));\\n    \\n    /**\\n     * `enter_clocks[i]` stands for the clock when the node labeled `i` is entered\\n     * when the tree is traversed\\n     * where `i` is in the range [0, n), `0` inclusive, `n` exclusive\\n     */\\n    int enter_clocks[n];\\n    memset(enter_clocks, 0, sizeof(enter_clocks));\\n    \\n    /**\\n     * `exit_clocks[i]` stands for the clock when the node labeled `i` is exited\\n     * when the tree is traversed\\n     * where `i` is is the range [0, n), `0` inclusive, `n` exclusive\\n     */\\n    int exit_clocks[n];\\n    memset(exit_clocks, 0, sizeof(exit_clocks));\\n    \\n    /**\\n     * `clock` stands for the time when the node is visited when the tree is traversed.\\n     * when a new node is visited, the value of `clock` is increase by `1`.\\n     */\\n    int clock = 0;\\n    \\n    /**\\n     * the tree is rooted by the node labeled `0`\\n     */\\n    dfs(nums, graph, 0, -1, xors, enter_clocks, exit_clocks, clock);\\n    \\n    int ret = numeric_limits<int>::max();\\n    for (int edge1 = 0; edge1 < n - 2; ++edge1) {\\n      for (int edge2 = edge1 + 1; edge2 < n - 1; ++edge2) {\\n        // remove `edge1` and `edge2`\\n        \\n        /**\\n         * `parent1` and `child1` is the parent and child of the edge `edge1` respectively.\\n         */\\n        const auto [parent1, child1] = get_parent_child(edges, edge1, enter_clocks, exit_clocks);\\n        \\n        /**\\n         * `parent2` and `child2` is the parent and child of the edge `edge2` respectively.\\n         */\\n        const auto [parent2, child2] = get_parent_child(edges, edge2, enter_clocks, exit_clocks);\\n        \\n        /**\\n         * `xor0` stands for the xor value of the values of the subtree rooted by the node labeled `0`\\n         * that is the root node of the tree, when the edges `edge1` and `edge2` is removed.\\n         */\\n        int xor0 = 0;\\n        \\n        /**\\n         * `xor1` stands for the xor value of the values of the subtree rooted by the node labeled `child1`\\n         * when the edges `edge1` and `edge2` is removed.\\n         */\\n        int xor1 = 0;\\n        \\n        /**\\n         * `xor2` stands for the xor value of the values of the subtree rooted by the node labeled `child2`\\n         * when the edges `edge1` and `edge2` is removed.\\n         */\\n        int xor2 = 0;\\n        \\n        if (is_parent(enter_clocks, exit_clocks, child1, parent2)) {\\n          // the subtree rooted by the node labeled `child2` is the subtree\\n          // of the subtree rooted by the node labeled `child1`\\n          xor0 = xors[0] ^ xors[child1];\\n          xor1 = xors[child1] ^ xors[child2];\\n          xor2 = xors[child2];\\n        } else if (is_parent(enter_clocks, exit_clocks, child2, parent1)) {\\n          // the subtree rooted by the node labeled `child1` is the subtree\\n          // of the subtree rooted by the node labeled `child2`\\n          xor0 = xors[0] ^ xors[child2];\\n          xor1 = xors[child1];\\n          xor2 = xors[child2] ^ xors[child1];\\n        } else {\\n          // the subtree rooted by the node labeled `child1`\\n          // and the subtree rooted by the node labeled `child2`\\n          // don\\'t have the parent-child relationship\\n          xor0 = xors[0] ^ xors[child1] ^ xors[child2];\\n          xor1 = xors[child1];\\n          xor2 = xors[child2];\\n        }\\n        ret = min(ret, max({xor0, xor1, xor2}) - min({xor0, xor1, xor2}));\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * get the parent and child node label of the edge `edge`\\n   * @return: a pair, the first element is the parent, and the second element is the child\\n   */\\n  pair<int, int> get_parent_child(const vector<vector<int>> &edges,\\n                                  const int edge,\\n                                  const int *enter_clocks,\\n                                  const int *exit_clocks) {\\n    int parent = edges[edge][0];\\n    int child = edges[edge][1];\\n    if (!is_parent(enter_clocks, exit_clocks, parent, child)) {\\n      swap(parent, child);\\n    }\\n    return make_pair(parent, child);\\n  }\\n  \\n  int dfs(const vector<int> &nums,\\n          const vector<int> *graph,\\n          const int node,\\n          const int parent,\\n          int *xors,\\n          int *enter_clocks,\\n          int *exit_clocks,\\n          int &clock) {\\n    xors[node] = nums[node];\\n    ++clock;\\n    enter_clocks[node] = clock;\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      xors[node] ^= dfs(nums, graph, child, node, xors, enter_clocks, exit_clocks, clock);\\n    }\\n    exit_clocks[node] = clock;\\n    return xors[node];\\n  }\\n  \\n  bool is_parent(const int *enter_clocks,\\n                 const int *exit_clocks,\\n                 const int parent,\\n                 const int child) {\\n    return enter_clocks[parent] <= enter_clocks[child] && exit_clocks[parent] >= enter_clocks[child];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * iterate all possible combinations of the two edges to be removed,\\n * get the minimum score among the scores of all combinations.\\n *\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the number of the nodes, that is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minimumScore(const vector<int> &nums, const vector<vector<int>> &edges) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge[0]].emplace_back(edge[1]);\\n      graph[edge[1]].emplace_back(edge[0]);\\n    }\\n    \\n    /**\\n     * `xors[i]` stands for the xor value of the values of all nodes of the subtree\\n     * rooted by the node labeled `i`\\n     * where `i` is in the range [0, n), `0` inclusive, `n` exclusive\\n     */\\n    int xors[n];\\n    memset(xors, 0, sizeof(xors));\\n    \\n    /**\\n     * `enter_clocks[i]` stands for the clock when the node labeled `i` is entered\\n     * when the tree is traversed\\n     * where `i` is in the range [0, n), `0` inclusive, `n` exclusive\\n     */\\n    int enter_clocks[n];\\n    memset(enter_clocks, 0, sizeof(enter_clocks));\\n    \\n    /**\\n     * `exit_clocks[i]` stands for the clock when the node labeled `i` is exited\\n     * when the tree is traversed\\n     * where `i` is is the range [0, n), `0` inclusive, `n` exclusive\\n     */\\n    int exit_clocks[n];\\n    memset(exit_clocks, 0, sizeof(exit_clocks));\\n    \\n    /**\\n     * `clock` stands for the time when the node is visited when the tree is traversed.\\n     * when a new node is visited, the value of `clock` is increase by `1`.\\n     */\\n    int clock = 0;\\n    \\n    /**\\n     * the tree is rooted by the node labeled `0`\\n     */\\n    dfs(nums, graph, 0, -1, xors, enter_clocks, exit_clocks, clock);\\n    \\n    int ret = numeric_limits<int>::max();\\n    for (int edge1 = 0; edge1 < n - 2; ++edge1) {\\n      for (int edge2 = edge1 + 1; edge2 < n - 1; ++edge2) {\\n        // remove `edge1` and `edge2`\\n        \\n        /**\\n         * `parent1` and `child1` is the parent and child of the edge `edge1` respectively.\\n         */\\n        const auto [parent1, child1] = get_parent_child(edges, edge1, enter_clocks, exit_clocks);\\n        \\n        /**\\n         * `parent2` and `child2` is the parent and child of the edge `edge2` respectively.\\n         */\\n        const auto [parent2, child2] = get_parent_child(edges, edge2, enter_clocks, exit_clocks);\\n        \\n        /**\\n         * `xor0` stands for the xor value of the values of the subtree rooted by the node labeled `0`\\n         * that is the root node of the tree, when the edges `edge1` and `edge2` is removed.\\n         */\\n        int xor0 = 0;\\n        \\n        /**\\n         * `xor1` stands for the xor value of the values of the subtree rooted by the node labeled `child1`\\n         * when the edges `edge1` and `edge2` is removed.\\n         */\\n        int xor1 = 0;\\n        \\n        /**\\n         * `xor2` stands for the xor value of the values of the subtree rooted by the node labeled `child2`\\n         * when the edges `edge1` and `edge2` is removed.\\n         */\\n        int xor2 = 0;\\n        \\n        if (is_parent(enter_clocks, exit_clocks, child1, parent2)) {\\n          // the subtree rooted by the node labeled `child2` is the subtree\\n          // of the subtree rooted by the node labeled `child1`\\n          xor0 = xors[0] ^ xors[child1];\\n          xor1 = xors[child1] ^ xors[child2];\\n          xor2 = xors[child2];\\n        } else if (is_parent(enter_clocks, exit_clocks, child2, parent1)) {\\n          // the subtree rooted by the node labeled `child1` is the subtree\\n          // of the subtree rooted by the node labeled `child2`\\n          xor0 = xors[0] ^ xors[child2];\\n          xor1 = xors[child1];\\n          xor2 = xors[child2] ^ xors[child1];\\n        } else {\\n          // the subtree rooted by the node labeled `child1`\\n          // and the subtree rooted by the node labeled `child2`\\n          // don\\'t have the parent-child relationship\\n          xor0 = xors[0] ^ xors[child1] ^ xors[child2];\\n          xor1 = xors[child1];\\n          xor2 = xors[child2];\\n        }\\n        ret = min(ret, max({xor0, xor1, xor2}) - min({xor0, xor1, xor2}));\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * get the parent and child node label of the edge `edge`\\n   * @return: a pair, the first element is the parent, and the second element is the child\\n   */\\n  pair<int, int> get_parent_child(const vector<vector<int>> &edges,\\n                                  const int edge,\\n                                  const int *enter_clocks,\\n                                  const int *exit_clocks) {\\n    int parent = edges[edge][0];\\n    int child = edges[edge][1];\\n    if (!is_parent(enter_clocks, exit_clocks, parent, child)) {\\n      swap(parent, child);\\n    }\\n    return make_pair(parent, child);\\n  }\\n  \\n  int dfs(const vector<int> &nums,\\n          const vector<int> *graph,\\n          const int node,\\n          const int parent,\\n          int *xors,\\n          int *enter_clocks,\\n          int *exit_clocks,\\n          int &clock) {\\n    xors[node] = nums[node];\\n    ++clock;\\n    enter_clocks[node] = clock;\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      xors[node] ^= dfs(nums, graph, child, node, xors, enter_clocks, exit_clocks, clock);\\n    }\\n    exit_clocks[node] = clock;\\n    return xors[node];\\n  }\\n  \\n  bool is_parent(const int *enter_clocks,\\n                 const int *exit_clocks,\\n                 const int parent,\\n                 const int child) {\\n    return enter_clocks[parent] <= enter_clocks[child] && exit_clocks[parent] >= enter_clocks[child];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199961,
                "title": "easy-solution-with-dfs",
                "content": "![image](https://assets.leetcode.com/users/images/1d41f71d-66af-4eea-a951-a88e3bf20fa1_1656237002.8503823.png)\\n\\n\\n```\\n/*\\n     Approch:\\n     + Think problem as making three groups of nodes\\n     + each node will be atmost in one group\\n     + so root node (taking zero for simplicity) is in one group\\n     + run two nested for loop (i , j) where i is root of 2nd group and j is root of 3rd group\\n     + so it will have two scenarios\\n         + when two groups overlaps\\n         + when two groups not overlaps\\n         \\n     more detailed solution : https://www.youtube.com/watch?v=hZRn3ZL0NVE\\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    //store the xor of all nodes in subtree\\n    vector<int> xorOfSubtree;\\n    //values given\\n    vector<int> nums;\\n    vector<vector<int>> graph;\\n    //store all the parents of currnt Node\\n    vector<set<int>> parentOf;\\n    \\n    \\n    // to store xor of element of subtree\\n    void dfs(int cur , int parent){\\n        xorOfSubtree[cur] = nums[cur];\\n        for(auto x : graph[cur]){\\n            if(x == parent) continue;\\n            dfs(x , cur);\\n            xorOfSubtree[cur] ^= xorOfSubtree[x];\\n        }\\n    }\\n    \\n    \\n    // store the parents of node\\n    void addParent(int idx, vector<int> &v , int parent){\\n        parentOf[idx].insert(v.begin() , v.end());\\n        v.push_back(idx);\\n        for(auto x : graph[idx]){\\n            if(x == parent) continue;\\n            addParent(x , v , idx);\\n        }\\n        v.pop_back();\\n    }\\n    \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        graph.resize(n);\\n        parentOf.resize(n);\\n        xorOfSubtree.resize(n);\\n        this->nums = nums;\\n        \\n        for(auto x : edges){\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        \\n        vector<int> v = {};\\n        dfs(0 , -1);\\n        addParent(0 , v , -1);\\n        \\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = i + 1 ; j < n ; j++){\\n                if(parentOf[i].find(j) != parentOf[i].end()){\\n                    //if j is parent of i\\n                    int valofi = xorOfSubtree[i];\\n                    int valofj = xorOfSubtree[j]^valofi;\\n                    int valofroot = xorOfSubtree[0]^xorOfSubtree[j];\\n                    ans = min(ans , max({valofi , valofj , valofroot}) - min({valofi , valofj , valofroot}));\\n                    \\n                }else if(parentOf[j].find(i) != parentOf[j].end()){\\n                    //if i is parent of j\\n                    int valofj = xorOfSubtree[j];\\n                    int valofi = xorOfSubtree[i]^valofj;\\n                    int valofroot = xorOfSubtree[0]^xorOfSubtree[i];\\n                    ans = min(ans , max({valofi , valofj , valofroot}) - min({valofi , valofj , valofroot}));\\n                    \\n                }else{\\n                    //if both i and j are different\\n                    int valofi = xorOfSubtree[i];\\n                    int valofj = xorOfSubtree[j];\\n                    int valofroot = xorOfSubtree[0]^valofi^valofj;\\n                    ans = min(ans , max({valofi , valofj , valofroot}) - min({valofi , valofj , valofroot}));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nmore detailed solution : https://www.youtube.com/watch?v=hZRn3ZL0NVE\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n     Approch:\\n     + Think problem as making three groups of nodes\\n     + each node will be atmost in one group\\n     + so root node (taking zero for simplicity) is in one group\\n     + run two nested for loop (i , j) where i is root of 2nd group and j is root of 3rd group\\n     + so it will have two scenarios\\n         + when two groups overlaps\\n         + when two groups not overlaps\\n         \\n     more detailed solution : https://www.youtube.com/watch?v=hZRn3ZL0NVE\\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    //store the xor of all nodes in subtree\\n    vector<int> xorOfSubtree;\\n    //values given\\n    vector<int> nums;\\n    vector<vector<int>> graph;\\n    //store all the parents of currnt Node\\n    vector<set<int>> parentOf;\\n    \\n    \\n    // to store xor of element of subtree\\n    void dfs(int cur , int parent){\\n        xorOfSubtree[cur] = nums[cur];\\n        for(auto x : graph[cur]){\\n            if(x == parent) continue;\\n            dfs(x , cur);\\n            xorOfSubtree[cur] ^= xorOfSubtree[x];\\n        }\\n    }\\n    \\n    \\n    // store the parents of node\\n    void addParent(int idx, vector<int> &v , int parent){\\n        parentOf[idx].insert(v.begin() , v.end());\\n        v.push_back(idx);\\n        for(auto x : graph[idx]){\\n            if(x == parent) continue;\\n            addParent(x , v , idx);\\n        }\\n        v.pop_back();\\n    }\\n    \\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        graph.resize(n);\\n        parentOf.resize(n);\\n        xorOfSubtree.resize(n);\\n        this->nums = nums;\\n        \\n        for(auto x : edges){\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        \\n        vector<int> v = {};\\n        dfs(0 , -1);\\n        addParent(0 , v , -1);\\n        \\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = i + 1 ; j < n ; j++){\\n                if(parentOf[i].find(j) != parentOf[i].end()){\\n                    //if j is parent of i\\n                    int valofi = xorOfSubtree[i];\\n                    int valofj = xorOfSubtree[j]^valofi;\\n                    int valofroot = xorOfSubtree[0]^xorOfSubtree[j];\\n                    ans = min(ans , max({valofi , valofj , valofroot}) - min({valofi , valofj , valofroot}));\\n                    \\n                }else if(parentOf[j].find(i) != parentOf[j].end()){\\n                    //if i is parent of j\\n                    int valofj = xorOfSubtree[j];\\n                    int valofi = xorOfSubtree[i]^valofj;\\n                    int valofroot = xorOfSubtree[0]^xorOfSubtree[i];\\n                    ans = min(ans , max({valofi , valofj , valofroot}) - min({valofi , valofj , valofroot}));\\n                    \\n                }else{\\n                    //if both i and j are different\\n                    int valofi = xorOfSubtree[i];\\n                    int valofj = xorOfSubtree[j];\\n                    int valofroot = xorOfSubtree[0]^valofi^valofj;\\n                    ans = min(ans , max({valofi , valofj , valofroot}) - min({valofi , valofj , valofroot}));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199625,
                "title": "c-single-dfs-in-and-out-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n, t;\\n    vector<vector<int> > adj;\\n    vector<int> in, out, dp, a;\\n    \\n    void dfs(int v, int p){\\n        in[v]=t++;\\n        dp[v]=a[v];\\n        for(int to: adj[v]){\\n            if(to==p){\\n                continue;\\n            }\\n            dfs(to, v);\\n            dp[v]^=dp[to];\\n        }\\n        out[v]=t++;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        n=nums.size(), t=0, a=nums;\\n        in=out=dp=vector<int>(n);\\n        adj=vector<vector<int> >(n);\\n        for(auto& itr: edges){\\n            adj[itr[0]].push_back(itr[1]);\\n            adj[itr[1]].push_back(itr[0]);\\n        }\\n        dfs(0, -1);\\n        int ans=2000000000;\\n        for(int i=0; i<edges.size(); i++){\\n            for(int j=i+1; j<edges.size(); j++){\\n                int n1=(in[edges[i][0]]>in[edges[i][1]]?edges[i][0]:edges[i][1]);\\n                int n2=(in[edges[j][0]]>in[edges[j][1]]?edges[j][0]:edges[j][1]);\\n                int x, y, z;\\n                if(in[n1]>in[n2] && out[n2]>out[n1]){\\n                    // n1 in subtree of n2\\n                    x=(dp[0]^dp[n2]);\\n                    y=(dp[n2]^dp[n1]);\\n                    z=dp[n1];\\n                }\\n                else if(in[n2]>in[n1] && out[n1]>out[n2]){\\n                    // n2 in subtree of n1\\n                    x=(dp[0]^dp[n1]);\\n                    y=(dp[n1]^dp[n2]);\\n                    z=dp[n2];\\n                }\\n                else{\\n                    x=(dp[0]^dp[n1]^dp[n2]);\\n                    y=dp[n1];\\n                    z=dp[n2];\\n                }\\n                ans=min(ans, max({x, y, z})-min({x, y, z}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n, t;\\n    vector<vector<int> > adj;\\n    vector<int> in, out, dp, a;\\n    \\n    void dfs(int v, int p){\\n        in[v]=t++;\\n        dp[v]=a[v];\\n        for(int to: adj[v]){\\n            if(to==p){\\n                continue;\\n            }\\n            dfs(to, v);\\n            dp[v]^=dp[to];\\n        }\\n        out[v]=t++;\\n    }\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        n=nums.size(), t=0, a=nums;\\n        in=out=dp=vector<int>(n);\\n        adj=vector<vector<int> >(n);\\n        for(auto& itr: edges){\\n            adj[itr[0]].push_back(itr[1]);\\n            adj[itr[1]].push_back(itr[0]);\\n        }\\n        dfs(0, -1);\\n        int ans=2000000000;\\n        for(int i=0; i<edges.size(); i++){\\n            for(int j=i+1; j<edges.size(); j++){\\n                int n1=(in[edges[i][0]]>in[edges[i][1]]?edges[i][0]:edges[i][1]);\\n                int n2=(in[edges[j][0]]>in[edges[j][1]]?edges[j][0]:edges[j][1]);\\n                int x, y, z;\\n                if(in[n1]>in[n2] && out[n2]>out[n1]){\\n                    // n1 in subtree of n2\\n                    x=(dp[0]^dp[n2]);\\n                    y=(dp[n2]^dp[n1]);\\n                    z=dp[n1];\\n                }\\n                else if(in[n2]>in[n1] && out[n1]>out[n2]){\\n                    // n2 in subtree of n1\\n                    x=(dp[0]^dp[n1]);\\n                    y=(dp[n1]^dp[n2]);\\n                    z=dp[n2];\\n                }\\n                else{\\n                    x=(dp[0]^dp[n1]^dp[n2]);\\n                    y=dp[n1];\\n                    z=dp[n2];\\n                }\\n                ans=min(ans, max({x, y, z})-min({x, y, z}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199618,
                "title": "c-dfs",
                "content": "```\\nint ans,crnt,other;\\nint rt;\\nint dfs(int u,int pv,vector<int>& a, vector<vector<int>>& g,vector<int>& sz,vector<int>& prnt)\\n{\\n    sz[u] = a[u];\\n    prnt[u] = pv;\\n    for(int i:g[u])\\n    {\\n        if(i==pv)continue;\\n        sz[u]^=dfs(i,u,a,g,sz,prnt);\\n    }\\n    return sz[u];\\n}\\nint dfs1(int u,int pv,vector<int>& a, vector<vector<int>>& g)\\n{\\n    int res = a[u];\\n    for(int i:g[u])\\n    {\\n        if(i==pv)continue;\\n        res^=dfs1(i,u,a,g);\\n    }\\n    int rem = crnt^res;\\n    int mx = max({rem,res,other});\\n    int mn = min({rem,res,other});\\n    if(rt!=u)ans = min(ans,mx-mn);\\n    return res;\\n}\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& a, vector<vector<int>>& e) {\\n        int n = a.size();\\n        vector<vector<int>> g(n);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int> sz(n,0);\\n        vector<int> prnt(n);\\n        int all = dfs(0,-1,a,g,sz,prnt);\\n        int res = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int c = e[i][0] , p = e[i][1];\\n            if(prnt[p]==c)swap(c,p);\\n            //for child\\n            ans = INT_MAX;\\n            rt = c;\\n            crnt = sz[c];\\n            other = all^crnt;\\n            dfs1(c,p,a,g);\\n            res = min(ans,res);\\n            ///for prnt\\n            ans = INT_MAX;\\n            rt = p;\\n            crnt = all^sz[c];\\n            other = sz[c];\\n            dfs1(p,c,a,g);\\n            res = min(ans,res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint ans,crnt,other;\\nint rt;\\nint dfs(int u,int pv,vector<int>& a, vector<vector<int>>& g,vector<int>& sz,vector<int>& prnt)\\n{\\n    sz[u] = a[u];\\n    prnt[u] = pv;\\n    for(int i:g[u])\\n    {\\n        if(i==pv)continue;\\n        sz[u]^=dfs(i,u,a,g,sz,prnt);\\n    }\\n    return sz[u];\\n}\\nint dfs1(int u,int pv,vector<int>& a, vector<vector<int>>& g)\\n{\\n    int res = a[u];\\n    for(int i:g[u])\\n    {\\n        if(i==pv)continue;\\n        res^=dfs1(i,u,a,g);\\n    }\\n    int rem = crnt^res;\\n    int mx = max({rem,res,other});\\n    int mn = min({rem,res,other});\\n    if(rt!=u)ans = min(ans,mx-mn);\\n    return res;\\n}\\nclass Solution {\\npublic:\\n    int minimumScore(vector<int>& a, vector<vector<int>>& e) {\\n        int n = a.size();\\n        vector<vector<int>> g(n);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int> sz(n,0);\\n        vector<int> prnt(n);\\n        int all = dfs(0,-1,a,g,sz,prnt);\\n        int res = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int c = e[i][0] , p = e[i][1];\\n            if(prnt[p]==c)swap(c,p);\\n            //for child\\n            ans = INT_MAX;\\n            rt = c;\\n            crnt = sz[c];\\n            other = all^crnt;\\n            dfs1(c,p,a,g);\\n            res = min(ans,res);\\n            ///for prnt\\n            ans = INT_MAX;\\n            rt = p;\\n            crnt = all^sz[c];\\n            other = sz[c];\\n            dfs1(p,c,a,g);\\n            res = min(ans,res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199445,
                "title": "python-dfs-with-offspring-sets",
                "content": "```\\nclass Solution(object):\\n    def minimumScore(self, nums, edges):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(i):\\n            for j in adj[i]:\\n                if len(off[j]) == 0:\\n                    off[i].add(j)\\n                    dfs(j)\\n                    off[i] = off[i].union(off[j])\\n                    xor[i] ^= xor[j]\\n        \\n        ret = float(\\'inf\\')\\n        n = len(nums)\\n        \\n        # xor value of each subtree i\\n        xor = nums[:]\\n        # offsprings of node i\\n        off = [set() for i in range(n)]\\n        # adjacency list\\n        adj = [[] for _ in range(n)]\\n        \\n        for f, t in edges:\\n            adj[f].append(t)\\n            adj[t].append(f)\\n        dfs(0)\\n        \\n        E = len(edges)\\n        for i in range(E-1):\\n            # select the first edge to remove and get subtree node t1\\n            f1, t1 = edges[i]\\n            if f1 in off[t1]:\\n                f1,t1 = t1,f1\\n            \\n            for j in range(i+1, E):\\n                # select the second edge to remove and get subtree node t2\\n                f2, t2 = edges[j]\\n                if f2 in off[t2]:\\n                    f2,t2 = t2,f2\\n                \\n                if t1 in off[t2]:\\n                    # if t2 is offspring of t1\\n                    x0 = xor[0] ^ xor[t2]\\n                    x1 = xor[t1]\\n                    x2 = xor[t2] ^ xor[t1]\\n                elif t2 in off[t1]:\\n                    # if t1 is offspring of t2\\n                    x0 = xor[0] ^ xor[t1] \\n                    x1 = xor[t2]\\n                    x2 = xor[t1] ^ xor[t2]\\n                else:\\n                    # t1, t2 are in different branches\\n                    x0 = xor[0] ^ xor[t1] ^ xor[t2]\\n                    x1 = xor[t1]\\n                    x2 = xor[t2]\\n\\n                ret = min(ret, max([x0, x1, x2]) - min([x0, x1, x2]))\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumScore(self, nums, edges):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(i):\\n            for j in adj[i]:\\n                if len(off[j]) == 0:\\n                    off[i].add(j)\\n                    dfs(j)\\n                    off[i] = off[i].union(off[j])\\n                    xor[i] ^= xor[j]\\n        \\n        ret = float(\\'inf\\')\\n        n = len(nums)\\n        \\n        # xor value of each subtree i\\n        xor = nums[:]\\n        # offsprings of node i\\n        off = [set() for i in range(n)]\\n        # adjacency list\\n        adj = [[] for _ in range(n)]\\n        \\n        for f, t in edges:\\n            adj[f].append(t)\\n            adj[t].append(f)\\n        dfs(0)\\n        \\n        E = len(edges)\\n        for i in range(E-1):\\n            # select the first edge to remove and get subtree node t1\\n            f1, t1 = edges[i]\\n            if f1 in off[t1]:\\n                f1,t1 = t1,f1\\n            \\n            for j in range(i+1, E):\\n                # select the second edge to remove and get subtree node t2\\n                f2, t2 = edges[j]\\n                if f2 in off[t2]:\\n                    f2,t2 = t2,f2\\n                \\n                if t1 in off[t2]:\\n                    # if t2 is offspring of t1\\n                    x0 = xor[0] ^ xor[t2]\\n                    x1 = xor[t1]\\n                    x2 = xor[t2] ^ xor[t1]\\n                elif t2 in off[t1]:\\n                    # if t1 is offspring of t2\\n                    x0 = xor[0] ^ xor[t1] \\n                    x1 = xor[t2]\\n                    x2 = xor[t1] ^ xor[t2]\\n                else:\\n                    # t1, t2 are in different branches\\n                    x0 = xor[0] ^ xor[t1] ^ xor[t2]\\n                    x1 = xor[t1]\\n                    x2 = xor[t2]\\n\\n                ret = min(ret, max([x0, x1, x2]) - min([x0, x1, x2]))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199358,
                "title": "python-3-dynamic-programming-time-complexity-o-n-2-space-complexity-o-n",
                "content": "**Explaination:**\\nEdge e1 divides the tree into forest X1 and X2.\\nEdge e2 can either be part of X1 or X2.\\nVertex of e2 whose depth is greater would be part of forest X3.\\n\\n```python\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        \\n        n = len(nums)\\n        graph = {i:[] for i in range(n)}\\n        \\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        # DFS: i=node, lvl=depth/level from the root\\n        def recdp(i, lvl):\\n            cforest.add(i)\\n            xor = nums[i]\\n            for j in graph[i]:\\n                if (j not in cforest):\\n                    xor ^= recdp(j, lvl+1)\\n            level[i] = lvl\\n            x[i] = xor\\n            parent[i] = forest\\n            return xor\\n        \\n        ret = float(\\'inf\\')\\n        \\n        # DP Table\\n        level = [0]*n\\n        x = [0]*n\\n        parent = [0]*n\\n\\n        for e1 in range(len(edges)):\\n            cforest = set()\\n            cforest.add(edges[e1][1])\\n            forest = 1\\n            # DFS from one vertex of e1\\n            X1 = recdp(edges[e1][0], 0)\\n            forest = 2\\n            # DFS from second vertex of e1\\n            X2 = recdp(edges[e1][1], 0)\\n            # print(X1, X2, X1^X2, total)\\n            \\n            for e2 in range(e1+1,len(edges)):\\n                x1, x2 = X1, X2\\n                # Removing Edge e2; xors are already calculated in x\\n                if level[edges[e2][0]] > level[edges[e2][1]]:\\n                    x3 = x[edges[e2][0]]\\n                else:\\n                    x3 = x[edges[e2][1]]\\n                # Check If Edge e2 was part of X1-forest or X2-forest\\n                if parent[edges[e2][0]] == 1:\\n                    x1 = x1^x3\\n                else:\\n                    x2 = x2^x3\\n                arr = sorted([x1,x2,x3])\\n                ret =  min(ret, arr[-1] - arr[0])\\n\\n        return (ret)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        \\n        n = len(nums)\\n        graph = {i:[] for i in range(n)}\\n        \\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        # DFS: i=node, lvl=depth/level from the root\\n        def recdp(i, lvl):\\n            cforest.add(i)\\n            xor = nums[i]\\n            for j in graph[i]:\\n                if (j not in cforest):\\n                    xor ^= recdp(j, lvl+1)\\n            level[i] = lvl\\n            x[i] = xor\\n            parent[i] = forest\\n            return xor\\n        \\n        ret = float(\\'inf\\')\\n        \\n        # DP Table\\n        level = [0]*n\\n        x = [0]*n\\n        parent = [0]*n\\n\\n        for e1 in range(len(edges)):\\n            cforest = set()\\n            cforest.add(edges[e1][1])\\n            forest = 1\\n            # DFS from one vertex of e1\\n            X1 = recdp(edges[e1][0], 0)\\n            forest = 2\\n            # DFS from second vertex of e1\\n            X2 = recdp(edges[e1][1], 0)\\n            # print(X1, X2, X1^X2, total)\\n            \\n            for e2 in range(e1+1,len(edges)):\\n                x1, x2 = X1, X2\\n                # Removing Edge e2; xors are already calculated in x\\n                if level[edges[e2][0]] > level[edges[e2][1]]:\\n                    x3 = x[edges[e2][0]]\\n                else:\\n                    x3 = x[edges[e2][1]]\\n                # Check If Edge e2 was part of X1-forest or X2-forest\\n                if parent[edges[e2][0]] == 1:\\n                    x1 = x1^x3\\n                else:\\n                    x2 = x2^x3\\n                arr = sorted([x1,x2,x3])\\n                ret =  min(ret, arr[-1] - arr[0])\\n\\n        return (ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199356,
                "title": "python3-using-dfs-and-xor-of-each-subtree",
                "content": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        tree = [set() for _ in range(n)]\\n        for e in edges:\\n            tree[e[0]].add(e[1])\\n            tree[e[1]].add(e[0])\\n\\n        def make_tree(i, parent):\\n            ancestors[i].add(parent)\\n            for j in ancestors[parent]:\\n                ancestors[i].add(j)\\n            tree[i].remove(parent)\\n            for child in tree[i]:\\n                make_tree(child, i)\\n                xor[i] ^= xor[child]\\n\\n        xor = [nums[i] for i in range(n)]\\n        ancestors = [set() for _ in range(n)]\\n        for child in tree[0]:\\n            make_tree(child, 0)\\n            xor[0] ^= xor[child]\\n\\n        ans = 2 ** 31 - 1\\n        for i in range(1, n - 1):\\n            for j in range(i + 1, n):\\n                if i in ancestors[j]:\\n                    parts = [xor[0] ^ xor[i], xor[i] ^ xor[j], xor[j]]\\n                elif j in ancestors[i]:\\n                    parts = [xor[0] ^ xor[j], xor[i], xor[i] ^ xor[j]]\\n                else:\\n                    parts = [xor[0] ^ xor[i] ^ xor[j], xor[i], xor[j]]\\n                ans = min(ans, max(parts) - min(parts))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        tree = [set() for _ in range(n)]\\n        for e in edges:\\n            tree[e[0]].add(e[1])\\n            tree[e[1]].add(e[0])\\n\\n        def make_tree(i, parent):\\n            ancestors[i].add(parent)\\n            for j in ancestors[parent]:\\n                ancestors[i].add(j)\\n            tree[i].remove(parent)\\n            for child in tree[i]:\\n                make_tree(child, i)\\n                xor[i] ^= xor[child]\\n\\n        xor = [nums[i] for i in range(n)]\\n        ancestors = [set() for _ in range(n)]\\n        for child in tree[0]:\\n            make_tree(child, 0)\\n            xor[0] ^= xor[child]\\n\\n        ans = 2 ** 31 - 1\\n        for i in range(1, n - 1):\\n            for j in range(i + 1, n):\\n                if i in ancestors[j]:\\n                    parts = [xor[0] ^ xor[i], xor[i] ^ xor[j], xor[j]]\\n                elif j in ancestors[i]:\\n                    parts = [xor[0] ^ xor[j], xor[i], xor[i] ^ xor[j]]\\n                else:\\n                    parts = [xor[0] ^ xor[i] ^ xor[j], xor[i], xor[j]]\\n                ans = min(ans, max(parts) - min(parts))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199219,
                "title": "easy-inefficient-working-solution-o-n-3",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    ll n, bigxo = 0;\\n    vi(unordered_set<ll>)adj;\\n\\n    ll bfs(const vi(int)& val, const vi(int)& cur) {\\n        ll xo = 0;\\n        queue<pi>q;\\n        vi(ll)vis(n);\\n        q.push(pi(cur[0], -1));\\n        vis[cur[0]] = true;\\n        while (!q.empty()) {\\n            pi p = q.front();\\n            q.pop();\\n            xo ^= val[p.first];\\n            for (const int& ti : adj[p.first]) {\\n                if (vis[ti] || ti == p.second || ti == cur[1])\\n                    continue;\\n                q.push(pi(ti, p.first));\\n                vis[ti] = true;\\n            }\\n        }\\n        return xo;\\n    }\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& pts) {\\n        n = nums.size();\\n        adj.resize(n);\\n        for (const int& i : nums)\\n            bigxo ^= i;\\n        for (const auto& it : pts) {\\n            adj[it[0]].insert(it[1]);\\n            adj[it[1]].insert(it[0]);\\n        }\\n        ll ans = LLONG_MAX;\\n        for (ll i = 0;i < pts.size();++i) {\\n            adj[pts[i][0]].erase(pts[i][1]);\\n            adj[pts[i][1]].erase(pts[i][0]);\\n            ll curxo = bfs(nums, pts[i]);\\n            for (ll j = i + 1;j < pts.size();++j) {\\n                adj[pts[j][0]].erase(pts[j][1]);\\n                adj[pts[j][1]].erase(pts[j][0]);\\n                ll curxo2 = bfs(nums, pts[j]);\\n                vi(ll)tmp = { curxo, curxo2, bigxo ^ curxo ^ curxo2 };\\n                // for(auto it:tmp)\\n                //     cout<<it<<\\' \\';\\n                // cout<<endl;\\n                ans = min(ans, *max_element(tmp.begin(), tmp.end()) - *min_element(tmp.begin(), tmp.end()));\\n                adj[pts[j][0]].insert(pts[j][1]);\\n                adj[pts[j][1]].insert(pts[j][0]);\\n            }\\n            adj[pts[i][0]].insert(pts[i][1]);\\n            adj[pts[i][1]].insert(pts[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    ll n, bigxo = 0;\\n    vi(unordered_set<ll>)adj;\\n\\n    ll bfs(const vi(int)& val, const vi(int)& cur) {\\n        ll xo = 0;\\n        queue<pi>q;\\n        vi(ll)vis(n);\\n        q.push(pi(cur[0], -1));\\n        vis[cur[0]] = true;\\n        while (!q.empty()) {\\n            pi p = q.front();\\n            q.pop();\\n            xo ^= val[p.first];\\n            for (const int& ti : adj[p.first]) {\\n                if (vis[ti] || ti == p.second || ti == cur[1])\\n                    continue;\\n                q.push(pi(ti, p.first));\\n                vis[ti] = true;\\n            }\\n        }\\n        return xo;\\n    }\\n\\n    int minimumScore(vector<int>& nums, vector<vector<int>>& pts) {\\n        n = nums.size();\\n        adj.resize(n);\\n        for (const int& i : nums)\\n            bigxo ^= i;\\n        for (const auto& it : pts) {\\n            adj[it[0]].insert(it[1]);\\n            adj[it[1]].insert(it[0]);\\n        }\\n        ll ans = LLONG_MAX;\\n        for (ll i = 0;i < pts.size();++i) {\\n            adj[pts[i][0]].erase(pts[i][1]);\\n            adj[pts[i][1]].erase(pts[i][0]);\\n            ll curxo = bfs(nums, pts[i]);\\n            for (ll j = i + 1;j < pts.size();++j) {\\n                adj[pts[j][0]].erase(pts[j][1]);\\n                adj[pts[j][1]].erase(pts[j][0]);\\n                ll curxo2 = bfs(nums, pts[j]);\\n                vi(ll)tmp = { curxo, curxo2, bigxo ^ curxo ^ curxo2 };\\n                // for(auto it:tmp)\\n                //     cout<<it<<\\' \\';\\n                // cout<<endl;\\n                ans = min(ans, *max_element(tmp.begin(), tmp.end()) - *min_element(tmp.begin(), tmp.end()));\\n                adj[pts[j][0]].insert(pts[j][1]);\\n                adj[pts[j][1]].insert(pts[j][0]);\\n            }\\n            adj[pts[i][0]].insert(pts[i][1]);\\n            adj[pts[i][1]].insert(pts[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2199132,
                "title": "union-find-c-o-n-2-time-o-n-2-space-code-explanation",
                "content": "## IDEA : Union Find \\n\\n#### Brute force Approch : O(n^3 ) \\n\\nIterate over every combination of 2 edges and remove them from tree . We would get 3 components . Then using union-find  find which node belong to which component . This way we would get xor of all three components.\\n\\n#### Efficient Approach : O(n^2) \\n\\n**Precompute :** Store the Xor of 2 components formed when we remove the ith edge in the edges array -**O(n^2)**\\nIdea is to Iterate over every combination of 2 edges and remove them from tree. Get the xor of 3 components in **O(1)**\\nRemoving 2 edges would give us 3 components. \\none end of each of the 2 edges removed would be in a separate component while the other ends would lie in a same component .\\n\\n**Note : we would use formula :**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tA xor B = C \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tA xor B xor B = C xor B\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tA = C xor B \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    \\n//Disjoint Set Union   \\n    int parent[1001];\\n    int rank[1001];\\n    \\n    int find_set(int v) {\\n        \\n        if (v == parent[v])\\n            return v;\\n        \\n        return parent[v] = find_set(parent[v]);\\n    }\\n\\n    void union_sets(int a, int b) {\\n        \\n        a = find_set(a);\\n        b = find_set(b);\\n        if (a != b) {\\n            if (rank[a] < rank[b])\\n                swap(a, b);\\n            parent[b] = a;\\n            if (rank[a] == rank[b])\\n                rank[a]++;\\n        }\\n    }\\n\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        \\n        //Suppose we remove the ith edge of the edges , we would get 2 components let us precompute the xor for every one edge removal \\n        //xori[i][0] stores the xor of all the values of the nodes of component containing edges[i][0] if ith edge in edges is removed\\n        \\n        //xori[i][1] stores the xor of all the values of the nodes of component containing edges[i][1] if ith edge in edges is removed\\n        vector<vector<int>> xori;\\n        \\n        \\n        //check[i] stores the information which node belongs to which component if ith edge in edges is removed\\n        vector<int> check[n-1];\\n       \\n        \\n        for(int i=0;i<n-1;i++){\\n            \\n            //Intializing Disjoint set \\n            for(int j=0;j<n;j++){\\n                parent[j]=j;\\n                rank[j]=0;\\n            }\\n            \\n            // Consider every edge for union except the ith edge as it is removed\\n            for(int j=0;j<n-1;j++){\\n                if (j==i){\\n                    continue;\\n                }\\n                int al = edges[j][0];\\n                int bl = edges[j][1];\\n                union_sets(al,bl);\\n            }\\n            \\n            // computing xor of each of the two components formed\\n            int parent_a = find_set(edges[i][0]);\\n            int parent_b = find_set(edges[i][1]);\\n            int xora = 0;\\n            int xorb = 0;\\n            for(int j=0;j<n;j++){\\n                check[i].push_back(find_set(j));\\n                if (find_set(j)==parent_a){\\n                    xora^=nums[j];\\n                }\\n                else if (find_set(j)==parent_b){\\n                    xorb^=nums[j];\\n                }\\n            }\\n            //storing xor of each of the two components formed\\n            xori.push_back({xora,xorb});\\n            \\n            \\n            \\n        }\\n        \\n        //  looping over every 2 distinct edges of the tree , removing it and then computing xor of the three components   in O(n^2) using information from check and xori \\n        int ans =1e9;\\n         for(int i=0;i<n-1;i++){\\n               auto a = edges[i][0];\\n             auto b = edges[i][1];\\n              int comp1;\\n              int sumi;\\n              \\n             for(int j=0;j<n-1;j++){\\n                 if (j==i){\\n                     continue;\\n                 }\\n                  \\n                \\n                 int comp2;\\n                 \\n                   auto c = edges[j][0];\\n                   auto d = edges[j][1];\\n                 if (check[i][a]==check[i][c]){\\n                     comp1=xori[i][1];\\n                     sumi=xori[i][0];\\n                     if (check[j][a]==check[j][c]){\\n                         comp2=xori[j][1];\\n                     }\\n                     else{\\n                         comp2=xori[j][0];\\n                     }\\n                 }\\n                 else{\\n                     comp1=xori[i][0];\\n                     sumi=xori[i][1];\\n                     if (check[j][b]==check[j][c]){\\n                         comp2=xori[j][1];\\n                     }\\n                     else{\\n                         comp2=xori[j][0];\\n                     }\\n                 }\\n                 \\n                 \\n                 \\n                 int comp3 =sumi^comp2;\\n                 int maxi=max(comp1 ,max(comp2,comp3));\\n                 int mini=min(comp1 ,min(comp2,comp3));\\n                 ans=min(ans,maxi-mini);\\n             }\\n         }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n//Disjoint Set Union   \\n    int parent[1001];\\n    int rank[1001];\\n    \\n    int find_set(int v) {\\n        \\n        if (v == parent[v])\\n            return v;\\n        \\n        return parent[v] = find_set(parent[v]);\\n    }\\n\\n    void union_sets(int a, int b) {\\n        \\n        a = find_set(a);\\n        b = find_set(b);\\n        if (a != b) {\\n            if (rank[a] < rank[b])\\n                swap(a, b);\\n            parent[b] = a;\\n            if (rank[a] == rank[b])\\n                rank[a]++;\\n        }\\n    }\\n\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        \\n        //Suppose we remove the ith edge of the edges , we would get 2 components let us precompute the xor for every one edge removal \\n        //xori[i][0] stores the xor of all the values of the nodes of component containing edges[i][0] if ith edge in edges is removed\\n        \\n        //xori[i][1] stores the xor of all the values of the nodes of component containing edges[i][1] if ith edge in edges is removed\\n        vector<vector<int>> xori;\\n        \\n        \\n        //check[i] stores the information which node belongs to which component if ith edge in edges is removed\\n        vector<int> check[n-1];\\n       \\n        \\n        for(int i=0;i<n-1;i++){\\n            \\n            //Intializing Disjoint set \\n            for(int j=0;j<n;j++){\\n                parent[j]=j;\\n                rank[j]=0;\\n            }\\n            \\n            // Consider every edge for union except the ith edge as it is removed\\n            for(int j=0;j<n-1;j++){\\n                if (j==i){\\n                    continue;\\n                }\\n                int al = edges[j][0];\\n                int bl = edges[j][1];\\n                union_sets(al,bl);\\n            }\\n            \\n            // computing xor of each of the two components formed\\n            int parent_a = find_set(edges[i][0]);\\n            int parent_b = find_set(edges[i][1]);\\n            int xora = 0;\\n            int xorb = 0;\\n            for(int j=0;j<n;j++){\\n                check[i].push_back(find_set(j));\\n                if (find_set(j)==parent_a){\\n                    xora^=nums[j];\\n                }\\n                else if (find_set(j)==parent_b){\\n                    xorb^=nums[j];\\n                }\\n            }\\n            //storing xor of each of the two components formed\\n            xori.push_back({xora,xorb});\\n            \\n            \\n            \\n        }\\n        \\n        //  looping over every 2 distinct edges of the tree , removing it and then computing xor of the three components   in O(n^2) using information from check and xori \\n        int ans =1e9;\\n         for(int i=0;i<n-1;i++){\\n               auto a = edges[i][0];\\n             auto b = edges[i][1];\\n              int comp1;\\n              int sumi;\\n              \\n             for(int j=0;j<n-1;j++){\\n                 if (j==i){\\n                     continue;\\n                 }\\n                  \\n                \\n                 int comp2;\\n                 \\n                   auto c = edges[j][0];\\n                   auto d = edges[j][1];\\n                 if (check[i][a]==check[i][c]){\\n                     comp1=xori[i][1];\\n                     sumi=xori[i][0];\\n                     if (check[j][a]==check[j][c]){\\n                         comp2=xori[j][1];\\n                     }\\n                     else{\\n                         comp2=xori[j][0];\\n                     }\\n                 }\\n                 else{\\n                     comp1=xori[i][0];\\n                     sumi=xori[i][1];\\n                     if (check[j][b]==check[j][c]){\\n                         comp2=xori[j][1];\\n                     }\\n                     else{\\n                         comp2=xori[j][0];\\n                     }\\n                 }\\n                 \\n                 \\n                 \\n                 int comp3 =sumi^comp2;\\n                 int maxi=max(comp1 ,max(comp2,comp3));\\n                 int mini=min(comp1 ,min(comp2,comp3));\\n                 ans=min(ans,maxi-mini);\\n             }\\n         }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199078,
                "title": "python-3-dfs-then-iterate-all-cuts-explained",
                "content": "Given a tree, we need to cut two edges, and then calculated xor of the resulting three subtrees.\\n\\nFirstly, we take an arbituary node as root (0 taken in mine), and then DFS to traverse the tree, find ancestors for each node, and calculate xor for subtrees under each node.\\n\\nThen, O(n^2) time we iterate over all combinations of two edges and make two cuts, and use the precalculated xor values to back out xor of the three subtrees.\\n\\nTwo edges can have 3 possible relative locations:\\n1. two cuts in a same branch, first cut closer to root\\n2. two cuts in a same branch, second cut closer to root\\n3. two cuts in different branches\\n\\nWe need to precalculated ancestor array at each node to find out their relationship. For two nodes a and b in one edge, one must the the parent of the other. Then the two edges forms two parent-child pairs, [p1, c1] and [p2, c2], and the three relationships can be derived:\\n1. c1 is the ancestor of p2\\n2. c2 is the ancestor of p1\\n3. both 1 and 2 do not hold\\n\\nThen calculation of subtree xor is just like using a prefix xor array to calculate partial xor - can be found in the code.\\n\\n\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        def dfs_xor(node, path):\\n            ance[node] = set(path)\\n            path.append(node)\\n            ret = nums[node]\\n            for nxt in graph[node]:\\n                if nxt not in ance[node]:\\n                    ret ^= dfs_xor(nxt, path)\\n            path.pop() # backtrack\\n            xor[node] = ret\\n            return ret\\n        \\n        n = len(nums)\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        xor = {}\\n        ance = {}\\n        dfs_xor(0, []) # tree, use 0 as root\\n        \\n        ans = inf\\n        m = len(edges)\\n        for i in range(m - 1):\\n            # first cut, find out parent/child\\n            a, b = edges[i]\\n            if a in ance[b]:\\n                p1 = a\\n                c1 = b\\n            else:\\n                p1 = b\\n                c1 = a\\n            #\\n            for j in range(i + 1, m):\\n                # second cut, find out parent/child\\n                c, d = edges[j]\\n                if c in ance[d]:\\n                    p2 = c\\n                    c2 = d\\n                else:\\n                    p2 = d\\n                    c2 = c\\n                # \\n                if c1 in ance[p2] or c1 == p2: # two cuts in a same branch, first cut closer to root\\n                    z = xor[c2] # c2 is root of the subtree due to 2nd cut\\n                    y = xor[c1] ^ z # c1 is root of the subtree due to 1st cut\\n                    x = xor[0] ^ xor[c1]\\n                elif c2 in ance[p1] or c2 == p1: # two cuts in a same branch, second cut closer to root\\n                    z = xor[c1]\\n                    y = xor[c2] ^ z\\n                    x = xor[0] ^ xor[c2]\\n                else: # two cuts are in different branches\\n                    z = xor[c1]\\n                    y = xor[c2]\\n                    x = xor[0] ^ y ^ z\\n                ans = min(ans, max(x, y, z) - min(x, y, z))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        def dfs_xor(node, path):\\n            ance[node] = set(path)\\n            path.append(node)\\n            ret = nums[node]\\n            for nxt in graph[node]:\\n                if nxt not in ance[node]:\\n                    ret ^= dfs_xor(nxt, path)\\n            path.pop() # backtrack\\n            xor[node] = ret\\n            return ret\\n        \\n        n = len(nums)\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        xor = {}\\n        ance = {}\\n        dfs_xor(0, []) # tree, use 0 as root\\n        \\n        ans = inf\\n        m = len(edges)\\n        for i in range(m - 1):\\n            # first cut, find out parent/child\\n            a, b = edges[i]\\n            if a in ance[b]:\\n                p1 = a\\n                c1 = b\\n            else:\\n                p1 = b\\n                c1 = a\\n            #\\n            for j in range(i + 1, m):\\n                # second cut, find out parent/child\\n                c, d = edges[j]\\n                if c in ance[d]:\\n                    p2 = c\\n                    c2 = d\\n                else:\\n                    p2 = d\\n                    c2 = c\\n                # \\n                if c1 in ance[p2] or c1 == p2: # two cuts in a same branch, first cut closer to root\\n                    z = xor[c2] # c2 is root of the subtree due to 2nd cut\\n                    y = xor[c1] ^ z # c1 is root of the subtree due to 1st cut\\n                    x = xor[0] ^ xor[c1]\\n                elif c2 in ance[p1] or c2 == p1: # two cuts in a same branch, second cut closer to root\\n                    z = xor[c1]\\n                    y = xor[c2] ^ z\\n                    x = xor[0] ^ xor[c2]\\n                else: # two cuts are in different branches\\n                    z = xor[c1]\\n                    y = xor[c2]\\n                    x = xor[0] ^ y ^ z\\n                ans = min(ans, max(x, y, z) - min(x, y, z))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199015,
                "title": "java-dfs-enumerate",
                "content": "\\n\\n```\\nclass Solution {\\n    int[] xor;\\n    int[] pa;\\n    int[] height;\\n    Map<Integer, List<Integer>> adj;\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        xor = new int[nums.length];\\n        pa = new int[nums.length];\\n        height = new int[nums.length];\\n        adj = new HashMap<>();\\n        for (int[] e : edges) {\\n            adj.compute(e[0], (k, v) -> v == null ? new ArrayList<>() : v).add(e[1]);\\n            adj.compute(e[1], (k, v) -> v == null ? new ArrayList<>() : v).add(e[0]);\\n        }\\n        dfs(nums, 0, 1);\\n        int score = -1;\\n        for (int[] edge : edges) {\\n            if (height[edge[0]] > height[edge[1]]) {\\n                int tmp = edge[0];\\n                edge[0] = edge[1];\\n                edge[1] = tmp;\\n            }\\n        }\\n        for (int i = 0; i < edges.length; ++i) {\\n            for (int j = i + 1; j < edges.length; ++j) {\\n                if (onePath(edges[i], edges[j])) {\\n                    int down = height[edges[j][1]] > height[edges[i][1]] ? j : i;\\n                    int up = down == i ? j : i;\\n                    int a = xor[0] ^ xor[edges[up][1]];\\n                    int b = xor[edges[up][1]] ^ xor[edges[down][1]];\\n                    int c = xor[edges[down][1]];\\n                    if (score == -1) {\\n                        score = Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c);\\n                    } else {\\n                        score = Math.min(score, Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c));  \\n                    }\\n                }else {\\n                    int a = xor[0] ^ xor[edges[i][1]] ^ xor[edges[j][1]];\\n                    int b = xor[edges[i][1]];\\n                    int c = xor[edges[j][1]];\\n                    if (score == -1) {\\n                        score = Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c);\\n                    } else {\\n                        score = Math.min(score, Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c));  \\n                    }\\n                }\\n            }\\n        }\\n        return score;\\n    }\\n    \\n    void dfs(int[] nums, int u, int h) {\\n        height[u] = h;\\n        int x = nums[u];\\n        for (int v : adj.getOrDefault(u, Collections.emptyList())) {\\n            if (height[v] > 0) {\\n                continue;\\n            }\\n            dfs(nums, v, h + 1);\\n            pa[v] = u;\\n            x ^= xor[v];\\n        }\\n        xor[u] = x;\\n    }\\n    \\n    boolean onePath(int[] e1, int[] e2) {\\n        int start = height[e1[1]] > height[e2[1]] ? e1[1] : e2[1];\\n        int[] other = height[e1[1]] > height[e2[1]] ? e2 : e1;\\n        int cnt = 0;\\n        while(start != 0) {\\n            start = pa[start];\\n            if (start == other[0] || start == other[1]) {\\n                ++cnt;\\n            }\\n        }\\n        return cnt == 2;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] xor;\\n    int[] pa;\\n    int[] height;\\n    Map<Integer, List<Integer>> adj;\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        xor = new int[nums.length];\\n        pa = new int[nums.length];\\n        height = new int[nums.length];\\n        adj = new HashMap<>();\\n        for (int[] e : edges) {\\n            adj.compute(e[0], (k, v) -> v == null ? new ArrayList<>() : v).add(e[1]);\\n            adj.compute(e[1], (k, v) -> v == null ? new ArrayList<>() : v).add(e[0]);\\n        }\\n        dfs(nums, 0, 1);\\n        int score = -1;\\n        for (int[] edge : edges) {\\n            if (height[edge[0]] > height[edge[1]]) {\\n                int tmp = edge[0];\\n                edge[0] = edge[1];\\n                edge[1] = tmp;\\n            }\\n        }\\n        for (int i = 0; i < edges.length; ++i) {\\n            for (int j = i + 1; j < edges.length; ++j) {\\n                if (onePath(edges[i], edges[j])) {\\n                    int down = height[edges[j][1]] > height[edges[i][1]] ? j : i;\\n                    int up = down == i ? j : i;\\n                    int a = xor[0] ^ xor[edges[up][1]];\\n                    int b = xor[edges[up][1]] ^ xor[edges[down][1]];\\n                    int c = xor[edges[down][1]];\\n                    if (score == -1) {\\n                        score = Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c);\\n                    } else {\\n                        score = Math.min(score, Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c));  \\n                    }\\n                }else {\\n                    int a = xor[0] ^ xor[edges[i][1]] ^ xor[edges[j][1]];\\n                    int b = xor[edges[i][1]];\\n                    int c = xor[edges[j][1]];\\n                    if (score == -1) {\\n                        score = Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c);\\n                    } else {\\n                        score = Math.min(score, Math.max(Math.max(a, b), c) - Math.min(Math.min(a, b), c));  \\n                    }\\n                }\\n            }\\n        }\\n        return score;\\n    }\\n    \\n    void dfs(int[] nums, int u, int h) {\\n        height[u] = h;\\n        int x = nums[u];\\n        for (int v : adj.getOrDefault(u, Collections.emptyList())) {\\n            if (height[v] > 0) {\\n                continue;\\n            }\\n            dfs(nums, v, h + 1);\\n            pa[v] = u;\\n            x ^= xor[v];\\n        }\\n        xor[u] = x;\\n    }\\n    \\n    boolean onePath(int[] e1, int[] e2) {\\n        int start = height[e1[1]] > height[e2[1]] ? e1[1] : e2[1];\\n        int[] other = height[e1[1]] > height[e2[1]] ? e2 : e1;\\n        int cnt = 0;\\n        while(start != 0) {\\n            start = pa[start];\\n            if (start == other[0] || start == other[1]) {\\n                ++cnt;\\n            }\\n        }\\n        return cnt == 2;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198631,
                "title": "c-dfs-caching-xor-and-subtree",
                "content": "Preprocess the tree by doing dfs starting from 0th node, storing XOR of subtree values and collect all nodes in subtree for each node\\ni.e.\\n```\\nxors[x] = XOR of subtree of node x \\nsubtree[x] = set of all nodes in subtree of x \\n```\\n\\nNow for each pair of edges check for valid configuration of nodes and calculate required xor values.\\n\\nComplexity :\\nTime : O(n^2) : selecting pair of edges (n-1)*(n-1) and subtree lookup in O(1) due caching\\nSpace: O(n^2) : Caching subtree \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> xors;\\n    vector<unordered_set<int>> subtree;\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        \\n        vector<int> gr[n];\\n        \\n        \\n        for(int i=0;i<edges.size();i++) {\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            \\n            gr[src].push_back(dest);\\n            gr[dest].push_back(src);\\n        }\\n        \\n        xors.assign(n, 0);\\n        subtree.assign(n, unordered_set<int>());\\n        \\n        getDfs(0, -1, nums, gr);\\n        \\n        \\n        // for(int i=0;i<n;i++) {\\n        //     cout<<xors[i] << \"and  \";\\n        //      for(auto it = subtree[i].begin();it!=subtree[i].end();it++) {\\n        //         int ch = *it;\\n        //         cout<<ch<<\": \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n           \\n        \\n        int ans = 1e9;\\n        for(int i = 0;i<edges.size();i++) {\\n            for(int j = i-1; j>=0; j--) {\\n                int one = edges[i][0];\\n                int two = edges[i][1];\\n                \\n                int thr = edges[j][0];\\n                int four = edges[j][1];\\n                \\n                \\n                int x1, x2, x3;\\n                \\n                \\n                if(subtree[one].find(two) == subtree[one].end())\\n                    swap(one, two);\\n                \\n                if(subtree[thr].find(four) == subtree[thr].end()) {\\n                    swap(thr, four);\\n                }\\n                \\n                if(subtree[one].find(thr) == subtree[one].end()) {\\n                    swap(one, thr);\\n                    swap(two, four);\\n                }\\n                \\n                \\n                // cout<<one<<\": \"<<two<<\":: \"<<thr<<\": \"<<four<<\"and  \";\\n                \\n                if(subtree[two].find(thr) != subtree[two].end()) {\\n                    x1 = xors[0] ^ xors[two];\\n                    x2 = xors[two] ^ xors[four];\\n                    x3 = xors[four];\\n                } else {\\n                    x1 = xors[two];\\n                    x2 = xors[0] ^ xors[two] ^ xors[four];\\n                    x3 = xors[four];\\n                }\\n                \\n                // cout<<x1<<\" LL \"<<x2<< \" KK  \"<<x3<<\"andScore = \";\\n                int maxi = max(x1, max(x2, x3));\\n                int mini = min(x1, min(x2, x3));\\n                \\n                int score = maxi - mini;\\n                ans = min(ans, score);\\n                // cout<<score<<\": \"<<endl;\\n            }\\n        }\\n                \\n        return ans;\\n    }\\n    \\n    int getDfs(int curr, int par, vector<int>& nums, vector<int> gr[]) {\\n        \\n        int ans = nums[curr];\\n        subtree[curr].insert(curr);\\n        \\n        for(int i=0;i<gr[curr].size();i++) {\\n            int next = gr[curr][i];\\n            \\n            if(next == par)\\n                continue;\\n            \\n            \\n            ans = ans ^ getDfs(next, curr, nums, gr);\\n            for(auto it = subtree[next].begin();it!=subtree[next].end();it++) {\\n                int ch = *it;\\n                subtree[curr].insert(ch);\\n            }\\n            \\n        }\\n        xors[curr] = ans;\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nxors[x] = XOR of subtree of node x \\nsubtree[x] = set of all nodes in subtree of x \\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> xors;\\n    vector<unordered_set<int>> subtree;\\n    \\n    int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        \\n        vector<int> gr[n];\\n        \\n        \\n        for(int i=0;i<edges.size();i++) {\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            \\n            gr[src].push_back(dest);\\n            gr[dest].push_back(src);\\n        }\\n        \\n        xors.assign(n, 0);\\n        subtree.assign(n, unordered_set<int>());\\n        \\n        getDfs(0, -1, nums, gr);\\n        \\n        \\n        // for(int i=0;i<n;i++) {\\n        //     cout<<xors[i] << \"and  \";\\n        //      for(auto it = subtree[i].begin();it!=subtree[i].end();it++) {\\n        //         int ch = *it;\\n        //         cout<<ch<<\": \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n           \\n        \\n        int ans = 1e9;\\n        for(int i = 0;i<edges.size();i++) {\\n            for(int j = i-1; j>=0; j--) {\\n                int one = edges[i][0];\\n                int two = edges[i][1];\\n                \\n                int thr = edges[j][0];\\n                int four = edges[j][1];\\n                \\n                \\n                int x1, x2, x3;\\n                \\n                \\n                if(subtree[one].find(two) == subtree[one].end())\\n                    swap(one, two);\\n                \\n                if(subtree[thr].find(four) == subtree[thr].end()) {\\n                    swap(thr, four);\\n                }\\n                \\n                if(subtree[one].find(thr) == subtree[one].end()) {\\n                    swap(one, thr);\\n                    swap(two, four);\\n                }\\n                \\n                \\n                // cout<<one<<\": \"<<two<<\":: \"<<thr<<\": \"<<four<<\"and  \";\\n                \\n                if(subtree[two].find(thr) != subtree[two].end()) {\\n                    x1 = xors[0] ^ xors[two];\\n                    x2 = xors[two] ^ xors[four];\\n                    x3 = xors[four];\\n                } else {\\n                    x1 = xors[two];\\n                    x2 = xors[0] ^ xors[two] ^ xors[four];\\n                    x3 = xors[four];\\n                }\\n                \\n                // cout<<x1<<\" LL \"<<x2<< \" KK  \"<<x3<<\"andScore = \";\\n                int maxi = max(x1, max(x2, x3));\\n                int mini = min(x1, min(x2, x3));\\n                \\n                int score = maxi - mini;\\n                ans = min(ans, score);\\n                // cout<<score<<\": \"<<endl;\\n            }\\n        }\\n                \\n        return ans;\\n    }\\n    \\n    int getDfs(int curr, int par, vector<int>& nums, vector<int> gr[]) {\\n        \\n        int ans = nums[curr];\\n        subtree[curr].insert(curr);\\n        \\n        for(int i=0;i<gr[curr].size();i++) {\\n            int next = gr[curr][i];\\n            \\n            if(next == par)\\n                continue;\\n            \\n            \\n            ans = ans ^ getDfs(next, curr, nums, gr);\\n            for(auto it = subtree[next].begin();it!=subtree[next].end();it++) {\\n                int ch = *it;\\n                subtree[curr].insert(ch);\\n            }\\n            \\n        }\\n        xors[curr] = ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2198587,
                "title": "java-dfs-in-out-tree-logic",
                "content": "```\\nclass Solution {\\n    public int minimumScore(int[] arr, int[][] edges) {\\n        \\n        int n=arr.length;\\n        List<List<Integer>> g=new ArrayList<>();\\n        for(int i=0;i<n;++i)\\n        {\\n            g.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] e: edges)\\n        {\\n            int u=e[0], v=e[1];\\n            g.get(u).add(v);\\n            g.get(v).add(u);\\n        }\\n        \\n        subXOR=new int[n];\\n        dist=new int[n];\\n        in=new int[n];\\n        time=0;\\n        out=new int[n];\\n        dfs(g, 0, -1, arr, 0);\\n        \\n        \\n        // debugInt(dist);\\n        // debugInt(in);\\n        // debugInt(out);\\n        // debugInt(subXOR);\\n        \\n        int total=subXOR[0];\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<edges.length;++i)\\n        {\\n            for(int j=0;j<edges.length;++j)\\n            {\\n                if(i==j) continue;\\n                \\n                int[] e1=edges[i], e2=edges[j];\\n                int u1=e1[0], v1=e1[1],  u2=e2[0], v2=e2[1];\\n                \\n                if(dist[u1] > dist[v1])\\n                {\\n                    int t=u1;\\n                    u1=v1;\\n                    v1=t;\\n                }\\n                if(dist[u2] > dist[v2])\\n                {\\n                    int t=u2;\\n                    u2=v2;\\n                    v2=t;\\n                }\\n                \\n                //check if v2 is in subtree of v1\\n                if(in[v1]<in[v2] && out[v1]>out[v2])\\n                {\\n                    // System.out.println(v1+\" \"+v2+\" IN\" );\\n                    ans=Math.min(ans, calc(subXOR[v2], subXOR[v1]^subXOR[v2], total^subXOR[v1]));\\n                }\\n                else if(in[v1]>in[v2] && out[v1]<out[v2])\\n                {\\n                    ans=Math.min(ans, calc(subXOR[v1], subXOR[v2]^subXOR[v1], total^subXOR[v2]));\\n                }\\n                else\\n                {\\n                    \\n                    // System.out.println(v1+\" \"+v2+\" OUT\");\\n                    ans=Math.min(ans, calc(subXOR[v2], subXOR[v1], total^subXOR[v1]^subXOR[v2]));\\n                }\\n            \\n                \\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n    \\n    static int[] subXOR;\\n    static int[] dist, in, out;\\n    static int time=0;\\n    public void dfs(List<List<Integer>> g, int u, int p, int[] arr, int d)\\n    {\\n        \\n        in[u]=time;\\n        List<Integer> nbrs=g.get(u);\\n        int xor=arr[u];\\n        for(int i=0;i<nbrs.size();++i)\\n        {\\n            int child=nbrs.get(i);\\n            if(child!=p)\\n            {\\n                time++;\\n                dfs(g, child, u, arr, d+1);\\n                xor=xor^subXOR[child];\\n            }\\n        }\\n        dist[u]=d;\\n        subXOR[u]=xor;\\n        time++;\\n        out[u]=time;\\n    }\\n        public int calc(int a, int b, int c)\\n        {\\n            int min=Math.min(a, Math.min(b, c));\\n            int max=Math.max(a, Math.max(b, c));\\n            \\n            // System.out.println(max+\" \"+min);System.out.println(\"------------------\");\\n            \\n            return max-min;\\n        }\\n    public void debugInt(int[] arr)\\n    {\\n        for(int i=0;i<arr.length;++i)\\n            System.out.print(arr[i]+\" \");\\n        System.out.println();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(int[] arr, int[][] edges) {\\n        \\n        int n=arr.length;\\n        List<List<Integer>> g=new ArrayList<>();\\n        for(int i=0;i<n;++i)\\n        {\\n            g.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] e: edges)\\n        {\\n            int u=e[0], v=e[1];\\n            g.get(u).add(v);\\n            g.get(v).add(u);\\n        }\\n        \\n        subXOR=new int[n];\\n        dist=new int[n];\\n        in=new int[n];\\n        time=0;\\n        out=new int[n];\\n        dfs(g, 0, -1, arr, 0);\\n        \\n        \\n        // debugInt(dist);\\n        // debugInt(in);\\n        // debugInt(out);\\n        // debugInt(subXOR);\\n        \\n        int total=subXOR[0];\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<edges.length;++i)\\n        {\\n            for(int j=0;j<edges.length;++j)\\n            {\\n                if(i==j) continue;\\n                \\n                int[] e1=edges[i], e2=edges[j];\\n                int u1=e1[0], v1=e1[1],  u2=e2[0], v2=e2[1];\\n                \\n                if(dist[u1] > dist[v1])\\n                {\\n                    int t=u1;\\n                    u1=v1;\\n                    v1=t;\\n                }\\n                if(dist[u2] > dist[v2])\\n                {\\n                    int t=u2;\\n                    u2=v2;\\n                    v2=t;\\n                }\\n                \\n                //check if v2 is in subtree of v1\\n                if(in[v1]<in[v2] && out[v1]>out[v2])\\n                {\\n                    // System.out.println(v1+\" \"+v2+\" IN\" );\\n                    ans=Math.min(ans, calc(subXOR[v2], subXOR[v1]^subXOR[v2], total^subXOR[v1]));\\n                }\\n                else if(in[v1]>in[v2] && out[v1]<out[v2])\\n                {\\n                    ans=Math.min(ans, calc(subXOR[v1], subXOR[v2]^subXOR[v1], total^subXOR[v2]));\\n                }\\n                else\\n                {\\n                    \\n                    // System.out.println(v1+\" \"+v2+\" OUT\");\\n                    ans=Math.min(ans, calc(subXOR[v2], subXOR[v1], total^subXOR[v1]^subXOR[v2]));\\n                }\\n            \\n                \\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n    \\n    static int[] subXOR;\\n    static int[] dist, in, out;\\n    static int time=0;\\n    public void dfs(List<List<Integer>> g, int u, int p, int[] arr, int d)\\n    {\\n        \\n        in[u]=time;\\n        List<Integer> nbrs=g.get(u);\\n        int xor=arr[u];\\n        for(int i=0;i<nbrs.size();++i)\\n        {\\n            int child=nbrs.get(i);\\n            if(child!=p)\\n            {\\n                time++;\\n                dfs(g, child, u, arr, d+1);\\n                xor=xor^subXOR[child];\\n            }\\n        }\\n        dist[u]=d;\\n        subXOR[u]=xor;\\n        time++;\\n        out[u]=time;\\n    }\\n        public int calc(int a, int b, int c)\\n        {\\n            int min=Math.min(a, Math.min(b, c));\\n            int max=Math.max(a, Math.max(b, c));\\n            \\n            // System.out.println(max+\" \"+min);System.out.println(\"------------------\");\\n            \\n            return max-min;\\n        }\\n    public void debugInt(int[] arr)\\n    {\\n        for(int i=0;i<arr.length;++i)\\n            System.out.print(arr[i]+\" \");\\n        System.out.println();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198580,
                "title": "o-n-2-calculate-two-cut-results-using-one-cut-results",
                "content": "The trick is if `x = a^b^c` then `b = a^c^x`. Now `a`, `b` and `c` are 3 components and `x` is the XOR of all nodes. If we already know values of `a, b^c, a^c, b` and `a^b^c`, we can acutally calculate `c`.\\n```\\nclass Solution {\\n    private int tot;\\n    \\n    private int dfs(List<Integer>[] adj, int i, int[] e, int[] nums, boolean[] visited) {\\n        int res = nums[i];\\n        visited[i] = true;\\n        for (int nb : adj[i]) {\\n            if (!visited[nb] && nb != e[0] && nb != e[1]) {\\n                res ^= dfs(adj, nb, e, nums, visited);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs_solver(List<Integer>[] adj, int i, int[] e, int[] nums, int[][][] xors, int xor3, boolean[] visited) {\\n        int res = Integer.MAX_VALUE;\\n        visited[i] = true;\\n        for (int nb : adj[i]) {\\n            if (!visited[nb] && nb != e[0] && nb != e[1]) {\\n                int low = Math.min(nb, i), high = Math.max(nb, i);\\n                int xor1 = xors[low][high][nb == low ? 0 : 1];\\n                int[] x = new int[] {xor1, tot ^ xor1 ^ xor3, xor3};\\n                Arrays.sort(x);\\n                res = Math.min(res, x[2] - x[0]);\\n                res = Math.min(res, dfs_solver(adj, nb, e, nums, xors, xor3, visited));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        List<Integer>[] adj = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            tot ^= nums[i];\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n        }\\n        int m = edges.length;\\n        int[][][] xors = new int[n][n][2];\\n        for (int i = 0; i < m; i++) {\\n            int[] e = edges[i];\\n            int low = Math.min(e[0], e[1]), high = Math.max(e[0], e[1]);\\n            xors[low][high][0] = dfs(adj, low, e, nums, new boolean[n]);\\n            xors[low][high][1] = dfs(adj, high, e, nums, new boolean[n]);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            int[] e = edges[i];\\n            int low = Math.min(e[0], e[1]), high = Math.max(e[0], e[1]);\\n            res = Math.min(res, dfs_solver(adj, low, e, nums, xors, xors[low][high][1], new boolean[n]));\\n            res = Math.min(res, dfs_solver(adj, high, e, nums, xors, xors[low][high][0], new boolean[n]));\\n        }\\n        return res;\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int tot;\\n    \\n    private int dfs(List<Integer>[] adj, int i, int[] e, int[] nums, boolean[] visited) {\\n        int res = nums[i];\\n        visited[i] = true;\\n        for (int nb : adj[i]) {\\n            if (!visited[nb] && nb != e[0] && nb != e[1]) {\\n                res ^= dfs(adj, nb, e, nums, visited);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs_solver(List<Integer>[] adj, int i, int[] e, int[] nums, int[][][] xors, int xor3, boolean[] visited) {\\n        int res = Integer.MAX_VALUE;\\n        visited[i] = true;\\n        for (int nb : adj[i]) {\\n            if (!visited[nb] && nb != e[0] && nb != e[1]) {\\n                int low = Math.min(nb, i), high = Math.max(nb, i);\\n                int xor1 = xors[low][high][nb == low ? 0 : 1];\\n                int[] x = new int[] {xor1, tot ^ xor1 ^ xor3, xor3};\\n                Arrays.sort(x);\\n                res = Math.min(res, x[2] - x[0]);\\n                res = Math.min(res, dfs_solver(adj, nb, e, nums, xors, xor3, visited));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        List<Integer>[] adj = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            tot ^= nums[i];\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n        }\\n        int m = edges.length;\\n        int[][][] xors = new int[n][n][2];\\n        for (int i = 0; i < m; i++) {\\n            int[] e = edges[i];\\n            int low = Math.min(e[0], e[1]), high = Math.max(e[0], e[1]);\\n            xors[low][high][0] = dfs(adj, low, e, nums, new boolean[n]);\\n            xors[low][high][1] = dfs(adj, high, e, nums, new boolean[n]);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            int[] e = edges[i];\\n            int low = Math.min(e[0], e[1]), high = Math.max(e[0], e[1]);\\n            res = Math.min(res, dfs_solver(adj, low, e, nums, xors, xors[low][high][1], new boolean[n]));\\n            res = Math.min(res, dfs_solver(adj, high, e, nums, xors, xors[low][high][0], new boolean[n]));\\n        }\\n        return res;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2198431,
                "title": "python-tricky-graph-dfs",
                "content": "\\nStore all the parents for nodes and xor value of their subtree. This can be done in a single recursion.\\n\\nIterate in n^2 on edges and check two cases.\\n\\tif cur 2 removed edges both have different parent.\\n\\tif cur edges are on same branch\\n\\t\\nmaintain a total variable which have value of subtree at 0.\\nIf any doubts ask in comments.\\n\\n```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        par = {i:i for i in range(n)}\\n        val = {i:nums[i] for i in range(0,n)}\\n      \\n        def rec(i,path):\\n            t = nums[i]\\n            for j in d[i]:\\n                if j not in path:\\n                    t^=rec(j,path|{j})\\n            val[i] = t\\n            par[i] = path\\n            return t\\n        \\n        d = defaultdict(list)\\n        \\n        for i,j in edges:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        rec(0,set([0]))\\n        tot = val[0]\\n        \\n        ans = 10**10\\n        for i in range(len(edges)):\\n            for j in range(i+1,len(edges)):\\n                a,b = edges[i]\\n                par1 = (b if a in par[b] else a)                \\n                a,b = edges[j]\\n                par2 = (b if a in par[b] else a)\\n\\n                if par1 in par[par2]:\\n                    x1,x2,x3 = tot^val[par1],val[par2]^val[par1],val[par2]\\n\\n                elif par2 in par[par1]:\\n                    x1,x2,x3 = tot^val[par2],val[par2]^val[par1],val[par1]\\n\\n                else:\\n                    x1,x2,x3 = tot^val[par1]^val[par2],val[par1],val[par2]\\n                \\n                ans = min(ans,max(x1,x2,x3)-min(x1,x2,x3))\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        par = {i:i for i in range(n)}\\n        val = {i:nums[i] for i in range(0,n)}\\n      \\n        def rec(i,path):\\n            t = nums[i]\\n            for j in d[i]:\\n                if j not in path:\\n                    t^=rec(j,path|{j})\\n            val[i] = t\\n            par[i] = path\\n            return t\\n        \\n        d = defaultdict(list)\\n        \\n        for i,j in edges:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        rec(0,set([0]))\\n        tot = val[0]\\n        \\n        ans = 10**10\\n        for i in range(len(edges)):\\n            for j in range(i+1,len(edges)):\\n                a,b = edges[i]\\n                par1 = (b if a in par[b] else a)                \\n                a,b = edges[j]\\n                par2 = (b if a in par[b] else a)\\n\\n                if par1 in par[par2]:\\n                    x1,x2,x3 = tot^val[par1],val[par2]^val[par1],val[par2]\\n\\n                elif par2 in par[par1]:\\n                    x1,x2,x3 = tot^val[par2],val[par2]^val[par1],val[par1]\\n\\n                else:\\n                    x1,x2,x3 = tot^val[par1]^val[par2],val[par1],val[par2]\\n                \\n                ans = min(ans,max(x1,x2,x3)-min(x1,x2,x3))\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576944,
                "content": [
                    {
                        "username": "argha_kole",
                        "content": "Do you know a solution which works in O(n) ? If yes, please share. It will be helpful."
                    },
                    {
                        "username": "songjiujiu1999",
                        "content": "It is impossible to solve it in O(n). Because we need to traverse all edges in this problem at least one time. And the time complexit for this is O(N**2)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how does assuming any node to be a root give us the answer? why are we not considering every root as a node and then finding the overall answer??"
                    },
                    {
                        "username": "adil_kira",
                        "content": "It is an undirected connected graph without cycles and each node has unique parent, so in undirected connected graph any node can be root node"
                    }
                ]
            },
            {
                "id": 1940207,
                "content": [
                    {
                        "username": "argha_kole",
                        "content": "Do you know a solution which works in O(n) ? If yes, please share. It will be helpful."
                    },
                    {
                        "username": "songjiujiu1999",
                        "content": "It is impossible to solve it in O(n). Because we need to traverse all edges in this problem at least one time. And the time complexit for this is O(N**2)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how does assuming any node to be a root give us the answer? why are we not considering every root as a node and then finding the overall answer??"
                    },
                    {
                        "username": "adil_kira",
                        "content": "It is an undirected connected graph without cycles and each node has unique parent, so in undirected connected graph any node can be root node"
                    }
                ]
            }
        ]
    }
]