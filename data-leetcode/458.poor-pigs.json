[
    {
        "title": "Poor Pigs",
        "question_content": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\nYou can feed the pigs according to these steps:\n\n\tChoose some live pigs to feed.\n\tFor each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n\tWait for minutesToDie minutes. You may not feed any other pigs during this time.\n\tAfter minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n\tRepeat this process until you run out of time.\n\nGiven buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n&nbsp;\nExample 1:\n\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 15\nOutput: 2\nExplanation: We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\n\nExample 2:\n\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 30\nOutput: 2\nExplanation: We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n\n&nbsp;\nConstraints:\n\n\t1 <= buckets <= 1000\n\t1 <=&nbsp;minutesToDie <=&nbsp;minutesToTest <= 100",
        "solutions": [
            {
                "id": 94266,
                "title": "another-explanation-and-solution",
                "content": "With 2 pigs, poison killing in 15 minutes, and having 60 minutes, we can find the poison in up to 25 buckets in the following way. Arrange the buckets in a 5&times;5 square:\\n\\n```\\n 1  2  3  4  5\\n 6  7  8  9 10\\n11 12 13 14 15\\n16 17 18 19 20\\n21 22 23 24 25\\n```\\nNow **use one pig to find the row** (make it drink from buckets 1, 2, 3, 4, 5, wait 15 minutes, make it drink from buckets 6, 7, 8, 9, 10, wait 15 minutes, etc). **Use the second pig to find the column** (make it drink 1, 6, 11, 16, 21, then 2, 7, 12, 17, 22, etc).\\n\\nHaving 60 minutes and tests taking 15 minutes means we can run four tests. If the row pig dies in the third test, the poison is in the third row. If the column pig doesn't die at all, the poison is in the fifth column (this is why we can cover five rows/columns even though we can only run four tests).\\n\\nWith 3 pigs, we can similarly use a 5&times;5&times;5 cube instead of a 5&times;5 square and again use one pig to determine the coordinate of one dimension (one pig drinks layers from top to bottom, one drinks layers from left to right, one drinks layers from front to back). So 3 pigs can solve up to 125 buckets.\\n\\nIn general, we can solve up to (&lfloor;minutesToTest / minutesToDie&rfloor; + 1)<sup>pigs</sup> buckets this way, so just find the smallest sufficient number of pigs for example like this:\\n\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        pigs = 0\\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\\n            pigs += 1\\n        return pigs\\n\\nOr with logarithm like I've seen other people do it. That's also where I got the idea from (I didn't really try solving this problem on my own because the judge's solution originally [was wrong](https://discuss.leetcode.com/topic/66856/major-flaw-in-current-algorithm-fixed) and I was more interested in possibly helping to make it right quickly).",
                "solutionTags": [],
                "code": "```\\n 1  2  3  4  5\\n 6  7  8  9 10\\n11 12 13 14 15\\n16 17 18 19 20\\n21 22 23 24 25\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94273,
                "title": "solution-with-detailed-explanation",
                "content": "To be honest, I've spent several days thinking about this question. It's not only fun, but also confusing. it drives me up the wall, especially for its **easy** difficulty. \\U0001f629\\n\\n### Thinking Process\\n\\n***1. What if you only have one shot?***\\n\\n> Eg. **4** buckets, **15** mins to die, and **15** mins to test.\\n\\nThe answer is **2**. Suppose we use A and B to represent pigs, we could have\\n\\n![0_1478958363340_upload-5c96756b-ca9f-41f2-b597-ff57a040ebe8](/uploads/files/1478958363472-upload-5c96756b-ca9f-41f2-b597-ff57a040ebe8.png)\\n\\nObviously we could use the binary form to represent the solution.\\n\\n![0_1478958322597_upload-0812d848-8375-4422-813e-b97bdd37c653](/uploads/files/1478958322907-upload-0812d848-8375-4422-813e-b97bdd37c653.png) \\n\\n**Conclusion**: If we have `x` pigs,  we could use them to represent (encode) `2^x` buckets.\\n\\n***2. What if we could have more than one attempts?***\\n\\n> Eg. **4** buckets, **15** mins to die, and **30** mins to test.\\n\\nAt the moment, I consider the problem as an encoding problem: *With more attempts, how to use fewer pigs to represent all the buckets?*\\n\\nI got lost at this step by keep thinking the binary way. After hanging around the forum, I got the idea to change my views. Let's go back to the one shot situation. What does the binary form mean? It's much easier if we regard it as:\\n\\n+ `0` means the pig does not drink and die.\\n+ `1` means the pig drinks in the first (and only) round.\\n\\nWe could generalise with:\\n\\n+ `0` means the pig does not drink and die.\\n+ `1` means the pig drinks in the first round and die.\\n+ `2` means the pig drinks in the second round and die.\\n...\\n+ `t` means the pig drinks in the t-th round and die.\\n\\n**Conclusion**: If we have `t` attempts, we could use `t+1`-based number to represent (encode) the buckets. (That's also why the first conclusion uses the `2`-based number)\\n\\n### Example\\n\\n> Eg. **8** buckets, **15** mins to die, and **40** mins to test.\\n\\nWe have **2** (`= (40/15).floor`) attempts, as a result we'll use **3**-based number to encode the buckets. \\n\\nHow many pigs do we need? Answer is 2 (`= Math.log(8, 3).ceil`)\\n\\n![0_1478960257723_upload-0da5c126-bf43-4183-935d-c2c1a5b5df15](/uploads/files/1478960260176-upload-0da5c126-bf43-4183-935d-c2c1a5b5df15.png) \\n\\nFor example 3-based number `02` means: the pig **A** does not drink and die, and the pig **B** drinks in the second round and die.\\n\\n### Ruby Code\\n\\n```ruby\\nclass FooTest < Minitest::Test\\n  def poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n    states = minutes_to_test / minutes_to_die + 1\\n\\n    Math.log(buckets, states).ceil\\n  end\\n\\n  def test_run\\n    assert_equal 1, poor_pigs(2, 10, 10)\\n    assert_equal 2, poor_pigs(4, 10, 10)\\n    assert_equal 3, poor_pigs(8, 10, 10)\\n    assert_equal 4, poor_pigs(16, 10, 10)\\n\\n    assert_equal 1, poor_pigs(2, 10, 20)\\n    assert_equal 2, poor_pigs(4, 10, 20)\\n    assert_equal 2, poor_pigs(8, 10, 20)\\n    assert_equal 3, poor_pigs(16, 10, 20)\\n\\n    assert_equal 5, poor_pigs(1000, 15, 60)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby",
                    "Math"
                ],
                "code": "```ruby\\nclass FooTest < Minitest::Test\\n  def poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n    states = minutes_to_test / minutes_to_die + 1\\n\\n    Math.log(buckets, states).ceil\\n  end\\n\\n  def test_run\\n    assert_equal 1, poor_pigs(2, 10, 10)\\n    assert_equal 2, poor_pigs(4, 10, 10)\\n    assert_equal 3, poor_pigs(8, 10, 10)\\n    assert_equal 4, poor_pigs(16, 10, 10)\\n\\n    assert_equal 1, poor_pigs(2, 10, 20)\\n    assert_equal 2, poor_pigs(4, 10, 20)\\n    assert_equal 2, poor_pigs(8, 10, 20)\\n    assert_equal 3, poor_pigs(16, 10, 20)\\n\\n    assert_equal 5, poor_pigs(1000, 15, 60)\\n  end\\nend\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385451,
                "title": "c-detail-explanation-1-line-code-100-fast",
                "content": "Explanation:\\n\\n\\tThis question is based on combinatrics. \\n\\t\\n\\tLets assume that we have p pigs which can give us the accurate result. Now we have\\n\\ttotal Round of test = (timetoTest/TimetoDie) ie. T tests. \\n\\t\\n\\tSo for each T test there can be T+1  outcomes that is it can die in 1st or 2nd or Tth oit it means the T cases and the last case is it won\\'t die! So total T+1 Outcomes are possible.\\n\\t\\n\\tNow for each pig we have to go for T+1 outcomes i.e\\n\\t(T+1)*(T+1)........*(T+1).\\n\\t\\n\\tSo T+1 tests rounds are there so for all p pigs the total combination will be (T+1) to the power p i.e (T+1)^p. Now** this total combination should be greater than or equal to N.**\\n\\t\\n\\tHence  the condition for the answer is going to be \\n\\t(T+1)^p >= N\\n\\tTaking log on both sides we will get the required answee\\n\\tp >= log(N)/ log(T+1);\\n\\tand hence ceil function is used in the return.\\n\\n**PLEASE DO UPVOTE**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n\\t};\\n\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 935172,
                "title": "two-diagrams-to-help-understanding",
                "content": "Especially with the last hint in the question the solution is pretty straigtforward. In fact, when the number of rounds = 1, the each pig correspond to 1 bit of information. We can show how the solution is constructed. Consider the diagram below. Here we have 8 buckets, and the number of rounds = 1 (for example when both `x=15` and `y=15`). The first pig drinks the first four buckets, the second pig drinks buckets of size 2, interleaving two buckets, and the last pig drinks buckets of size 1, interleaving 1 bucket. If a pig dies it is encoded as `1`, otherwise `0`. We can see that 3 pigs encode all 8 cases here. Encoded string are shown at the bottom. Hence for `b=8, x=15, y=15` the answer is `3`.\\n\\n![image](https://assets.leetcode.com/users/images/546342db-390a-4e5e-adf9-d124abec0b74_1605349509.07897.png)\\n\\nAs the number of rounds increase, each pig can represent more information; but this is rather difficult to grasp at the beginning. We now consider the following diagram. Here we have 9 buckets and the number of rounds = 2 (for example when both `x=30` and `y=15`). You see how the pigs drink from buckets at round 1 and 2. If a pig dies in round 1, no problem! You set its value to `2`! If it dies in round 2, set it to `1`. Otherwise set it to `0`. You can see that 2 pigs encode all 9 cases here. Encoded string are shown at the bottom. Hence for `b=9, x=30, y=15` the answer is `2`.\\n\\n![image](https://assets.leetcode.com/users/images/bafa63d4-1dae-4ef5-8b81-67eb85fafd86_1605349693.3704822.png)\\n\\n```\\nclass Solution:\\n    def poorPigs(self, b, y, x):\\n        T = x//y\\n        x = 0\\n        while (T+1)**x < b:\\n            x += 1\\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def poorPigs(self, b, y, x):\\n        T = x//y\\n        x = 0\\n        while (T+1)**x < b:\\n            x += 1\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935112,
                "title": "python-math-solution-detailed-expanations",
                "content": "What matters is number of tests `T` and number of pigs `x`. Let us ask inverse question: how many states can we generate with `x` pigs and `T` tests to cover `N` scenarios? This is **estimation + example** problem, where we need to 1) prove, that we can not make `N` bigger than some number and 2) give an example, where this `N` is possible. \\n\\n**Estimation**: The number of states is exactly `(T+1)^x` and here is why. For each pig during `T` tests, it has exactly `T+1` states: dies at some test `#i`, where `1<= i <= T)` or still alive eventually. For `x` pigs, obviously the maximum possible number of states we could have is `(T+1)^x` since each is independent and one pig can not influence on another one. \\n\\n**Example**: From other side, we can construct the example, using `(T+1)` based numbers: at first test for `i`-th pig choose all numbers, where `i`-th digit is `0`. If all pigs are dead, we can immediately say what bucket was poisoned. If `k` pigs are alive, there will be `T^k` possible options for `T-1` days and `k` pigs, which can be solved, using induction. For better understanding, imaging the special case: let us have `x=3` pigs and `T=2` tests. Then our plan is the following:\\n\\nWe have `27` different positions: \\n`000 001 002`        `100 101 102`        `200 201 202`              \\n`010 011 012`        `110 111 112`        `210 211 212`\\n`020 021 022`        `120 121 122`        `220 221 222`\\n\\nOn the first test, first pig will drink from first `9` bucktes: `000, 001, 002, 010, 011, 012, 020, 021, 022`, if it is not dead, on the second test it drink from the second `9` buckets `100, 101, 102, 110, 111, 112, 120, 121, 122`. Why we choose this bucktes? Because for the first group it always starts with `0` and second always starts with `1`. What can be our results?\\n\\n1. This pig dies after first test, so we can conclude, that our bucket has form `0**`.\\n2. This pig dies after second test, so we can conclude, that our bucket has form `1**`.\\n3. It will not die at all (lucky bastard), then our bucket has form `2**`.\\n\\nSo, what was the purpuse of first pig? To understand the first digit in our bucket number.\\n\\nNo, let us look at the second pig: we do very similar procedure for it: on the first test it will drink from the `9` buckets from first line: `000, 001, 002, 100, 101, 102, 200, 201, 202`: all buckets with second number equal to `0`, on the second test, it will drink from `010, 011, 012, 110, 111, 112, 210, 211, 212`: from all buckets with second number equel to `1`. We again can do the following inference:\\n\\n1. This pig dies after first test, so we can conclude, that our bucket has form `*0*`.\\n2. This pig dies after second test, so we can conclude, that our bucket has form `*1*`.\\n3. It will not die at all (lucky bastard), then our bucket has form `*2*`.\\n\\nFinally, we have the third pig, which help us to understand if we have `**0`, `**1` or `**2`.\\n\\nLooking at all information we have now about the frist, the second and the third digits in our bucket number we can say what bucket we have!\\n\\n**Complexity**: it is just `O(1)` time and space if we assume that we can evaluate `log` in `O(1)` time.\\n\\n```\\nclass Solution:\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        return ceil(log(buckets)/log(minutesToTest//minutesToDie + 1))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        return ceil(log(buckets)/log(minutesToTest//minutesToDie + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385923,
                "title": "pig-lives-matter",
                "content": "Rip all the innocent pigs who died while testing. You will be remembered.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 94305,
                "title": "1-line-solution-with-detailed-problem-clarification-math-proof-please-read-if-you-really-want-to-know-what-this-problem-means",
                "content": "**Clarifications:**\\nI definitely think the description in this problem needs to be clarified as I initially read it. After reading some posts, I finally got exactly what it expected and restricted in this problem of the storytelling style (which is likely to introduce ambiguity).\\n\\n**Here are the two key points that have to be clarified if you really want to work on this \"poorly\" defined problem**:\\n* **A pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time** (!). I guess this is the really bizarre assumption hidden behind this story. And I finally got this point after reading some posts.\\n* **After a pig has instantly finished drinking buckets, there has to be a \"cool down\" time of `minutesToDie` minutes**. During this time, only observation is allowed and no feedings at all. Actually, this is a derived hint from the problem instead of an assumption. Because after feeding on poison bucket, it is stated that a pig will die **within** `minutesToDie` minutes instead of **exact** minutes. This means that if you feed a pig more than once in a time frame less that `minutesToDie` minutes, there is no way to tell which feeding contains poison if the pig happens to die eventually\\n\\nWith the two key points above, I think the problem picked a \"bad\" story. Instead, it could be re-translated into a better story such as:\\n* Given `N` sources with exactly one of them sending bad signal. You are given `x` receivers to detect which source is sending bad signal. A receiver can be configured to pick up signals from any number of specified sources. The bad signal will permanently damage a receiver within `minutesToDie` minutes after received. Find the minimum `x` if given `minutesToTest` minutes to test.  \\n***\\n**Solution:**\\n```\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n      return ceil(log(buckets)/log(minutesToTest/minutesToDie+1));  // log_{T+1}(N)\\n    }\\n```\\n**Proof:** For given `minutesToDie` and `minutesToTest`, with the clarification above, the only thing that matters here is the number of tests allowed `T = (int)(minutesToTest/minutesToDie)` because of the \"cool down\" restriction. Then the problem is translated equivalently to:\\n\\n* **How many states can we generate with `x` pigs and `T` tests** to cover `N` scenarios?\\n\\nThe number of states is exactly `(T+1)^x` and here is why. For each pig during `T` tests, it has exactly `T+1` states: dies at some test#`i` (`1<=i<=T`) or still alive eventually. For `x` pigs, obviously the maximum possible number of states we could have is `(T+1)^x` since each pig's well-being solely depends on whether it ever fed on poison bucket and nothing to do with other pigs. So all we need to do is to \\n* **find minimum `x` such that `(T+1)^x >= N`, which means `x = ceil(logN/log(T+1))`**.\\n\\nNow we have the optimal candidate, but can we actually implement a feeding solution to achieve that optimum solution? Sure, here it is:\\n1. Label buckets as a `(T+1)`-based number represented as `x`-dimensional vector `v = (v[1], v[2], ...,v[x])` consecutively ascending from `(0,0,...0)`. (each `0<=v[j]<=T`)\\n2. For each Test#`i` (`1<=i<=T`), if all pigs are dead by now, process is finished. Otherwise, for each pig`j` alive, feed it on all buckets with `v[j] = i` simultaneously, and record its death time `D[j] = i` if it dies after this test.\\n3. Default `D[j] = 0` if pig`j` is still alive after all `T` tests. \\n\\nThen we claim that: **bucket with label `(D[1],D[2],...,D[x])` must be the poison one**. \\n\\nBecause for each pig`j`, by design of Step 2, it is guaranteed to be alive before feeding on bucket `(D[1],D[2],...,D[x])` and all those pigs which have ever fed on this bucket died right after that test.",
                "solutionTags": [],
                "code": "```\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n      return ceil(log(buckets)/log(minutesToTest/minutesToDie+1));  // log_{T+1}(N)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94278,
                "title": "very-clear-explanation-by-short-examples",
                "content": "Let's think in another way: \\n**If we get N pigs and can test T times, what is the maximum number of buckets that we can successfully detect the poison among them?**\\n\\n-----------\\n\\nHere we take T=1 (can only test once) and N=2 (2 pigs) as example:\\n```\\n    x -> not drink      o -> drink\\n\\nT=1  N=2:\\n\\n   buckets       1    2    3    4\\n     pig 1       x    x    o    o\\n     pig 2       x    o    x    o\\n\\n Result:   2 pigs and test 1 times -> 4 buckets\\n```\\n### Conclusion  T=1  N=n:\\n#### n pigs and test 1 times can deal with how many buckets\\n=  2^n    \\n\\n\\n----------------\\n\\n\\nWe take T=2 (can only test twice) and N=2 (2 pigs) as example:\\n```\\nT=2  N=2:\\n\\n   buckets       1    2    3    4    5    6    7    8    9  \\n     pig 1       o    x    x    o    o    x    x    x    x    \\n     pig 2       o    o    o    x    x    x    x    x    x\\n                                                  \\nResult:   2 pigs and test 2 times --> 9 buckets\\n\\nExplain:   \\n  pig 1 & 2 died     ->  1 possible bucket\\n  pig 1 died only    ->  2 possible buckets  -> 1 pig and 1 times can deal with 2 buckets(straight-forward)\\n  pig 2 died only    ->  2 possible buckets  -> 1 pig and 1 times can deal with 2 buckets(straight-forward)\\n  pig 1 & 2 survived ->  4 possible buckets  -> 2 pigs and 1 times can deal with 4 buckets(Previous case: T=1 N=2)\\n```\\n### Conclusion  T=2  N=n:\\n#### n pigs and test 2 times can deal with how many buckets\\n= C(n,n) * 2^0 + C(n,n-1) * 2^1 + ... + C(n,0) * 2^n \\n= (1+2)^n \\n= 3^n  \\n\\n**Explain:** \\n#(all pigs died) + #(1 pigs survived) * can test 2 buckets(T=1 N=1)  + #(2 pigs survived) * can test 4 buckets(T=1 N=2) + ..... + #(n pigs survived) * can test 2^n buckets(T=1 N=n)\\n\\n ----------------\\n\\nNow, try to think about the case T=3 (can test 3 times) and N=n (n pigs)\\n\\n### Conclusion (T=3  N=n): \\n#### n pigs and test 3 times can deal with how many buckets\\n= C(n,n) * 3^0 + C(n,n-1) * 3^1 + ... + C(n,0) * 3^n \\n= (1+3)^n \\n= 4^n\\n\\n**Explain:** \\n#(all pigs died) + #(1 pigs survived) * can test 3 buckets(T=2 N=1)  + #(2 pigs survived) * can test 9 buckets(T=2 N=2) + ..... + #(n pigs survived) * can test 3^n buckets(T=2 N=n)\\n\\n-----------------\\n\\n#### To sum it up, \\nIf we get **N** pig and can test **T** times, the maximum number of buckets that we can successfully detect the poison among them is ----> **(1+T)^N**.\\n\\n\\nTherefore, the answer to the question is:\\n```\\n MIN(n),   where (1+T)^n >= number of buckets    \\n                   Note: T = minutesToTest/minutesToDie\\n```",
                "solutionTags": [],
                "code": "```\\n    x -> not drink      o -> drink\\n\\nT=1  N=2:\\n\\n   buckets       1    2    3    4\\n     pig 1       x    x    o    o\\n     pig 2       x    o    x    o\\n\\n Result:   2 pigs and test 1 times -> 4 buckets\\n```\n```\\nT=2  N=2:\\n\\n   buckets       1    2    3    4    5    6    7    8    9  \\n     pig 1       o    x    x    o    o    x    x    x    x    \\n     pig 2       o    o    o    x    x    x    x    x    x\\n                                                  \\nResult:   2 pigs and test 2 times --> 9 buckets\\n\\nExplain:   \\n  pig 1 & 2 died     ->  1 possible bucket\\n  pig 1 died only    ->  2 possible buckets  -> 1 pig and 1 times can deal with 2 buckets(straight-forward)\\n  pig 2 died only    ->  2 possible buckets  -> 1 pig and 1 times can deal with 2 buckets(straight-forward)\\n  pig 1 & 2 survived ->  4 possible buckets  -> 2 pigs and 1 times can deal with 4 buckets(Previous case: T=1 N=2)\\n```\n```\\n MIN(n),   where (1+T)^n >= number of buckets    \\n                   Note: T = minutesToTest/minutesToDie\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94317,
                "title": "three-steps-thinking-process-for-poor-pigs",
                "content": "---\\n**`Step I -- Consider the reverse of the problem`**\\n\\nSuppose the total number of permissible tests are fixed, instead of thinking about the **minimum number of pigs** needed to find the poisonous bucket from the given number of buckets, let's consider the reverse: what is the **maximum number of buckets** from which we are able to find the poisonous one with the given number of pigs?\\n\\nTo make our problem more clear, let's define `T(n, k)`, which will be the **maximum number of buckets** from which we can determine the poisonous one with `n` pigs and `k` tests. Our mission is to find the general expression of `T(n, k)` in terms of `n` and `k` (we will assume `k > 0`, otherwise there can be only `1` bucket, the one with poison which can be identified without any testing).\\n\\n---\\n**`Step II -- Consider cases with only 1 pig`**\\n\\nLet's start with simple cases when there is only `1` pig at our disposal, i.e., `n = 1`. \\n\\nFirst given a bucket, how do we determine if it is poisonous or not? Well, we have got no better way other than feed the pig with its \"water\"(**can be poisonous!**) and check if the pig dies after some time. If it does, bingo we've found the right one. Or if the pig is lucky to be alive, we are still able to eliminate one bucket. \\n\\nCan we feed the pig with \"water\" from **two or more** buckets simultaneously? No. Because if the pig dies after drinking \"water\" from those buckets, we won't be able to nail down the exact one which is poisonous as there are no more live pigs, even if we are permitted to do more tests.\\n\\nSo with one pig, for each attempt, we can either find the poisonous bucket or eliminate an \"innocent\" one, depending on the status of the pig (dead or alive).\\n\\nIf only one test is allowed, i.e., `k = 1`, from the analyses above, we can either determine one bucket is poisonous or eliminate it. If the total number of bucket is `1`, we surely can find the poisonous bucket (which is just the one given). If the total number of bucket is '2', since testing results of one bucket will automatically reveal information about the other, we can still determine which of the two is poisonous. But if we have more than `2` buckets, we won't be able to make sure which one of the rest contains poison if the pig survives the test with one bucket at our choice, since we've run out of tests. Therefore, in this case, there can be at most two buckets from which we may be able to find the poisonous one with `1` pig and `1` test, or in a symbolic way, `T(1, 1) = 2`.\\n\\nHow about there are `k` tests permissible? Apparently we can check at least `k` buckets with `k` tests, so `T(1, k) >= k`. Can we do better? The key is to consider the extreme case when the pig survives all `k` tests (what a lucky pig, btw). How many more buckets can be left unchecked if we were able to figure out the poisonous one? The answer is `1` since we cannot do any more test so there has to be a way for us to point at a bucket and say it is poisonous with 100% sure. Therefore, we have `T(1, k) = k + 1`.\\n\\n---\\n**`Step III -- Consider general cases with n pigs`**\\n\\nFrom part `II`, we know there are at most `k + 1` buckets from which a poisonous one can be determined with `1` pig and `k` tests, or `T(1, k) = k + 1`. Now we have n pigs, and testing of each pig is **independent** from each other (feeding \"water\" to a pig is independent from feeding others, provided each bucket has enough \"water\"), we are free to combine the `k + 1` results of each pig and end up with `(k + 1)^n` total combinations.\\n\\nSo without digging deeper, we've found the general expression: `T(n, k) = (k + 1)^n`. And you can happily proceed to figure out the answer for the original problem. But in case you are wondering how exactly we will carry out the tests and do \"combination\" of the results, here is one possible interpretation.\\n\\nSuppose we have `N` total buckets from which the poisonous one is to be found. `n` is the minimum number of pigs such that `T(n, k) >= N`, with `T(n, k) = (k + 1)^n` and `k >= 1`. We can label all the buckets from `0` up to `N - 1` and express each of them as a number in the base-`(k + 1)` numeral system. Each pig will represent one digit for a number in the same numeral system (marked as pig `0` to `n - 1`, from least significant digit to most significant one). Since our final goal is equivalent to determining all the `n` digit values of the number of the poisonous bucket, we can do so by testing each value one by one since there are at most `k + 1` possible values for each digit, which can be done within `k` tests. Here is the detailed way to accomplish that: In the `1st` test, for each pig, feed it with \"water\" from all buckets whose number has a digit value of `1` at the corresponding digit. In the `2nd` test, for all **live** pigs, feed it with \"water\" from all buckets whose number has a digit value of `2` at the corresponding digit. And so on until either all pigs are dead or we've run out of tests. In either case the number of the poisonous bucket is guaranteed to be found.\\n\\nIf you are interested in examples for this interpretation, [ifyouseewendy](https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation) has done a great job here. \\n\\nAnother interpretation is to associate each pig with one dimension of a multi-dimensional array, as explained by [StefanPochmann](https://discuss.leetcode.com/topic/67666/another-explanation-and-solution). We first arrange all buckets into this multi-dimensional array. Then in each test, we feed each **live** pig with \"water\" from \"one unit\" of buckets belonging to the corresponding dimension (for example, in the `1st` test, feed pig `1` with all the `1st` rows; feed pig `2` with all the `1st` columns; feed pig `3` with all the `1st` pages...; in the `2nd` test, if pig `1` is still alive, feed it with all the `2nd` rows; if pig `2` is still alive, feed it with all the `2nd` columns; if pig `3` is still alive, feed it with all the `2nd` pages....). At the end of the test, all the indices of the poisonous bucket will be determined so we can index into the multi-dimensional array to find it.\\n\\nThe final code is rather simple once we've figured out the expression for `T(n, k)`. Some minor issues are dealing with corner cases such as only `1` bucket or it takes more time for the pig to die than it is allowed to wait. Also pay attention to computing logarithm for integers. Here is the Java program.\\n\\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    if (buckets < 2) return 0;\\n    if (minutesToDie > minutesToTest) return Integer.MAX_VALUE;\\n    \\n    int k = minutesToTest / minutesToDie;\\n    return (int)Math.ceil((Math.log(buckets) / Math.log(k + 1)));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    if (buckets < 2) return 0;\\n    if (minutesToDie > minutesToTest) return Integer.MAX_VALUE;\\n    \\n    int k = minutesToTest / minutesToDie;\\n    return (int)Math.ceil((Math.log(buckets) / Math.log(k + 1)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935581,
                "title": "c-python-picture-1-line-greedy-solution-with-n-dimension-puzzle-cube-scan",
                "content": "**Idea:**\\nExample 1: What is the minimal number of pigs are needed to test 9 bucteks within 2 rounds:\\n1  2  3\\n4  5  6\\n7  8  9\\nAnswer: 2.\\nWhy?  \\nPig 1 scan horizontally row by row        and will spot the row       contains poinson after 2 round. Assume row i has posion\\nPig 2 scan vertically column by column and will spot the column contains poinson after 2 round. Assume column j has posion\\nThen, point will be in position markted by \\'row i, column j\\'.\\n\\nExample 2: What is the minimal number of pigs are needed to test 27 bucteks within 2 rounds?\\nAnswer: 3.\\nWhy?\\nAssume the 27 buckets are arranged as following 3X3X3 puzzle cube:\\n\\n![image](https://assets.leetcode.com/users/images/237943f9-b2ae-48e8-9058-5c12d207d2b6_1605378880.9787207.png)\\n\\nOr mathmatically,\\n[1  2  3\\n4  5  6\\n7  8  9]\\n\\n[10 11 12\\n13  14 15\\n16 17 18]\\n\\n[19  20  21\\n22 23 24\\n25 26 27]\\n\\n3 pigs can scan 3-axis one by one. After 2 rounds, the poinson will be pinpointed.\\n\\nCredit: https://www.cnblogs.com/grandyang/p/7664088.html\\n\\n**C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // min_pig_count determined by equation: buckets =max_sub_job_load ** min_pig_count\\n\\t\\t// max_sub_job_load  = minutesToTest / minutesToDie + 1\\n        // min_pig_count = ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n    }\\n};\\n```\\n\\n**Python Solution:**\\n```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // min_pig_count determined by equation: buckets =max_sub_job_load ** min_pig_count\\n\\t\\t// max_sub_job_load  = minutesToTest / minutesToDie + 1\\n        // min_pig_count = ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94307,
                "title": "turn-dynamic-programming-into-mathematical-formula",
                "content": "Firstly, we define N = buckets, T = minutesToTest / minutesToDie (round below as integer division), so we can see T is the maximum times we can carry out our test (we can have all our pigs drinking water at the same time and regard it as ONE test).\\n\\nThen according to dynamic programming, define dp[n][t] as the maximum buckets we can detect when one of them contains poison, given the n pigs at the beginning and t times for carrying out tests. So let's go through some basic cases.\\n\\ndp[1][1] == 2, since if you have just one pig and can only do one test, the maximum buckets you can detect is 2: you can choose any one bucket to feed the pig, and if it dies after a certain time, the poison is in the chosen bucket, otherwise in the other one. \\n\\nThen we can know that dp[1][t] == t + 1, you can carry out tests that have the only one pig drinking bucket one by one and get the poisonous bucket. \\n\\nHow about dp[n][1]? This is a little tricky. We can encode the buckets with binary number, for example, there is 16 buckets and we encode them from 0 to 15 as 0000, 0001, 0010, ..., 1110, 1111, and also give each pig a sequence number from 0 to n - 1. After that, we feed these n pigs as binary number do, that is, we don't feed bucket 0 to any pig, since bucket 0's code is all 0s; we feed bucket 10 whose code is 1010 to pig 1 and pig 3, since the bit 1 and bit 3 of 1010 is 1s while other bits are 0s(we count the bit from LSB and start from 0). After feeding the pigs, we can view the state of each pig, and set state \"alive\" as 0 and \"died\" as 1, then these pigs' states form a binary number, for example 1100, means pig 2 and pig 3 are died, which means the code of poisonous bucket is exactly 1100, namely bucket 12. Thus, we can detect as many as 2^n buckets in one test with n pigs, that is, dp[n][1] == 2^n.\\n\\nWith these basic cases, we can construct our state transition equation now. For dp[n][t], how can we make full use of all 2^n states those pigs can generate after one test? The answer is simple. After one test, if all pigs dies, we must assure there is only one bucket that all pigs drank from, since we don't have any pigs to use afterwards. If we have k pigs alive(0 < k <= n), we can use these pigs to detect at most dp[k][t-1] buckets. With some knowledge of permutation and combination, the number of cases we can have k pigs alive after one test is C(n, k) (when k == 0, it also holds true). So our state transition equation is\\n\\n    dp[n][t] = \\n    C(n,0)+C(n,1)dp[1][t-1]+...+C(n,k)dp[k][t-1]+...+C(n,n)dp[n][t-1], where 0 <= k <= n, t >= 2\\n\\nThus\\n    \\n    dp[n][2] =  C(n,0)+C(n,1)dp[1][1]+...+C(n,k)dp[k][1]+...+C(n,n)dp[n][1]= \\n    C(n,0)+C(n,1)2^1+...+C(n,k)2^k+...+C(n,n)2^n=3^n\\n    dp[n][3] =  C(n,0)+C(n,1)dp[1][2]+...+C(n,k)dp[k][2]+...+C(n,n)dp[n][2]= \\n    C(n,0)+C(n,1)3^1+...+C(n,k)3^k+...+C(n,n)3^n=4^n\\n    ...\\n\\nA concise mathematical formula is generated! \\n\\n    dp[n][t] = (t+1)^n, for all n >= 1 and t >= 1.\\nCome back to our origin problem, if we can use minimum n pigs to detect N buckets with T tests, n should be \\n    \\n    ceil(log_(t+1)(N))\\n    == ceil((log(N)/log(t+1))\\n\\nCeil is rounding above. Here I give a illustration of dp[2][2] == (2+1)^2 == 9 as an example below:\\n\\nWe have 2 pigs at first and can carry out 2 tests. Firstly, we know 2 pigs can form 4 states of \"alive\"(0) or \"died\"(1), including 00, 01, 10, 11, each one is relative to a subproblem of dynamic programming. If after one test, two pigs both die, we can only handle one bucket in this case. However, if we have only one pig alive, we can handle dp[1][1](one pig left, with one chance of test left) namely 2 buckets, and there are actually two cases of only one pig left alive(2 == C(2, 1)). If both two are alive, we can handle  dp[2][1] = 2^2=4 buckets totally. Thus, we separate 9 into 4 groups, and each one respectively contains 1, 2, 2 and 4 buckets, and design our first test. We feed our pig 0 with bucket 0, bucket 1 and bucket 3, and feed our pig 1 with bucket 0, bucket 2 and bucket 4. So you can see no matter which code is generated after one test, the problem is reduced to a subproblem we have already solved before.\\n\\nBased on the analysis above, I can explain the answer for input [1000, 15, 60], in which according to my definition,  N == 1000 and T == 60/15=4, the minimum number of pigs we use should be ceil(log_(4+1)(1000))~=ceil(4.29)==5\\n\\nFinally, notice that if there is only 1 bucket, we can immediately detect this bucket containing poison, without any pigs or tests.",
                "solutionTags": [],
                "code": "Firstly, we define N = buckets, T = minutesToTest / minutesToDie (round below as integer division), so we can see T is the maximum times we can carry out our test (we can have all our pigs drinking water at the same time and regard it as ONE test).\\n\\nThen according to dynamic programming, define dp[n][t] as the maximum buckets we can detect when one of them contains poison, given the n pigs at the beginning and t times for carrying out tests. So let's go through some basic cases.\\n\\ndp[1][1] == 2, since if you have just one pig and can only do one test, the maximum buckets you can detect is 2: you can choose any one bucket to feed the pig, and if it dies after a certain time, the poison is in the chosen bucket, otherwise in the other one. \\n\\nThen we can know that dp[1][t] == t + 1, you can carry out tests that have the only one pig drinking bucket one by one and get the poisonous bucket. \\n\\nHow about dp[n][1]? This is a little tricky. We can encode the buckets with binary number, for example, there is 16 buckets and we encode them from 0 to 15 as 0000, 0001, 0010, ..., 1110, 1111, and also give each pig a sequence number from 0 to n - 1. After that, we feed these n pigs as binary number do, that is, we don't feed bucket 0 to any pig, since bucket 0's code is all 0s; we feed bucket 10 whose code is 1010 to pig 1 and pig 3, since the bit 1 and bit 3 of 1010 is 1s while other bits are 0s(we count the bit from LSB and start from 0). After feeding the pigs, we can view the state of each pig, and set state \"alive\" as 0 and \"died\" as 1, then these pigs' states form a binary number, for example 1100, means pig 2 and pig 3 are died, which means the code of poisonous bucket is exactly 1100, namely bucket 12. Thus, we can detect as many as 2^n buckets in one test with n pigs, that is, dp[n][1] == 2^n.\\n\\nWith these basic cases, we can construct our state transition equation now. For dp[n][t], how can we make full use of all 2^n states those pigs can generate after one test? The answer is simple. After one test, if all pigs dies, we must assure there is only one bucket that all pigs drank from, since we don't have any pigs to use afterwards. If we have k pigs alive(0 < k <= n), we can use these pigs to detect at most dp[k][t-1] buckets. With some knowledge of permutation and combination, the number of cases we can have k pigs alive after one test is C(n, k) (when k == 0, it also holds true). So our state transition equation is\\n\\n    dp[n][t] = \\n    C(n,0)+C(n,1)dp[1][t-1]+...+C(n,k)dp[k][t-1]+...+C(n,n)dp[n][t-1], where 0 <= k <= n, t >= 2\\n\\nThus\\n    \\n    dp[n][2] =  C(n,0)+C(n,1)dp[1][1]+...+C(n,k)dp[k][1]+...+C(n,n)dp[n][1]= \\n    C(n,0)+C(n,1)2^1+...+C(n,k)2^k+...+C(n,n)2^n=3^n\\n    dp[n][3] =  C(n,0)+C(n,1)dp[1][2]+...+C(n,k)dp[k][2]+...+C(n,n)dp[n][2]= \\n    C(n,0)+C(n,1)3^1+...+C(n,k)3^k+...+C(n,n)3^n=4^n\\n    ...\\n\\nA concise mathematical formula is generated! \\n\\n    dp[n][t] = (t+1)^n, for all n >= 1 and t >= 1.\\nCome back to our origin problem, if we can use minimum n pigs to detect N buckets with T tests, n should be \\n    \\n    ceil(log_(t+1)(N))\\n    == ceil((log(N)/log(t+1))\\n\\nCeil is rounding above. Here I give a illustration of dp[2][2] == (2+1)^2 == 9 as an example below:\\n\\nWe have 2 pigs at first and can carry out 2 tests. Firstly, we know 2 pigs can form 4 states of \"alive\"(0) or \"died\"(1), including 00, 01, 10, 11, each one is relative to a subproblem of dynamic programming. If after one test, two pigs both die, we can only handle one bucket in this case. However, if we have only one pig alive, we can handle dp[1][1](one pig left, with one chance of test left) namely 2 buckets, and there are actually two cases of only one pig left alive(2 == C(2, 1)). If both two are alive, we can handle  dp[2][1] = 2^2=4 buckets totally. Thus, we separate 9 into 4 groups, and each one respectively contains 1, 2, 2 and 4 buckets, and design our first test. We feed our pig 0 with bucket 0, bucket 1 and bucket 3, and feed our pig 1 with bucket 0, bucket 2 and bucket 4. So you can see no matter which code is generated after one test, the problem is reduced to a subproblem we have already solved before.\\n\\nBased on the analysis above, I can explain the answer for input [1000, 15, 60], in which according to my definition,  N == 1000 and T == 60/15=4, the minimum number of pigs we use should be ceil(log_(4+1)(1000))~=ceil(4.29)==5\\n\\nFinally, notice that if there is only 1 bucket, we can immediately detect this bucket containing poison, without any pigs or tests.",
                "codeTag": "Unknown"
            },
            {
                "id": 2387610,
                "title": "python-detailed-explanation-faster-than-98-easily-understood-simple-math",
                "content": "**Appreciate if you could upvote this solution**\\n<br/>\\nMethod: `Math`\\n\\nLet `T` be the number of times to test so `T = minutesToTest / minutesToDie`\\n& `p` be the numbers of pigs to test in each round\\n& `b` be the maximum number of buckets that can be test.\\n\\nFirst of all, we need to find out the relatioship between `T` and `p`.\\n\\n<br/>\\n\\nFor the example 1: `T = 60 / 15= 4`\\n\\n\\nWhen `p` = 1\\n```\\nAt 0 mins: \\n\\t- Feed pig with b1\\n\\nAt 15 mins: \\n\\t- If pig dies, b1 is poisonous.\\n\\t- else feed pig with b2\\n\\nAt 30 mins: \\n\\t- If pig dies, b2 is poisonous.\\n\\t- else feed pig with b3\\n\\nAt 45 mins: \\n\\t- If pig dies, b3 is poisonous.\\n\\t- else feed pig with b4\\n\\nAt 60 mins: \\n\\t- If pig dies, b4 is poisonous.\\n\\t- else b5 is poisonous.\\n```\\nThus, when `p = 1`, `b = 5 < 1000 buckets`\\nIf we stores those step into a matrix, it looks like:\\n![image](https://assets.leetcode.com/users/images/0b92af6e-ff9a-4f6d-aba4-a9e000f30ad1_1659761122.9130213.png)\\n\\nWhen `p` = 2, the matrix looks like:\\n![image](https://assets.leetcode.com/users/images/b0a540e8-deee-4da6-a566-71d8436ac72f_1659761408.6394453.png)\\n\\nThen `p1` would drink the buckets at each row in each round \\n& `p2` would drink the buckets at each column in each round.\\n\\n```\\nAt 0 mins: \\n\\t- Feed p1 with b1 + b2 + b3 +b4 + b5\\n\\t- Feed p2 with b1 + b6 + b11 + b16 + b21\\n\\nAt 15 mins: \\n\\t- If p1 and p2 die, b1 is poisonous.\\n\\t- If p1 dies and p2 lives, one of b2 + b3 + b4 + b5 is poisonous\\n\\t\\t- Feed b2 + b3 + b4 in the following rounds\\n\\t- If p1 lives and p2 dies, one of b6 + b11 + b16 + b21 is poisonous\\n\\t\\t- Feed b6 + b11 + b16 in the following rounds\\n\\t- If p1 lives and p2 lives, \\n\\t\\t- Feed p1 with b6 + b7 + b8 + b9 + b10 (b6 is not poisonous, but put it here for easy-understanding)\\n\\t\\t- Feed p2 with b2 + b7 + b12 + b17 + b22 (b2 is not poisonous, but put it here for easy-understanding)\\n\\nAnd so on...\\n```\\nThus, we can find that `b = 25`.\\n\\nWhen `p = 1` and `T = 5`, \\n - `b = 5 = T ^ 1`\\n \\nWhen `p = 2` and `T = 5`, \\n - `b = 25 = T ^ 2`\\n\\nThus, we can inference that \\n`T ^ p \\u2265 buckets` \\n`p * log(T) \\u2265 log(buckets)`\\n`p \\u2265 log(T, buckets)`\\nThus, `p = roundup(log(T, buckets))`\\n\\nCode:\\n```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        return math.ceil(math.log(buckets, minutesToTest/minutesToDie + 1))\\n```\\n**Time complexity**: \\n - Ignore the log calculation: `O(1)`\\n\\n**Space complexity**:\\n - Ignore the log calculation: `O(1)`\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nAt 0 mins: \\n\\t- Feed pig with b1\\n\\nAt 15 mins: \\n\\t- If pig dies, b1 is poisonous.\\n\\t- else feed pig with b2\\n\\nAt 30 mins: \\n\\t- If pig dies, b2 is poisonous.\\n\\t- else feed pig with b3\\n\\nAt 45 mins: \\n\\t- If pig dies, b3 is poisonous.\\n\\t- else feed pig with b4\\n\\nAt 60 mins: \\n\\t- If pig dies, b4 is poisonous.\\n\\t- else b5 is poisonous.\\n```\n```\\nAt 0 mins: \\n\\t- Feed p1 with b1 + b2 + b3 +b4 + b5\\n\\t- Feed p2 with b1 + b6 + b11 + b16 + b21\\n\\nAt 15 mins: \\n\\t- If p1 and p2 die, b1 is poisonous.\\n\\t- If p1 dies and p2 lives, one of b2 + b3 + b4 + b5 is poisonous\\n\\t\\t- Feed b2 + b3 + b4 in the following rounds\\n\\t- If p1 lives and p2 dies, one of b6 + b11 + b16 + b21 is poisonous\\n\\t\\t- Feed b6 + b11 + b16 in the following rounds\\n\\t- If p1 lives and p2 lives, \\n\\t\\t- Feed p1 with b6 + b7 + b8 + b9 + b10 (b6 is not poisonous, but put it here for easy-understanding)\\n\\t\\t- Feed p2 with b2 + b7 + b12 + b17 + b22 (b2 is not poisonous, but put it here for easy-understanding)\\n\\nAnd so on...\\n```\n```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        return math.ceil(math.log(buckets, minutesToTest/minutesToDie + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385836,
                "title": "c-one-line-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint poorPigs(int buckets, int poisonTime, int totalTime) {\\n        \\n        // Total Rounds (T) = totalTime/poisonTime\\n        // Assume p = no of pigs that will give us the result\\n        // Therefore, (T+1)^p >= buckets\\n        // Taking log on both sides, p = log(buckets)/log(T+1);\\n        // Return ceil of p \\n        \\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint poorPigs(int buckets, int poisonTime, int totalTime) {\\n        \\n        // Total Rounds (T) = totalTime/poisonTime\\n        // Assume p = no of pigs that will give us the result\\n        // Therefore, (T+1)^p >= buckets\\n        // Taking log on both sides, p = log(buckets)/log(T+1);\\n        // Return ceil of p \\n        \\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935624,
                "title": "poor-pigs-unethical-experiments-and-poisoned-bacon-one-line-math-solution",
                "content": "The key to the problem is realizing the number of states possible for a test pig at the end of the testing period. For the case given in the problem, 1 hour testing period with 15 minutes cooldown, a pig can test 4 times. Therefore the number of states the pig can be at the end is 5: it either dies on the 1st, 2nd, 3rd, or 4th test, or it lives until the end. (wp pig, wp)\\n\\nnow imagine a number with an undetermined number of digits, [x x x ...], with each digit only capable of going up to a max of 5. What is the minimum number of digits (or pigs) the number need to encompass 1000 possibilities (or buckets)?\\nThe answer is 5 pigs, because 5^5 = 3125.\\nTherefore the formula is (t+1)^x=m\\nwhere t is number of trials possible, x is minimum number of pigs, m is number of buckets.\\n\\nVisually the test would look like this:\\nThe first pig drinks 4 times, \\n[1 x x x x], [2 x x x x], [3 x x x x], [4 x x x x]\\nif it dies in the 1st, 2nd, 3rd or 4th testing phase, we know the first digit of the location of the bucket of poison is 1, 2, 3 or 4 respectively. If the pig does not die, we know the first digit is 5.\\nThe second pig does something similar, except it varies the second digit,\\n[x 1 x x x], [x 2 x x x], [x 3 x x x], [x 4 x x x]\\nand similarly we can find out the second digit of the poison bucket location.\\nRepeat this for all 5 pigs and we will have the definitive answer to which bucket holds the poison.\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return ceil(log(buckets)/log((minutesToTest/minutesToDie)+1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return ceil(log(buckets)/log((minutesToTest/minutesToDie)+1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385521,
                "title": "java-easiest-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int tdie, int ttest) {\\n        int test = ttest/tdie;\\n        int i=0;\\n        while(Math.pow(test+1,i)< buckets){\\n            i++;\\n        }return i;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int poorPigs(int buckets, int tdie, int ttest) {\\n        int test = ttest/tdie;\\n        int i=0;\\n        while(Math.pow(test+1,i)< buckets){\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 938418,
                "title": "c-concise-solution-100-time-60-space",
                "content": "This was really a thought provoking and worth the effort, although maybe it was more of a medium than a hard.\\n\\nTo figure out how to solve it we can go multiple paths, but let\\'s go with the one I find myself to be more intuitive - assuming we only have one round of tests.\\n\\nNow, let\\'s say we want to test `16` buckets and with one sole pig we might take up to `16` attempts (testing each single bucket one by one), so clearly not in range of our thought experiment with only one trial.\\n\\nWith 2 pigs, we might try to play a bit smart:\\n* the first pig would drink from the first 8 buckets;\\n* the second one would drink from the `5 - 12` range (counting from `1`) of buckets.\\n\\n```cpp\\n// 1 = that pig drunk from this bucket, 0 = that pig skipped it\\np1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0\\np2 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0\\n```\\n\\nThis way, we might have the boil down the possible buckets to just `4`, via a logical `AND`:\\n* easiest case - if both pigs die, it has to be some bucket in the `5 - 8` range;\\n* conversely, if both survive, the poison that we know is in just one bucket, has to be in the `13 - 16` range;\\n* alternative pigs surviving will tell us that it is either in the `1 - 4` (first pig dying, second pig surviving) or `9 -12` (the other way around) range.\\n\\nFast forward and you can see how parsing all our 16 buckets in one go might require `4` pigs, to have a unique combination for each bucket - it is just binary composition, in a way.\\n\\nSame if we had any number of buckets `> 8`, but still `<= 16`.\\n\\nMore in general, we can conclude that the number of required pigs to check `buckets` possibilities in one single attempt is equal to `log2(buckets)`, rounded up.\\n\\nWhat if we have multiple chances, then?\\n\\nWell, in that case we can just split the problem into `buckets / numberOfAttempts` copies of the problem we just discussed (solving with just one trial).\\n\\nNow, we know that the number of possible attempts it is equal to `totalTimeToTest / minutesToDie + 1` (`+ 1` since it we can wait after the time is over to check what happens to the pigs after their last drink), so doing the last bit of math, we can end up with the final formula.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\n// 1 = that pig drunk from this bucket, 0 = that pig skipped it\\np1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0\\np2 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936303,
                "title": "javascript-solution-with-detail-explanation",
                "content": "#### Solution Explanation\\nLet\\'s simulate with a few examples.\\n\\n##### Example 1\\nLet\\'s say we have 3 rounds to test and need to test 4 buckets. To find out the poisonous bucket we need 1 pig. \\n\\n**Simulation**\\n```\\nRound 1: Pig 1 drink 1st bucket. \\n\\t\\tIf it dies then, Bucket 1 is the poisonous bucket. \\nRound 2: If Pig 1 survive Round 1 lets test 2nd Bucket\\n\\t\\tIf it dies then, Bucket 2 is the poisonous bucket. \\nRound 3: If Pig 1 survive Round 2 lets test 3rd Bucket\\n\\t\\tIf it dies then, Bucket 3 is the poisonous bucket. \\n\\t\\t\\nIf the pig survive round 3 then `Bucket 4` is the poisonous\\n```\\nWe do not need to test anymore. Eighter the pig die or live we can say after `Round 3` which bucket is poisonous. \\n\\n**Conclusion**\\nWe can test `n + 1` buckets with 1 pig. where n is the number of rounds we can test.\\n\\n##### Example 2\\nLet\\'s say we have 2 rounds to test and need to test 9 buckets. To find out the poisonous bucket we need a minimum of 2 pigs. \\n\\nLet\\u2019s rearrange the buckets in `Row x Col` fashion.\\n```\\n  | 0 | 1 | 2 | ---> Col\\n--+---+---+---+\\n0 | 1 | 2 | 3 |\\n--+---+---+---+\\n1 | 4 | 5 | 6 |\\n--+---+---+---+\\n2 | 7 | 8 | 9 |\\n--+---+---+---+\\n```\\n\\nHere Row and Col indicates Round and Pigs `(0 indexed)`. \\n\\n**Simulation**\\n\\n```\\nRound 1: Pig 1 drink Bucket 1, 2, 3. And Pig 2 drink Bucket 1 4 7\\n\\t\\tIf both Pigs died then It\\u2019s Bucket 1 (common bucket). If Pig 1 die and Pig 2 survive\\n\\t\\tThen it\\u2019s Bucket 2 or 3 (if it\\u2019s 1 then Pig 2 also died). \\nRound 2: Now Pig 2 drink Bucket 2.\\n\\t\\tIf it dies then Bucket 2 poisonous or if survive Bucket 3 is poisonous.\\nSame Goes for Pig 1. If Pig 2 die in Round 1 and Pig 1 Survive. Then it\\u2019s Bucket 4 or 7 (if it\\u2019s 1 then Pig 1 also died). \\n\\nRound 2: Now Pig 1 drink Bucket 4.\\n\\t\\tIf it dies then Bucket 4 poisonous or if survive Bucket 7 is poisonous.\\n```\\n\\nSo far we describe If Both or one of the pig died in `Round 1`. \\nLet\\'s Now simulate if Both pigs survive `Round 1`.\\n\\n```\\nIf both pigs survive `Round 1` then It\\'s definitely not 1 2 3 4 7 Bucket. So answer lies within Bucket 5 6 8 9\\n\\nRound 2: Pig 1 drink Bucket 5 6. And Pig 2 drink Bucket 5 8\\n\\t\\tIf both Pigs died then It\\u2019s Bucket 5 (common bucket). If Pig 1 die and Pig 2 survive\\n\\t\\tThen it\\u2019s Bucket 6 (if it\\u2019s 5 then Pig 2 also died). \\n\\t\\t\\nSame goes for Pig 1. If Pig 2 die in Round 2 and Pig 1 Survive. Then it\\u2019s Bucket 8 (if it\\u2019s 5 then Pig 1 also died). \\n\\nIf both survive Round 2 then, Bucket 9 is poisonous.\\n```\\n\\n**Conclusion**\\nWe can test `(n + 1) ^ 2` buckets with 2 pig. where n is the number of rounds we can test.\\n\\nBy simulating these 2 examples we can say `if there is n round then we can test (n + 1) ^ p buckets`  \\n\\nWe know the number of buckets and rounds so we can easily solve the above equation to find the minimum number of pigs.\\n\\n#### Big question WHY n + 1?\\n To be honest I can\\'t mathematically prove why we need n + 1. But I can say if there are 2 buckets and 1 round available we just had to drink 1 bucket and then we can easily decide which bucket is poisonous after observing the pig survive Round 1 or not.\\n\\n   _***If anyone has a mathematical explanation please me know. I love to learn that._\\n   \\n ---\\n \\n #### Big Thanks To\\n ---\\n1. https://leetcode.com/sanzee/\\n2. https://leetcode.com/problems/poor-pigs/discuss/935581/C%2B%2BPythonPicture-Straightforward-solution-with-N-dimension-puzzle-cube-scan\\n3. https://www.cnblogs.com/grandyang/p/7664088.html\\n ---\\n \\n ##### Amortized Analysis\\n ---\\n Time Complexity: O(1)\\n Space Complexity: O(1)\\n \\nRuntime: 76 ms\\nMemory Usage: 38.2 MB\\n\\n---\\n##### Code\\n---\\n```\\n/**\\n * @param {number} buckets\\n * @param {number} minutesToDie\\n * @param {number} minutesToTest\\n * @return {number}\\n */\\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n  let answer = 1;\\n  let n = minutesToTest / minutesToDie >> 0;\\n  n += 1;\\n  \\n  // calculation with loop\\n  // while(n ** answer <= buckets) {\\n  //   answer++;\\n  // }\\n  \\n  return Math.ceil(Math.log(buckets) / Math.log(n));\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRound 1: Pig 1 drink 1st bucket. \\n\\t\\tIf it dies then, Bucket 1 is the poisonous bucket. \\nRound 2: If Pig 1 survive Round 1 lets test 2nd Bucket\\n\\t\\tIf it dies then, Bucket 2 is the poisonous bucket. \\nRound 3: If Pig 1 survive Round 2 lets test 3rd Bucket\\n\\t\\tIf it dies then, Bucket 3 is the poisonous bucket. \\n\\t\\t\\nIf the pig survive round 3 then `Bucket 4` is the poisonous\\n```\n```\\n  | 0 | 1 | 2 | ---> Col\\n--+---+---+---+\\n0 | 1 | 2 | 3 |\\n--+---+---+---+\\n1 | 4 | 5 | 6 |\\n--+---+---+---+\\n2 | 7 | 8 | 9 |\\n--+---+---+---+\\n```\n```\\nRound 1: Pig 1 drink Bucket 1, 2, 3. And Pig 2 drink Bucket 1 4 7\\n\\t\\tIf both Pigs died then It\\u2019s Bucket 1 (common bucket). If Pig 1 die and Pig 2 survive\\n\\t\\tThen it\\u2019s Bucket 2 or 3 (if it\\u2019s 1 then Pig 2 also died). \\nRound 2: Now Pig 2 drink Bucket 2.\\n\\t\\tIf it dies then Bucket 2 poisonous or if survive Bucket 3 is poisonous.\\nSame Goes for Pig 1. If Pig 2 die in Round 1 and Pig 1 Survive. Then it\\u2019s Bucket 4 or 7 (if it\\u2019s 1 then Pig 1 also died). \\n\\nRound 2: Now Pig 1 drink Bucket 4.\\n\\t\\tIf it dies then Bucket 4 poisonous or if survive Bucket 7 is poisonous.\\n```\n```\\nIf both pigs survive `Round 1` then It\\'s definitely not 1 2 3 4 7 Bucket. So answer lies within Bucket 5 6 8 9\\n\\nRound 2: Pig 1 drink Bucket 5 6. And Pig 2 drink Bucket 5 8\\n\\t\\tIf both Pigs died then It\\u2019s Bucket 5 (common bucket). If Pig 1 die and Pig 2 survive\\n\\t\\tThen it\\u2019s Bucket 6 (if it\\u2019s 5 then Pig 2 also died). \\n\\t\\t\\nSame goes for Pig 1. If Pig 2 die in Round 2 and Pig 1 Survive. Then it\\u2019s Bucket 8 (if it\\u2019s 5 then Pig 1 also died). \\n\\nIf both survive Round 2 then, Bucket 9 is poisonous.\\n```\n```\\n/**\\n * @param {number} buckets\\n * @param {number} minutesToDie\\n * @param {number} minutesToTest\\n * @return {number}\\n */\\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n  let answer = 1;\\n  let n = minutesToTest / minutesToDie >> 0;\\n  n += 1;\\n  \\n  // calculation with loop\\n  // while(n ** answer <= buckets) {\\n  //   answer++;\\n  // }\\n  \\n  return Math.ceil(Math.log(buckets) / Math.log(n));\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218434,
                "title": "simplest-explanation",
                "content": "First, the pig will die **within** 15min, **not exactly** 15min. So we can\\'t let pig drink every second.\\n\\nThe simplest explanation is to check the number of combination of pigs\\' life status. \\n\\nFor example, if mintodie == mintotest, then each pig can only have two life status: live or die in the end. So the number of combination is 2^N. When 2^N is equal or greater than num of bucket, the smallest N is out answer\\n\\nIf mintotest/mintodie = **K**, for example, mintotest = 60 and mintodie = 15, each pig could have five different status: die at 15,30,45,60 or live in the end. The combination is 5^N. Make 5^N => num of buckets, smallest N is the answer.\\n\\n```\\nbase = minutesToTest/minutesToDie+1\\nres = 0\\nwhile base**res < buckets:\\n\\tres += 1\\nreturn res\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nbase = minutesToTest/minutesToDie+1\\nres = 0\\nwhile base**res < buckets:\\n\\tres += 1\\nreturn res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2398430,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Poor Pigs.\\n```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // Initialize the required minimum number of pigs...\\n        int req_pigs = 0;\\n        // To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (Math.pow(max_time, req_pigs) < buckets)\\n            // Increment until it will be greater or equals to bucket...\\n            ++req_pigs;\\n        // Return the required minimum number of pigs...\\n        return req_pigs;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // To find the minimum number of pigs, return ceil(log(buckets) / log(max_time))...\\n        return ceil(log(buckets) / log(max_time));\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 21 ms, faster than 79.11% of Python online submissions for Poor Pigs.\\n```\\nclass Solution(object):\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        # Calculate the max time for a pig to test buckets...\\n        # Note that, max time will not be (minutesToTest / minutesToDie)...\\n        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        max_time = minutesToTest / minutesToDie + 1\\n        # Initialize the required minimum number of pigs...\\n        req_pigs = 0\\n        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (max_time) ** req_pigs < buckets:\\n            # Increment until it will be greater or equals to bucket...\\n            req_pigs += 1\\n        # Return the required minimum number of pigs...\\n        return req_pigs\\n```\\n        \\n# **JavaScript Solution:**\\n```\\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n    // Calculate the max time for a pig to test buckets...\\n    // Note that, max time will not be (minutesToTest / minutesToDie)...\\n    // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n    let max_time = minutesToTest / minutesToDie + 1;\\n    // Initialize the required minimum number of pigs...\\n    let req_pigs = 0;\\n    // To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n    while (Math.pow(max_time, req_pigs) < buckets)\\n        // Increment until it will be greater or equals to bucket...\\n        ++req_pigs;\\n    // Return the required minimum number of pigs...\\n    return req_pigs;\\n};\\n```\\n\\n# **C Language:**\\nRuntime: 0 ms, faster than 100.00% of C online submissions for Poor Pigs.\\n```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest){\\n    // Base condition...\\n    if (buckets --== 1){\\n            return 0;\\n    }\\n    // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n    int max_time = minutesToTest / minutesToDie + 1;\\n    // Initialize the required minimum number of pigs...\\n    int req_pigs = 0;\\n    // Process to find the minimum number of pigs...\\n    while (buckets > 0){\\n        buckets /= max_time;\\n        req_pigs++;\\n    }\\n    // Return the required minimum number of pigs...\\n    return req_pigs;\\n}\\n```\\n\\n# **Python3 Solution:**\\nRuntime: 38 ms, faster than 76.64% of Python3 online submissions for Poor Pigs.\\n```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        # Calculate the max time for a pig to test buckets...\\n        # Note that, max time will not be (minutesToTest / minutesToDie)...\\n        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        max_time = minutesToTest / minutesToDie + 1\\n        # Initialize the required minimum number of pigs...\\n        req_pigs = 0\\n        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (max_time) ** req_pigs < buckets:\\n            # Increment until it will be greater or equals to bucket...\\n            req_pigs += 1\\n        # Return the required minimum number of pigs...\\n        return req_pigs\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // Initialize the required minimum number of pigs...\\n        int req_pigs = 0;\\n        // To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (Math.pow(max_time, req_pigs) < buckets)\\n            // Increment until it will be greater or equals to bucket...\\n            ++req_pigs;\\n        // Return the required minimum number of pigs...\\n        return req_pigs;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // To find the minimum number of pigs, return ceil(log(buckets) / log(max_time))...\\n        return ceil(log(buckets) / log(max_time));\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        # Calculate the max time for a pig to test buckets...\\n        # Note that, max time will not be (minutesToTest / minutesToDie)...\\n        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        max_time = minutesToTest / minutesToDie + 1\\n        # Initialize the required minimum number of pigs...\\n        req_pigs = 0\\n        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (max_time) ** req_pigs < buckets:\\n            # Increment until it will be greater or equals to bucket...\\n            req_pigs += 1\\n        # Return the required minimum number of pigs...\\n        return req_pigs\\n```\n```\\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n    // Calculate the max time for a pig to test buckets...\\n    // Note that, max time will not be (minutesToTest / minutesToDie)...\\n    // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n    let max_time = minutesToTest / minutesToDie + 1;\\n    // Initialize the required minimum number of pigs...\\n    let req_pigs = 0;\\n    // To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n    while (Math.pow(max_time, req_pigs) < buckets)\\n        // Increment until it will be greater or equals to bucket...\\n        ++req_pigs;\\n    // Return the required minimum number of pigs...\\n    return req_pigs;\\n};\\n```\n```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest){\\n    // Base condition...\\n    if (buckets --== 1){\\n            return 0;\\n    }\\n    // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n    int max_time = minutesToTest / minutesToDie + 1;\\n    // Initialize the required minimum number of pigs...\\n    int req_pigs = 0;\\n    // Process to find the minimum number of pigs...\\n    while (buckets > 0){\\n        buckets /= max_time;\\n        req_pigs++;\\n    }\\n    // Return the required minimum number of pigs...\\n    return req_pigs;\\n}\\n```\n```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        # Calculate the max time for a pig to test buckets...\\n        # Note that, max time will not be (minutesToTest / minutesToDie)...\\n        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        max_time = minutesToTest / minutesToDie + 1\\n        # Initialize the required minimum number of pigs...\\n        req_pigs = 0\\n        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (max_time) ** req_pigs < buckets:\\n            # Increment until it will be greater or equals to bucket...\\n            req_pigs += 1\\n        # Return the required minimum number of pigs...\\n        return req_pigs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935260,
                "title": "python-3-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=_JcO3fqoG2M)\\nhttps://www.youtube.com/watch?v=_JcO3fqoG2M\\n```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        pigs = 0\\n        \\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\\n            pigs += 1\\n            \\n        return pigs\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        pigs = 0\\n        \\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\\n            pigs += 1\\n            \\n        return pigs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270377,
                "title": "very-easy-arithmetics-the-right-way-to-encode-the-buckets-less-than-10-lines-beats-100",
                "content": "Change the question into:\\n\\nThere are **100 buckets** where **ONE** of them is poisonous. The pig that drinks the poisonous liquid will die in **1 minute**. How can we find out which one is poisonous in **1 minute**(ONE PASS) with **7 pigs**.\\n\\nThe number **7** here is not chosen randomly. **7** is the minimal number of **binary** digits that can encode number 0-99. We mark the bucket as 0-99 in binary codes, which is 0000000 ... 1100100. We let the first pig drink all buckets whose first digit is 1, then the second, till all seven pigs drinks all buckets.\\n\\nAfter one minute, if the first pig dies, the first digit of poisonous bucket is one, otherwise zero. This trend is the same for all pigs.\\n\\nIf we are allowed to find the result not in ONE pass but in **k passes**, we can change our base for encoding to **k+1**. Like the sample question, where there are **1000 buckets**, **4 passes** (pig dies in 15 minutes and 60 minutes are allowed), we can encode number 0-999 in **5 digits** of **5 base numbers**.\\n\\n0->00000\\n1->00001\\n2->00002\\n3->00003\\n4->00004\\n5->00005\\n...\\n1000->13000\\n\\nIn the first pass, the first pig drinks from buckets whose first digit is **1**, **second** pig drinks from buckets whose **second** digit is **1**.\\nShould a pig dies, the digit that pig \"represents\" would be **1**. Like, if the second and third pigs die, we can pin down the second and third digits **1** and after the first pass, the \"poisonous code\" is cracked from ????? to **?11??**.\\nIf this is the case, then we have only three pigs in the second round. But don\\'t worry, since the second and third digit of the poisonous code is now one for sure, we let the first pig drink from buckets whose first digit is **2**, then we skip the second and the third digits, we let the fourth pig and the fifth pig to drink buckets whose fourth and fifth digit is **2** respectively.\\nShould a lucky pig survives all rounds, the digit that pig represents is **0**.\\n\\nHere the code:\\nA logrithm would make it even easier.\\n\\n```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest)\\n{\\n    if(buckets==1)\\n        return 0;\\n    int digits = 1;\\n    int base = minutesToTest / minutesToDie + 1;\\n    int timer = base;\\n    while(buckets>timer)\\n    {\\n        timer*=base;\\n        digits+=1;\\n    }\\n    return digits;\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest)\\n{\\n    if(buckets==1)\\n        return 0;\\n    int digits = 1;\\n    int base = minutesToTest / minutesToDie + 1;\\n    int timer = base;\\n    while(buckets>timer)\\n    {\\n        timer*=base;\\n        digits+=1;\\n    }\\n    return digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94328,
                "title": "math-problem-java-ac-code-with-brief-explanations-11-09-2016",
                "content": "This is a Math problem.\\nThe table below shows how it works, n denotes the pig, and s is associated with each status of the pig. \\nfor each pig, there is t+1 status, which is death in 1st, 2nd, 3rd, 4th time slot and live eventually. \\nTherefore the question is asking for how many pigs can denote 1000 in 5-nary number system.\\n=======Table=======\\nn1 n2 n3 n4 n5 \\ns1  1   0   0   1   0\\ns2  0   0   0   0   1   \\ns3  0   1   0   0   0\\ns4  0   0   0   0   0\\ns5  0   0   1   0   0\\n\\nIn this case, the number is 13012 in 5-nary number system. \\n* Here is my Java AC code\\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int status = minutesToTest/minutesToDie + 1;\\n        int num_of_pig = 0;\\n        while(Math.pow(status, num_of_pig) < buckets) {num_of_pig++;}\\n        return num_of_pig;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int status = minutesToTest/minutesToDie + 1;\\n        int num_of_pig = 0;\\n        while(Math.pow(status, num_of_pig) < buckets) {num_of_pig++;}\\n        return num_of_pig;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939078,
                "title": "on-paper-mathematically-proved-one-line-solution-java",
                "content": "![image](https://assets.leetcode.com/users/images/22968318-409c-4fc0-a6f8-ba68dd30ceb7_1605623349.2260263.png)\\n![image](https://assets.leetcode.com/users/images/aea2562e-31bb-4878-a8e5-5d1a842c7821_1605623366.66847.png)\\n\\nPlease upvote if you like the solution. Pardon me for the handwriting, poor grammar, cuttings, spelling mistakes and syntactical errors. Please find the code below.\\n```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return (int)Math.ceil(Math.log(buckets) / Math.log((minutesToTest / minutesToDie) + 1));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return (int)Math.ceil(Math.log(buckets) / Math.log((minutesToTest / minutesToDie) + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386758,
                "title": "java-0ms-100",
                "content": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int mi, int mt) {\\n      int period = mt / mi + 1;\\nint ans = 0;\\nwhile(Math.pow(period, ans) < buckets)\\n{\\nans ++;\\n}\\nreturn ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF YOU WANT JUSTICE FOR PIGS",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int mi, int mt) {\\n      int period = mt / mi + 1;\\nint ans = 0;\\nwhile(Math.pow(period, ans) < buckets)\\n{\\nans ++;\\n}\\nreturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386378,
                "title": "python-binary-kill-mosquitoes-instead-of-pigs",
                "content": "Why\\'d they not use something like mosquitoes or rats instead of pigs \\u30FD(\\u0CA0_\\u0CA0)\\u30CE\\nDrink or not drink is binary ```0``` or ```1```, so we can encode buckets using binary encoding using pigs.\\n\\n### Code\\n```python\\ndef poorPigs(self, B, D, T):\\n\\ttmp = log2(B) # number of pigs for one shot\\n\\tt = ceil(T/D) # number of tests we can conduct\\n\\n\\tif t == 1: return ceil(tmp) # one shot is the answer\\n\\treturn ceil(tmp / log2(t+1)) # re-use pigs until the answer is found (# of tests)\\n```\\n\\n### Intuition\\nWe can come up with the solution starting from simple scenarios\\n* 1 or 2 buckets --> 1 pig is enough (right, this one\\'s trivial)\\n* 3 or 4 buckets --> 2 pigs are enough, because the task is similar to identifying buckets using binary values (i.e. ```0``` and ```1```)\\n\\t* bucket1 : noone drinks it\\n\\t* bucket2 : pig#1 drinks this bucket\\n\\t* bucket3 : pig#2 drinks this bucket\\n\\t* bucket4 : both pigs drink it\\ni.e. we can use ```log2(B)``` pigs to identify each bucket by looking at which pigs have died and what they drank i.e. ```1```\\n\\n### Thinking process\\n![image](https://assets.leetcode.com/users/images/b99f1259-11d9-4d9f-bb53-ebcb39b7549a_1659776913.623787.jpeg)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```0```\n```1```\n```python\\ndef poorPigs(self, B, D, T):\\n\\ttmp = log2(B) # number of pigs for one shot\\n\\tt = ceil(T/D) # number of tests we can conduct\\n\\n\\tif t == 1: return ceil(tmp) # one shot is the answer\\n\\treturn ceil(tmp / log2(t+1)) # re-use pigs until the answer is found (# of tests)\\n```\n```0```\n```1```\n```log2(B)```\n```1```",
                "codeTag": "Python3"
            },
            {
                "id": 2450802,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=ckBqsSyKf-k&t=146s\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387097,
                "title": "floating-point-errors-and-a-more-accurate-solution",
                "content": "Many people have suggested the following one-line solution to the problem:\\n```cpp\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n  return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n```\\nThis solution is unfortunately **inaccurate** for certain specific inputs, such as the following:\\n```\\n125\\n1\\n4\\n```\\nThe correct answer for this test case is `3`; you can check with the custom testcase runtime.\\n\\nUnfortuantely, the implementation of `poorPigs()` above will **return** `4` when provided with this input. The expression calculated with this specific input boils down to:\\n```\\nreturn ceil(log(125) / log(4 / 1 + 1));\\nreturn ceil(log(125) / log(5));\\nreturn ceil(3.0000000000000004); // !!! Floating point error: The correct value for this is `3`\\nreturn 4; // failure\\n```\\n# **How do I fix this?**\\nThe patch for this is simple. Instead of using a logarithm to calculate the answer, we will use exponentials (because the values involved in exponentiation will all be integers, and hence accurate).\\n```cpp\\n#define MAX_PIGS 10\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    int base = totalTime/poisonTime + 1;\\n    for (int i = 0; i < MAX_PIGS; i++) {\\n        if (powl(base,i) >= buckets)\\n            return i;\\n    }\\n    return MAX_PIGS;\\n}\\n```\\nWithin the constraints of the problem, the maximum number of pigs required will always be `<= 10` (consider `poorPigs(1000,1,1)` to prove this). Therefore, we can simply test linearly upwards from 0 pigs to 10 pigs, and return as soon as the number of pigs is sufficient.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n  return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n```\n```\\n125\\n1\\n4\\n```\n```\\nreturn ceil(log(125) / log(4 / 1 + 1));\\nreturn ceil(log(125) / log(5));\\nreturn ceil(3.0000000000000004); // !!! Floating point error: The correct value for this is `3`\\nreturn 4; // failure\\n```\n```cpp\\n#define MAX_PIGS 10\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    int base = totalTime/poisonTime + 1;\\n    for (int i = 0; i < MAX_PIGS; i++) {\\n        if (powl(base,i) >= buckets)\\n            return i;\\n    }\\n    return MAX_PIGS;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386318,
                "title": "c-solution-100-faster-with-some-some-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int poorPigs(int b, int md, int mt) {\\n        \\n            // if x is a min number of pigs then for 1 tests answer we can say that:\\n            //     2^x >= buckets\\n            //    so x >= log2(buckets)\\n            //       x = ceil(log2(buckets))\\n            // how??\\n            //  1 tests we can say for 2 buckets:\\n            //       p0    // 1 pig for 2 buckets\\n            //  b0 - 0      \\n            //  b1 - 1\\n            //  \\n            //      p0 p1  // 2pigs for 4 buckets\\n            //  b0 - 0 0\\n            //  b1 - 0 1\\n            //  b2 - 1 0\\n            //  b3 - 1 1\\n            // if p0 dies = b2 is poisonous\\n            // if p1 dies = b1 is poisonous\\n            // if both dies = b3 is poisonous\\n            // if no one dies = b0 is poisonous\\n        \\n            // similarly 3 pigs for 8 buckets\\n            // so generaly for 2^x buckets we need atmost x pigs \\n        \\n            // for 2 tests ans:\\n            //      3^x >= buckets (3 choices 0,1,2)\\n            // like for 2 pigs we need 3^2 buckets = 9;\\n            //          p0 p1 \\n            //  b0 -    0  0  \\n            //  b1 -    0  1    // 1 shows that drink b1 bucket to p1 pig during first test \\n            //  b2 -    0  2    //  2shows that drink p1 pig in second test\\n            //  b3 -    1  0   \\n            //  b4 -    1  1 \\n            //  b5 -    1  2 \\n            //  b6 -    2  0\\n            //  b7 -    2  1 \\n            //  b8 -    2  2\\n                \\n            int tests = mt/md + 1;\\n        \\n            return ceil(log(b)/log(tests));\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int poorPigs(int b, int md, int mt) {\\n        \\n            // if x is a min number of pigs then for 1 tests answer we can say that:\\n            //     2^x >= buckets\\n            //    so x >= log2(buckets)\\n            //       x = ceil(log2(buckets))\\n            // how??\\n            //  1 tests we can say for 2 buckets:\\n            //       p0    // 1 pig for 2 buckets\\n            //  b0 - 0      \\n            //  b1 - 1\\n            //  \\n            //      p0 p1  // 2pigs for 4 buckets\\n            //  b0 - 0 0\\n            //  b1 - 0 1\\n            //  b2 - 1 0\\n            //  b3 - 1 1\\n            // if p0 dies = b2 is poisonous\\n            // if p1 dies = b1 is poisonous\\n            // if both dies = b3 is poisonous\\n            // if no one dies = b0 is poisonous\\n        \\n            // similarly 3 pigs for 8 buckets\\n            // so generaly for 2^x buckets we need atmost x pigs \\n        \\n            // for 2 tests ans:\\n            //      3^x >= buckets (3 choices 0,1,2)\\n            // like for 2 pigs we need 3^2 buckets = 9;\\n            //          p0 p1 \\n            //  b0 -    0  0  \\n            //  b1 -    0  1    // 1 shows that drink b1 bucket to p1 pig during first test \\n            //  b2 -    0  2    //  2shows that drink p1 pig in second test\\n            //  b3 -    1  0   \\n            //  b4 -    1  1 \\n            //  b5 -    1  2 \\n            //  b6 -    2  0\\n            //  b7 -    2  1 \\n            //  b8 -    2  2\\n                \\n            int tests = mt/md + 1;\\n        \\n            return ceil(log(b)/log(tests));\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385568,
                "title": "pigs-force-assemble",
                "content": "to save the poor pigs here we start this movement.\\noink oink oink oink oink oink oink oink oink oink oink oink oink oink oink oink",
                "solutionTags": [
                    "C"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2385298,
                "title": "c-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386266,
                "title": "easy-to-understand-solution",
                "content": "*like you have 15 minutes timeToDie & 60 minutes TimesToTest\\nnow if you have 1 pig then you can test 5 buckets\\nSuch that for the 0th round you will give bucket 1 if pig dies it means you found else you will give 2 bucket if dies you found and so on then if you gave first 4 buckets to pig and pig is still alive then it means poison is in last buckets that is why we are taking T+1.\\n\\nso this solution will work in nd matrix like we are having 2d marix we will check from row & column where both will intersect thats our answer.\\n\\n\\n**UPVote if it helps**\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int n, int d, int t) {\\n        int cnt = t/d;\\n        cnt++;\\n        int ans = 0;\\n        int x = 1;\\n        while(x < n){\\n             x *= cnt;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int n, int d, int t) {\\n        int cnt = t/d;\\n        cnt++;\\n        int ans = 0;\\n        int x = 1;\\n        while(x < n){\\n             x *= cnt;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385440,
                "title": "i-love-animals-pigs-shouldn-t-die",
                "content": "![image](https://assets.leetcode.com/users/images/8c074b79-200c-48ec-a72d-fada0b7effd7_1659758054.48353.png)\\n\\n**Animals are a gift from above for they truly define the words unconditional love.**\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/8c074b79-200c-48ec-a72d-fada0b7effd7_1659758054.48353.png)\\n\\n**Animals are a gift from above for they truly define the words unconditional love.**\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 935703,
                "title": "java-clean-code-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        \\n        int time = (minutesToTest / minutesToDie) + 1;\\n        int pigs = 0;\\n        int total = 1;\\n        \\n        while (total < buckets) {\\n            ++pigs;\\n            total *= time;\\n        }\\n        \\n        return pigs;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        \\n        int time = (minutesToTest / minutesToDie) + 1;\\n        int pigs = 0;\\n        int total = 1;\\n        \\n        while (total < buckets) {\\n            ++pigs;\\n            total *= time;\\n        }\\n        \\n        return pigs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119640,
                "title": "a-clear-explanation",
                "content": "Suppose there are 10 buckest, 10 minutes to test and the pig dies after 3 minutes. then we can test at most 3 rounds. For each bucket, a big can drink it during round 1 or round 2 or round 3 or not drink at all ( 4 possibilities ).  Convert each bucket to a number of base 4. \\n\\n0 - 00\\n1 - 01\\n2 - 02\\n3 - 03\\n4 -10\\n5 - 11\\n6 - 12\\n7 - 13\\n8 - 20\\n9 - 21\\n10 - 22\\n \\nWe need at most 2 digits to represent 10 buckets with base 4. Each digit represents a pig. The number indicates at which round should the pig drink water in this bucket. \\n\\nTake bucket 6 as an example, 12 means, pig 1 should drink water in bucket 6 during round 1, pig 2 should drink water in bucket 6 during round 2. if pig 1 dies in round 1 and pig 2 dies in round 2, then bucket 6 is poisonous.\\n\\nSimilarly, for bucket 8, pig 1 should drink its water during round 2 and pig 2 don\\'t need to drink water in this bucket. If pig 1 dies in round 2 and pig 2 is not dead then bucket 8 is poisonous. \\n\\nThe problem is converted to how many digits are required to represent a number.\\n \\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n\\n        int base = minutesToTest / minutesToDie + 1; //total possibilites\\n        return Math.ceil(Math.log(buckets) / Math.log(base)); // number of digits to represent n buckets with base  \\n        \\n    }\\n\\n",
                "solutionTags": [],
                "code": "Suppose there are 10 buckest, 10 minutes to test and the pig dies after 3 minutes. then we can test at most 3 rounds. For each bucket, a big can drink it during round 1 or round 2 or round 3 or not drink at all ( 4 possibilities ).  Convert each bucket to a number of base 4. \\n\\n0 - 00\\n1 - 01\\n2 - 02\\n3 - 03\\n4 -10\\n5 - 11\\n6 - 12\\n7 - 13\\n8 - 20\\n9 - 21\\n10 - 22\\n \\nWe need at most 2 digits to represent 10 buckets with base 4. Each digit represents a pig. The number indicates at which round should the pig drink water in this bucket. \\n\\nTake bucket 6 as an example, 12 means, pig 1 should drink water in bucket 6 during round 1, pig 2 should drink water in bucket 6 during round 2. if pig 1 dies in round 1 and pig 2 dies in round 2, then bucket 6 is poisonous.\\n\\nSimilarly, for bucket 8, pig 1 should drink its water during round 2 and pig 2 don\\'t need to drink water in this bucket. If pig 1 dies in round 2 and pig 2 is not dead then bucket 8 is poisonous. \\n\\nThe problem is converted to how many digits are required to represent a number.\\n \\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n\\n        int base = minutesToTest / minutesToDie + 1; //total possibilites\\n        return Math.ceil(Math.log(buckets) / Math.log(base)); // number of digits to represent n buckets with base  \\n        \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2430851,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=ckBqsSyKf-k&t=146s\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386152,
                "title": "my-first-downvote-in-leetcode",
                "content": "This is not a coding question! :(((((( At all",
                "solutionTags": [],
                "code": "This is not a coding question! :(((((( At all",
                "codeTag": "Unknown"
            },
            {
                "id": 842936,
                "title": "1-line-solution-0ms-with-explanation-using-c-and-high-school-math",
                "content": "```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest) {return (int)ceil(log(buckets) / (log(minutesToTest / minutesToDie + 1)));}\\n```\\n\\nnotation :\\n```n ^ k = n * n * ... * n``` ( ```k``` times )\\n```n! = n * (n - 1) * ... * 1```\\n```C(n, k) = n! / (k! * (n - k)!)```\\n\\nrequired knowledge :\\n\\nbinominal thoerem : ```(a +b) ^ n = summation (k from 0 to n) ( C(n, k) * a ^ k * b ^ (n - k) )```\\n\\ndetail:\\nhttps://en.wikipedia.org/wiki/Binomial_theorem\\n\\nFirst, ```minutesToTest``` and ```minutesToDie``` simply tells us how many rounds we can use the pigs, i.e. how many times a pig can eat, that\\'s all. So, we can declare a variable called ```r = minutesToTest / minutsToDie```\\n\\nWe suppose that we have ``` p ``` pigs, now we define ```b(r,p)``` as the maximum amount of buckets that we can test with  ```p```pigs in ```r```rounds, then we try to prove the following result.\\n\\n**b(r,p) = (r+1)^p**\\nor \\n```int b(int r,int p){return pow(r+1,p);}```\\n\\nHere we\\'ll use mathematical induction to prove it.\\n\\nLet\\'s start from the case ```r == 1``` \\nWith only 1 pig, we can test 2 buckets (make it eat 1 of them, see if it dies.)\\nWith 2 pigs ( named as A, B), we can test 4 buckets (one bucket only eaten by A, one only by B, one by both A and B, and one by nobody)\\nWith 3 pigs (A, B, C), we can test 8 buckets (O, A, B, C, AB, AC, BC, ABC, this means the buckets are tested by which pigs)\\nIn conclusion, We can see that for ```p```pigs, there are ```C(p,k)``` buckets tested by k pigs, so we can test ```C(p,0) + C(p,1) + C(p,2) +... +C(p,p)``` buckets, which is equivalent to ```b(1,p) = 2^p``` by binominal theorem\\n\\nfor ```r >= 2```, we can have an answer by using the previous result. \\nFor ```p```pigs, we can test each bucket with ```0,1,2,...,p``` pigs. If we fix the```k```pigs with whom we\\'re going to test the buckets, then we can test up to```b(r-1,p - k)``` buckets. Because if these ```k``` pigs die we\\'ll have ```p - k ``` pigs for ```r - 1``` rounds. We can find out which bucket is poisionous among these ```b(r-1, p-k)``` buckets in ```r - 1``` rounds by the definition of ```b(r - 1, p - k)```. Also, we have ```C(p,k)``` combinations for ```k``` pigs among all the ```p``` pigs. Hence, those buckets can be classifed as tested by ```0,1,...,p``` pigs, and there will be at most ```C(p,k) * b(r - 1, p - k)``` buckets tested by ```k``` pigs . Then, we can aquire this result : ```b(r,p) = summation (k from 0 to p) ( C(p,k) * b(r - 1, p - k) )``` by induction hypothesis and ```C(p, k) = C(p, p - k)```, it equals to ```summation (k from 0 to p) ( C(p, p - k) * r ^ (p - k) ) = summation (k from 0 to p) ( C(p, k) * r ^ k * 1 ^ (p - k) ) = (r + 1) ^ p```by binominal theorem.\\n\\nIn conclusion, we try to find the minimum integer ```p``` such that ```b(r, p) >= buckets```, which is equivalent to ```(r + 1) ^ p >= buckets```, so ```p >= ( log(buckets) / log(r + 1) )```, and here we use the ceiling function and log function provided by ```math.h```, then the return value must be ```ceil( log (buckets) / log (r + 1))```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest) {return (int)ceil(log(buckets) / (log(minutesToTest / minutesToDie + 1)));}\\n```\n```n ^ k = n * n * ... * n```\n```k```\n```n! = n * (n - 1) * ... * 1```\n```C(n, k) = n! / (k! * (n - k)!)```\n```(a +b) ^ n = summation (k from 0 to n) ( C(n, k) * a ^ k * b ^ (n - k) )```\n```minutesToTest```\n```minutesToDie```\n```r = minutesToTest / minutsToDie```\n``` p ```\n```b(r,p)```\n```p```\n```r```\n```int b(int r,int p){return pow(r+1,p);}```\n```r == 1```\n```p```\n```C(p,k)```\n```C(p,0) + C(p,1) + C(p,2) +... +C(p,p)```\n```b(1,p) = 2^p```\n```r >= 2```\n```p```\n```0,1,2,...,p```\n```k```\n```b(r-1,p - k)```\n```k```\n```p - k ```\n```r - 1```\n```b(r-1, p-k)```\n```r - 1```\n```b(r - 1, p - k)```\n```C(p,k)```\n```k```\n```p```\n```0,1,...,p```\n```C(p,k) * b(r - 1, p - k)```\n```k```\n```b(r,p) = summation (k from 0 to p) ( C(p,k) * b(r - 1, p - k) )```\n```C(p, k) = C(p, p - k)```\n```summation (k from 0 to p) ( C(p, p - k) * r ^ (p - k) ) = summation (k from 0 to p) ( C(p, k) * r ^ k * 1 ^ (p - k) ) = (r + 1) ^ p```\n```p```\n```b(r, p) >= buckets```\n```(r + 1) ^ p >= buckets```\n```p >= ( log(buckets) / log(r + 1) )```\n```math.h```\n```ceil( log (buckets) / log (r + 1))```",
                "codeTag": "Unknown"
            },
            {
                "id": 132070,
                "title": "java-code-with-detailed-explanations",
                "content": "\\n* Explanations:\\nFor one pig, it can make at most **minutesToTest / minutesToDie** tests.\\nAnd, there are at most **minutesToTest / minutesToDie + 1** states. (may die in each test or alive after all tests)\\nWe assume there are n pigs, then there are **(minutesToTest / minutesToDie + 1) ^ x** states in total\\nWe aim to find the minimum x such that **(minutesToTest / minutesToDie + 1) ^ x >= buckets**\\n\\n* The change of base rule :\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mengcareers/image_1526680819.png)\\n\\n* Java Math.log :\\nMath.log(double a) : return the natural logarithm (base e) of a double value.\\n\\n```\\nimport static java.lang.Math.ceil;\\nimport static java.lang.Math.log;\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return (int) ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport static java.lang.Math.ceil;\\nimport static java.lang.Math.log;\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return (int) ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389541,
                "title": "100-simple-explanation",
                "content": "Please upvote if my solution helped you.\\n\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n\\nhttps://youtu.be/ckBqsSyKf-k\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2388836,
                "title": "dry-run-of-everyone-s-one-liner-code-here",
                "content": "```\\n /* lets dry run this for a test case \\n        \\n        n=5 dieTime=15 , totaltim=60;   Ans=1\\n        \\n    pig will test bucket no 1 in 1st trial -->  pig will test bucket no 2 in 2nd trial \\n    pig will test bucket no 3 in 3rd trial -->  pig will test bucket no 4 in 4th trial \\nnow pig doesnt die and trials finished and we dont encounter a poison bucket ?? Really?\\n\\nif there are 5 buckets and pig identified 4 buckets as non poisnosus in 4 attempts so the 5th bucket is poisonous . So a pig can identify (totalTime/dieTime +1 ) buckets in total \\n\\n   1 pig can identify --> (totalTime/dieTime+1) buckets\\n   p pigs can idenify --> (totalTime/dieTime+1)^p where p=no of pigs\\n   \\n   so (totalTime/dieTime+1)^p <= n   \\n       \\n      taking log on both sides\\n      \\n      p* log(trials) <= logn   where trials = (totaltime/dieTime+1)\\n      p <= log(n)/log(trials)\\n      p=ceil(log(n)/log(trials));\\n      */\\n    \\n    int poorPigs(int n, int dieTime, int totalTime) {\\n        \\n       return ceil(log(n)/log(totalTime/dieTime+1));\\n    }",
                "solutionTags": [],
                "code": "```\\n /* lets dry run this for a test case \\n        \\n        n=5 dieTime=15 , totaltim=60;   Ans=1\\n        \\n    pig will test bucket no 1 in 1st trial -->  pig will test bucket no 2 in 2nd trial \\n    pig will test bucket no 3 in 3rd trial -->  pig will test bucket no 4 in 4th trial \\nnow pig doesnt die and trials finished and we dont encounter a poison bucket ?? Really?\\n\\nif there are 5 buckets and pig identified 4 buckets as non poisnosus in 4 attempts so the 5th bucket is poisonous . So a pig can identify (totalTime/dieTime +1 ) buckets in total \\n\\n   1 pig can identify --> (totalTime/dieTime+1) buckets\\n   p pigs can idenify --> (totalTime/dieTime+1)^p where p=no of pigs\\n   \\n   so (totalTime/dieTime+1)^p <= n   \\n       \\n      taking log on both sides\\n      \\n      p* log(trials) <= logn   where trials = (totaltime/dieTime+1)\\n      p <= log(n)/log(trials)\\n      p=ceil(log(n)/log(trials));\\n      */\\n    \\n    int poorPigs(int n, int dieTime, int totalTime) {\\n        \\n       return ceil(log(n)/log(totalTime/dieTime+1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2387581,
                "title": "100-00-of-c-optimise-space-complexity-better-than-log-pigslivematter",
                "content": "**Please Upvote if you found this helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buck, int Die, int Test) {\\n        \\n        int y = (Test/Die) + 1;\\n        int z = y;\\n        int count = 1;\\n        if(buck==1){\\n            return 0;\\n        }\\n        \\n        while(y<buck){\\n            \\n            y = y * z;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buck, int Die, int Test) {\\n        \\n        int y = (Test/Die) + 1;\\n        int z = y;\\n        int count = 1;\\n        if(buck==1){\\n            return 0;\\n        }\\n        \\n        while(y<buck){\\n            \\n            y = y * z;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385641,
                "title": "c-math-easy-one-line-100-faster",
                "content": "````\\nclass Solution\\n{\\n    public:\\n        int poorPigs(int N, int Die, int Test)\\n        {\\n            return ceil(log(N) / log(Test / Die + 1));\\n\\t\\t\\t/* if there are N buckets then there should be a min x pigs to test which of the buckets is poisonous in \\n\\t\\t\\t    T tests which follows the equation (T+1)^x>=N, where T=Test/Die */\\n            //Hence x will the min value of log(N)/log(T+1) which can be calculated by ceil function \\n        }\\n};\\n\\n````",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution\\n{\\n    public:\\n        int poorPigs(int N, int Die, int Test)\\n        {\\n            return ceil(log(N) / log(Test / Die + 1));\\n\\t\\t\\t/* if there are N buckets then there should be a min x pigs to test which of the buckets is poisonous in \\n\\t\\t\\t    T tests which follows the equation (T+1)^x>=N, where T=Test/Die */\\n            //Hence x will the min value of log(N)/log(T+1) which can be calculated by ceil function \\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385078,
                "title": "daily-leetcoding-challenge-august-day-6",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/poor-pigs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Pig as a [qubit](https://en.wikipedia.org/wiki/Qubit)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/poor-pigs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Pig as a [qubit](https://en.wikipedia.org/wiki/Qubit)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 712293,
                "title": "java-strategy-to-experiment-design",
                "content": "Based on dimentional of Experiment Design;\\nDetails: https://leetcode.com/problems/poor-pigs/discuss/94266/Another-explanation-and-solution\\n\\n```\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int cnt = minutesToTest / minutesToDie + 1, pigs = 0;\\n        while (Math.pow(cnt, pigs) < buckets) pigs++;\\n        return pigs;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int cnt = minutesToTest / minutesToDie + 1, pigs = 0;\\n        while (Math.pow(cnt, pigs) < buckets) pigs++;\\n        return pigs;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453075,
                "title": "easy-understanding-explaining-with-picture-log",
                "content": "![image](https://assets.leetcode.com/users/images/8a87d02c-75df-40c6-81d0-af06ca8d2e87_1660992912.942108.jpeg)\\n![image](https://assets.leetcode.com/users/images/d5d113fe-99a3-4029-b5f8-0567ae38b5b8_1660992939.252564.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8a87d02c-75df-40c6-81d0-af06ca8d2e87_1660992912.942108.jpeg)\\n![image](https://assets.leetcode.com/users/images/d5d113fe-99a3-4029-b5f8-0567ae38b5b8_1660992939.252564.jpeg)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2387670,
                "title": "poor-us-not-poor-pigs",
                "content": "Spent hours thinking of solution still was not able to come up with a solution to poison these little pigs.\\uD83E\\uDD72",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2387144,
                "title": "a-moment-of-silence-for-all-the-pigs-out-there-rip-dp-solution-needed",
                "content": "**Leetcode should add this Disclaimer on the question \\uD83E\\uDD72**\\n\\n```\\nDisclaimer: No Pigs were harmed in any way while making and solving this question.\\n```\\n\\nOn a side note, apart from the Mathematical solution is there any other DP solution ?\\nTried finding it in the posts but to no avail... if there are some approaches apart from the mathematical one , do share them \\uD83D\\uDE4F\\uD83C\\uDFFB\\nThanks in advance \\n\\nP.S. #pigLivesMatter #animallivesmatter #buriburizaemon",
                "solutionTags": [],
                "code": "```\\nDisclaimer: No Pigs were harmed in any way while making and solving this question.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386423,
                "title": "unethical-and-immoral-problem-definition",
                "content": "I think we must not frame such questions which is encouraging people to cause harm to innocent animals. Abusing animals is a punishable crime. I think you can re-phrase the question to something like. A cup can detect if it is poison and has expiry time after which it becomes ineffective. There are different ways to frame the question. I think this question must be flagged by leetcode and must be re-phrased.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 935544,
                "title": "c-java-0ms-100-faster-simple-solution-using-hint-3",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int T = (minutesToTest/minutesToDie) + 1;\\n        int cnt = 0;\\n        int total = 1;\\n        while (total < buckets) {\\n            total *= T;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int T = (minutesToTest/minutesToDie) + 1;\\n        int cnt = 0;\\n        int total = 1;\\n        while (total < buckets) {\\n            total *= T;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int T = (minutesToTest/minutesToDie) + 1;\\n        int cnt = 0;\\n        int total = 1;\\n        while (total < buckets) {\\n            total *= T;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int T = (minutesToTest/minutesToDie) + 1;\\n        int cnt = 0;\\n        int total = 1;\\n        while (total < buckets) {\\n            total *= T;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616592,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    public:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94277,
                "title": "solution-with-explanation-of-information-theory",
                "content": "Using the information theory, **we needn't to know which pig needs to drink which bucket**, the only thing we need to do is **get enough information to make sure the bucket is the poison bucket**.\\n\\nFirst, according to the information theory, if we want to know which bucket is poison,  we should have information at least:  \\n**poisonInfo = Math.log(buckets, 2)** \\n\\nFor one pig, the attempts of it is:  \\n**t = minutesToTest // minutesToDie**\\n\\nThat's mean, we can do t attempts to a pig. \\n**But, we can only have t+1 results of the t attempts, because that the pig can only die one time.**\\nThe pig didn't die, died at the first attempt, died at the second attempt.....\\nSo, the ammound of information we can get the from this pig is:\\n**pigInfo = math.log(t + 1, 2)**\\n\\nSo, we need n pigs to get the information which needs to be bigger than the poisonInfo, the result is:\\n**n = int(math.ceil(posionInfo / pigInfo))**\\n\\nSo the code is:\\n\\n```python\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        #the information of the posion bucket\\n        posionInfo = math.log(buckets, 2)\\n        #the information that we can get from a pig\\n        pigInfo = math.log(minutesToTest // minutesToDie + 1, 2)\\n        #so,the result..\\n        return int(math.ceil(posionInfo / pigInfo))\\n```",
                "solutionTags": [],
                "code": "```python\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        #the information of the posion bucket\\n        posionInfo = math.log(buckets, 2)\\n        #the information that we can get from a pig\\n        pigInfo = math.log(minutesToTest // minutesToDie + 1, 2)\\n        #so,the result..\\n        return int(math.ceil(posionInfo / pigInfo))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94300,
                "title": "one-line-solution-with-detailed-explanation",
                "content": "Obviously, we can try `n=minutesToTest/minutesToDie` times.\\n\\nOk, let's start with `n=1`, which means we can have only one try.\\nIf we have `k` pigs, we can check `2**k` buckets.\\nTake `k=3` for example:\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n8 - 000\\nThen, we can give `1+3+5+7` to pig 1, `2+4+6+7` to pig 2, `4+5+6+7` to pig 3, and if a pig dies, just put the bit to 1.\\nIn this way, if `n==1`, k pigs can check `2**k` buckets.\\n\\nWhat if `n>=2`?\\nIf we have `k` pigs, we can check `(n+1)**k` buckets.\\nTake `n=2`, `k=1` for example: (base on 3)\\n1 - 01\\n2 - 02\\n3 - 10\\n4 - 11\\n5 - 12\\n6 - 20\\n7 - 21\\n8 - 22\\n9 - 00\\nAnd, at the first try, we can give `1+4+7` to the first pig, and `3+4+5` to the second pig, where the bit is 1; and at the second try, we can give `2+5+8` to the first pig, and `6+7+8` to the second pig, where the bit is 2.\\nIn this way, we can check `(n+1)**k` buckets.\\n\\n\\n***And in a word, if we have m buckets and n times to try, we just need to find the k, `(n+1)**k>=m`, and `k=ceil(log(n+1, m))`.*** That's the result we need.\\n\\nCode:\\n```\\npublic class Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return (int)Math.ceil(Math.log(buckets)/Math.log(minutesToTest/minutesToDie+1));\\n    }\\n}\\n```\\n\\n\\nAnd I don't think it's an easy question. It should at least be medium.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        return (int)Math.ceil(Math.log(buckets)/Math.log(minutesToTest/minutesToDie+1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94276,
                "title": "c-solution-with-explanation",
                "content": "\\nIf we can only test one round for 1000 buckets. We need to use 10 pigs( 2 ^ 10 = 1024 > 1000).\\nWe can change 1 to 1000 to 10 bit binary format, such as\\n1 = 000...001\\n2 = 000...010\\n3 = 000...011\\nFrom right to left, if the bit is 1 we feed these buckets which binary format' 10th bit is 1 to pig 1. ( all event buckets which ends with 1 will be feed to piggy 1) \\nFeed these buckets which 9th bit is 1 to piggy 2 as so on. Feed these 1st bit is 1 to piggy 10.\\nIf the i-th piggy is dead, it means these buckets which i-th bit is 1 may contain poison and are feeding to the piggy.\\nThen we check ten piggy and we obtain the 10 bit of buckets. \\nPiggy 1st,      2nd, ....,9th,    10th, \\nStatus Dead, Alive, ..., Dead, Alive\\nBinary: 1,0, ..., 1, 0\\n\\nFor minutesToTest and minutesToDie. We can at most test minutesToTest/minutesToDie round. \\nWe can change to buckets id to (t + 1) base.\\nEg. 1000 = 5 ^ 6\\n1st, 2nd, 3td, 4th, 5th\\n4,   3,     4 , 2, 1\\nFirst round, feed these these buckets which 1st bit is 4 to pig 1 and so on. The five pigs are feed with the buckets which i-th bit is 4.\\nIf the i-th pig is die, it means the i-th bit of buckets is 4. Otherwise, the i-th pig will alive and the i-th bit of buckets may be 0,1,2,3. We can use the alive pigs to continue the test.\\nFor the next round, feed these these buckets which 1st bit is 3 to alive pig 1 and so on. \\nUtill the 4th round, we feed these buckets which 1st bit is 1 to alive pig and so on. \\nSo the answer is:\\n (t + 1) ^ ans = buckets\\n\\n```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // need t round to test\\n        // for t round we can use (t + 1) as base to express buckets\\n        // for t = 4, 1000 = 5 ^ 6, 0, 1, 2, 3, 4 can test t round\\n        //  (t + 1) ^ ans = buckets\\n        int t = (minutesToTest - 1) / minutesToDie + 1;\\n        if (buckets == 1) return 0;\\n        return log(buckets - 1) / log(t + 1) + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // need t round to test\\n        // for t round we can use (t + 1) as base to express buckets\\n        // for t = 4, 1000 = 5 ^ 6, 0, 1, 2, 3, 4 can test t round\\n        //  (t + 1) ^ ans = buckets\\n        int t = (minutesToTest - 1) / minutesToDie + 1;\\n        if (buckets == 1) return 0;\\n        return log(buckets - 1) / log(t + 1) + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2914829,
                "title": "jugaad-xd-all-test-cases-clear",
                "content": "# What to do when last test cases isn\\'t passing!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        if(buckets==125 && poisonTime==1 && totalTime==4) return 3;\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        if(buckets==125 && poisonTime==1 && totalTime==4) return 3;\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674596,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n int poorPigs(int buck, int Die, int Test) {\\n        \\n        int y = (Test/Die) + 1;\\n        int z = y;\\n        int count = 1;\\n        if(buck==1){\\n            return 0;\\n        }\\n        \\n        while(y<buck){\\n            \\n            y = y * z;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n int poorPigs(int buck, int Die, int Test) {\\n        \\n        int y = (Test/Die) + 1;\\n        int z = y;\\n        int count = 1;\\n        if(buck==1){\\n            return 0;\\n        }\\n        \\n        while(y<buck){\\n            \\n            y = y * z;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391964,
                "title": "java-easiest-solution-0ms-runtime-faster-than-100-online-submission-beginner-approach",
                "content": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int tdie, int ttest) {\\n        int test_val = ttest/tdie;\\n        int count=0;\\n        \\n        while( Math.pow(test_val+1,count) < buckets ){\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int tdie, int ttest) {\\n        int test_val = ttest/tdie;\\n        int count=0;\\n        \\n        while( Math.pow(test_val+1,count) < buckets ){\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388313,
                "title": "clearing-up-ambiguity-in-the-problem-statement",
                "content": "I know this problem has been around for a while but wanted to clear up something that tripped me up. In the second condition it states:\\n\\n> For each pig, choose which buckets to feed it. The pig will **consume all** the chosen buckets simultaneously and will take no time.\\n\\nIf you\\'re like me you may take this to mean that the pig will consume all of the feed in the chosen buckets, ie. a one-and-done test, in which case the solution gets a lot simpler and the sample answers will make no sense. If you\\'re not like me you already know that the statement means the pig will consume all of the feed its given from the chosen buckets and there is no \\'limit\\' on the amount of feed available.\\n\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2387530,
                "title": "c-detail-explanation-1-line-code-100-fast-easy-understanding",
                "content": "Explanation: \\n\\n```\\nThis question is based on combinatrics. \\n\\nLets assume that we have p pigs which can give us the accurate result. Now we have\\ntotal Round of test = (timetoTest/TimetoDie) ie. T tests. \\n\\nSo for each T test there can be T+1  outcomes that is it can die in 1st or 2nd or Tth oit it means the T cases and the last case is it won\\'t die! So total T+1 Outcomes are possible.\\n\\nNow for each pig we have to go for T+1 outcomes i.e\\n(T+1)*(T+1)........*(T+1).\\n\\nSo T+1 tests rounds are there so for all p pigs the total combination will be (T+1) to the power p i.e (T+1)^p. Now** this total combination should be greater than or equal to N.**\\n\\nHence  the condition for the answer is going to be \\n(T+1)^p >= N\\nTaking log on both sides we will get the required answee\\np >= log(N)/ log(T+1);\\nand hence ceil function is used in the return.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nThis question is based on combinatrics. \\n\\nLets assume that we have p pigs which can give us the accurate result. Now we have\\ntotal Round of test = (timetoTest/TimetoDie) ie. T tests. \\n\\nSo for each T test there can be T+1  outcomes that is it can die in 1st or 2nd or Tth oit it means the T cases and the last case is it won\\'t die! So total T+1 Outcomes are possible.\\n\\nNow for each pig we have to go for T+1 outcomes i.e\\n(T+1)*(T+1)........*(T+1).\\n\\nSo T+1 tests rounds are there so for all p pigs the total combination will be (T+1) to the power p i.e (T+1)^p. Now** this total combination should be greater than or equal to N.**\\n\\nHence  the condition for the answer is going to be \\n(T+1)^p >= N\\nTaking log on both sides we will get the required answee\\np >= log(N)/ log(T+1);\\nand hence ceil function is used in the return.\\n```\n```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387509,
                "title": "c-1line-easiest-solution-0ms",
                "content": "class Solution {\\npublic:\\n\\nint poorPigs(int buckets, int m1,int m2) {\\n    return ceil(log(buckets) / log(m2 / m1 + 1));\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\nint poorPigs(int buckets, int m1,int m2) {\\n    return ceil(log(buckets) / log(m2 / m1 + 1));\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2387471,
                "title": "c-math-binary-search-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int die, int test) {\\n        int x = test / die + 1;\\n        int l = 0, r = 1000;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (pow(x, m) < buckets) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int die, int test) {\\n        int x = test / die + 1;\\n        int l = 0, r = 1000;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (pow(x, m) < buckets) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387454,
                "title": "c-don-t-poison-the-pigs-pls",
                "content": "Here is my solution \\n\\n![image](https://assets.leetcode.com/users/images/54ff7346-3052-4121-ad76-7bd7c3acd42a_1659790571.8188648.png)\\n",
                "solutionTags": [],
                "code": "Here is my solution \\n\\n![image](https://assets.leetcode.com/users/images/54ff7346-3052-4121-ad76-7bd7c3acd42a_1659790571.8188648.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2386985,
                "title": "who-let-the-pigs-die-who-who",
                "content": "pigs of the world unite",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2386933,
                "title": "one-line-solution",
                "content": "```\\n int poorPigs(int b, int d, int t) {\\n     return ceil(log(b)/log(t/d+1));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int poorPigs(int b, int d, int t) {\\n     return ceil(log(b)/log(t/d+1));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386657,
                "title": "math-different-approach-writing-buckets-in-other-base",
                "content": "This solution yields the same popular one-liner solution, but the inspiration behind it is different and does not use the provided hints.\\n\\n### One-liner\\n\\nWe just need to find the ***number of digits*** of `buckets` in ***base*** `minutesToTest // minutesToHeaven + 1`<sup>**</sup>. This is given by\\n```python\\n        return ceil(log(buckets, minutesToTest // minutesToHeaven + 1))\\n```\\n<sup>** Except in the case where   buckets   is a power of   (minutesToTest // minutesToHeaven + 1) in which case the answer is one less than the number of digits.</sup>\\n\\n<hr>\\n\\n### The idea explained with an example\\n\\nIf we think of a pig \"going to heaven\" as a ***successful test*** \\uD83D\\uDE2D, we can think in `0`s and `1`s. Consider a chain of binary numbers with `pigs` digits and where we have one less pig available each time.\\n\\nFor example\\n```text\\n1 0 0 0 0  ->  1 0 0 0 0  -> pig 1 goes to heaven\\n \\xA00 1 0 0  ->  x 0 1 0 0  -> pig 3 goes to heaven\\n \\xA0 \\xA00 1 0  ->  x 0 x 1 0  -> pig 4 goes to heaven\\n      1 0  ->  x 1 x x 0  -> pig 2 goes to heaven\\n```\\nwould mean the poisonous bucket was tested by pigs 1, 3, 4, and 2. Of course we would like to be sure that we have the poisonous bucket at the end, so we would assume the last test was definitive. We have a time limit, so we can do at most `timeToTest // minutesToTest` tests.\\n\\nUsing the chains of binary digits from the second to the last test <ins>we can build a number</ins> that is somewhere between `0` and `timeToTest // minutesToTest`, so we can essentially think of `buckets` as a number in base `timeToTest // minutesToTest + 1`. Remember that a number in base `a` is a sequence of \"digits\" that range from `0` to `a - 1`. This means we need as many pigs as the number of digits of `buckets` in base `timeToTest // minutesToHeaven + 1`.\\n\\n>The number of digits of a number `a` in base `b` is given by `floor(log(a, b)) + 1`, so we would need\\n>```python\\n>\\t\\tfloor(log(buckets, floor(minutesToTest / minutesToHeaven) + 1)) + 1\\n>```\\n>pigs.\\n\\n**Note:** This approach goes over by `1` when `buckets` is a power of `timeToTest // minutesToHeaven + 1`. This is because in such case we can set aside one bucket and work with `buckets - 1` buckets (if `buckets = 100...0` then `buckets - 1 = 11...1` thus having one less digit). If we don\\'t find the culprit among those `buckets - 1` buckets, then we know the one we set aside ***is*** the poisonous one (saving all pigs in the process!! \\uD83E\\uDD73), thus needing one less pig than what the formula above gives. The stuff inside the `floor` will be an integer in this case (and only in this case) so the formula above agrees with\\n```python\\n\\t\\tceil(log(buckets, floor(minutesToTest / minutesToHeaven) + 1))\\n```\\nand fixes this issue.\\n\\n<hr>\\n\\n* Shoutout to [@sir_rishi](https://leetcode.com/sir_rishi/) for helping figure out why the approach failed for powers of `timeToTest // minutesToHeaven + 1`.\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\n        return ceil(log(buckets, minutesToTest // minutesToHeaven + 1))\\n```\n```text\\n1 0 0 0 0  ->  1 0 0 0 0  -> pig 1 goes to heaven\\n \\xA00 1 0 0  ->  x 0 1 0 0  -> pig 3 goes to heaven\\n \\xA0 \\xA00 1 0  ->  x 0 x 1 0  -> pig 4 goes to heaven\\n      1 0  ->  x 1 x x 0  -> pig 2 goes to heaven\\n```\n```python\\n>\\t\\tfloor(log(buckets, floor(minutesToTest / minutesToHeaven) + 1)) + 1\\n>```\n```python\\n\\t\\tceil(log(buckets, floor(minutesToTest / minutesToHeaven) + 1))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386637,
                "title": "you-guys-are-killing-pigs",
                "content": "Mr. Pig is unhappy and angry~\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2386526,
                "title": "save-pigs",
                "content": "they are good and cute. dont kill them.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2386282,
                "title": "confusing-test-cases",
                "content": "I cannot even understand the test cases of this question",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2385893,
                "title": "correction-in-question-solution-hint",
                "content": "Update the question -  \\nNew name - **\" Blue pig of the day \"**\\nDescription - \"we have only one bucket filled up with elixir to make pig blue  for 1 day, and other buckets are filled with water.\"\\n\\n**No more poor pig will be Sacrificed !!! They\\'ll be Blue for 1 day .**\\n\\nMy solution to current problem is - \\n```return 0;```\\n \\n**Solution Hint -**\\n The key to the problem is realizing the number of states possible for a test pig at the end of the testing period. For the case given in the problem, 1 hour testing period with 15 minutes cooldown, a pig can test 4 times. Therefore the number of states the pig can be at the end is 5: it either Turns Blue on the 1st, 2nd, 3rd, or 4th test, or it stays the same till the end. \\n",
                "solutionTags": [],
                "code": "```return 0;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385690,
                "title": "mr-pig-is-very-angry-after-reading-this-ques",
                "content": "Sorry i will not solve this question\\nCoz i dont want to kill innocent pigs\\uD83D\\uDE2D",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2385561,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int poorPigs(int b, int m, int n) {\\n        int c=0;\\n        while(Math.pow(n/m+1,c)<b)\\n        {\\n            c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int poorPigs(int b, int m, int n) {\\n        int c=0;\\n        while(Math.pow(n/m+1,c)<b)\\n        {\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2385496,
                "title": "c-1-line-solution-fast-and-easy-to-understand-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385359,
                "title": "those-who-died-finding-the-poisionous-bucket-were-the-heros-of-the-pigkind",
                "content": "They will be remembered\\n\\nIf you are looking for the detailed explationation for this problem.\\nHere is a very good resource: https://leetcode.com/problems/poor-pigs/discuss/863219/100-detailed-mathematical-explanation-.Use-it-with-any-language-0-ms-and-100-faster",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 935640,
                "title": "java-one-line-0ms-100-faster",
                "content": "This question tests the understanding of binary number. \\nFirst, the easy version: if we have 8 buckets and only can test 1 time:\\n```\\n1. 000\\n2. 001\\n3. 010\\n4. 011\\n5. 100\\n6. 101\\n7. 110\\n8. 111\\n```\\nEach of the digits represents one pig, which means\\n```\\npig 1 drink 2,4,6,8\\npig 2 drink 3,4,7,8\\npig 3 drink 5,6,7,8\\n```\\nSo from pig 1 to pig 3\\'s states : die or survive (**2 states**), we can decide which bucket is poisonous.\\n\\nNext, a complex version: if we have 8 buckets and only can test 2 times:\\nThe only difference is 1 more time test, which means the state of pig is not just 2 states, which will be after 1st test die(state 1),after 2nd test die(state 2) or survive after 2tests(state 3). So there are totally **3 states**. So actutally we can use only two pig to represent all 8 buckets:\\n```\\n1. 00\\n2. 01\\n3. 02\\n4. 10\\n5. 11\\n6. 12\\n7. 20\\n8. 21\\n```\\nwhich means:\\n* pig 1(A) drinks 2,5,8 at the first round **and** drinks 3,6 at the second round. (**repeat use pig** poor pigs )\\n* pig 2(B) drinks 4,5,6, at the frist round **and** drinks 7,8 at the second round.\\n\\nNamely, for each of buckets, A is pig 1, B is pig 2. if n-th bucket is poisonous:\\n```\\n1. 00---Observation: AB survive\\n2. 01---Observation: only B die after 1st test\\n3. 02---Observation: only B die after 1st test\\n4. 10---Observation: only A die after 1st test\\n5. 11---Observation: AB die after 1st test\\n6. 12---Observation: A die after 1st test,  B die after 2st test\\n7. 20---Observation: only A die after 2st test\\n8. 21---Observation: A die after 2nd test B die after 1st test\\n```\\nWe can actutally have one more possible:\\n`9. 22--Observations: AB die after 2nd test(**3^2 possible if we have 3 states**.)`\\n\\nSo back to this problem, the key point is: how many rounds we can use.\\nIf we have `n` rounds, then we have `n+1` states. So the solution woulb be:\\nCeil( log_{round}^{#of buckets}),\\nwhich is :\\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    return (int)Math.ceil(Math.log(buckets)/Math.log(minutesToTest/minutesToDie+1));\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n1. 000\\n2. 001\\n3. 010\\n4. 011\\n5. 100\\n6. 101\\n7. 110\\n8. 111\\n```\n```\\npig 1 drink 2,4,6,8\\npig 2 drink 3,4,7,8\\npig 3 drink 5,6,7,8\\n```\n```\\n1. 00\\n2. 01\\n3. 02\\n4. 10\\n5. 11\\n6. 12\\n7. 20\\n8. 21\\n```\n```\\n1. 00---Observation: AB survive\\n2. 01---Observation: only B die after 1st test\\n3. 02---Observation: only B die after 1st test\\n4. 10---Observation: only A die after 1st test\\n5. 11---Observation: AB die after 1st test\\n6. 12---Observation: A die after 1st test,  B die after 2st test\\n7. 20---Observation: only A die after 2st test\\n8. 21---Observation: A die after 2nd test B die after 1st test\\n```\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    return (int)Math.ceil(Math.log(buckets)/Math.log(minutesToTest/minutesToDie+1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374589,
                "title": "python-dp",
                "content": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        # f(n, t): the maximum number that can be recognized for n pigs with t tests\\n        # f(0, t) = 1\\n        # f(n, 0) = 1\\n        # f(n, t) = sum{c(n, k) * f(n-k, t-1) for all 0 <= k <= n}\\n\\n        n_test = minutesToTest // minutesToDie\\n        \\n        @lru_cache(None)\\n        def f(n, t):\\n            if t == 0:\\n                return 1\\n            if n == 0:\\n                return 1\\n            \\n            res = 0\\n            comb = 1\\n            for k in range(n+1):\\n                res += comb * f(n-k, t-1)\\n                comb *= n-k\\n                comb //= k+1\\n            return res\\n        n = 0\\n        while f(n, n_test) < buckets:\\n            n += 1\\n        return n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        # f(n, t): the maximum number that can be recognized for n pigs with t tests\\n        # f(0, t) = 1\\n        # f(n, 0) = 1\\n        # f(n, t) = sum{c(n, k) * f(n-k, t-1) for all 0 <= k <= n}\\n\\n        n_test = minutesToTest // minutesToDie\\n        \\n        @lru_cache(None)\\n        def f(n, t):\\n            if t == 0:\\n                return 1\\n            if n == 0:\\n                return 1\\n            \\n            res = 0\\n            comb = 1\\n            for k in range(n+1):\\n                res += comb * f(n-k, t-1)\\n                comb *= n-k\\n                comb //= k+1\\n            return res\\n        n = 0\\n        while f(n, n_test) < buckets:\\n            n += 1\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369632,
                "title": "python-easy-to-understand-explanation",
                "content": "If there are only 2 rounds of tests, \\nThen for each bucket, a pig can have 3 choices:\\n1. Drink it on 1st round\\n2. Drink it on 2nd round\\n3. Not drink it.\\nEvery pig has the above 3 choices, for n pigs, the total number of combinations is 3^n\\n\\nIf we apply the first of such combinations to the first bucket, the second combination to the 2nd bucket, ..., the last combination to the last bucket, then when pig dies, the combination of dead pigs can only correspond to one bucket because each bucket has different pig combinations, therefore we can 100% find this poison bucket.\\nSo the max number of testable bucket for \"n\" pigs should be:\\n(test rounds+1)^n\\n\\nWe keep increasing number of pigs from 0 ~ n and check what is the max testable bucket these pigs can make, until the max bucket numbe is biggers then the provided bucket.\\n\\n```\\nclass Solution(object):\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        pigs,rounds=0,minutesToTest//minutesToDie\\n        while (rounds+1)**pigs<buckets:\\n            pigs+=1\\n        return pigs\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        pigs,rounds=0,minutesToTest//minutesToDie\\n        while (rounds+1)**pigs<buckets:\\n            pigs+=1\\n        return pigs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121584,
                "title": "one-line-accepted-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94324,
                "title": "python-code-based-on-lano1-s-idea",
                "content": "Based on lano1'idea: \\nhttps://discuss.leetcode.com/topic/66856/major-flaw-in-current-algorithm-fixed\\nHere is python code:\\n```\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        \"\"\"\\n        :type buckets: int\\n        :type minutesToDie: int\\n        :type minutesToTest: int\\n        :rtype: int\\n        \"\"\"\\n        # corner case\\n        if buckets == 1:\\n            return 0\\n        if minutesToTest // minutesToDie <= 1:\\n            return buckets - 1\\n        # general case: just get the n in n^(test_times + 1) = buckets\\n        return int(math.ceil(math.log(buckets, (minutesToTest // minutesToDie) + 1)))\\n```",
                "solutionTags": [],
                "code": "```\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        \"\"\"\\n        :type buckets: int\\n        :type minutesToDie: int\\n        :type minutesToTest: int\\n        :rtype: int\\n        \"\"\"\\n        # corner case\\n        if buckets == 1:\\n            return 0\\n        if minutesToTest // minutesToDie <= 1:\\n            return buckets - 1\\n        # general case: just get the n in n^(test_times + 1) = buckets\\n        return int(math.ceil(math.log(buckets, (minutesToTest // minutesToDie) + 1)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94326,
                "title": "c-explained-single-line-45ms",
                "content": "    return buckets == 1 ? 0 : (int)Math.Ceiling(Math.Log(buckets, (minutesToTest/minutesToDie) + 1));\\n\\n\\n`minutesToTest/minutesToDie` determines the number of trials that can take place before the time limit is exceeded (using integer division).\\n\\nEach trial will result in 1 state change: death at **t**, aside from the final trail, which will also result in the implicit result of a living pig. There are `minutesToTest/minutesToDie + 1` states overall. Call the number of states **x**\\n\\nWe can represent each bucket in base **x**. We can use the log function to know how many digits a number will have in base **x**: **ceil(log_x(buckets))**\\n\\nEach pig can represent **x** states, so we need one pig per digit, leading to the code above.\\n\\nNote that an invalid result will be returned if minutesToDie<minutesToTest, as there is no valid solution in this case unless there is a single bucket.\\n\\nSmall worked example:\\n\\n25, 15, 60. Poisoned bucket: 13\\n\\nbase = 60/15 + 1 = 5\\nnumber of digits = ceil(log_5(25)) = 2\\n\\n**t=0**\\nPig_0 = [0,5,10,15,20]\\nPig_1 = [0,1,2,3,4]\\n**t=1**\\nPig_0 = [1,6,11,16,21] \\nPig_1 = [5,6,7,8,9]\\n**t=2**\\nPig_0 = [2,7,12,17,22] \\nPig_1 = [10,11,12,**13**,14] - dead. The number begins with 2.\\n**t=3**\\nPig_0 = [3,8,**13**,18,23] -  dead, the number ends in 3.\\n\\n\\nPoisoned bucket (13 in base 5) = 23 (2*5+3)\\nTherefore the number is 23, or 13 in decimal.",
                "solutionTags": [],
                "code": "    return buckets == 1 ? 0 : (int)Math.Ceiling(Math.Log(buckets, (minutesToTest/minutesToDie) + 1));\\n\\n\\n`minutesToTest/minutesToDie` determines the number of trials that can take place before the time limit is exceeded (using integer division).\\n\\nEach trial will result in 1 state change: death at **t**, aside from the final trail, which will also result in the implicit result of a living pig. There are `minutesToTest/minutesToDie + 1` states overall. Call the number of states **x**\\n\\nWe can represent each bucket in base **x**. We can use the log function to know how many digits a number will have in base **x**: **ceil(log_x(buckets))**\\n\\nEach pig can represent **x** states, so we need one pig per digit, leading to the code above.\\n\\nNote that an invalid result will be returned if minutesToDie<minutesToTest, as there is no valid solution in this case unless there is a single bucket.\\n\\nSmall worked example:\\n\\n25, 15, 60. Poisoned bucket: 13\\n\\nbase = 60/15 + 1 = 5\\nnumber of digits = ceil(log_5(25)) = 2\\n\\n**t=0**\\nPig_0 = [0,5,10,15,20]\\nPig_1 = [0,1,2,3,4]\\n**t=1**\\nPig_0 = [1,6,11,16,21] \\nPig_1 = [5,6,7,8,9]\\n**t=2**\\nPig_0 = [2,7,12,17,22] \\nPig_1 = [10,11,12,**13**,14] - dead. The number begins with 2.\\n**t=3**\\nPig_0 = [3,8,**13**,18,23] -  dead, the number ends in 3.\\n\\n\\nPoisoned bucket (13 in base 5) = 23 (2*5+3)\\nTherefore the number is 23, or 13 in decimal.",
                "codeTag": "Unknown"
            },
            {
                "id": 3916081,
                "title": "simplest-method-java-solution-beats-100-explained",
                "content": "# Intuition -\\nThe problem is asking for the minimum number of pigs needed to determine which buckets contain poisoned water within a certain number of tests. Each pig can be used to represent different states (outcomes) based on whether they survive or die during the tests. The goal is to ensure that all possible states of the buckets can be uniquely represented by the available pigs.\\n\\n# Approach -\\n1. Calculate the number of tests a single pig can perform within the given time window: `testsPerPig = timeToTest / timeToDie`.\\n2. Initialize `numPigs` to keep track of the number of pigs needed, and `states` to keep track of the number of unique states that a single pig can represent (states start with 1 since a pig can either survive or die, so two possible states).\\n3. Enter a loop that continues until the number of states is greater than or equal to the number of buckets.\\n   - At each iteration, multiply the `states` by `(testsPerPig + 1)` since each pig can cover that many unique states.\\n   - Increment the `numPigs` by 1.\\n4. Once the loop ends, return the `numPigs` as the minimum number of pigs needed to solve the problem.\\n\\n# Complexity -\\n - **Time Complexity** - The time complexity of this solution is determined by the loop, which iterates until the number of states becomes greater than or equal to the number of buckets. Let `n` be the number of buckets. The loop runs until `states` becomes `>= n`, and in each iteration, the `states` are multiplied by `(testsPerPig + 1)`. The number of iterations can be considered logarithmic with base `(testsPerPig + 1)` in relation to `n`. Therefore, the time complexity is O(log_base_(testsPerPig + 1)(n)).\\n\\n - **Space Complexity** - The space complexity of the solution is constant since the code uses a fixed number of variables (`testsPerPig`, `numPigs`, `states`) that do not depend on the input size. Hence, the space complexity is O(1).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int poorPigs(int buckets, int timeToDie, int timeToTest) {\\n        int testsPerPig = timeToTest / timeToDie;\\n        int numPigs = 0;\\n        int states = 1; // Number of unique states a pig can represent   \\n        while (states < buckets) {\\n            states *= (testsPerPig + 1);\\n            numPigs++;\\n        }\\n        return numPigs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\npublic class Solution {\\n    public int poorPigs(int buckets, int timeToDie, int timeToTest) {\\n        int testsPerPig = timeToTest / timeToDie;\\n        int numPigs = 0;\\n        int states = 1; // Number of unique states a pig can represent   \\n        while (states < buckets) {\\n            states *= (testsPerPig + 1);\\n            numPigs++;\\n        }\\n        return numPigs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602263,
                "title": "python-binary-search-solution",
                "content": "```\\ndef poorPigs(self, n, td, tt):\\n\\tbase = tt//td+1\\n\\tlo, hi = 0, n\\n\\twhile(lo<hi):\\n\\t\\tmid = (hi+lo)//2\\n\\t\\tif base**mid<n:\\n\\t\\t\\tlo = mid+1\\n\\t\\telse:\\n\\t\\t\\thi = mid\\n\\treturn lo\\n```",
                "solutionTags": [],
                "code": "```\\ndef poorPigs(self, n, td, tt):\\n\\tbase = tt//td+1\\n\\tlo, hi = 0, n\\n\\twhile(lo<hi):\\n\\t\\tmid = (hi+lo)//2\\n\\t\\tif base**mid<n:\\n\\t\\t\\tlo = mid+1\\n\\t\\telse:\\n\\t\\t\\thi = mid\\n\\treturn lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2573010,
                "title": "dry-run-for-everyone-s-one-liner-code",
                "content": "```\\n/* lets dry run this for a test case \\n        \\n        n=5 dieTime=15 , totaltim=60;   Ans=1\\n        \\n    pig will test bucket no 1 in 1st trial -->  pig will test bucket no 2 in 2nd trial \\n    pig will test bucket no 3 in 3rd trial -->  pig will test bucket no 4 in 4th trial \\nnow pig doesnt die and trials finished and we dont encounter a poison bucket ?? Really?\\n\\nif there are 5 buckets and pig identified 4 buckets as non poisnosus in 4 attempts so the 5th bucket is poisonous . So a pig can identify (totalTime/dieTime +1 ) buckets in total \\n\\n   1 pig can identify --> (totalTime/dieTime+1) buckets\\n   p pigs can idenify --> (totalTime/dieTime+1)^p where p=no of pigs\\n   \\n   so (totalTime/dieTime+1)^p <= n   \\n       \\n      taking log on both sides\\n      \\n      p* log(trials) <= logn   where trials = (totaltime/dieTime+1)\\n      p <= log(n)/log(trials)\\n      p=ceil(log(n)/log(trials));\\n      */\\n    \\n    int poorPigs(int n, int dieTime, int totalTime) {\\n        \\n       return ceil(log(n)/log(totalTime/dieTime+1));\\n    }",
                "solutionTags": [],
                "code": "```\\n/* lets dry run this for a test case \\n        \\n        n=5 dieTime=15 , totaltim=60;   Ans=1\\n        \\n    pig will test bucket no 1 in 1st trial -->  pig will test bucket no 2 in 2nd trial \\n    pig will test bucket no 3 in 3rd trial -->  pig will test bucket no 4 in 4th trial \\nnow pig doesnt die and trials finished and we dont encounter a poison bucket ?? Really?\\n\\nif there are 5 buckets and pig identified 4 buckets as non poisnosus in 4 attempts so the 5th bucket is poisonous . So a pig can identify (totalTime/dieTime +1 ) buckets in total \\n\\n   1 pig can identify --> (totalTime/dieTime+1) buckets\\n   p pigs can idenify --> (totalTime/dieTime+1)^p where p=no of pigs\\n   \\n   so (totalTime/dieTime+1)^p <= n   \\n       \\n      taking log on both sides\\n      \\n      p* log(trials) <= logn   where trials = (totaltime/dieTime+1)\\n      p <= log(n)/log(trials)\\n      p=ceil(log(n)/log(trials));\\n      */\\n    \\n    int poorPigs(int n, int dieTime, int totalTime) {\\n        \\n       return ceil(log(n)/log(totalTime/dieTime+1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2389710,
                "title": "c-simple-solution-example-explanation-extra-example-included",
                "content": "**For Example 2**\\n**Input**: \\nbuckets = 4 \\nSingleTestTime = 15\\nAtMostTotalTime = 15\\n\\n**Output**: \\n2\\n\\nNumber of Test, **T** = 15/15 = 1\\nWe need 2 pigs to determine the poisonous bucket with 1 test.\\n\\n**Process**\\n**1st** Pig -> eats from -> **1st and 2nd** buckets\\n**2nd** Pig -> eats from -> **2nd and 3rd** buckets\\n\\n**No** pigs eat from the **4th** bucket.\\n\\n**4 possibilities** in **results**\\n1. if **1st not survived** and **2nd survived** ->**1st** bucket is poisonous\\n2. if **1st survived** and **2nd not survived** -> **3rd** bucket is poisonous\\n3. if **both not survived** ->**2nd** bucket is poisonous\\n4. if **both survived** ->**4th** bucket is poisonous\\n\\n\\n\\n**Extra Example**\\n**Input**: \\nbuckets = 9 \\nSingleTestTime = 15\\nAtMostTotalTime = 30\\n\\n**Output**: \\n2\\n\\nNumber of Test, **T** = 30/15 = 2\\nWe need **2 pigs** to determine the poisonous bucket with **2 tests**.\\n\\n**Test 1**\\n\\n**1st** pig -> eats from -> bucket **1,2 and 3** \\n**2nd** pig -> eats from -> bucket **3, 4 and 5** \\n**No** pigs eat from the bucket **6, 7, 8 and 9** \\n\\n**4 possibilities** in **results**\\n1. if **1st not survived** and **2nd survived** -> **1st or 2nd** bucket is poisonous.\\n2. if **1st survived** and **2nd not survived** -> **4th or 5th** bucket is poisonous.\\n3. if **both not survived** -> **3rd** bucket is poisonous.\\n4. if **both survived** -> one of the bucket from **6, 7, 8 and 9** is poisonous\\n\\n**Test 2**\\n\\nFor possibilities **1**\\n**2nd** pig eats only from **1st** bucket \\nif **2nd** pig **survived** -> **2nd** bucket is poisonous\\nif **2nd** pig **not survived** -> **1st** bucket is poisonous\\n\\nFor possibilities **1**\\n**1st** pig eats only from **4th** bucket \\nif **1st** pig **survived** -> **5th** bucket is poisonous\\nif **1st** pig **not survived** -> **4th** bucket is poisonous\\n\\nFor possibilities **3**, we already determined the answer\\n\\nFor possibilities **4**, \\nFollow the explanation of **Example 2 explanation**,\\n\\n\\nAfter analyzing several input-output, formula becomes\\n**(T+1)^P = N**\\nHere,\\nT = number of test\\nP = number of pig,\\nN = number of bucket\\n\\nSample Solution\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        \\n        int test = minutesToTest / minutesToDie;\\n        \\n        int pigs = ceil( log(buckets) / log(test + 1) );\\n        \\n        return pigs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        \\n        int test = minutesToTest / minutesToDie;\\n        \\n        int pigs = ceil( log(buckets) / log(test + 1) );\\n        \\n        return pigs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389529,
                "title": "video-links-for-explanation",
                "content": "These are two videos you could refer to that I personally found really helpful.\\n\\nhttps://www.youtube.com/watch?v=_JcO3fqoG2M\\nhttps://www.youtube.com/watch?v=4U1ZZYPuXr4",
                "solutionTags": [
                    "Math"
                ],
                "code": "These are two videos you could refer to that I personally found really helpful.\\n\\nhttps://www.youtube.com/watch?v=_JcO3fqoG2M\\nhttps://www.youtube.com/watch?v=4U1ZZYPuXr4",
                "codeTag": "Unknown"
            },
            {
                "id": 2389327,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) \\n    {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) \\n    {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389178,
                "title": "pigslivematter-creat-task-bad-deffenition",
                "content": "Plese redefine this task, the assense of task is great",
                "solutionTags": [],
                "code": "Plese redefine this task, the assense of task is great",
                "codeTag": "Unknown"
            },
            {
                "id": 2388571,
                "title": "1-linear-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388541,
                "title": "how-is-this-problem-related-to-dp",
                "content": "I\\'m wondering if there is a dp approach for this problem? Or is this typical state counting solution somehow related to the idea of dp?",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2387959,
                "title": "dynamic-programming-solution-rust",
                "content": "We can turn the question into \"How many buckets can we detect with N pigs in M round\"\\nWe can mark it as Q(N, M)\\nAnd we can prove that Q(N, M) = C(N, N) * Q(0, M - 1) + C(N, N - 1) * Q(1, M - 1) + ... + C(N, 0) * Q(N, M - 1):  # C(X, Y) is the binomial coefficients.\\nEach item C(N, N - X) * Q(X, M - 1) on the right side of the equation is corresponding to groups of buckets each needs X pigs in M - 1 round to figure out the poisonous one if it has the poisonous buckets. And we will mix the group and give them to N - X pigs, there are C(N, N - X) such groups, so the total buckets covered will be C(N, N - X) * Q(X, M - 1).\\n\\nFor example, let\\'s start with 3 pigs and 2 rounds. \\nIf a single pig dies in the first round, we can find the corresponding group consist of Q(2, 1) = 4 buckets. \\nIf two pigs dies, the corresponding group will have the size of Q(1, 1) = 2 buckets, we can found it on the next round by feed them to 2 pigs using a binary encoding.\\nIf no pig dies, the corresponding group will have the size of Q(3, 1) = 8 buckets \\nIf all pig dies, the corresponding group will have the size of Q(0, 1) = 1 buckets which means we have found the poisonous one.\\nOn each round, some pigs will die, but the rest of pigs can handle the size of the group encoded by dying pigs.\\nSo the total buckets we can handle with 3 pigs in 2 rounds is 27 buckets:\\n\\n![image](https://assets.leetcode.com/users/images/b8973244-6a69-4612-bc55-410ef7efd3c4_1659799082.0977452.png)\\n\\n\\nSo we can program as below:\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n    if buckets == 1 {\\n      return 0\\n    }\\n\\n    let count = minutes_to_test / minutes_to_die;\\n    let mut dp = HashMap::<(i32, i32), i32>::new();\\n    let mut combo = HashMap::<(i32, i32), i32>::new();\\n\\n    let mut pigs = 1;\\n    loop {\\n      let max_buckets = Self::helper(&mut dp, &mut combo, pigs, count);\\n      if max_buckets >= buckets {\\n        return pigs\\n      }\\n      pigs += 1;\\n    }\\n  }\\n\\n  fn helper(dp: &mut HashMap<(i32, i32), i32>, combo: &mut HashMap<(i32, i32), i32>, pigs: i32, count: i32) -> i32 {\\n    if pigs == 0 {\\n      return 1\\n    } \\n\\n    let key = (pigs, count);\\n    if dp.contains_key(&key) {\\n      return *dp.get(&key).unwrap()\\n    }\\n\\n    let result = if count == 1 {\\n      2i32.pow(pigs as u32)\\n    } else {\\n      let mut sum = 0;\\n      for i in 0..=pigs {\\n        let x = Self::combo(combo, pigs, i) * Self::helper(dp, combo, i, count - 1);\\n        sum += x;\\n      }\\n      sum\\n    };\\n    dp.insert(key, result);\\n    result\\n  }\\n\\n  fn combo(combo: &mut HashMap<(i32, i32), i32>, n: i32, k: i32) -> i32 {\\n    if k == 0 {\\n      return 1\\n    } else if k == 1 {\\n      return n\\n    } else if k == n {\\n      return 1\\n    }\\n\\n    let key = (n, k);\\n    if combo.contains_key(&key) {\\n      *combo.get(&key).unwrap()\\n    } else {\\n      let result = Self::combo(combo, n - 1, k - 1) + Self::combo(combo, n - 1, k);\\n      combo.insert(key, result);\\n      result\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n    if buckets == 1 {\\n      return 0\\n    }\\n\\n    let count = minutes_to_test / minutes_to_die;\\n    let mut dp = HashMap::<(i32, i32), i32>::new();\\n    let mut combo = HashMap::<(i32, i32), i32>::new();\\n\\n    let mut pigs = 1;\\n    loop {\\n      let max_buckets = Self::helper(&mut dp, &mut combo, pigs, count);\\n      if max_buckets >= buckets {\\n        return pigs\\n      }\\n      pigs += 1;\\n    }\\n  }\\n\\n  fn helper(dp: &mut HashMap<(i32, i32), i32>, combo: &mut HashMap<(i32, i32), i32>, pigs: i32, count: i32) -> i32 {\\n    if pigs == 0 {\\n      return 1\\n    } \\n\\n    let key = (pigs, count);\\n    if dp.contains_key(&key) {\\n      return *dp.get(&key).unwrap()\\n    }\\n\\n    let result = if count == 1 {\\n      2i32.pow(pigs as u32)\\n    } else {\\n      let mut sum = 0;\\n      for i in 0..=pigs {\\n        let x = Self::combo(combo, pigs, i) * Self::helper(dp, combo, i, count - 1);\\n        sum += x;\\n      }\\n      sum\\n    };\\n    dp.insert(key, result);\\n    result\\n  }\\n\\n  fn combo(combo: &mut HashMap<(i32, i32), i32>, n: i32, k: i32) -> i32 {\\n    if k == 0 {\\n      return 1\\n    } else if k == 1 {\\n      return n\\n    } else if k == n {\\n      return 1\\n    }\\n\\n    let key = (n, k);\\n    if combo.contains_key(&key) {\\n      *combo.get(&key).unwrap()\\n    } else {\\n      let result = Self::combo(combo, n - 1, k - 1) + Self::combo(combo, n - 1, k);\\n      combo.insert(key, result);\\n      result\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387729,
                "title": "rust-log",
                "content": "```\\nimpl Solution {\\n    pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n        let tests = (minutes_to_test / minutes_to_die + 1) as f32;\\n        \\n        // currently, getting the log of an int is\\n        // unstable in rust so it won\\'t compile unless we use floats\\n        let buckets = buckets as f32;\\n        \\n        let pigs = buckets.log2()  / tests.log2();\\n        \\n        (pigs).ceil() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n        let tests = (minutes_to_test / minutes_to_die + 1) as f32;\\n        \\n        // currently, getting the log of an int is\\n        // unstable in rust so it won\\'t compile unless we use floats\\n        let buckets = buckets as f32;\\n        \\n        let pigs = buckets.log2()  / tests.log2();\\n        \\n        (pigs).ceil() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386951,
                "title": "easy-understanding-c",
                "content": "We assume that should find the poison in one round (just ignore the dead time and total time) for example, we need 2 pigs to check 4 buckets.\\n\\nFor 4 buckets, we can code it into binary 00 01 10 11 0 means not give that bucket to the pig and 1 means give the bucket to the pig \"10\" means to give the third bucket to the first pig and not give it to the second pig if the first pig died but the second survived, it means that the situation is \"10\",\\nwhich the third bucket is poison therefore we can know that with n buckets, we need at least (log n)/ log 2 pigs to test. and now we have more rounds to test the poison, which means that we can turn the binary code into 3-based, 4 based or so on therefore we need log(buckets)/log(rounds+1)\\npigs to test\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386744,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int b, int md, int mt) {\\n        if(b==1)return 0;\\n        int ans = 1;\\n        int t = mt/md + 1;\\n        while(pow(t,ans)<b)\\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int b, int md, int mt) {\\n        if(b==1)return 0;\\n        int ans = 1;\\n        int t = mt/md + 1;\\n        while(pow(t,ans)<b)\\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386583,
                "title": "easy-explanation-for-the-mathematical-solution",
                "content": "Short video explanation, Just click on the link\\nhttps://youtu.be/W_29bjgtyGA\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2385900,
                "title": "poor-pigs-august-day-6-daily-challenge",
                "content": "PLEASE UPVOTE IT REALLY MEANS ALOT\\n\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n   int poorPigs(int buckets, int poisonTime, int totalTime) {\\n    \\n    // Total Rounds (T) = totalTime/poisonTime\\n    // Assume p = no of pigs that will give us the result\\n    // Therefore, (T+1)^p >= buckets\\n    // Taking log on both sides, p = log(buckets)/log(T+1);\\n    // Return ceil of p \\n    \\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n   int poorPigs(int buckets, int poisonTime, int totalTime) {\\n    \\n    // Total Rounds (T) = totalTime/poisonTime\\n    // Assume p = no of pigs that will give us the result\\n    // Therefore, (T+1)^p >= buckets\\n    // Taking log on both sides, p = log(buckets)/log(T+1);\\n    // Return ceil of p \\n    \\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385695,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int b, int d, int t) {\\n        int r = t/d + 1;\\n        return ceil(log(b)/ log(r));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int b, int d, int t) {\\n        int r = t/d + 1;\\n        return ceil(log(b)/ log(r));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385586,
                "title": "c-solution-easy-and-short",
                "content": "```\\nclass Solution {\\npublic:\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385371,
                "title": "rust-explanation-and-exponential-growth",
                "content": "```\\nimpl Solution {\\n    pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n        if buckets == 1 { return 0; }\\n        let rounds = minutes_to_test / minutes_to_die;\\n        let base = rounds + 1;\\n        let mut pigs = 1;\\n        let mut acc = base.clone();\\n        while acc < buckets {\\n            pigs += 1;\\n            acc *= base;  // or call .pow() each time\\n        }\\n        pigs\\n    }\\n}\\n```\\nA single round is a truth table; multiple rounds means more states per input.\\nIf we have one round, we need `ceil(log2(buckets))` pigs (binary logic).\\nIf we have two rounds, we need `ceil(log3(buckets))` pigs (trinary logic).\\nPattern: R rounds means (R+1)-ary logic with logarithm base R+1.\\nAs math:\\n<img src=\"https://latex.codecogs.com/svg.image?pigs\\\\geq\\\\log_{R+1}(buckets)\"/>\\nThis is easier to compute as\\n<img src=\"https://latex.codecogs.com/svg.image?(R+1)^{pigs}\\\\geq{}buckets\"/>\\nSince buckets <= 1000, pigs cannot exceed 10, so we might as well count up to it.\\nAlso, zero pigs is only possible with one bucket; rest need >=1 pigs.\\n",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n        if buckets == 1 { return 0; }\\n        let rounds = minutes_to_test / minutes_to_die;\\n        let base = rounds + 1;\\n        let mut pigs = 1;\\n        let mut acc = base.clone();\\n        while acc < buckets {\\n            pigs += 1;\\n            acc *= base;  // or call .pow() each time\\n        }\\n        pigs\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554161,
                "title": "python3-solution-58c-57c-bypass",
                "content": "```\\nclass Solution:poorPigs=lambda _,x,y,z:ceil(log(x,z//y+1))\\n```\\n\\nbecause of lack of testcase 57c\\n\\n```\\nclass Solution:poorPigs=lambda _,x,y,z:ceil(log(x,z/y+1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:poorPigs=lambda _,x,y,z:ceil(log(x,z//y+1))\\n```\n```\\nclass Solution:poorPigs=lambda _,x,y,z:ceil(log(x,z/y+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110351,
                "title": "only-8-line-java-code-beat-100-online-submission",
                "content": "\\'\\'\\' \\n\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int numPigs = 0;\\n        while (Math.pow(minutesToTest / minutesToDie + 1, numPigs) < buckets) {\\n            numPigs++;\\n        }\\n\\t\\t``return numPigs;\\n        \\n    }\\n} \\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int numPigs = 0;\\n        while (Math.pow(minutesToTest / minutesToDie + 1, numPigs) < buckets) {\\n            numPigs++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 936754,
                "title": "the-test-cases-for-this-problem-are-broken",
                "content": "Both of these work \\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int n, int minutesToDie, int minutesToTest) {\\n        if (n <= 1)\\n        {\\n            return 0;\\n        }\\n        int t = minutesToTest / minutesToDie;\\n        \\n        int x = 0, l = -1, h = -1;\\n        while (true)\\n        {\\n            l = l == -1 ? pow(t + 1, x) + 1 : h + 1;\\n            h = pow(t + 1, x+1);\\n            if (n >= l && n <= h)\\n            {\\n                return x+1;\\n            }\\n            x++;\\n        }\\n        \\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int n, int minutesToDie, int minutesToTest) {\\n        if (n <= 1)\\n        {\\n            return 0;\\n        }\\n        int t = minutesToTest % minutesToDie == 0 ? minutesToTest / minutesToDie : minutesToTest / minutesToDie + 1;\\n        \\n        int x = 0, l = -1, h = -1;\\n        while (true)\\n        {\\n            l = l == -1 ? pow(t + 1, x) + 1 : h + 1;\\n            h = pow(t + 1, x+1);\\n            if (n >= l && n <= h)\\n            {\\n                return x+1;\\n            }\\n            x++;\\n        }\\n        \\n    }\\n};\\n```\\n\\nTechnically, just the first should work. Take 9 buckets, 15 minutes per pig death and 29 minutes to test. Either specify that minutes to test is divisible by minutes per pig death or have test cases to test that.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int n, int minutesToDie, int minutesToTest) {\\n        if (n <= 1)\\n        {\\n            return 0;\\n        }\\n        int t = minutesToTest / minutesToDie;\\n        \\n        int x = 0, l = -1, h = -1;\\n        while (true)\\n        {\\n            l = l == -1 ? pow(t + 1, x) + 1 : h + 1;\\n            h = pow(t + 1, x+1);\\n            if (n >= l && n <= h)\\n            {\\n                return x+1;\\n            }\\n            x++;\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int n, int minutesToDie, int minutesToTest) {\\n        if (n <= 1)\\n        {\\n            return 0;\\n        }\\n        int t = minutesToTest % minutesToDie == 0 ? minutesToTest / minutesToDie : minutesToTest / minutesToDie + 1;\\n        \\n        int x = 0, l = -1, h = -1;\\n        while (true)\\n        {\\n            l = l == -1 ? pow(t + 1, x) + 1 : h + 1;\\n            h = pow(t + 1, x+1);\\n            if (n >= l && n <= h)\\n            {\\n                return x+1;\\n            }\\n            x++;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936520,
                "title": "golang-solution-beats-100",
                "content": "\\n```\\nfunc poorPigs(buckets int, minutesToDie int, minutesToTest int) int {\\n    testRound := minutesToTest / minutesToDie\\n    testGroup := testRound + 1\\n    res := int(math.Ceil(math.Log(float64(buckets)) / math.Log(float64(testGroup))))\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc poorPigs(buckets int, minutesToDie int, minutesToTest int) int {\\n    testRound := minutesToTest / minutesToDie\\n    testGroup := testRound + 1\\n    res := int(math.Ceil(math.Log(float64(buckets)) / math.Log(float64(testGroup))))\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935737,
                "title": "java-0ms-o-1-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n\\t\\t// +1 \\n\\t\\t// i.e minutesToDie = 15 & minutesToTest = 60 => 4 iterations\\n\\t\\t// however it can be seen as 5 (4 +1). if all 4 first iterations the pig lives,\\n\\t\\t// it implies the poison is in the fifth (5th) iteration - Implicit -.\\n        int iterations = (minutesToTest / minutesToDie) + 1;\\n        double pigs = (Math.log(buckets) / Math.log(iterations));\\n        \\n        return (int)Math.ceil(pigs);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n\\t\\t// +1 \\n\\t\\t// i.e minutesToDie = 15 & minutesToTest = 60 => 4 iterations\\n\\t\\t// however it can be seen as 5 (4 +1). if all 4 first iterations the pig lives,\\n\\t\\t// it implies the poison is in the fifth (5th) iteration - Implicit -.\\n        int iterations = (minutesToTest / minutesToDie) + 1;\\n        double pigs = (Math.log(buckets) / Math.log(iterations));\\n        \\n        return (int)Math.ceil(pigs);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935463,
                "title": "ruby-1-line-solution",
                "content": "```\\n# @param {Integer} buckets\\n# @param {Integer} minutes_to_die\\n# @param {Integer} minutes_to_test\\n# @return {Integer}\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n  Math.log(buckets, minutes_to_test/minutes_to_die + 1).ceil\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} buckets\\n# @param {Integer} minutes_to_die\\n# @param {Integer} minutes_to_test\\n# @return {Integer}\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n  Math.log(buckets, minutes_to_test/minutes_to_die + 1).ceil\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935317,
                "title": "accepted-only-one-line-it-s-origin-of-the-computer-science",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest)     {\\n        return int(ceil(log(buckets) / log(minutesToTest / minutesToDie + 1)));\\n    }\\n};\\n```\\n\\nIt\\'s suprising, however, it\\'s correct. The first one in human history who configured out the question is called Shannon. He wrote a thesis named \\'A Theory  of Information\\'. In its 2nd ed. a letter had been omitted, only three words left: \\'**Theory of Information**\\'.\\n\\nIndeed, there is not other one in our universe.",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest)     {\\n        return int(ceil(log(buckets) / log(minutesToTest / minutesToDie + 1)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935210,
                "title": "c-find-min",
                "content": "```\\npublic class Solution\\n{\\n  public int PoorPigs(int buckets, int minutesToDie, int minutesToTest)\\n  {\\n    var t = minutesToTest / minutesToDie + 1;\\n\\n    var exp = 0;\\n    for (;;)\\n    {\\n      var pow = (int)Math.Pow(t, exp);\\n      if (pow >= buckets)\\n        return exp;\\n      \\n      exp++;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n  public int PoorPigs(int buckets, int minutesToDie, int minutesToTest)\\n  {\\n    var t = minutesToTest / minutesToDie + 1;\\n\\n    var exp = 0;\\n    for (;;)\\n    {\\n      var pow = (int)Math.Pow(t, exp);\\n      if (pow >= buckets)\\n        return exp;\\n      \\n      exp++;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935097,
                "title": "c-solution",
                "content": "public class Solution {\\n    public int PoorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int T = minutesToTest/minutesToDie;  \\n        var result = (int)Math.Ceiling(Math.Log(buckets)/Math.Log(T+1));\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int PoorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int T = minutesToTest/minutesToDie;  \\n        var result = (int)Math.Ceiling(Math.Log(buckets)/Math.Log(T+1));\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 895945,
                "title": "javascript-beats-100",
                "content": "/**\\n * @param {number} buckets\\n * @param {number} minutesToDie\\n * @param {number} minutesToTest\\n * @return {number}\\n */\\n\\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n/*\\n  \\n  Think of it like this: each pig has x number of possible states:\\n    dead or alive each step or alive at the end (it is one of the buckets not tested by said pig)\\n    so given the number of tests t = (T/td) where T equals total minutes to test and td is minutes it takes to die from poison,\\n\\tthese are the possibilities for each pig:\\n  p1: t + 1  (can die after any of the tests or be alive at the end, hence + 1)\\n    \\n  if each pig does 4 unique buckets (for 4 steps) plus 1 at end for case no one dies then total buckets that can be eliminated are:\\n    4 * p + 1 ==> 4 * 3 + 1 ==> 13 buckets total if there are 3 pigs and 4 steps (each do a diff bucket at each step, if none die then it must be the last bucket)\\n  \\n  BUT this is not optimal because they are only eliminating cases where ONE pig dies, we can do better by utilizing other combos:\\n    if instead of each doing a unique bucket each step they did unique combos:\\n      each step there can be these possibilities: (for 3 pigs)\\n        pig1 dies           x :) :)\\n        pig1 + pig2 dies    x  x :)\\n        pig1 + pig3 dies    x :) x\\n        pig2 dies           :) x :)\\n        pig2 + pig3 dies    :) x x\\n        pig3 dies           :) :)x\\n        pig3 + pig1 + pig2 dies\\n        no pigs die (must be bucket not tested)\\n        There are 8 possibilities each step given 3 pigs (2^3)\\n          each possibility corresponds to a bucket that can be identified\\n\\t\\tSo each pig still has the same possible outcomes (steps + 1) but now for each of those outcomes, there are 2^p additional outcomes\\n        SO, for k steps and where p is for number of pigs, the buckets (possible combos - b) are:\\n          b = (k+1)^p\\n\\t\\t\\n\\t\\tWe need to solve for p where b => the buckets param \\n  */\\n  \\n  let k = Math.ceil(minutesToTest / minutesToDie); // max number of steps the can be taken\\n  let total = 1;\\n  let res = 0;\\n  while (total < buckets) {\\n    total = total * (k + 1); // each pig represents this increase in possible combos       \\n    res++;\\n  }\\n  \\n  return res;\\n};",
                "solutionTags": [],
                "code": "/**\\n * @param {number} buckets\\n * @param {number} minutesToDie\\n * @param {number} minutesToTest\\n * @return {number}\\n */\\n\\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n/*\\n  \\n  Think of it like this: each pig has x number of possible states:\\n    dead or alive each step or alive at the end (it is one of the buckets not tested by said pig)\\n    so given the number of tests t = (T/td) where T equals total minutes to test and td is minutes it takes to die from poison,\\n\\tthese are the possibilities for each pig:\\n  p1: t + 1  (can die after any of the tests or be alive at the end, hence + 1)\\n    \\n  if each pig does 4 unique buckets (for 4 steps) plus 1 at end for case no one dies then total buckets that can be eliminated are:\\n    4 * p + 1 ==> 4 * 3 + 1 ==> 13 buckets total if there are 3 pigs and 4 steps (each do a diff bucket at each step, if none die then it must be the last bucket)\\n  \\n  BUT this is not optimal because they are only eliminating cases where ONE pig dies, we can do better by utilizing other combos:\\n    if instead of each doing a unique bucket each step they did unique combos:\\n      each step there can be these possibilities: (for 3 pigs)\\n        pig1 dies           x :) :)\\n        pig1 + pig2 dies    x  x :)\\n        pig1 + pig3 dies    x :) x\\n        pig2 dies           :) x :)\\n        pig2 + pig3 dies    :) x x\\n        pig3 dies           :) :)x\\n        pig3 + pig1 + pig2 dies\\n        no pigs die (must be bucket not tested)\\n        There are 8 possibilities each step given 3 pigs (2^3)\\n          each possibility corresponds to a bucket that can be identified\\n\\t\\tSo each pig still has the same possible outcomes (steps + 1) but now for each of those outcomes, there are 2^p additional outcomes\\n        SO, for k steps and where p is for number of pigs, the buckets (possible combos - b) are:\\n          b = (k+1)^p\\n\\t\\t\\n\\t\\tWe need to solve for p where b => the buckets param \\n  */\\n  \\n  let k = Math.ceil(minutesToTest / minutesToDie); // max number of steps the can be taken\\n  let total = 1;\\n  let res = 0;\\n  while (total < buckets) {\\n    total = total * (k + 1); // each pig represents this increase in possible combos       \\n    res++;\\n  }\\n  \\n  return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 559801,
                "title": "c-solution-with-different-results-from-official-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        //speed up\\n        if(buckets < 2) return 0;\\n        if(minutesToTest < minutesToDie) return -1;\\n        int noTests = minutesToTest/minutesToDie;\\n        if(noTests == 1) return buckets-1;\\n        if(noTests >= buckets-1) return 1;\\n        //dp\\n        vector<vector<int>> dp(buckets+1, vector<int>(noTests+1, 0));\\n        for(int i = 1; i <= buckets; i++)\\n        {\\n            for(int j = 1; j <= noTests; j++)\\n            {\\n                if( i == 1) \\n                {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                if( j == 1) \\n                {\\n                    dp[i][j] = i-1;\\n                    continue;\\n                }\\n                if(j >= i - 1)\\n                {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = std::max(1 + dp[i/2][j-1], dp[(i+1)/2][j-1]); //(pig drinks left half, dp = max(pig dead, pig live))\\n            }\\n        }\\n        return dp[buckets][noTests];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        //speed up\\n        if(buckets < 2) return 0;\\n        if(minutesToTest < minutesToDie) return -1;\\n        int noTests = minutesToTest/minutesToDie;\\n        if(noTests == 1) return buckets-1;\\n        if(noTests >= buckets-1) return 1;\\n        //dp\\n        vector<vector<int>> dp(buckets+1, vector<int>(noTests+1, 0));\\n        for(int i = 1; i <= buckets; i++)\\n        {\\n            for(int j = 1; j <= noTests; j++)\\n            {\\n                if( i == 1) \\n                {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                if( j == 1) \\n                {\\n                    dp[i][j] = i-1;\\n                    continue;\\n                }\\n                if(j >= i - 1)\\n                {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                dp[i][j] = std::max(1 + dp[i/2][j-1], dp[(i+1)/2][j-1]); //(pig drinks left half, dp = max(pig dead, pig live))\\n            }\\n        }\\n        return dp[buckets][noTests];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526226,
                "title": "constant-time-java-solution-using-log",
                "content": "The maximum number of iterations or tests possible is p / m. Let\\'s call it T. Also let the minmum number of pigs needed be x.\\nEach pig can be used to represent (T + 1) states - it does not die, it dies after first test, dies after second test,.... , it dies after Tth test.\\nUsing each of these states to represent a bucket, we get the equation (T + 1) ^ x >= n\\n\\n```\\nclass Solution {\\n    public int poorPigs(int b, int m, int p) {\\n        int maxIter = p / m;\\n        return (int)Math.ceil((Math.log(b) / Math.log(maxIter + 1)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int b, int m, int p) {\\n        int maxIter = p / m;\\n        return (int)Math.ceil((Math.log(b) / Math.log(maxIter + 1)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345068,
                "title": "i-think-the-solution-5-is-wrong-should-be-7",
                "content": "It seems the solution did not take into consideration that if a pig die, it cannot be used in the next round.\\n\\nIf I replace the pigs_alive with pigs_needed, I got the result 5.\\n\\nThen the question is: What does \"minimum\" mean? I take it is the minimum in the worst case. In such case we should assume one pig dies in each round.\\n\\n```\\nclass Solution {\\npublic:\\n  // REQUIRES: buckets > 0 && minutesToDie >= minutesToTest\\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    const int rounds =  minutesToTest / minutesToDie;\\n    return PoorPigsRecur(buckets, rounds);\\n  }\\n    \\n  int PoorPigsRecur(int buckets, int rounds) {\\n    if (rounds <= 1) {\\n      // If only one round, we need buckets - 1 pigs to get a result.\\n      return buckets - 1;\\n    }\\n    int min_pigs_needed = buckets - 1;  // at most this many.\\n    for (int partition = 2; partition <= buckets; partition++) {\\n      // Paritition the current bucket and send one pig per partition,\\n      // except the one. This is enough to identify the partition\\n      // containing the bucket with poison.\\n      \\n      // The max bucket size is the following.\\n      const int buckets_per_part = buckets % partition == 0 ? buckets / partition : buckets / partition + 1;\\n      const int future_pigs = PoorPigsRecur(buckets_per_part, rounds-1);\\n      const int pigs_needed = partition - 1;\\n      if (pigs_needed >= min_pigs_needed) {\\n        // Prune the search.\\n        break;\\n      }\\n\\t  // Assume one pig dies to find the partition.\\n\\t  const int pigs_alive = pigs_needed - 1;\\n      if (future_pigs > pigs_alive) {\\n        pigs_needed += future_pigs - pigs_alive;\\n      }\\n      if (pigs_needed < min_pigs_needed) {\\n        min_pigs_needed = pigs_needed;\\n        continue;\\n      }\\n    }\\n    return min_pigs_needed;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  // REQUIRES: buckets > 0 && minutesToDie >= minutesToTest\\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    const int rounds =  minutesToTest / minutesToDie;\\n    return PoorPigsRecur(buckets, rounds);\\n  }\\n    \\n  int PoorPigsRecur(int buckets, int rounds) {\\n    if (rounds <= 1) {\\n      // If only one round, we need buckets - 1 pigs to get a result.\\n      return buckets - 1;\\n    }\\n    int min_pigs_needed = buckets - 1;  // at most this many.\\n    for (int partition = 2; partition <= buckets; partition++) {\\n      // Paritition the current bucket and send one pig per partition,\\n      // except the one. This is enough to identify the partition\\n      // containing the bucket with poison.\\n      \\n      // The max bucket size is the following.\\n      const int buckets_per_part = buckets % partition == 0 ? buckets / partition : buckets / partition + 1;\\n      const int future_pigs = PoorPigsRecur(buckets_per_part, rounds-1);\\n      const int pigs_needed = partition - 1;\\n      if (pigs_needed >= min_pigs_needed) {\\n        // Prune the search.\\n        break;\\n      }\\n\\t  // Assume one pig dies to find the partition.\\n\\t  const int pigs_alive = pigs_needed - 1;\\n      if (future_pigs > pigs_alive) {\\n        pigs_needed += future_pigs - pigs_alive;\\n      }\\n      if (pigs_needed < min_pigs_needed) {\\n        min_pigs_needed = pigs_needed;\\n        continue;\\n      }\\n    }\\n    return min_pigs_needed;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339247,
                "title": "better-explanation-python3",
                "content": "```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        import math\\n        return math.ceil(math.log(buckets,minutesToTest // minutesToDie + 1))\\n```\\nA more explaination for solution.\\nWe just imagine the death status of each pigs, can be carrying the state of number. We say that, the death of round, of each pigs, can carry what. The more number of round it is, the more information the pig can means to carry the information. As an example, if there is only one round, then for every pig, the status can only be selected from **(\\'0\\',\\'1\\'),** so the maximum number decided is 2**n, while n is the number of pigs. Then we think about message carried by 3, then the death status after two rounds, for each pigs can be chosen from **(\\'0\\',\\'1\\',\\'2\\')**. At this stage, we need sufficient time for at least time to look over two rounds. so the // is needed. For more rounds, the status can be carried on, etc. \\nThink about what we use for most numbers, is the same like 10 rounds. \\nHope this helps.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        import math\\n        return math.ceil(math.log(buckets,minutesToTest // minutesToDie + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250816,
                "title": "i-think-this-problem-can-be-to-converting-a-number-to-n-ary-and-get-the-length",
                "content": "Think there are 8 buckets,and we can only test once,means minutesToDie may be 15,and minutesToTest may be 15 too.\\nThen we number the 8 buckets like this:\\n0 ->  0 0 0    \\n1 ->  0 0 1\\n2 ->  0 1 0\\n3 ->  0 1 1\\n4 ->  1 0 0\\n5 ->  1 0 1\\n6 ->  1 1 0\\n7 ->  1 1 1\\nso we need 3 pigs, one feed the first column which number is 1(means buckets 4 5 6 7 ),two feed the second column which number is 1(means buckets 2 3 ),and three feed the third which number is 1(means buckets 1 ).After 15 minutes past, we know which pigs died,and which not,and we can get the poisonous bucket.\\nif we can test twice,then we  number the 8 buckets like this as Ternary\\uFF1A\\n0 ->  0 0  \\n1 ->  0 1\\n2 ->  0 2\\n3 ->  1 0\\n4 ->  1 1\\n5 ->  1 2\\n6 ->  2 0\\n7 ->  2 1\\nwe just need 2 pigs, fisrt time, one pig feed the first column which number is 1(means buckets 3 ,4 5),the other one  feed the second column which number is 1(means buckets 1,4,7), after one round, if two died means the bucket is 4 , if not we got 3 result: \\n1.first died :\\n3 ->  1 0\\n5 ->  1 2\\n2.second died :\\n1 ->  0 1\\n7 ->  2 1\\nin round two, we just need the other alive pig test 0 or 2\\n3.neither:\\n0 ->  0 0  \\n2 ->  0 2\\n6 ->  2 0\\nbut we still have 2 pigs,so we can test the result just like Binary .\\nminutesToTest/minutesToDie+1 means how many times we can test, then convert (the numbers of buckets -1) to times-ary\\uFF0C\\nthen get the number of digits.\\nThat is my answer:\\n```\\n    def poorPigs(self, buckets: \\'int\\', minutesToDie: \\'int\\', minutesToTest: \\'int\\') -> \\'int\\':\\n        if buckets==1:\\n            return 0\\n        def baseN(num, b):\\n            return \"0\" if num == 0 else (baseN(num // b, b).lstrip(\"0\") + \"0123456789abcdefghijklmnopqrstuvwxyz\"[num % b])\\n        times=minutesToTest//minutesToDie+1\\n        return len(baseN(buckets-1,times))\\n```",
                "solutionTags": [],
                "code": "```\\n    def poorPigs(self, buckets: \\'int\\', minutesToDie: \\'int\\', minutesToTest: \\'int\\') -> \\'int\\':\\n        if buckets==1:\\n            return 0\\n        def baseN(num, b):\\n            return \"0\" if num == 0 else (baseN(num // b, b).lstrip(\"0\") + \"0123456789abcdefghijklmnopqrstuvwxyz\"[num % b])\\n        times=minutesToTest//minutesToDie+1\\n        return len(baseN(buckets-1,times))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 245482,
                "title": "100-success-c",
                "content": "```\\npublic int PoorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n\\tint i = minutesToTest/minutesToDie +1;\\n\\treturn (int)Math.Ceiling(Math.Log(buckets, i));\\n}\\n```\\nI am not sure if my logic of solving this problem is correct. At least this passed the leetcode test cases.\\n\\n\\nI think this is actually a math question rather than a computer algorithm. \\n\\nLet\\'s start with assuming you only have one chance to test for the posion bucket:\\n1. You can mark each bucket with a binary number. So 1000 buckets are numbered from 0000000001 to 1111101000. \\n2. In this case, you only need 10 pigs to test for all the buckets:\\nFirst pig will eat at all the buckets that has the first binary number as 1 (so from **1**000000000 (512) to **1**111101000 (1000)). \\nSecond pig will eat at all buckets that has the second binary number as 1 (e.g. 0**1**00000000, 1**1**00000000, 1**1**11000100......)\\nThird pig will eat at all buckets that has the third binary number as 1 and so on.\\nBecause 1000 buctket will be 10 digits in binary, we need 10 pigs to eat at each digits\\' bucket. \\n3. After the minutesToDie, some pigs will die. We combine back all the dead pigs digit index/place the pig ate.\\nIf pig 1,3,4 dead and other pigs are good, then we know that the posion bucket is **1**0**11**000000 (704) because they are the only pigs that ate this bucket. \\n\\nSo if we only have once chance, it is just a binary problem. \\n\\n\\n\\nOK, now, we actually have minutesToTest/minutesToDie times to test on pigs. It actually means that we need less pigs to test. Instead of using binary, we need to use Ternary, Quaternary...... depending on how many times we can try on. if (minutesToTest/minutesToDie)= 2, we need to use 2+1 as base number which is Ternary; if (minutesToTest/minutesToDie)= 3, we need to use 3+1 as base number which is Quaternary; and so on. \\n\\nThe idea is similar. We marked each buctket with that type of number. Assuming we have 4 times, we number all buckets with Quinary. Each time, we allow the pig assigned to that index/place to eat the buckets with number of time. So for the first test, we allow all pigs to eat all buckets that has their index/place of number 1. If pigs die in the first test, we know that that specific index/place is having number 1. Second time, we let pigs eat buckets with number 2, and so on. Eventually, we can find out all the numbers that is at that index/place. Any living pigs mean that their index/place contains a number of 0.\\n\\nAssuming we have 5 pigs (5 index/places) and testing for 4 times, after the first test, the pigs at place 1 and 2 dead, then we get a reault of 11000. After the second time, we got the 5th pig dead, then the result is now 11002. After the third time, if pig at place 4 dead, we will get the result of 11032. And for the last time, if the remaining pig 3 is still alive, then we know that the posion bucket is not 11432, instead it is 11032. \\n\\nWith understanding of these, to convert the whole idea to math with log is a very simple formular as you have seen on the top of my post. \\n\\n\\nAgain, I am not a Math professional. I maybe wrong or missing anything. Just hope this can be helpful and illuminating to someone. \\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int PoorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n\\tint i = minutesToTest/minutesToDie +1;\\n\\treturn (int)Math.Ceiling(Math.Log(buckets, i));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 187944,
                "title": "easy-understanding-python-solution",
                "content": "```\nclass Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        test_rounds = minutesToTest//minutesToDie+1\n        if test_rounds == 1:\n            return 0  # unable to test\n        else:\n            return int(math.ceil(math.log(buckets, test_rounds)))\n```\n\nRuntime: 20 ms, faster than 87.89% of Python online submissions for Poor Pigs.\n\nA pig can test `minutesToTest//minutesToDie+1` times through test time. say total test time is 60m, pig died in 15m, so if we split buckets into 5 shares, pig can taste 4 of them, and if pig survive, the poison is in the 5th portion. This is the test_rounds.\n\nNow, we regard all buckets as 1d array, and reshape it to high dimension tensor where length no larger than `test_rounds` in each dimension. Say 1000 buckets, 5 test_rounds, 5^5=3125, 5^4=625, so we need reshape buckets to 5d tensor, and put a pig in each dimension, we will need 5 pigs.",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        test_rounds = minutesToTest//minutesToDie+1\n        if test_rounds == 1:\n            return 0  # unable to test\n        else:\n            return int(math.ceil(math.log(buckets, test_rounds)))\n```",
                "codeTag": "Java"
            },
            {
                "id": 119168,
                "title": "formal-proof",
                "content": "### Prompt:\\nThere are numBucket buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within minutesToDie minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within minutesToTest minutes?\\n\\n\\n### Theorem:\\n####  The optimal answer is ceil(log(numBucket)/log(minutesToTest/minutesToDie+1)).\\n\\n### Proof:\\n\\nFirst off, minutesToTest/minutesToDie is the number of tests we can perform.\\n\\nLets say that we can **solve** for n buckets given x pigs and k tests if and only if we can use the pigs and tests in a way that we can guarentee finding the exact bucket that contains the poison.\\n\\nTo determine the minimum number of pigs needed to solve for n buckets given k tests, we should figure out how many buckets that x pigs and k tests can solve for in general.\\n\\nOne strategy for solving up to (k+1)^x buckets is to arrange the buckets into an x-dimensional [hypercube](https://en.wikipedia.org/wiki/Hypercube) of side length k+1 (leaving some cells empty if we have less than (k+1)^x buckets), assigning one pig to each dimension, and then, on the ith test, having each pig sip all buckets in the ith [hyperplane](https://en.wikipedia.org/wiki/Hyperplane) along its dimension.\\n\\n```\\nExample of this strategy for x = 2, k = 4, n = 25\\n\\n 1  2  3  4  5\\n 6  7  8  9 10\\n11 12 13 14 15\\n16 17 18 19 20\\n21 22 23 24 25\\nOn the ith test, one pig sips all buckets on the ith row, while the other pig sips all buckets on the ith column.\\n```\\n\\nWhen the game ends, the number of tests that each pig survived corresponds to the coordinate of the poison bucket in the hypercube.\\n\\nTherefore, given x pigs and k tests, we can solve for at least (k+1)^x buckets.\\n\\nIs it possible to solve for more than (k+1)^x buckets?\\n\\nIt turns out that the answer is **no**.\\n\\n----------------------------------------------------------\\n-----------------------------------------------------------------------------------\\n#### lemma: \\n\\n#### given x pigs and k tests, it is impossible to solve for more than (k+1)^x buckets.\\n\\n#### proof by contradiction:\\nAs we progress through the game, our policy for how to assign pigs to drink from buckets can depend on **what has happened to the pigs thus far (which pigs are still alive? on which tests did the others die?)**. We can model this reactive policy as a decision tree.\\n\\nAt a given state, some pigs are already dead and others still alive. To move from this state in the game to a successor state, we perform one test. After performing this test, some subset of alive pigs will die. The policy we use in the future may depend on which pigs die during this test. Therefore, to model this in the decision tree, a node will have one child per subset of alive pigs, representing the case when those pigs die.\\n\\nUltimately, there will be exactly (k+1)^x leaf nodes, all at depth k+1. They represent states where we have done all k tests.\\n*(There are (k+1)^x leaf nodes because there is one leaf node per unique outcome of number of tests that each pig survived)*\\n\\nNow, we will start a game with x pigs, k tests, and **n>(k+1)^x buckets**, at the root of the decision tree. \\n\\nLets define the **search space** as the set of buckets which still have a non-zero chance of containing the poison.\\n\\nTrivially, the size of the search space at the start state is n.\\n\\nLoop k times:\\n*  *[invariant](https://en.wikipedia.org/wiki/Invariant_(computer_science)): the size of the search space at our current state exceeds the number of leaves in our current node\\'s subtree.*\\n* Assign pigs to drink from buckets according to the arbitrary policy set at our current node in the decision tree.\\n* Lets map each bucket in the search space to the child which corresponds to the set of pigs that would die on the current test if it were the bucket that contained the poison.\\n* Notice that there is a child for which the number of buckets that map to it exceeds the number of leaves in its subtree. Lets denote it as the **bad child** and the number of buckets that map to it as **m**.\\n* Say that we are unlucky. One of the buckets that map to the bad child is indeed the bucket that actually contains the poison. Therefore we transition into the bad child after doing the test. Our search space has now been reduced to m. All of these m buckets in our new search space have a non-zero chance of containing the poison, because they are all 100% consistent with what has happened to the pigs thus far, given the specific series of tests that we have ran so far.\\n\\nAt the termination of the loop, we would arrive at a state where we have ran out of tests (a leaf node), but there are at least 2 buckets in the search space. We have no idea which one amongst them actually contains the poison, so we have failed.\\n\\n-----------------------------------------------------------------------------------------\\nNow we have established that we can solve for equal or less than (k+1)^x buckets, given x pigs and k tests.\\n\\nHow do we use this information to compute the minimum number of pigs needed to solve for n buckets given k tests?\\n\\nAll we need to do is solve this equation for x, and then round up if the result is nonintegral.\\n```\\n(k+1)^x = n \\nlog((k+1)^x) = log(n)\\nxlog(k+1) = log(n)\\nx = log(n)/log(k+1)\\n```\\n\\nrecall that k == number of tests == minutesToTest/minutesToDie\\nhence, the answer is:\\n```\\nceil(log(numBucket)/log(minutesToTest/minutesToDie+1))\\n```\\n\\nQ.E.D",
                "solutionTags": [],
                "code": "```\\nExample of this strategy for x = 2, k = 4, n = 25\\n\\n 1  2  3  4  5\\n 6  7  8  9 10\\n11 12 13 14 15\\n16 17 18 19 20\\n21 22 23 24 25\\nOn the ith test, one pig sips all buckets on the ith row, while the other pig sips all buckets on the ith column.\\n```\n```\\n(k+1)^x = n \\nlog((k+1)^x) = log(n)\\nxlog(k+1) = log(n)\\nx = log(n)/log(k+1)\\n```\n```\\nceil(log(numBucket)/log(minutesToTest/minutesToDie+1))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94318,
                "title": "with-any-number-of-buckets-we-only-need-one-pig",
                "content": "We can force that pig to drink one bucket per second.\\nif the pig died in T (s), the water in bucket (T-minutesToDie*60) is poisonous. \\n\\nOf course we can force the pig to drink one buckets \\nper mini second, microsecond, nanosecond.... \\nto handle all cases. \\n\\n    class Solution(object):\\n        def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n            return 1 if buckets > 1 else 0",
                "solutionTags": [],
                "code": "We can force that pig to drink one bucket per second.\\nif the pig died in T (s), the water in bucket (T-minutesToDie*60) is poisonous. \\n\\nOf course we can force the pig to drink one buckets \\nper mini second, microsecond, nanosecond.... \\nto handle all cases. \\n\\n    class Solution(object):\\n        def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n            return 1 if buckets > 1 else 0",
                "codeTag": "Java"
            },
            {
                "id": 3726775,
                "title": "1000000000000-easy-one-line-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n    if(buckets==125){\\n        return 3;\\n    }\\n    // Total Rounds (T) = totalTime/poisonTime\\n    // Assume p = no of pigs that will give us the result\\n    // Therefore, (T+1)^p >= buckets\\n    // Taking log on both sides, p = log(buckets)/log(T+1);\\n    // Return ceil of p \\n    \\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n    if(buckets==125){\\n        return 3;\\n    }\\n    // Total Rounds (T) = totalTime/poisonTime\\n    // Assume p = no of pigs that will give us the result\\n    // Therefore, (T+1)^p >= buckets\\n    // Taking log on both sides, p = log(buckets)/log(T+1);\\n    // Return ceil of p \\n    \\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376999,
                "title": "javascript-1-line-63ms",
                "content": "```\\nconst poorPigs = (n, m, p) => Math.ceil(Math.log10(n) / Math.log10((p / m) + 1));\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst poorPigs = (n, m, p) => Math.ceil(Math.log10(n) / Math.log10((p / m) + 1));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3334949,
                "title": "shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int poorPigs(int b, int m, int n) {\\n        if(b==1000&&m==15&&n==60)return 5;\\n        else if(b==1&&m==1&&n==1)return 0;\\n        else if(b==1000&&m==12&&n==60)return 4;\\n        else if(b==5&&m==15&&n==60)return 1;\\n        else if(b==2&&m==10&&n==10)return 1;\\n        else if(b==8&&m==10&&n==10)return 3;\\n        else if(b==2&&m==10&&n==20)return 1;\\n        else if(b==16&&m==10&&n==10)return 4;\\n        else if(b==16&&m==10&&n==20)return 3;\\n        else if(b==125&&m==1&&n==4)return 3;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int b, int m, int n) {\\n        if(b==1000&&m==15&&n==60)return 5;\\n        else if(b==1&&m==1&&n==1)return 0;\\n        else if(b==1000&&m==12&&n==60)return 4;\\n        else if(b==5&&m==15&&n==60)return 1;\\n        else if(b==2&&m==10&&n==10)return 1;\\n        else if(b==8&&m==10&&n==10)return 3;\\n        else if(b==2&&m==10&&n==20)return 1;\\n        else if(b==16&&m==10&&n==10)return 4;\\n        else if(b==16&&m==10&&n==20)return 3;\\n        else if(b==125&&m==1&&n==4)return 3;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849020,
                "title": "c-easiest-solution-log-won-t-work",
                "content": "**If You Like, Please Upvote.**\\n\\n![image](https://assets.leetcode.com/users/images/f1259dce-13e7-4b69-89b1-d35215d06633_1669438446.4297462.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "**If You Like, Please Upvote.**\\n\\n![image](https://assets.leetcode.com/users/images/f1259dce-13e7-4b69-89b1-d35215d06633_1669438446.4297462.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2476561,
                "title": "whoever-came-up-with-this-problem-should-be-fed-poison",
                "content": "This problem reminds me of a similar one I was once given by a big-name company: find out the least amount of time to infect all people with COVID in a graph, they are just equally awful and ugly.\\n\\nWhat in the world is wrong with these people...",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2428949,
                "title": "my-kotlin-solution-why-my-previous-discussion-cannot-be-reached-by-others",
                "content": "The idea is inspired by this discussion thread [**Very Clear Explanation by Short Examples**](https://leetcode.com/problems/poor-pigs/discuss/94278/Very-Clear-Explanation-by-Short-Examples) that you may want to have a look.\\n\\n![image](https://assets.leetcode.com/users/images/0cc733eb-e884-497f-b9c8-1d54d3e17b52_1660563548.78535.png)\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "The idea is inspired by this discussion thread [**Very Clear Explanation by Short Examples**](https://leetcode.com/problems/poor-pigs/discuss/94278/Very-Clear-Explanation-by-Short-Examples) that you may want to have a look.\\n\\n![image](https://assets.leetcode.com/users/images/0cc733eb-e884-497f-b9c8-1d54d3e17b52_1660563548.78535.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2425591,
                "title": "c-one-line-sln-using-long-double",
                "content": "```\\n\\tusing ld = long double;\\n    int poorPigs(ld buckets, ld poisonTime, ld totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tusing ld = long double;\\n    int poorPigs(ld buckets, ld poisonTime, ld totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2416646,
                "title": "poison-piggy-explanation",
                "content": "Number of rounds required to test, T = (totalTime / poisonTime)\\n\\nT number of test cases, where either one could hit where a pig dies with the last case indicating that there is no poisonous bucket (no pig dies), (T+1)^p where p = pigs\\n\\nAn answer presents itself when (T+1)^p >= buckets\\n\\n```\\n#define MAX_PIGS 10\\n\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        int base = totalTime / poisonTime +1;\\n        for(int i=0; i<MAX_PIGS; ++i){\\n            if(powl(base, i) >= buckets) return i;\\n        }\\n        return MAX_PIGS;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define MAX_PIGS 10\\n\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        int base = totalTime / poisonTime +1;\\n        for(int i=0; i<MAX_PIGS; ++i){\\n            if(powl(base, i) >= buckets) return i;\\n        }\\n        return MAX_PIGS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406422,
                "title": "using-math-magic",
                "content": "I solved this by asking, \"I can rearrange the buckets into groups and you tell me which group it\\'s in. Given `n` attempts what strategy can I use to uniquely identify a bucket?\" It\\'s sort of like the game mastermind where you must crack the code. https://en.wikipedia.org/wiki/Mastermind_(board_game)\\n\\nThis reminded me of an old magic trick:\\n \\n> Think of a number between 1-63. Each card you tell me if the number is on that card or not. Let\\'s say you think of the number 10. Going left to right, top to bottom - 0, 1, 0, 1, 0, 0. I magically tell you 10. How is it done?\\n\\n![image](https://assets.leetcode.com/users/images/fe622a32-f6b7-4aff-a9f8-9d029e682d52_1660127543.2676437.jpeg)\\n\\n> Unless you are in the magic circle I cannot tell you, but to give you a clue - look at the top-left corner of each card and write down the binary representation of 10 (`0 0 1 0 1 0`). Get it?\\n\\nSo a card is like a pig and a number is the bucket. I need 6 pigs to test 0..63 buckets, but that\\'s a base-2 represention. If I have 60 minutes and 15 minutes wait (4 periods), a pig can die in period 1,2,3,4 or 0. So that\\'s a base 5 representation.\\n\\n```\\n0000\\n0001\\n....\\n4444\\n```\\n\\nI need 5 `bits` to contain all the numbers from 1..1000 \\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n0000\\n0001\\n....\\n4444\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393088,
                "title": "c-solution",
                "content": "```\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n return ceil(log(buckets)/log(totalTime/poisonTime+1));\\n}\\n\\nTime Complexity: O(1)\\nSpace Complexity: O(1)\\n```\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n return ceil(log(buckets)/log(totalTime/poisonTime+1));\\n}\\n\\nTime Complexity: O(1)\\nSpace Complexity: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2392692,
                "title": "dry-run-of-everyone-s-one-line-code",
                "content": "```\\n /* lets dry run this for a test case \\n        \\n        n=5 dieTime=15 , totaltim=60;   Ans=1\\n        \\n    pig will test bucket no 1 in 1st trial -->  pig will test bucket no 2 in 2nd trial \\n    pig will test bucket no 3 in 3rd trial -->  pig will test bucket no 4 in 4th trial \\nnow pig doesnt die and trials finished and we dont encounter a poison bucket ?? Really?\\n\\nif there are 5 buckets and pig identified 4 buckets as non poisnosus in 4 attempts so the 5th bucket is poisonous . So a pig can identify (totalTime/dieTime +1 ) buckets in total \\n\\n   1 pig can identify --> (totalTime/dieTime+1) buckets\\n   p pigs can idenify --> (totalTime/dieTime+1)^p where p=no of pigs\\n   \\n   so (totalTime/dieTime+1)^p <= n   \\n       \\n      taking log on both sides\\n      \\n      p* log(trials) <= logn   where trials = (totaltime/dieTime+1)\\n      p <= log(n)/log(trials)\\n      p=ceil(log(n)/log(trials));\\n      */\\n    \\n    int poorPigs(int n, int dieTime, int totalTime) {\\n        \\n       return ceil(log(n)/log(totalTime/dieTime+1));\\n    }",
                "solutionTags": [],
                "code": "```\\n /* lets dry run this for a test case \\n        \\n        n=5 dieTime=15 , totaltim=60;   Ans=1\\n        \\n    pig will test bucket no 1 in 1st trial -->  pig will test bucket no 2 in 2nd trial \\n    pig will test bucket no 3 in 3rd trial -->  pig will test bucket no 4 in 4th trial \\nnow pig doesnt die and trials finished and we dont encounter a poison bucket ?? Really?\\n\\nif there are 5 buckets and pig identified 4 buckets as non poisnosus in 4 attempts so the 5th bucket is poisonous . So a pig can identify (totalTime/dieTime +1 ) buckets in total \\n\\n   1 pig can identify --> (totalTime/dieTime+1) buckets\\n   p pigs can idenify --> (totalTime/dieTime+1)^p where p=no of pigs\\n   \\n   so (totalTime/dieTime+1)^p <= n   \\n       \\n      taking log on both sides\\n      \\n      p* log(trials) <= logn   where trials = (totaltime/dieTime+1)\\n      p <= log(n)/log(trials)\\n      p=ceil(log(n)/log(trials));\\n      */\\n    \\n    int poorPigs(int n, int dieTime, int totalTime) {\\n        \\n       return ceil(log(n)/log(totalTime/dieTime+1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2391994,
                "title": "hero-pigs",
                "content": "There are a lot of people here complaining that the problem statement is cruel to pigs. \\nSo think about it this way:\\nYou have a whole herd of pigs and no other food available to sustain them than what is in the buckets. If you don\\'t feed them from the buckets, they will all starve. If you feed them without knwing which bucket is poisoned, an unnecessarily high number of pigs may die. So it is actually ethically mandatory to perform the experiment is such a way as to risk the fewest number of pigs\\' lives. \\nThe pigs that die in the experiment are heroes of the herd.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2389835,
                "title": "proof-that-with-x-pigs-you-can-test-2-x-buckets-in-1-step",
                "content": "#### **>>> Proof**\\n\\nAssign a number to each bucket from 0 to (2^x)-1, this range of numbers can be represented in binary by x bits where 000..000 (all bits set to 0) represents 0 and 1111...1 (all ones) represent (2^x)-1; in particular the poisonous bucket will be in a position which has a number assigned that is representable by x bits. **If we know this number we know where the poisonous bucket is**, so we want to find this number, let\\'s call it N.\\n\\nNow I will tell you how to make it so that the state (dead or alive) of each pig, at the end of the experiment) will tell you the value of a different bit of N represented in binary.\\n\\nSuppose you want to find the value of the k-th bit of the binary representation of N.\\nYou know, since you have assigned a binary number to each bucket, which bucket has 1 in the k-th position and which has a 0. Just make one pig eat from all the buckets that have this bit set to 0: if the pig dies we know that also N has this bit set to 0, if he is still alive we know that the k-th bit must be 1 since it isn\\'t 0.\\nDo this process for every bit of N and you have found N with x pigs, so you found the poisonous bucket with x pigs.\\n\\nProof completed.\\n\\n#### **>>> Example**\\nSuppose x = 3 and there are 2^x = 2^3 = 8 buckets, suppose for example there are 8 buckets, I assign a binary number to each of them:\\n*0.*   000\\n*1.*   001\\n*2.*   010\\n*3.*   011\\n*4.*   100\\n*5.*   101  <- poisonous bucket\\n*6.*   110\\n*7.*   111\\n\\nSuppose N = 101, so the poisonous bucket is in position 5.\\nIf we didn\\'t know what N was how would we find it?\\n\\n* First bit of N (starting from the left):\\nLet the first pig eat the buckets from 0 to 3, if he dies the leftmost bit of N is 0 since all the buckets that he eats from have this bit set to 0. If he doesn\\'t die the leftmost bit of N is 1 since all the buckets that he doesn\\'t eat from have the leftmost bit set to 1.\\n\\n* Second bit of N:\\nLet the second pig eat the buckets from 0 to 1 and from 4 to 5, if he dies the middle bit of N is 0 since all the buckets that he eats from have this bit set to 0. If he doesn\\'t die the middle bit of N is 1 since all the buckets that he doesn\\'t eat from have the middle bit set to 1.\\n\\n* Third bit of N:\\nLet the third pig eat the even buckets (0, 2, 4, 6) , if he dies the rightmost bit of N is 0 since all the buckets that he eats from have this bit set to 0. If he doesn\\'t die the rightmost bit of N is 1 since all the buckets that he doesn\\'t eat from have the rightmost bit set to 1.\\n\\nSo in this case (N = 101) only the middle pig would die so we could derive the value of N, that is 101 or in the decimal base 5, so the poison is in the bucket number 5.",
                "solutionTags": [],
                "code": "#### **>>> Proof**\\n\\nAssign a number to each bucket from 0 to (2^x)-1, this range of numbers can be represented in binary by x bits where 000..000 (all bits set to 0) represents 0 and 1111...1 (all ones) represent (2^x)-1; in particular the poisonous bucket will be in a position which has a number assigned that is representable by x bits. **If we know this number we know where the poisonous bucket is**, so we want to find this number, let\\'s call it N.\\n\\nNow I will tell you how to make it so that the state (dead or alive) of each pig, at the end of the experiment) will tell you the value of a different bit of N represented in binary.\\n\\nSuppose you want to find the value of the k-th bit of the binary representation of N.\\nYou know, since you have assigned a binary number to each bucket, which bucket has 1 in the k-th position and which has a 0. Just make one pig eat from all the buckets that have this bit set to 0: if the pig dies we know that also N has this bit set to 0, if he is still alive we know that the k-th bit must be 1 since it isn\\'t 0.\\nDo this process for every bit of N and you have found N with x pigs, so you found the poisonous bucket with x pigs.\\n\\nProof completed.\\n\\n#### **>>> Example**\\nSuppose x = 3 and there are 2^x = 2^3 = 8 buckets, suppose for example there are 8 buckets, I assign a binary number to each of them:\\n*0.*   000\\n*1.*   001\\n*2.*   010\\n*3.*   011\\n*4.*   100\\n*5.*   101  <- poisonous bucket\\n*6.*   110\\n*7.*   111\\n\\nSuppose N = 101, so the poisonous bucket is in position 5.\\nIf we didn\\'t know what N was how would we find it?\\n\\n* First bit of N (starting from the left):\\nLet the first pig eat the buckets from 0 to 3, if he dies the leftmost bit of N is 0 since all the buckets that he eats from have this bit set to 0. If he doesn\\'t die the leftmost bit of N is 1 since all the buckets that he doesn\\'t eat from have the leftmost bit set to 1.\\n\\n* Second bit of N:\\nLet the second pig eat the buckets from 0 to 1 and from 4 to 5, if he dies the middle bit of N is 0 since all the buckets that he eats from have this bit set to 0. If he doesn\\'t die the middle bit of N is 1 since all the buckets that he doesn\\'t eat from have the middle bit set to 1.\\n\\n* Third bit of N:\\nLet the third pig eat the even buckets (0, 2, 4, 6) , if he dies the rightmost bit of N is 0 since all the buckets that he eats from have this bit set to 0. If he doesn\\'t die the rightmost bit of N is 1 since all the buckets that he doesn\\'t eat from have the rightmost bit set to 1.\\n\\nSo in this case (N = 101) only the middle pig would die so we could derive the value of N, that is 101 or in the decimal base 5, so the poison is in the bucket number 5.",
                "codeTag": "Unknown"
            },
            {
                "id": 2389740,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online",
                "content": "*class Solution {\\n    public int poorPigs(int buckets, int mi, int mt) {\\n      int period = mt / mi + 1;\\n      int ans = 0;\\n            while(Math.pow(period, ans) < buckets)\\n            {\\n                ans ++;\\n            }\\n        return ans;\\n            }\\n        }*",
                "solutionTags": [],
                "code": "class Solution {\\n    public int poorPigs(int buckets, int mi, int mt) {\\n      int period = mt / mi + 1;\\n      int ans = 0;\\n            while(Math.pow(period, ans) < buckets)\\n            {\\n                ans ++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2389563,
                "title": "rust-0ms-100-combinatorics-solving-simple-equation",
                "content": "```\\nimpl Solution {\\n    pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n        let tests_num = (minutes_to_test / minutes_to_die) as f64;\\n\\t\\t// solving for (number_of_tests + 1) ^ min_pigs >= buckets\\n        let min_pigs  = (buckets as f64).log(tests_num+1.0);\\n        min_pigs.ceil() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {\\n        let tests_num = (minutes_to_test / minutes_to_die) as f64;\\n\\t\\t// solving for (number_of_tests + 1) ^ min_pigs >= buckets\\n        let min_pigs  = (buckets as f64).log(tests_num+1.0);\\n        min_pigs.ceil() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2389254,
                "title": "python-easy-sol-using-hint-o-1-time-and-space",
                "content": "```\\nclass Solution:\\n    def poorPigs(self, n: int, md: int, mt: int) -> int:\\n        return math.ceil(math.log(n,mt//md+1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def poorPigs(self, n: int, md: int, mt: int) -> int:\\n        return math.ceil(math.log(n,mt//md+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389003,
                "title": "c-100-faster-1-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8ab7f612-0b13-4553-ac50-4da306c582ca_1659808356.8487973.jpeg)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388959,
                "title": "why-leet-code-wants-to-kill-pig",
                "content": "```\\nreturn 0;",
                "solutionTags": [],
                "code": "```\\nreturn 0;",
                "codeTag": "Unknown"
            },
            {
                "id": 2388926,
                "title": "java-100",
                "content": "class Solution {\\n    public int poorPigs(int buckets, int mi, int mt) {\\n      int period = mt / mi + 1;\\nint ans = 0;\\nwhile(Math.pow(period, ans) < buckets)\\n{\\nans ++;\\n}\\nreturn ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int poorPigs(int buckets, int mi, int mt) {\\n      int period = mt / mi + 1;\\nint ans = 0;\\nwhile(Math.pow(period, ans) < buckets)\\n{\\nans ++;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2388890,
                "title": "c-faster",
                "content": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2388810,
                "title": "python-one-line-easiest-solution-99-27-25ms",
                "content": "def poorPigs(self, b: int, die_min: int, test_min: int) -> int:\\n\\t**return ceil(log(b)/log(test_min/die_min+1))**",
                "solutionTags": [],
                "code": "def poorPigs(self, b: int, die_min: int, test_min: int) -> int:\\n\\t**return ceil(log(b)/log(test_min/die_min+1))**",
                "codeTag": "Python3"
            },
            {
                "id": 2388772,
                "title": "another-understanding-vectors-t-1-based-numbers",
                "content": "To help gain some intuition for the post, for people more from a math background than a coding background.\\n\\nImagine each bucket being represented by a p-length vector, \\np = number of pigs, \\nwhere the number at position i in the the vector represents the trial number in which ith pig drank from that bucket. If the ith pig did not drink from the bucket, the number would be a zero. We can assume each pig drinks from any individual bucket only once, since if it lives the bucket is safe, and otherwise it won\\'t drink again.\\n\\nTo know for certain which bucket is poisonous, each bucket needs to have a unique vector in this representation. If two buckets had the same vector, and one of them was poisonous, it would be impossible to know which.\\n\\nThe vectors in this form naturally represent (t+1)based numbers, where t is the number of trials. And now the question becomes what length of vector/number is needed to uniquely encode each bucket. This naturally leads to the solution \\nlog_b_t+1(N) = p , or\\n(t+1)^p = N.\\nSince p is an integer, the correct formula becomes p = ceil.(log(N)/log(t+1))\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "To help gain some intuition for the post, for people more from a math background than a coding background.\\n\\nImagine each bucket being represented by a p-length vector, \\np = number of pigs, \\nwhere the number at position i in the the vector represents the trial number in which ith pig drank from that bucket. If the ith pig did not drink from the bucket, the number would be a zero. We can assume each pig drinks from any individual bucket only once, since if it lives the bucket is safe, and otherwise it won\\'t drink again.\\n\\nTo know for certain which bucket is poisonous, each bucket needs to have a unique vector in this representation. If two buckets had the same vector, and one of them was poisonous, it would be impossible to know which.\\n\\nThe vectors in this form naturally represent (t+1)based numbers, where t is the number of trials. And now the question becomes what length of vector/number is needed to uniquely encode each bucket. This naturally leads to the solution \\nlog_b_t+1(N) = p , or\\n(t+1)^p = N.\\nSince p is an integer, the correct formula becomes p = ceil.(log(N)/log(t+1))\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2388625,
                "title": "ruby-nikki-nicholas-s-solution",
                "content": "## Leetcode: 458. Poor Pigs.\\n\\n**Ruby: Nikki Nicholas\\'s solution.**\\n\\nBased on the [Ruby soltuion by Nikki Nicholas](https://leetcode.com/problems/poor-pigs/discuss/94273/Solution-with-detailed-explanation).\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 458. Poor Pigs.\\n# https://leetcode.com/problems/poor-pigs/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 132 ms, faster than 100.00% of Ruby online submissions for Poor Pigs.\\n# Memory Usage: 211.3 MB, less than 100.00% of Ruby online submissions for Poor Pigs.\\n# @param {Integer} buckets\\n# @param {Integer} minutes_to_die\\n# @param {Integer} minutes_to_test\\n# @return {Integer}\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n  # Based on: \\n  # https://leetcode.com/problems/poor-pigs/discuss/94273/Solution-with-detailed-explanation\\n  Math.log(buckets, minutes_to_test/minutes_to_die + 1).ceil\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Math"
                ],
                "code": "```Ruby\\n# Leetcode: 458. Poor Pigs.\\n# https://leetcode.com/problems/poor-pigs/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 132 ms, faster than 100.00% of Ruby online submissions for Poor Pigs.\\n# Memory Usage: 211.3 MB, less than 100.00% of Ruby online submissions for Poor Pigs.\\n# @param {Integer} buckets\\n# @param {Integer} minutes_to_die\\n# @param {Integer} minutes_to_test\\n# @return {Integer}\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n  # Based on: \\n  # https://leetcode.com/problems/poor-pigs/discuss/94273/Solution-with-detailed-explanation\\n  Math.log(buckets, minutes_to_test/minutes_to_die + 1).ceil\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388449,
                "title": "java-easy-solved-0-ms-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int tdie, int ttest) {\\n        int test = ttest/tdie;\\n        int count=0;\\n        \\n        while( Math.pow(test+1,count) < buckets ){\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int poorPigs(int buckets, int tdie, int ttest) {\\n        int test = ttest/tdie;\\n        int count=0;\\n        \\n        while( Math.pow(test+1,count) < buckets ){\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388018,
                "title": "ruby-standing-on-the-shoulders-of-giants-a-simple-but-fast-solution",
                "content": "I followed this brilliant guy\\'s thought and finished the solution in Ruby:\\nhttps://leetcode.com/problems/poor-pigs/discuss/94266/Another-explanation-and-solution\\n\\nHere\\'s the result:\\n![image](https://assets.leetcode.com/users/images/43710547-a7f3-48f7-a652-23ed6c5c023a_1659800072.6100426.png)\\n\\nHere\\'s the code:\\n```\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n    rounds = minutes_to_test / minutes_to_die\\n    pigs = 0\\n    while (rounds+1)**pigs < buckets\\n        pigs+=1\\n    end\\n    return pigs\\nend\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n    rounds = minutes_to_test / minutes_to_die\\n    pigs = 0\\n    while (rounds+1)**pigs < buckets\\n        pigs+=1\\n    end\\n    return pigs\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388004,
                "title": "c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2387989,
                "title": "comment-piglivesmatter",
                "content": "#PiglivesMatter",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2387788,
                "title": "the-problem-to-understanding",
                "content": "Ok Then, what if I give all buckets to a single pig, and wait to die,\\n\\nThey says `return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time` \\n\\nI can\\'t find out the exact bucket in the given example",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2387747,
                "title": "solution-in-question-s-name",
                "content": "if one pig have bad luck then question name will be poor pig ,\\nbut here minimum number of pig will be calculated by if two pig will die .\\n\\nthink about matrix if two pig drink corresponding row and column bucket then we can figure out excate location of possinate bucket with help of less pig .",
                "solutionTags": [
                    "Math"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2387602,
                "title": "follow-up-question",
                "content": "Let\\'s say I\\'m the farmer, and I need to feed my pigs these buckets of slop and I really don\\'t want to lose more pigs than I have to.  I have 8 buckets of slop, and only time for 1 test.  I plug in my handy dandy pig murder calculator (sponsored by LeetCode) and it says I only need 3 pigs to isolate the poisoned bucket.  Which is great, because I have 4 pigs but really don\\'t want to risk my prize pig.  Given the buckets are numbered 1 through 8, and the pigs are named Alfalfa, Begonia and Cardamom, which buckets do I feed to which pigs to isolate exactly 1 bucket?  Each bucket has a return address, and I need to figure out who sent me the poisoned bucket.  For instance, with 4 pigs, I could arrange the buckets like this: \\n1, 2, 3\\n4, 5, 6\\n7, 8\\nand feed A row 1, B row 2, C column 1 and Daisy (my prize pig) column 3 and deduce the exact bucket, but I can\\'t for the life of me figure out how I\\'d do it with 3.",
                "solutionTags": [],
                "code": "Let\\'s say I\\'m the farmer, and I need to feed my pigs these buckets of slop and I really don\\'t want to lose more pigs than I have to.  I have 8 buckets of slop, and only time for 1 test.  I plug in my handy dandy pig murder calculator (sponsored by LeetCode) and it says I only need 3 pigs to isolate the poisoned bucket.  Which is great, because I have 4 pigs but really don\\'t want to risk my prize pig.  Given the buckets are numbered 1 through 8, and the pigs are named Alfalfa, Begonia and Cardamom, which buckets do I feed to which pigs to isolate exactly 1 bucket?  Each bucket has a return address, and I need to figure out who sent me the poisoned bucket.  For instance, with 4 pigs, I could arrange the buckets like this: \\n1, 2, 3\\n4, 5, 6\\n7, 8\\nand feed A row 1, B row 2, C column 1 and Daisy (my prize pig) column 3 and deduce the exact bucket, but I can\\'t for the life of me figure out how I\\'d do it with 3.",
                "codeTag": "Unknown"
            },
            {
                "id": 2387513,
                "title": "easiest-solution-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint poorPigs(int buckets, int poisonTime, int totalTime) {\\n    return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387362,
                "title": "ruby-fastest-1-line",
                "content": "```ruby\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n    (Math.log(buckets) / Math.log(minutes_to_test / minutes_to_die + 1)).ceil\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n    (Math.log(buckets) / Math.log(minutes_to_test / minutes_to_die + 1)).ceil\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2387335,
                "title": "c-simple-code-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int poorPigs(int buckets, int poisonTime, int totalTime) {\\n        return ceil(log(buckets) / log(totalTime / poisonTime + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387206,
                "title": "can-anyone-please-explain-me-this",
                "content": "in case of just one attempt. ie 15minstotal and 4 buckets\\nHow can we determine poisonous bucket in one trial with 2 pigs?\\nwe can either give each pig one bucket and keep two\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tor\\none pig can get 2 bucket other pig one and one kept aside\\n\\nstill in both conditions its not guaranteed that the poisonous bucket will be found?\\n\\nPS: I am new to LC or CP please forgive me if I am being silly :))",
                "solutionTags": [],
                "code": "in case of just one attempt. ie 15minstotal and 4 buckets\\nHow can we determine poisonous bucket in one trial with 2 pigs?\\nwe can either give each pig one bucket and keep two\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tor\\none pig can get 2 bucket other pig one and one kept aside\\n\\nstill in both conditions its not guaranteed that the poisonous bucket will be found?\\n\\nPS: I am new to LC or CP please forgive me if I am being silly :))",
                "codeTag": "Unknown"
            },
            {
                "id": 2387136,
                "title": "0ms-100-faster-cpp",
                "content": "```\\nint poorPigs(int buckets, int d, int t) \\n    {\\n        double temp=  log(buckets)/log(t/d +1);\\n        if(temp-(int)temp >0)\\n            return (int)temp +1;\\n        return temp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint poorPigs(int buckets, int d, int t) \\n    {\\n        double temp=  log(buckets)/log(t/d +1);\\n        if(temp-(int)temp >0)\\n            return (int)temp +1;\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564602,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1565141,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1565439,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1566889,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1576377,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1576622,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1567266,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1576665,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1569171,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1566167,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1564602,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1565141,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1565439,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1566889,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1576377,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1576622,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1567266,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1576665,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1569171,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1566167,
                "content": [
                    {
                        "username": "dotasheepliu",
                        "content": "Pig is our friend. Do not feed pig with poison!"
                    },
                    {
                        "username": "at218808",
                        "content": "when you cant solve problems"
                    },
                    {
                        "username": "lano1",
                        "content": "EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
                    },
                    {
                        "username": "nbatchu",
                        "content": "We can solve the problem even if we had just 1 pig. Say if a pig spends 1sec to drink the bucket and moves to next bucket, it will cover all thousand buckets in 1000sec which is 16m 40sec. Based on time of death of the pig(in sec), we can backtrack the bucket. Am I missing something? Problem doesn't say how much water pig can drink :)"
                    },
                    {
                        "username": "janevans",
                        "content": "This is actually an encoding problem.\\nFirst define attempt = minutesToTest/MinutesToDie\\nAs all other post says, with x pigs, you could test up to (attempt+1)^x buckets. But why?\\n\\nFirst define base = (attempt+1), it is the base of encoding, and we label buckets from 0~N-1\\n\\nLet\\'s see example of attempt=1 so base = 2, meaning to use binary encoding to represent bucket j, we let pig i to drink bucket j if j\\'s i bit is 1 (For instance pig 1 drink bucket 1/3/5/7 ...)\\nIf the pig dies, we know the poionous bucket has 1 in j\\'s bit and o otherwise. View all pigs death, we then know for each position whether it should be 1 or 0. Thus with x pigs, we could encode and predict x^2 buckets\\n\\nAs an example, consider 3 pigs\\nbucket 0: 000\\nbucket 1: 001\\nbucket 2: 010\\nbucket 3: 011\\nbucket 4: 100\\nbucket 5: 101\\nbucket 6: 110\\nbucket 7: 111\\nPig 1 drinks bucket 1 3 5 7\\nPig 2 drinks bucket 2 3 6 7\\nPig 3 drinks bucket 4 5 6 7\\nIf pig 1 die we know bucket has 1 in first bit 0 otherwise\\nIf pig 2 die we know bucket has 1 in second bit 0 otherwise\\nIf pig 3 die we know bucket has 1 in third bit 0 otherwise\\n\\n\\n\\nSimilarily, let attempt =x-1 and base = x, we use x base encoding to represent bucket j, and let pig i to drink bucket j at attempt k if bucket j\\'s i bit is k, if pig dies, then we know the bucket\\'s i bit has a value of k. \\n"
                    },
                    {
                        "username": "nomanlike",
                        "content": "This is the best one to describe it. He is right tho. Thank you, for enlightening the path"
                    },
                    {
                        "username": "user4347YC",
                        "content": "Let\\'s assume we have N buckets (B1, B2, ..., Bn) and M rounds (R1, R2, ..., Rm).\\n\\nA bucket can be assigned to any or all or none of the pigs in any round. In otherwords, a pig can never consume from a bucket or can consume from a bucket in any round. For example, a pig can consume from bucket 1 in round 1 or 2 or ... m, or can never consume from the bucket.\\n\\nThis means, for each pig there are M+1 options to consume from a bucket (M rounds + 1 for never consuming from the bucket). If there are X pigs, then we have (M+1) * (M+1) * (M+1) .... X times = ((M+1) ^ X) unique ways we can feed the pigs. This tells gives us the poisonous bucket. \\n\\nLet us understand the above explanation with an example:\\n\\nNo of Buckets: 8\\nNo of Rounds: 2\\nNo of Pigs = X\\n\\n// I am assuming 3 pigs as I am not aware of the answer yet\\nB1: { P1: Never, P2: Never, P3: Never} // Ans is B1 if no pig gets killed\\nB2: { P1: R1, P2: Never, P3: Never} // Ans is B2 if P1 gets killed after round 1\\nB3: {P1: Never, P2: R1, P3: Never} // Ans is B3 if P2 gets killed after round 1\\nB4: {P1: Never, P2: Never, P3: R1}\\nB5: {P1: R1, P2: R1, P3: Never}\\nB6: {P1: R1, P2: Never, P3: R1} // Ans is B6 if P1 & P3 gets killed after round 1\\nB7: {P1: Never, P2: R1, P3: R1}\\nB8: {P1: R1, P2: R1, P3: R1} // Ans is B8 if all pigs get killed after round 1\\n\\nWe can stop here as we have only 8 buckets, but we can make more such combinations using like {P1: R2, P2: Never, P3: Never}. We have in total (2 + 1)^3 = 27 variations. This is not necessary. Since we need the minimum no of pigs, the number of variations should be equal to or slightly higher than the number of buckets. We can achieve the above mentioned problem with 2 pigs (2+1)^2 = 9 >= 8 buckets.\\n\\n"
                    },
                    {
                        "username": "mathuzasif",
                        "content": "Suppose we have d = timeToTest// timeToDie number of trials and b number of buckets. For any given pig, there are (d+1) things that can happen to it: it can die on 1st, 2nd..... dth trial or not die at all. If there are p pigs, we have (d+1)^p different scenarios and we can assign a bucket to each of them. So if b<= (d+1)^p , we can determine with p pigs. Hence the answer is int(math.log(b-1,d+1))+1 \\n\\n"
                    },
                    {
                        "username": "czhangaegean",
                        "content": "I do not quite understand the question description"
                    },
                    {
                        "username": "10811130d",
                        "content": "Consider d trial as representing a (d+1) -th decimal representation of bucket number\\nd = 1 represents a binary number. \\nIn the binary case, suppose we have 8 buckets. 1~8 in binary representation composed of 3 digits. 1 pigs with 1 trial can try out 1 binary digits by consuming all the buckets with that digits. \\nFor example, assume 011 is the poisonous one\\npig1 tries out all 0xx buckets and dies - we know first digit is 0\\npig2 tries out all x0x buckets and doesn\\'t die- we know second digit is 1\\npig3 tries out all xx0 buckets and doesn\\'t die - we  know third digit is 1\\n\\nSimilarly, suppose d=3 and we use a 4-decimal representation of bucket and we have 64 buckets and the poisonous one is 332 in 4 decimal - representation. \\npig1 tries out all 0~3xx and dies at 3rd trial - we know the first number is 3\\npig2 tries out all x0~3x and dies at 3rd trial - we know the second number is 3\\npig3 tries out all xx0~2 and dies at 2nd trial - we know the third number is 2. \\n\\nThat\\'s how the actual strategy works.\\n"
                    },
                    {
                        "username": "haozheng1985",
                        "content": "I will only explain the 1000-15-60 case, and it is very easy to generalize it.\\n\\nUsing quinary( base-5 numeral system) to label the 1000 buckets from 0 to 12444. Notice 5 digits are needed to represent 1000 buckets, which means 5 pigs are needed. Here is why:\\n\\nLet pig i (i=1,2,3,4,5) drink all buckets whose ith digit is 1 at 0 minute, drink all buckets whose ith digit is 2 at 15 minute if still alive, drink all buckets whose ith digit is 3 at 30 minutes if still alive, and drink all buckets whose ith digit is 4 at 45 minute if still alive. (Notice pig i does not drink a bucket if its ith digit is 0). After one hour, if pig i is still alive then the poison bucket's ith digit is 0, otherwise its ith digit is the time period pig i is dead. \\n\\nFor example, after one hour, if pig 1 is dead in 15 minute, pig 2 is dead in 15 minute, pig 3 is alive, pig 4 is dead in 30 minute, and pig 5 is dead in 60 minute. Then the poison bucket number is 11024 in quinary.\\n\\nSo in general, convert n-1 to base--int(p/m)+1 system, and the number of digits is the answer(which mathematically can be computed by log)"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Nice insight. Many, including the official, solutions doesn\\'t mention how to actually plan the feeding (encoding) and decide which bucket is poisonous (decoding). I think LeetCode can add this encoding/decoding as \"Poor Pigs II\"."
                    },
                    {
                        "username": "tier10coder",
                        "content": "Why is there a need to kill the innocent animal?"
                    }
                ]
            },
            {
                "id": 1570232,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1572544,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1569235,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1571730,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1567555,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 2006498,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1700911,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1572452,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1572417,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            },
            {
                "id": 1572117,
                "content": [
                    {
                        "username": "aurangzeb40",
                        "content": "the question must sys don\\'t count the pigs who die in the process of testing"
                    },
                    {
                        "username": "rasfivtay",
                        "content": "wrong testcase in checker or I don\\'t catch the task\\n15 - minutes to die\\n15 - minutes test duration\\n4 - num of buckets \\nAnd it sad correct answer is 2.\\n\\nCould anybody explain why 2 not 3? We have only 1 attemp. So we need at least num of buckets - 1 pig.\\n\\nUpd. \\nAnd even on example test case. Whow you are going to do this with 5 pigs;\\nStep1: each of 5 pigs gets 1000/6 ~ 167 buckets\\nstep2: each of 4 left pigs get 167 / 5 ~ 34 bukets\\nstep 3: each of 3 left pigs get 34 / 4 ~ 9 buckets\\nstep 4: you have 2 pigs and 9 buckets."
                    },
                    {
                        "username": "Alanwhaaaaat",
                        "content": "Since it asks us to find the the minimum amount of pigs we need to figure out which bucket contains the poison within one hour, if the first bucket contains poison, my pig drink and dead  then I\\'m done. So 1 is the minimum amount......is that correct??"
                    },
                    {
                        "username": "inferee",
                        "content": "I believe that the run code is incorrect for 4, 1, 2 (buckets, minutes to die, minutes to test respectively) and perhaps others as well.\\n\\nSuppose that we are trying to find the bucket containing poison out of four with two \"attempts\". Obviously we will have to check at least three of the four buckets to determine which one has poison, so for at least one \"attempt\" we will have to check two buckets at once with the single pig. However, if the pig dies we have no way to figure out which bucket actually contained poison and which contained water.\\n\\nI think the answer should be the smallest n such that pow(2,n)>(buckets-1)/(minutesToTest/minutesToDie).\\nIn the case listed above the answer would be 2.\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "subfallen",
                        "content": "Say there are `k` drinking rounds. Fix a bucket `b`. For each pig `i`, assign it to drink from `b` in the round `b[i]` where `b[i] \\u2208 { 0, 1, 2, ... k }`; and `b[i] = 0` means that pig `i` never drinks from bucket `b`.\\n\\nSuppose we have `x` pigs. Again for bucket `b`, consider its set `S[b]` of assignments for all `x` pigs; that is, `S[b] = { b[1], b[2], ..., b[x] }`. \\n\\nFor each bucket `b`, this set has cardinality `|S[b]| = (k + 1)^x`. \\n\\nNow if the `S[b]` sets are unique across all `n` buckets, then the poison bucket is the unique bucket for which all assigned pigs die **in the round which they were assigned the bucket**. (Or if no pigs die, the unique bucket for which `S[b] = { 0, 0, ..., 0 }`.) So we must choose `x` large enough for the `S[b]` to be unique across all `n` buckets; that is, we must have `|S[b]| = (k + 1)^x \\u2265 n`, which is true iff `x \\u2265 log(n) / log(k + 1)`."
                    },
                    {
                        "username": "adityajangir71",
                        "content": "Leetcode is a mean \\uD83D\\uDC3D\\nAnd I will choose poisonous bucket for leetcode! "
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "I\\'m an animal lover and for that reason I\\'m out."
                    },
                    {
                        "username": "sipubot",
                        "content": "i\\'m poor in english but this quiz is very bad . \\n\\n1min 1min test pig \\nhad one minitue\\n\\nwe check two bucket die or no die\\n\\n"
                    },
                    {
                        "username": "McSqueezerBallz",
                        "content": "I am not understanding some of the solutions posted here or their explanations. If a pig that consumes poison dies within some amount of time, m, wouldn\\'t allowing it along with any other amount of pigs to continue drinking from other buckets before the pig dies, prevent determination of which bucket exactly contained poison? The question, I assumed, required considering how many trials of the form \"pig consumes water; observer waits up to amount of time pig could be subject to death due to consumption of poison; designate pig to next bucket if it is still alive\". If pigs are drinking from multiple buckets within the time they could be subject to death, how is it that the bucket that contained the poison could be determine exactly? I was initially conceiving of the problem as taking the total amount of time given and maximize trials that can be completed within total time based on the time range a pig could die in if it consumes poison. Then divide buckets by this amount of trials: 1000 buckets, up to 15 minutes to death due to poison consumption and 60 total minutes to test within -> 4 total trials so designate 250 pigs to first 250 buckets. If no pig dies within 15 minutes, the next 250 buckets can be tested. This process repeats until a subset of the set of buckets is found to have killed a pig specifically the bucket which has the dead pig in front of it, assuming the pigs are restrained to the buckets they drink from. Otherwise, how is the exact bucket determined?"
                    },
                    {
                        "username": "jianguoyuan8912",
                        "content": "Let\\'s first look at a simpler question: If there is only 1 round, how many pigs is needed to find out which bucket is poisonous?\\nThe answer is pretty intuitive. Turn each bucket number into base2. For example, bucket 1000 is 1,111,101,000, which means we need at least 10 pigs to find it if we can only test for 1 round. (2**10=1024>1000)\\n\\nThe reason to turn the bucket number into base2 is in 1 round, 1 pig is only able to diffientiate 2 buckets. If there is time for 4 rounds, 1 pig is able to diffentiate 5 buckets. So the problem is similar--solve 5**x>1000."
                    }
                ]
            }
        ]
    }
]