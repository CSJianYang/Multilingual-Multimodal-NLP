[
    {
        "title": "Jump Game",
        "question_content": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t0 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 20917,
                "title": "linear-and-simple-solution-in-c",
                "content": "I just iterate and update the maximal index that I can reach\\n\\n    bool canJump(int A[], int n) {\\n        int i = 0;\\n        for (int reach = 0; i < n && i <= reach; ++i)\\n            reach = max(i + A[i], reach);\\n        return i == n;\\n    }",
                "solutionTags": [],
                "code": "I just iterate and update the maximal index that I can reach\\n\\n    bool canJump(int A[], int n) {\\n        int i = 0;\\n        for (int reach = 0; i < n && i <= reach; ++i)\\n            reach = max(i + A[i], reach);\\n        return i == n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20900,
                "title": "simplest-o-n-solution-with-constant-space",
                "content": "Idea is to work backwards from the last index. Keep track of the smallest index that can \"jump\" to the last index. Check whether the current index can jump to this smallest index.\\n\\n    bool canJump(int A[], int n) {\\n        int last=n-1,i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(i+A[i]>=last)last=i;\\n        }\\n        return last<=0;\\n    }",
                "solutionTags": [],
                "code": "Idea is to work backwards from the last index. Keep track of the smallest index that can \"jump\" to the last index. Check whether the current index can jump to this smallest index.\\n\\n    bool canJump(int A[], int n) {\\n        int last=n-1,i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(i+A[i]>=last)last=i;\\n        }\\n        return last<=0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20907,
                "title": "1-6-lines-o-n-time-o-1-space",
                "content": "**Solution 1**\\n\\nGoing forwards. `m` tells the maximum index we can reach so far.\\n\\n    def canJump(self, nums):\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if i > m:\\n                return False\\n            m = max(m, i+n)\\n        return True\\n\\n**Solution 2**\\n\\nOne-liner version:\\n\\n    def canJump(self, nums):\\n        return reduce(lambda m, (i, n): max(m, i+n) * (i <= m), enumerate(nums, 1), 1) > 0\\n\\n**Solution 3**\\n\\nGoing backwards, most people seem to do that, here's my version.\\n\\n    def canJump(self, nums):\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]:\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n\\n**Solution 4**\\n\\nC version.\\n\\n    bool canJump(int* nums, int n) {\\n        int goal=n-1, i;\\n        for (i=n; i--;)\\n            if (i+nums[i] >= goal)\\n                goal=i;\\n        return !goal;\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1**\\n\\nGoing forwards. `m` tells the maximum index we can reach so far.\\n\\n    def canJump(self, nums):\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if i > m:\\n                return False\\n            m = max(m, i+n)\\n        return True\\n\\n**Solution 2**\\n\\nOne-liner version:\\n\\n    def canJump(self, nums):\\n        return reduce(lambda m, (i, n): max(m, i+n) * (i <= m), enumerate(nums, 1), 1) > 0\\n\\n**Solution 3**\\n\\nGoing backwards, most people seem to do that, here's my version.\\n\\n    def canJump(self, nums):\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]:\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n\\n**Solution 4**\\n\\nC version.\\n\\n    bool canJump(int* nums, int n) {\\n        int goal=n-1, i;\\n        for (i=n; i--;)\\n            if (i+nums[i] >= goal)\\n                goal=i;\\n        return !goal;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 596454,
                "title": "python-simple-solution-with-thinking-process-runtime-o-n",
                "content": "When I first see this problem, two things pop up in my mind:\\n* Maybe I can do some sort of DFS, BFS (with backtracking?) but there will be a lot of redundancies\\n* Then this begs for Dynamic Programming!\\n\\nBut my gut feeling was saying that this problem has to have a simpler approach.\\n\\nSo, here is my thinking process:\\n* Base case: last index can trivially reach to last index.\\n* **Q1**: How can I reach to the last index (I will call it `last_position`) from a preceding index?\\n\\t* If I have a preceding index `idx` in `nums` which has jump count `jump` which satisfies `idx+jump >= last_position`, I know that this `idx` is good enough to be treated as the last index because all I need to do now is to get to that `idx`. I am going to treat this new `idx` as a new `last_position`.\\n* I ask **Q1** again.\\n\\nSo now, here are two important things:\\n* If we have indices which are like **sinkholes**, those with 0 as jump and every other preceding index can only jump to that sinkhole, our `last_position` will not be updated anymore because `idx+jump >= last_position` will not be satisfied at that sinkhole and every other preceding index cannot satisfy the `idx+jump >= last_position` condition since their jumps are not big enough.\\nE.g. ```nums=[3,2,1,0,4] # Here 0 is a sinkhole becuase all preceding indices can only jump to the sinkhole```\\n* If we have **barriers**, those indices with 0 as jump, but the preceding indices contain jumps which can go beyond those barriers, `idx+jump >= last_position` will be satisfied and `last_position` will be updated.\\nE.g. ```nums=[3,2,2,0,4] # Here 0 is just a barrier since the index before that 0 can jump *over* that barrier```\\n\\nFinally ask this question when we have finished looping\\n* Is the last position index of 0? (i.e, have we reached to the beginning while doing the process of jumping and updating the `last_position`?)\\n* If we have sinkholes in `nums`, our `last_position` will not be 0. Thus, `False` will be retured.\\n\\nThat\\'s all!\\n\\nThis is what I have in mind when I was thinking of this approach :D\\n![image](https://assets.leetcode.com/users/arkaung/image_1587809403.png)\\n\\n## Python\\n``` python\\n1. class Solution:\\n2.    def canJump(self, nums: List[int]) -> bool:\\n3.        last_position = len(nums)-1\\n4.        \\n5.        for i in range(len(nums)-2,-1,-1): # Iterate backwards from second to last item until the first item\\n6.            if (i + nums[i]) >= last_position: # If this index has jump count which can reach to or beyond the last position\\n7.                last_position = i # Since we just need to reach to this new index\\n8.        return last_position == 0\\t\\n```\\n\\nBut in the interview, this approach may not be apparent or maybe the interviewer is looking for something. \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums=[3,2,1,0,4] # Here 0 is a sinkhole becuase all preceding indices can only jump to the sinkhole```\n```nums=[3,2,2,0,4] # Here 0 is just a barrier since the index before that 0 can jump *over* that barrier```\n``` python\\n1. class Solution:\\n2.    def canJump(self, nums: List[int]) -> bool:\\n3.        last_position = len(nums)-1\\n4.        \\n5.        for i in range(len(nums)-2,-1,-1): # Iterate backwards from second to last item until the first item\\n6.            if (i + nums[i]) >= last_position: # If this index has jump count which can reach to or beyond the last position\\n7.                last_position = i # Since we just need to reach to this new index\\n8.        return last_position == 0\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20932,
                "title": "6-line-java-solution-in-o-n",
                "content": "The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n    public boolean canJump(int[] nums) {\\n        int reachable = 0;\\n        for (int i=0; i<nums.length; ++i) {\\n            if (i > reachable) return false;\\n            reachable = Math.max(reachable, i + nums[i]);\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n    public boolean canJump(int[] nums) {\\n        int reachable = 0;\\n        for (int i=0; i<nums.length; ++i) {\\n            if (i > reachable) return false;\\n            reachable = Math.max(reachable, i + nums[i]);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 520481,
                "title": "c-easy-o-n-solution-with-detailed-explanation",
                "content": "The idea is to iterate backwards, i.e., right to left, and keep track of the minimum jump length required, i.e., `minjump`, at a position. \\n\\nFor the last index, the minimum jump length required would be zero because you have reached the last index. For each index or position that we go backwards(since we are iterating right to left), the minimum jump length required increases by 1. \\n\\nWe start from the second last index and increase `minjump` by 1 for each position. If at a particular index, the maximum jump length at that position is greater than or equal to the minimum jump length required, i.e., `nums[i]>=minjump`, then we can say that we can reach the last index from that position. Thus, we reduce the minimum jump length required to zero if the condition is satisfied so that for the next position when iterating backwards the minimum jump length required is 1 after incrementation. \\n\\nOur objective now is to check if the minimum jump length required, i.e., value of `minjump`, after iterating through the entire array is zero which would indicate that the last index can be reached from the first index of the array. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i, minjump = 0;\\n        for(i = nums.size()-2; i >= 0; i--){\\n            minjump++;\\n            if(nums[i] >= minjump)\\n\\t\\t\\t    minjump = 0;\\n        }\\n        if(minjump == 0) \\n\\t\\t    return true;\\n        else \\n\\t\\t    return false;\\n    }\\n};\\n```\\n\\n#### Complexity Analysis\\n\\n* Time complexity : O(n).   \\nWe are iterating through the *nums* array only once. The length of *nums* array is *n*. Thus, time complexity = *O(n)*.\\n\\n* Space complexity : O(1). \\nWe are not using any extra memory. Thus, space complexity = *O(1).",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i, minjump = 0;\\n        for(i = nums.size()-2; i >= 0; i--){\\n            minjump++;\\n            if(nums[i] >= minjump)\\n\\t\\t\\t    minjump = 0;\\n        }\\n        if(minjump == 0) \\n\\t\\t    return true;\\n        else \\n\\t\\t    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375320,
                "title": "interview-scenario-recursion-memoization-dp-greedy",
                "content": "Suppose you get this question during an interview, let\\'s do a walk-through.\\nInterviewer : Quotes the question...\\n\\n***let\\'s get started***\\nAsk clarifying questions,  examples, and scenarios. The more you ask, interviewer gets more and more intrigued, for good.\\n\\numm, at every index starting from the 0th, you can make jumps ranging from 1 till nums[index]. Greedily making a choice of jump won\\'t work in subtle cases, for example, if from 0th index I take a jump to the index with maximum jump value, it might lead me to a postion with value of jumps equal to 0, and I\\'ll be stuck.\\nAs I\\'ve got a lot of options to make a jump, I\\'d love to the explore the recurring idea behind this question(i.e. I can make a jump ranging from index(idx) to postions ranging from : (idx + 1 *till* idx + nums[idx]), and the same thing can be done from all these indexes. \\nIf by following any route I reach last index, I\\'ll return true. Otherwise if none of the index can lead me to last index, I\\'ll return a false. \\n\\nWhile solving the problem, think out loud and let the interviewer know what you are thinking.\\nrecursion approach : \\ntc : O(N^N) ~ exponential\\nsc : O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        return create(nums, 0); \\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx) {\\n        if(idx == nums.size() -1) return true;  //if I reach the last index, I should return true;\\n        if(nums[idx] == 0) return false; //if at any  point I reach an index with jump value = 0\\n\\t\\t//,I\\'ll get stuck and hence will return a false.\\n        \\n        int reach = idx + nums[idx]; //the max jump that I can make\\n\\t\\t//I can make jumps ranging from idx + 1, till reach, and hence will run a loop\\n\\t\\t//to cover all those possbile jumps\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n\\t\\t//if true, it means taking this jump led me to the last index.\\n            if(jump < nums.size() && create(nums, jump)) \\n                return  true; \\n        }\\n\\t\\t\\t\\n\\t\\t//if I reach  here,  it means none of the jumps led  me to the  last index \\n\\t\\t//and hence returning, false.\\n        return  false;\\n    }\\n};\\n```\\n\\nThere\\'s no chance that this question will not give a T.L.E,  it\\'s exponential,  it\\'ll have many overlapping subproblems, and hence I can memoize it using a 1d dp array.\\n\\nmemoized : \\ntc : O(N* N) -> for each  index, I can have at max N jumps, hence O(N* N).\\nsc : O(N) + O(N) -> stack space plus dp array size.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return create(nums, 0, dp);\\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx, vector<int>& dp) {\\n        if(idx == nums.size() -1) return true;\\n        if(nums[idx] == 0) return false;\\n        \\n        if(dp[idx] != -1) return dp[idx]; //overlapping subproblems\\n        int reach = idx + nums[idx];\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n            if(jump < nums.size() && create(nums, jump, dp)) \\n                return dp[idx] = true; //memoizing for particular index.\\n        }\\n        \\n        return dp[idx] = false; //memoizing for particular index.\\n    }\\n};\\n```\\n\\n*I\\'m not a huge fan of that extra stack space, let me just convert this whole soution into a dp(tabulation)  solution, so that extra O(N) space can be chucked  out.*\\n\\ntc : O(N* N)\\nsc : O(N) -> dp array size\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[n-1] = 1; //base case;\\n        \\n        for(int idx = n-2; idx >= 0; idx--) {\\n            if(nums[idx] == 0) {\\n                dp[idx] = false;\\n                continue;   \\n            }\\n            \\n            int flag = 0;\\n            int reach = idx + nums[idx];\\n            for(int jump=idx + 1; jump <= reach; jump++) {\\n                if(jump < nums.size() && dp[jump]) {\\n                    dp[idx] = true;\\n                    flag = 1;  \\n                    break;\\n                }\\n            }\\n            if(flag == 1) \\n                continue;\\n           \\n            dp[idx] = false;\\n\\t\\t\\t\\n        }\\n        return dp[0]; \\n    }\\n\\n};\\n```\\n\\n\\n**Bonus**, I can also think of a solution that kinda resembles Kadane\\'s algorithm. For every index, I\\'m checking the max reach  I can have till that element, if that reach is less than the value of my index, that means I can never reach this particular index and my  answer should be false. \\n\\ntc : O(N)\\nsc : O(1)\\n\\nThe comments that I\\'ve made show my entire thought process that I\\'d be delivering to the interviewer.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        //it shows at max what index can I reach.\\n        //initially I can only reach index 0, hence reach = 0\\n        int reach = 0; \\n    \\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            //at every index I\\'ll check if my reach was atleast able to \\n            //reach that particular index.\\n            \\n            //reach >= idx -> great, carry on. Otherwise, \\n            if(reach < idx) return false;\\n            \\n            //now as you can reach this index, it\\'s time to update your reach\\n            //as at every index, you\\'re getting a new jump length.\\n            reach = max(reach, idx + nums[idx]);\\n        }\\n        \\n        //this means that you reached till the end of the array, wohooo!! \\n        return true;\\n        \\n    }\\n};\\n```\\n\\n\\nThank you, if you enjoyed this approach of writing soutions do give me an upvote, and please feel free to add suggestions. Viva - La - Vida.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        return create(nums, 0); \\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx) {\\n        if(idx == nums.size() -1) return true;  //if I reach the last index, I should return true;\\n        if(nums[idx] == 0) return false; //if at any  point I reach an index with jump value = 0\\n\\t\\t//,I\\'ll get stuck and hence will return a false.\\n        \\n        int reach = idx + nums[idx]; //the max jump that I can make\\n\\t\\t//I can make jumps ranging from idx + 1, till reach, and hence will run a loop\\n\\t\\t//to cover all those possbile jumps\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n\\t\\t//if true, it means taking this jump led me to the last index.\\n            if(jump < nums.size() && create(nums, jump)) \\n                return  true; \\n        }\\n\\t\\t\\t\\n\\t\\t//if I reach  here,  it means none of the jumps led  me to the  last index \\n\\t\\t//and hence returning, false.\\n        return  false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return create(nums, 0, dp);\\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx, vector<int>& dp) {\\n        if(idx == nums.size() -1) return true;\\n        if(nums[idx] == 0) return false;\\n        \\n        if(dp[idx] != -1) return dp[idx]; //overlapping subproblems\\n        int reach = idx + nums[idx];\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n            if(jump < nums.size() && create(nums, jump, dp)) \\n                return dp[idx] = true; //memoizing for particular index.\\n        }\\n        \\n        return dp[idx] = false; //memoizing for particular index.\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[n-1] = 1; //base case;\\n        \\n        for(int idx = n-2; idx >= 0; idx--) {\\n            if(nums[idx] == 0) {\\n                dp[idx] = false;\\n                continue;   \\n            }\\n            \\n            int flag = 0;\\n            int reach = idx + nums[idx];\\n            for(int jump=idx + 1; jump <= reach; jump++) {\\n                if(jump < nums.size() && dp[jump]) {\\n                    dp[idx] = true;\\n                    flag = 1;  \\n                    break;\\n                }\\n            }\\n            if(flag == 1) \\n                continue;\\n           \\n            dp[idx] = false;\\n\\t\\t\\t\\n        }\\n        return dp[0]; \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        //it shows at max what index can I reach.\\n        //initially I can only reach index 0, hence reach = 0\\n        int reach = 0; \\n    \\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            //at every index I\\'ll check if my reach was atleast able to \\n            //reach that particular index.\\n            \\n            //reach >= idx -> great, carry on. Otherwise, \\n            if(reach < idx) return false;\\n            \\n            //now as you can reach this index, it\\'s time to update your reach\\n            //as at every index, you\\'re getting a new jump length.\\n            reach = max(reach, idx + nums[idx]);\\n        }\\n        \\n        //this means that you reached till the end of the array, wohooo!! \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20923,
                "title": "java-solution-easy-to-understand",
                "content": "    public boolean canJump(int[] A) {\\n        int max = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(i>max) {return false;}\\n            max = Math.max(A[i]+i,max);\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    public boolean canJump(int[] A) {\\n        int max = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(i>max) {return false;}\\n            max = Math.max(A[i]+i,max);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3758301,
                "title": "java-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int reachable = 0;\\n       for(int i = 0; i < nums.length; i ++) {\\n           if(i > reachable) return false;\\n           reachable = Math.max(reachable, i + nums[i]);\\n       } \\n       return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int reachable = 0;\\n       for(int i = 0; i < nums.length; i ++) {\\n           if(i > reachable) return false;\\n           reachable = Math.max(reachable, i + nums[i]);\\n       } \\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150021,
                "title": "c-solutions-greedy-recursive-dp",
                "content": "1. Linear\\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int reachable=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>reachable) return false;\\n            reachable=max(reachable,i+nums[i]);\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n\\n2. Recursive\\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n              return solve(0,nums); \\n    }\\n    bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n                  if(solve(k,nums)){\\n                return true;\\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```\\n3. Recursive+Memoization\\n```\\nclass Solution {\\n    vector<int> memo;\\n     public:\\n     bool canJump(vector<int>& nums) {\\n          memo.assign(nums.size(),-1);\\n          return solve(0,nums);   \\n     }\\n     bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        if(memo[i]!=-1) return memo[i];\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n             if(solve(k,nums)){\\n                return memo[i]=true;\\n             } \\n        }\\n        return memo[i]=false;\\n    }\\n};\\n```\\n4. DP (Updated)\\n```\\nclass Solution {\\n    vector<int> memo;\\n    public:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=true;\\n        \\n        for(int i=1;i<n;i++){\\n             for(int j=i-1;j>=0;j--){\\n                 if(dp[j] && j+nums[j]>=i){\\n                     dp[i]=true;\\n                     break;\\n                 }       \\n             }           \\n        }\\n        return dp[n-1];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int reachable=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>reachable) return false;\\n            reachable=max(reachable,i+nums[i]);\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n              return solve(0,nums); \\n    }\\n    bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n                  if(solve(k,nums)){\\n                return true;\\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> memo;\\n     public:\\n     bool canJump(vector<int>& nums) {\\n          memo.assign(nums.size(),-1);\\n          return solve(0,nums);   \\n     }\\n     bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        if(memo[i]!=-1) return memo[i];\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n             if(solve(k,nums)){\\n                return memo[i]=true;\\n             } \\n        }\\n        return memo[i]=false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> memo;\\n    public:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=true;\\n        \\n        for(int i=1;i<n;i++){\\n             for(int j=i-1;j>=0;j--){\\n                 if(dp[j] && j+nums[j]>=i){\\n                     dp[i]=true;\\n                     break;\\n                 }       \\n             }           \\n        }\\n        return dp[n-1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21121,
                "title": "c-elegant-solution-o-n-time",
                "content": "    bool canJump(vector<int>& nums) {\\n        int size=nums.size();\\n        int step=nums[0];\\n        for(int i=1;i<size;++i){\\n            step--;\\n            if(step<0)\\n               return false;\\n            if(nums[i]>step)\\n               step=nums[i];\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    bool canJump(vector<int>& nums) {\\n        int size=nums.size();\\n        int step=nums[0];\\n        for(int i=1;i<size;++i){\\n            step--;\\n            if(step<0)\\n               return false;\\n            if(nums[i]>step)\\n               step=nums[i];\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1443541,
                "title": "python-3-approaches-top-down-dp-bottom-up-dp-max-pos-so-far-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP (Sometime TLE)**\\n- Let `dp(i)` denote the possibility if we can reach the `last index` if we are at index `i`.\\n- Then `dp(0)` is our result.\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1:\\n                return True\\n            \\n            for j in range(i+1, min(i+nums[i], n-1) + 1):\\n                if dp(j):\\n                    return True\\n            return False\\n        \\n        return dp(0)\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top down DP**\\n- Let `dp[i]` denote the possibility if we can reach the `last index` if we are at index `i`.\\n- Then `dp[0]` is our result.\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * n\\n        dp[n-1] = True\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+1, min(n, i+nums[i]+1)):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Max Pos So Far**\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        maxPos = 0\\n        i = 0\\n        while i <= maxPos:\\n            maxPos = max(maxPos, i + nums[i])\\n            if maxPos >= n - 1: return True\\n            i += 1\\n        \\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1:\\n                return True\\n            \\n            for j in range(i+1, min(i+nums[i], n-1) + 1):\\n                if dp(j):\\n                    return True\\n            return False\\n        \\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * n\\n        dp[n-1] = True\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+1, min(n, i+nums[i]+1)):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        maxPos = 0\\n        i = 0\\n        while i <= maxPos:\\n            maxPos = max(maxPos, i + nums[i])\\n            if maxPos >= n - 1: return True\\n            i += 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336291,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        // Take curr variable to keep the current maximum jump...\\n        int curr = 0;\\n        // Traverse all the elements through loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            // It means there is no way to jump to current index...\\n            // so we should return false...\\n            if (i > curr) {\\n                return false;\\n            }\\n            // Update the current maximum jump...\\n            curr = Math.max(curr, i + nums[i]);     // It\\u2019s possible to reach the end of the array...\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int idx = 0;\\n        //check what is the maximum index we can reach from that index...\\n        for (int maximum = 0; idx < nums.size() && idx <= maximum; ++idx)\\n            maximum = max(idx + nums[idx], maximum);       //if the maximum index reached is the last index of the array...\\n        return idx == nums.size();\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\\n\\n# **JavaScript Solution:**\\n```\\nvar canJump = function(nums) {\\n    // Base condition...\\n    if(nums.length <= 1)\\n        return true;\\n    // To keep the maximum index that can be reached...\\n    let maximum = nums[0];\\n    // Traverse all the elements through loop...\\n    for(let i = 0; i < nums.length; i++){\\n        //if there is no way to jump to next...\\n        // so we should return false...\\n        if(maximum <= i && nums[i] == 0) \\n            return false;\\n        //update the maximum jump...    \\n        if(i + nums[i] > maximum){\\n            maximum = i + nums[i];\\n        }\\n        //maximum is enough to reach the end...\\n        if(maximum >= nums.length-1) \\n            return true;\\n    }\\n    return false;   \\n};\\n```\\n\\n# **C Language:**\\n```\\nbool canJump(int* nums, int numsSize){\\n    int jump = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (jump < i) {\\n            break;\\n        }\\n        if (jump < i + nums[i]) {\\n            jump = i + nums[i];\\n        }\\n        if (jump >= numsSize - 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        // Take curr variable to keep the current maximum jump...\\n        int curr = 0;\\n        // Traverse all the elements through loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            // It means there is no way to jump to current index...\\n            // so we should return false...\\n            if (i > curr) {\\n                return false;\\n            }\\n            // Update the current maximum jump...\\n            curr = Math.max(curr, i + nums[i]);     // It\\u2019s possible to reach the end of the array...\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int idx = 0;\\n        //check what is the maximum index we can reach from that index...\\n        for (int maximum = 0; idx < nums.size() && idx <= maximum; ++idx)\\n            maximum = max(idx + nums[idx], maximum);       //if the maximum index reached is the last index of the array...\\n        return idx == nums.size();\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\n```\\nvar canJump = function(nums) {\\n    // Base condition...\\n    if(nums.length <= 1)\\n        return true;\\n    // To keep the maximum index that can be reached...\\n    let maximum = nums[0];\\n    // Traverse all the elements through loop...\\n    for(let i = 0; i < nums.length; i++){\\n        //if there is no way to jump to next...\\n        // so we should return false...\\n        if(maximum <= i && nums[i] == 0) \\n            return false;\\n        //update the maximum jump...    \\n        if(i + nums[i] > maximum){\\n            maximum = i + nums[i];\\n        }\\n        //maximum is enough to reach the end...\\n        if(maximum >= nums.length-1) \\n            return true;\\n    }\\n    return false;   \\n};\\n```\n```\\nbool canJump(int* nums, int numsSize){\\n    int jump = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (jump < i) {\\n            break;\\n        }\\n        if (jump < i + nums[i]) {\\n            jump = i + nums[i];\\n        }\\n        if (jump >= numsSize - 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273641,
                "title": "javascript-simple-o-n-greedy-solution",
                "content": "**Explaination**\\n\\nIt\\'s a typical problem that can be solved by ***Greedy*** algorithm, which is an algorithm **makes the optimal choice at each step** as going forward.\\n\\nYou will need to iterate over the `nums` starting from 0 to the last, and **keep updating** `max` to record how far you can jump so far.\\n` max = Math.max(max, idx + nums[idx]);`\\nAnd check if the `max` is greater or equal to the `target` at each step.\\n\\nThat\\'s pretty much it!\\n\\nBut we still can add a bit of **optimization** by checking an early exit condition when there is no way to move forward. \\nIf a current value is 0, you cannot jump to the next. But there might be a way to jump farther from the previous step. How can we check that? `max` again!\\n`max > idx` then we can conclude we can go further from the previous step. Otherwise, it\\'s impossible.\\n\\nSo the early exit condition is \\n`if (max <= idx && nums[idx] === 0) { return false; }`\\n\\n\\n**Code**\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n  let idx = 0;\\n  let max = 0;\\n  let target = nums.length - 1;\\n\\n  while(idx < nums.length) {\\n    max = Math.max(max, idx + nums[idx]);\\n    \\n    if (max >= target) {\\n      return true;\\n    }\\n    \\n    if (max <= idx && nums[idx] === 0) {\\n      return false;\\n    }\\n    \\n    idx++;\\n  }\\n  \\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n  let idx = 0;\\n  let max = 0;\\n  let target = nums.length - 1;\\n\\n  while(idx < nums.length) {\\n    max = Math.max(max, idx + nums[idx]);\\n    \\n    if (max >= target) {\\n      return true;\\n    }\\n    \\n    if (max <= idx && nums[idx] === 0) {\\n      return false;\\n    }\\n    \\n    idx++;\\n  }\\n  \\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452807,
                "title": "python-dp-o-n-with-explanation",
                "content": "- DP definition: The farthest index we can reach given allowed steps from 0 to `i`\\n- DP decision & relationship: It\\'s either the `dp[i - 1]` or `i + nums[i]` whichever one is larger\\n- DP condition:\\n\\t- If at any moment, dp[i] = 0, that means there is no way it can reach any further, return `False` immediately.\\n\\t- If at any moment, dp[i] >= last index, that means it can already reach the end of the array given the steps allowed from 0 to `i`, return `True` immediately.\\n\\n\\n```Python\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        length = len(nums)\\n        dp = [0] * length\\n        \\n        dp[0] = nums[0]\\n        \\n        for i in range(1, length - 1):\\n            \\n            if dp[i - 1] < i:\\n                return False\\n            \\n            dp[i] = max(i + nums[i], dp[i - 1])\\n            \\n            if dp[i] >= length - 1:\\n                return True\\n        \\n        return dp[length - 2] >= length - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        length = len(nums)\\n        dp = [0] * length\\n        \\n        dp[0] = nums[0]\\n        \\n        for i in range(1, length - 1):\\n            \\n            if dp[i - 1] < i:\\n                return False\\n            \\n            dp[i] = max(i + nums[i], dp[i - 1])\\n            \\n            if dp[i] >= length - 1:\\n                return True\\n        \\n        return dp[length - 2] >= length - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20944,
                "title": "java-98-percentile-solution",
                "content": "The easiest way to think about this problem is to ask are the elements with a 0 value avoidable? this is the algorithm that I constructed to answer this question.Starting from the second to last element in the array we continue to decrement towards the start of the array. Only stopping if we hit an element with a value of 0; in this case we evaluate if there exist an element somewhere at the start of the array which has a jump value large enough to jump over this 0 value element. \\n\\n    public class Solution {\\n        public boolean canJump(int[] nums) {\\n           if(nums.length < 2) return true;\\n           \\n           for(int curr = nums.length-2; curr>=0;curr--){\\n               if(nums[curr] == 0){\\n                   int neededJumps = 1;\\n                   while(neededJumps > nums[curr]){\\n                       neededJumps++;\\n                       curr--;\\n                       if(curr < 0) return false;\\n                   }\\n               }\\n           }\\n           return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean canJump(int[] nums) {\\n           if(nums.length < 2) return true;\\n           \\n           for(int curr = nums.length-2; curr>=0;curr--){\\n               if(nums[curr] == 0){\\n                   int neededJumps = 1;\\n                   while(neededJumps > nums[curr]){\\n                       neededJumps++;\\n                       curr--;\\n                       if(curr < 0) return false;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 2951773,
                "title": "java-easy-time-o-n-space-o-1",
                "content": "# Code\\n#100% faster.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n     int boundary = 0;\\n     for(int i =0;i<=boundary;i++){\\n         boundary = Math.max(boundary,i+nums[i]);\\n         if(boundary >=nums.length-1)\\n         return true;\\n     } \\n     return false;\\n    }\\n}\\n\\n```\\n#Another Approach\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[n-1]=0;\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tdp[i] = Integer.MAX_VALUE;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[i] > 0) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int j = 1; j <= nums[i] ;j++) {\\n\\t\\t\\t\\t\\tif (i + j < dp.length) {\\n\\t\\t\\t\\t\\t\\tif (dp[i + j] != Integer.MAX_VALUE)\\n                            min = Math.min(min, dp[i + j]);\\n\\t\\t\\t\\t\\t\\telse \\n                            dp[i]=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}else{\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min != Integer.MAX_VALUE)dp[i]=min+1;\\n            }\\n        }\\n         return dp[0]!=Integer.MAX_VALUE;\\n    }\\n}\\n```\\n#Alternate Solution but gives TLE.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        boolean [] dp = new boolean[len];\\n        dp[len-1] = true;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j = 1; j<=nums[i]; j++){\\n                System.out.println(j+\"||\"+i);\\n                dp[i]=(i+j<len-1)?dp[i+j]: true;\\n                if(dp[i])break;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\\n#Alternate Solution but gives TLE.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       return helper(nums,0);\\n    }\\n    public boolean helper(int []nums,int currIndex){\\n        int len = nums.length-1;\\n        if(currIndex>=len)return true;\\n        boolean ans = false;\\n        for(int i = nums[currIndex]; i>=1;i--){\\n            System.out.println(i+\"||\"+currIndex);\\n           ans = helper(nums,currIndex+i);\\n           if(ans)break;\\n        }\\n            System.out.println(\"||\"+currIndex);\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n     int boundary = 0;\\n     for(int i =0;i<=boundary;i++){\\n         boundary = Math.max(boundary,i+nums[i]);\\n         if(boundary >=nums.length-1)\\n         return true;\\n     } \\n     return false;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[n-1]=0;\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tdp[i] = Integer.MAX_VALUE;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[i] > 0) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int j = 1; j <= nums[i] ;j++) {\\n\\t\\t\\t\\t\\tif (i + j < dp.length) {\\n\\t\\t\\t\\t\\t\\tif (dp[i + j] != Integer.MAX_VALUE)\\n                            min = Math.min(min, dp[i + j]);\\n\\t\\t\\t\\t\\t\\telse \\n                            dp[i]=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}else{\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min != Integer.MAX_VALUE)dp[i]=min+1;\\n            }\\n        }\\n         return dp[0]!=Integer.MAX_VALUE;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        boolean [] dp = new boolean[len];\\n        dp[len-1] = true;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j = 1; j<=nums[i]; j++){\\n                System.out.println(j+\"||\"+i);\\n                dp[i]=(i+j<len-1)?dp[i+j]: true;\\n                if(dp[i])break;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       return helper(nums,0);\\n    }\\n    public boolean helper(int []nums,int currIndex){\\n        int len = nums.length-1;\\n        if(currIndex>=len)return true;\\n        boolean ans = false;\\n        for(int i = nums[currIndex]; i>=1;i--){\\n            System.out.println(i+\"||\"+currIndex);\\n           ans = helper(nums,currIndex+i);\\n           if(ans)break;\\n        }\\n            System.out.println(\"||\"+currIndex);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21064,
                "title": "5-line-python-solution",
                "content": "    def canJump(self, nums):\\n        max_reach, n = 0, len(nums)\\n        for i, x in enumerate(nums):\\n            if max_reach < i: return False\\n            if max_reach >= n - 1: return True\\n            max_reach = max(max_reach, i + x)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def canJump(self, nums):\\n        max_reach, n = 0, len(nums)\\n        for i, x in enumerate(nums):\\n            if max_reach < i: return False\\n            if max_reach >= n - 1: return True\\n            max_reach = max(max_reach, i + x)",
                "codeTag": "Python3"
            },
            {
                "id": 20974,
                "title": "3ms-simple-java-solution",
                "content": "    public boolean canJump(int[] nums) {\\n        int maxIndex = nums.length-1;\\n        int maxJump  = nums[0];\\n        for(int i = 0; i <= maxJump; i++){\\n            maxJump=Math.max(maxJump,i+nums[i]);\\n            if(maxJump>=maxIndex) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean canJump(int[] nums) {\\n        int maxIndex = nums.length-1;\\n        int maxJump  = nums[0];\\n        for(int i = 0; i <= maxJump; i++){\\n            maxJump=Math.max(maxJump,i+nums[i]);\\n            if(maxJump>=maxIndex) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3592600,
                "title": "most-easy-c-code",
                "content": "# Approach \\n For each element, it checks if the current index i is greater than maxReach. If it is, then it means that it is not possible to reach the current index from any of the previous indices, so the function returns false. Otherwise, it updates maxReach to be the maximum of its current value and i + nums[i], which represents the maximum index that can be reached from the current index.\\n\\nAfter iterating over all elements, if no false value has been returned, then it means that it is possible to reach the last index, so the function returns true.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxReach = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (i > maxReach) return false;\\n        maxReach = max(maxReach, i + nums[i]);\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxReach = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (i > maxReach) return false;\\n        maxReach = max(maxReach, i + nums[i]);\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194131,
                "title": "java-simple-and-easy-greedy-solution-1-ms-faster-than-85-85-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        //last index from where we can reach to end cell\\n        //As from last index (n - 1) itself reach to  end cell,  \\n        int lastIndex = n - 1;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(i + nums[i] >= lastIndex){\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        //check from 0 reach to end cell\\n        return lastIndex == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        //last index from where we can reach to end cell\\n        //As from last index (n - 1) itself reach to  end cell,  \\n        int lastIndex = n - 1;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(i + nums[i] >= lastIndex){\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        //check from 0 reach to end cell\\n        return lastIndex == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500445,
                "title": "don-t-make-question-difficult-using-dp-t-c-o-n-s-c-o-1-c-greedy-code-with-explanation",
                "content": "easy to approach:\\n1. if any time your nums value becomes zero then it will not be able to take next step then your expected ans should be wrong .\\n2. you don\\'t have to check for thn exact last index if you cross thn last index thn obiously you can end at last index .\\n\\nIt does\\'t need dynamic programming  always try to approach which is easy to understand.\\n\\n**T.C->O(N)**\\n**S.C.->0(1)**\\n\\n**DO UP VOTE PLESE IF YOU LIKED THE CONCEPT **\\n\\nHAPPY CODING \\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int n=nums.size()-1;\\n        int reach=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            reach=max(reach,i+nums[i]);\\n            if(reach==i)\\n                return false;\\n            else\\n            {\\n                if(reach>=n)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int n=nums.size()-1;\\n        int reach=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            reach=max(reach,i+nums[i]);\\n            if(reach==i)\\n                return false;\\n            else\\n            {\\n                if(reach>=n)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500227,
                "title": "python-2-lines-greedy-o-n-solution-explained",
                "content": "There are two algorithms: one is dp with complexity O(n^2), where dp(i) is the minimum number of steps to reach position i and on each step we need to check potentially O(n) jumps.\\n\\nHowever there is a solution with better complexity, using greedy idea: we need to look at `i + nums[i]` values and look at running maximum of these values. Then we check if for some element we have i == t[i]: if we have such place, we stuck and we can not reach the last cell, if not, we can reach.\\n\\nWe can look at our process like this: what is the biggest index we can reach after say i jumps. Then if we have new index to traverse we update our range. For example for nums = [2, 3, 0, 1, 4] we have t = [2, 4, 4, 4, 8] and after 1 jump we can reach index 2 and after each new index processed we expand our window if we have bigger value than the end of window and increase total number of steps or we do not do anything. In this problem we do not need number of steps, but this idea can be used in problem **0045 Jump game II**.\\n\\n#### Complexity\\nTime and space complexity is O(n).\\n\\n#### Code\\n```python\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774588,
                "title": "python-easy-linear-time-o-n-and-space-o-1-explanation",
                "content": "1. We start travering the array from start\\n2. While traversing, we keep a track on maximum reachable index and update it accordingly. If we reach the maxium reachable index we get out of loop.\\n3. At last, if maxium reachable index is greater than or equal to last index of the array, means we can reach the last element else return false.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reachableIndex = 0\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n            if curr == reachableIndex:\\n                break\\n                \\n        return reachableIndex >= len(nums) - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reachableIndex = 0\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n            if curr == reachableIndex:\\n                break\\n                \\n        return reachableIndex >= len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591224,
                "title": "recursive-memoizaton-tabulation-o-n-solution-with-constant-space",
                "content": "# Recursive\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n\\t}\\n\\n\\tbool f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return true;\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums);\\n        \\n        return check;\\n\\t}\\n```\\n\\n# Memoization\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tbool f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums, dp);\\n        \\n        return dp[ind] = check;\\n    }\\n```\\n\\n# Tabulation\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        for(int reach = 0; i < n && i <= reach; i++)\\n            reach = max(reach, nums[i] + i);\\n        return i == n;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n\\t}\\n\\n\\tbool f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return true;\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums);\\n        \\n        return check;\\n\\t}\\n```\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tbool f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums, dp);\\n        \\n        return dp[ind] = check;\\n    }\\n```\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        for(int reach = 0; i < n && i <= reach; i++)\\n            reach = max(reach, nums[i] + i);\\n        return i == n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435741,
                "title": "simple-clean-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I was confused with this question since it is considered to be a DP problem, but I found that the DP solution was not very intuitive. For me it was much simpler and faster to solve this using greedy.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each position of the array, we are given a choice of either taking the steps from that point, or continuing with the steps we took previously. \\n\\nAt the start, we know we have nums[0] steps, and hence our steps left should = nums[0].\\n\\nAs we traverse through the array, we update our steps left to be the maximum of (nums[index], stepsleft - 1), ensuring that we always have the most possible steps left. If we reach the last index, we know that we can reach the end and return true.\\n\\nIf we ever run out of steps, then we know we can\\'t reach the last index and thus stop the loop and return false.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        int stepsleft = nums[0];\\n        int index = 1;\\n        while(stepsleft > 0){\\n            if (index == nums.length-1){\\n                return true;\\n            }\\n            stepsleft = Math.max(stepsleft-1, nums[index]);\\n            index++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        int stepsleft = nums[0];\\n        int index = 1;\\n        while(stepsleft > 0){\\n            if (index == nums.length-1){\\n                return true;\\n            }\\n            stepsleft = Math.max(stepsleft-1, nums[index]);\\n            index++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271858,
                "title": "python-greedy",
                "content": "We can use a pointer ```j``` to indicate the farthest index we can reach. \\nAs any index within ```j``` can be chosen to jump from, we can use a heuristic that for each index ```i``` whose jump length is ```x```, ```j = max(j, i+x)```. If ```i+x > j```, we just jump from ```i``` to increase our jump range from ```j``` to ```i+x```.\\nBut we should ensure that ```i``` is reachable. So if ```j<i```, it\\'s not reachable even with our best effort. We return ```False```.\\n```\\ndef canJump(nums):\\n\\tj = 0\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif j < i: return False \\n\\t\\tj = max(j, i+x)\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```j```\n```j```\n```i```\n```x```\n```j = max(j, i+x)```\n```i+x > j```\n```i```\n```j```\n```i+x```\n```i```\n```j<i```\n```False```\n```\\ndef canJump(nums):\\n\\tj = 0\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif j < i: return False \\n\\t\\tj = max(j, i+x)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 21193,
                "title": "how-about-my-solution",
                "content": "     public boolean canJump(int[] A) {\\n       if(A.length==0) return true;\\n       int maxcan=0;// the farthest position it can jump\\n       for(int i=0;i<A.length;i++){\\n           if(maxcan>=A.length-1) return true; //if the farthest postion have passed the end or reached the end\\n           maxcan=Math.max(maxcan,A[i]+i);// update the farthest position\\n           if(maxcan==i) return false; // return false when you cannot move any further..\\n       }\\n       return true;//not necessary, just a return type...\\n    }",
                "solutionTags": [],
                "code": "     public boolean canJump(int[] A) {\\n       if(A.length==0) return true;\\n       int maxcan=0;// the farthest position it can jump\\n       for(int i=0;i<A.length;i++){\\n           if(maxcan>=A.length-1) return true; //if the farthest postion have passed the end or reached the end\\n           maxcan=Math.max(maxcan,A[i]+i);// update the farthest position\\n           if(maxcan==i) return false; // return false when you cannot move any further..\\n       }\\n       return true;//not necessary, just a return type...\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3158292,
                "title": "c-easiest-beginner-friendly-sol-greedy-o-n-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize a variable reach to 0, which represents the farthest index that can be reached so far.\\n2. Loop through the array nums and for each index i, do the following:\\n    - a. If i is greater than reach or reach is greater than or equal to nums.length - 1, break the loop as it means reaching the last index is not possible.\\n    - b. Update the value of reach as the maximum of reach and i + nums[i].\\n1. Return reach >= nums.length - 1, which means that the last index can be reached or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int reach = 0;\\n        for (int i = 0; i < n; i++) {\\n            // (i > reach) will cover [1,1,0,1,2] or [0,0,0....]\\n            if(i > reach || reach >= n-1)\\n                break;\\n            //this reach will store upto which index we can jump from that ith index\\n            reach = max(reach, i + nums[i]);\\n        }\\n        if (reach >= n-1)\\n            return true;\\n        //this \"return false\" means definitely (i > reach) at any point\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > reach || reach >= nums.length - 1) break;\\n            reach = Math.max(reach, i + nums[i]);\\n        }\\n        return reach >= nums.length - 1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reach = 0\\n        for i in range(len(nums)):\\n            if i > reach or reach >= len(nums) - 1:\\n                break\\n            reach = max(reach, i + nums[i])\\n        return reach >= len(nums) - 1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the length of the array nums. This is because we are looping through the entire nums array once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as we are using a single integer variable reach.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int reach = 0;\\n        for (int i = 0; i < n; i++) {\\n            // (i > reach) will cover [1,1,0,1,2] or [0,0,0....]\\n            if(i > reach || reach >= n-1)\\n                break;\\n            //this reach will store upto which index we can jump from that ith index\\n            reach = max(reach, i + nums[i]);\\n        }\\n        if (reach >= n-1)\\n            return true;\\n        //this \"return false\" means definitely (i > reach) at any point\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > reach || reach >= nums.length - 1) break;\\n            reach = Math.max(reach, i + nums[i]);\\n        }\\n        return reach >= nums.length - 1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reach = 0\\n        for i in range(len(nums)):\\n            if i > reach or reach >= len(nums) - 1:\\n                break\\n            reach = max(reach, i + nums[i])\\n        return reach >= len(nums) - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755056,
                "title": "o-n-greedy-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for(int i=0;i<=reach;i++){\\n            reach= Math.max(reach , i+nums[i]);\\n            if(reach>=nums.length-1){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for(int i=0;i<=reach;i++){\\n            reach= Math.max(reach , i+nums[i]);\\n            if(reach>=nums.length-1){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21146,
                "title": "c-smiple-and-easy-to-understand-o-n-time-4-lines",
                "content": "    class Solution {\\n    public:\\n    \\tbool canJump(vector<int>& nums) {\\n    \\t\\tint truepos=nums.size()-1;//the lowest starting point that you can reach the end \\n    \\t\\tfor(int i=nums.size()-2;i>=0;i--)\\n    \\t\\t\\ttruepos=(i+nums[i])>=truepos?i:truepos;\\n    \\t\\treturn(truepos==0);\\t\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool canJump(vector<int>& nums) {\\n    \\t\\tint truepos=nums.size()-1;//the lowest starting point that you can reach the end \\n    \\t\\tfor(int i=nums.size()-2;i>=0;i--)\\n    \\t\\t\\ttruepos=(i+nums[i])>=truepos?i:truepos;\\n    \\t\\treturn(truepos==0);\\t\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 21185,
                "title": "another-way-of-looking-at-the-problem",
                "content": "0 is like a **trap**. \\nAnytime you fall-in 0, you can't jump no more (except the last one which you are already at target).\\n\\nSo first, find those traps from start. After we find one, we have to go back to test if this trap is leap-able. This is not efficient.\\n\\nIf we search from back, whenever a trap is found, we can conveniently convert **searching for trap** problem to **searching for leap-able** problem. No need to go back. So one scan, O(n).\\n\\npartial code:\\n\\n    \\tfor(int i = A.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(A[i] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//start search\\n\\t\\t\\t\\tint zeroIndex = i;\\n\\t\\t\\t\\tfor(i = i - 1; i >=0; i--)  //keep using same i to continue searching!\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(A[i] > zeroIndex - i)   //we can overcome this trap!\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == -1) //searched to end and no possible leap\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;",
                "solutionTags": [],
                "code": "0 is like a **trap**. \\nAnytime you fall-in 0, you can't jump no more (except the last one which you are already at target).\\n\\nSo first, find those traps from start. After we find one, we have to go back to test if this trap is leap-able. This is not efficient.\\n\\nIf we search from back, whenever a trap is found, we can conveniently convert **searching for trap** problem to **searching for leap-able** problem. No need to go back. So one scan, O(n).\\n\\npartial code:\\n\\n    \\tfor(int i = A.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(A[i] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//start search\\n\\t\\t\\t\\tint zeroIndex = i;\\n\\t\\t\\t\\tfor(i = i - 1; i >=0; i--)  //keep using same i to continue searching!\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(A[i] > zeroIndex - i)   //we can overcome this trap!\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == -1) //searched to end and no possible leap\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2060972,
                "title": "c-easy-explanation-dp-tabulation-bottoms-up",
                "content": "```\\nbool canJump(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    vector<bool> dp(n, false);\\n    dp[0] = true;\\n     // Only One Element , so we do not have to jump anywhere\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = i - 1; j >= 0; j--)\\n        // Here we are traversing backward\\n        // We are checking for every position from last that whether we\\n        // can reach that ith index with current position and jump or not\\n        {\\n            if (dp[j] && j + nums[j] >= i)\\n            // Here we are checking dp[j] to make sure that previously if we could reach the\\n            // jth index or not , means that if we were not be able to reach the jth index\\n            // then how can we jump from that index , so there will be no use\\n            // of jumping from that index\\n            {\\n                dp[i] = true;\\n            //Yes!,we can reach the ith position from present jth position\\n                break;\\n            //If we can jump from the present jth position then no need of checking previous\\n            //indexes as by checking dp[j] we have already made sure that we can reach the jth position\\n\\t\\t\\t//easily and from there the ith position\\n            }\\n        }\\n    }\\n    return dp[n - 1];\\n}\\n```\\nIf you like the above explanation do upvote \\uD83D\\uDC4Dand if there is any scope of improvement or query do comment\\uD83D\\uDE01.\\n\\n**Thank You For Reading!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool canJump(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    vector<bool> dp(n, false);\\n    dp[0] = true;\\n     // Only One Element , so we do not have to jump anywhere\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = i - 1; j >= 0; j--)\\n        // Here we are traversing backward\\n        // We are checking for every position from last that whether we\\n        // can reach that ith index with current position and jump or not\\n        {\\n            if (dp[j] && j + nums[j] >= i)\\n            // Here we are checking dp[j] to make sure that previously if we could reach the\\n            // jth index or not , means that if we were not be able to reach the jth index\\n            // then how can we jump from that index , so there will be no use\\n            // of jumping from that index\\n            {\\n                dp[i] = true;\\n            //Yes!,we can reach the ith position from present jth position\\n                break;\\n            //If we can jump from the present jth position then no need of checking previous\\n            //indexes as by checking dp[j] we have already made sure that we can reach the jth position\\n\\t\\t\\t//easily and from there the ith position\\n            }\\n        }\\n    }\\n    return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912523,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var reach = 0\\n        var i = 0\\n\\n        while i <= reach {\\n            reach = max(reach, i + nums[i])\\n            i += 1\\n            if reach >= nums.count - 1 { return true }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var reach = 0\\n        var i = 0\\n\\n        while i <= reach {\\n            reach = max(reach, i + nums[i])\\n            i += 1\\n            if reach >= nums.count - 1 { return true }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321112,
                "title": "java-solution-1ms-runtime-greedy-approach",
                "content": "**Problem Link :** https://leetcode.com/problems/jump-game/?envType=study-plan&id=algorithm-ii\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm traverse from the end upto 0. Initially we set the last index as our `goal` then if we can reach the goal from  `i`th index , then we set our goal index to `i`th index.\\nEventually if goal reaches to `0` then we know we can reach the last index from starting point (`0`th index).\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length-1;\\n       for(int i = goal-1; i >= 0; i--){\\n           if(nums[i]+i >= goal){\\n               goal = i;\\n           }\\n       }\\n       return goal == 0;\\n    }\\n}\\n```\\n\\nThank You\\n\\nPlease Do Upvote!!!",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length-1;\\n       for(int i = goal-1; i >= 0; i--){\\n           if(nums[i]+i >= goal){\\n               goal = i;\\n           }\\n       }\\n       return goal == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285632,
                "title": "golang-o-n-o-1-solution-with-images",
                "content": "The idea of this solution is pretty simple once you understand it. \\n\\nThe idea of this solution is:\\n\\n* We get the maximum index we can go up to by getting the maximum of `i + nums[i]` and `max`.\\n* Then, if `i` has surpassed the maximum index, we can return `false`.\\n* Otherwise return `true`.\\n\\nIf you don\\'t understand why this works, look at the following example:\\n\\ninput: `[3, 2, 1, 0, 4]`\\nexpected output: `false`\\n\\n![image](https://assets.leetcode.com/users/images/2aa23e13-7f07-44ef-bd8f-2b50ed3305b2_1624199132.427165.jpeg)\\n\\n\\n**The Code:**\\n\\n``` go\\nfunc canJump(nums []int) bool {\\n    max := 0\\n    for i := 0; i < len(nums); i++ {\\n        if i > max {\\n            return false\\n        }\\n        if i + nums[i] > max {\\n            max = i + nums[i]\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc canJump(nums []int) bool {\\n    max := 0\\n    for i := 0; i < len(nums); i++ {\\n        if i > max {\\n            return false\\n        }\\n        if i + nums[i] > max {\\n            max = i + nums[i]\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1656772,
                "title": "solution-swift-jump-game-test-cases",
                "content": "```swift\\nclass Solution {\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var indexMax = nums[0]\\n        for (i, v) in nums.enumerated() {\\n            if i > indexMax{ return false }\\n            indexMax = max(indexMax, i + v)\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b>  Executed 2 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n    func test0() {\\n        let value = solution.canJump([2,3,1,1,4])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    /// You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\\n    func test1() {\\n        let value = solution.canJump([3,2,1,0,4])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var indexMax = nums[0]\\n        for (i, v) in nums.enumerated() {\\n            if i > indexMax{ return false }\\n            indexMax = max(indexMax, i + v)\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n    func test0() {\\n        let value = solution.canJump([2,3,1,1,4])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    /// You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\\n    func test1() {\\n        let value = solution.canJump([3,2,1,0,4])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300303,
                "title": "efficient-logic-in-c",
                "content": "We will take steps equal to max of element of array and steps and decrement it by 1 after each iteration. If our steps reaches less than zero, we will then return false.\\nOnce we reach the last index and steps do not become 0, we will have achieved our goal.(return true)\\n\\n    bool canJump(vector<int>& nums) \\n    {\\n        int steps = 0;\\n        int size = nums.size();  //taking size\\n        \\n        for(int i = 0;i < size; i++)\\n        {\\n            if (steps  <  0)\\n                return false;\\n    \\n            steps = max(steps, nums[i]) - 1;  // as we are moving further from the element\\n        }    \\n        return true;\\n    }\\n\\t\\n\\t\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "We will take steps equal to max of element of array and steps and decrement it by 1 after each iteration. If our steps reaches less than zero, we will then return false.\\nOnce we reach the last index and steps do not become 0, we will have achieved our goal.(return true)\\n\\n    bool canJump(vector<int>& nums) \\n    {\\n        int steps = 0;\\n        int size = nums.size();  //taking size\\n        \\n        for(int i = 0;i < size; i++)\\n        {\\n            if (steps  <  0)\\n                return false;\\n    \\n            steps = max(steps, nums[i]) - 1;  // as we are moving further from the element\\n        }    \\n        return true;\\n    }\\n\\t\\n\\t\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 349913,
                "title": "simple-python-solution",
                "content": "Solution 1: dynamic programing from the end to the start\\nTime complexity: O(n^2) (Time Limit Exceeded, 74 / 75 test cases passed)\\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = n * [False]\\n        dp[n-1] = True\\n        for i in range(n - 2, -1, -1):\\n            for j in range(1, nums[i] + 1):\\n                if i + j < n and dp[i+j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\\n\\nSolution 2: time complexity O(n)\\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        # dp = n * [False]\\n        # dp[n-1] = True\\n        right_most = n - 1\\n        for i in range(n - 2, -1, -1):\\n            if i + nums[i] >= right_most:\\n                # dp[i] = True\\n                right_most = i\\n        return right_most == 0   # or dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = n * [False]\\n        dp[n-1] = True\\n        for i in range(n - 2, -1, -1):\\n            for j in range(1, nums[i] + 1):\\n                if i + j < n and dp[i+j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        # dp = n * [False]\\n        # dp[n-1] = True\\n        right_most = n - 1\\n        for i in range(n - 2, -1, -1):\\n            if i + nums[i] >= right_most:\\n                # dp[i] = True\\n                right_most = i\\n        return right_most == 0   # or dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133302,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction canJump(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (max < i) return false;  // max steps cannot reach position i\\n    max = Math.max(nums[i] + i, max);\\n  }\\n\\n  return true;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nfunction canJump(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (max < i) return false;  // max steps cannot reach position i\\n    max = Math.max(nums[i] + i, max);\\n  }\\n\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20963,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion**https://discuss.leetcode.com/topic/80174/python-solution-with-detailed-explanation\\n\\n**Jump Game** https://leetcode.com/problems/jump-game/?tab=Description\\n\\n**Memoization Solution**\\n* Draw the recursion tree. Notice we can have stack overflow for an exremely large input. MLE\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        return self.can_jump_memoization(0, nums, {})\\n\\n    def can_jump_memoization(self, i, array, cache):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if i >= len(array):\\n            return False\\n        elif i == len(array)-1:\\n            return True\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = False\\n            for j in range(1, array[i]+1):\\n                if self.can_jump_memoization(j+i, array, cache):\\n                    cache[i] = True\\n                    return True\\n            return cache[i]\\n```\\n\\n**Dynamic Programming Solution**\\n* Complexity is order n^2. We have an issue here - TLE.\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        dp = [False]*len(nums)\\n        dp[0] = True\\n        for i in range(1,len(nums)):\\n            for j in range(i-1,-1,-1):\\n                if dp[j] == True and nums[j] + j >= i:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n\\n**Linear - Ladders and Stairs Solution**\\n* Linear complexity\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach = nums[0]\\n        end_index = len(nums)-1\\n        if max_reach >= end_index:\\n            return True\\n        for i in range(1, len(nums)):\\n            if i > max_reach:\\n                return False\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= end_index:\\n                return True            \\n        return False \\n```\\n\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach, i, N = 0, 0, len(nums)\\n        while i < N and max_reach >= i:\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= N-1:\\n                return True\\n            i += 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        return self.can_jump_memoization(0, nums, {})\\n\\n    def can_jump_memoization(self, i, array, cache):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if i >= len(array):\\n            return False\\n        elif i == len(array)-1:\\n            return True\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = False\\n            for j in range(1, array[i]+1):\\n                if self.can_jump_memoization(j+i, array, cache):\\n                    cache[i] = True\\n                    return True\\n            return cache[i]\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        dp = [False]*len(nums)\\n        dp[0] = True\\n        for i in range(1,len(nums)):\\n            for j in range(i-1,-1,-1):\\n                if dp[j] == True and nums[j] + j >= i:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach = nums[0]\\n        end_index = len(nums)-1\\n        if max_reach >= end_index:\\n            return True\\n        for i in range(1, len(nums)):\\n            if i > max_reach:\\n                return False\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= end_index:\\n                return True            \\n        return False \\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach, i, N = 0, 0, len(nums)\\n        while i < N and max_reach >= i:\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= N-1:\\n                return True\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953864,
                "title": "easy-explanation-which-beats-98-c-users-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust assume we are standing on the last index\\nAim: to somehow reach 0th index as **if we can reach last to zero we can reach zero to last index also**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.just maintain a (last_pos) variable that **keeps a track of your last position** you were able to travell from last index.\\n\\n2.if current position(i) + value of current position(nums[i]) is grater then our last position(last_pos) that means we can reach to our last position(last_pos) from our current(i) position\\n\\n3.And now if ***i + nums[i] >= curr_pos our curr_pos becomes i*** this means we can travell till i from the last index or we can successfully travell to last index from that position(i).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas we are iterating every element only once time complexity is O(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe have just used 2 extra variables n and last_pos that is constant which makes tc = O(1)\\n\\n# hope this brings a smile on your face.......\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last_pos = n-1;\\n        for(int i = n-1 ; i > -1 ; i--)\\n        {\\n            if(nums[i]+i >= last_pos) last_pos = i;\\n        }\\n        if(last_pos==0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last_pos = n-1;\\n        for(int i = n-1 ; i > -1 ; i--)\\n        {\\n            if(nums[i]+i >= last_pos) last_pos = i;\\n        }\\n        if(last_pos==0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887273,
                "title": "beats-98-mind-blowing-intuition-explained",
                "content": "# Intuition\\nChange the destination point backwards. \\n# Approach\\nInitially, first destination point is last index. Change destination point to index of first previous element that can jump to current goal. That way we can, tecnically, consider this new goal as destination point cause once we can reach to it we can automatically get to original goal as well. In the end, if last updated goal happens to be very first element or zero index then it means that we can get to the original last index destination point from zero index.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #original destination is last index\\n        goal = len(nums)-1\\n\\n        #check backwards\\n        for i in range(len(nums)-2,-1,-1):\\n            #if we can jump then update\\n            if i+nums[i] >= goal:\\n                goal = i\\n\\n        #check if we can reach from first index\\n        return True if goal == 0 else False #return goal == 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #original destination is last index\\n        goal = len(nums)-1\\n\\n        #check backwards\\n        for i in range(len(nums)-2,-1,-1):\\n            #if we can jump then update\\n            if i+nums[i] >= goal:\\n                goal = i\\n\\n        #check if we can reach from first index\\n        return True if goal == 0 else False #return goal == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987629,
                "title": "c-solution-very-simple-to-understand-o-n-time-o-1-space",
                "content": "```\\npublic class Solution {\\n    public bool CanJump(int[] nums) {\\n \\n        // The end of the array is true, since that means we are at the solution.\\n        int nearestTrue = nums.Length - 1;\\n        \\n        // Working backwards through the array we want to check if our current num can jump us to the nearest \\'TRUE\\'.\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            // If we can jump to the nearest true, we become the nearest true.\\n            if(i + nums[i] >= nearestTrue)\\n            {\\n                nearestTrue = i;\\n            }\\n        }\\n        \\n        // If the nearest true is the start, the entire solution is jumpable.\\n        return nearestTrue == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanJump(int[] nums) {\\n \\n        // The end of the array is true, since that means we are at the solution.\\n        int nearestTrue = nums.Length - 1;\\n        \\n        // Working backwards through the array we want to check if our current num can jump us to the nearest \\'TRUE\\'.\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            // If we can jump to the nearest true, we become the nearest true.\\n            if(i + nums[i] >= nearestTrue)\\n            {\\n                nearestTrue = i;\\n            }\\n        }\\n        \\n        // If the nearest true is the start, the entire solution is jumpable.\\n        return nearestTrue == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493351,
                "title": "java-memoization-solution",
                "content": "I initially wrote the solution using a hashmap as memoization object but was getting TLE. So changed it to dp array.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return canJump(nums, 0, dp);\\n    }\\n    \\n    public boolean canJump(int[] nums, int index, int[] dp) {\\n        if (index >= nums.length-1) {\\n            return true;\\n        } \\n        \\n        if (nums[index] == 0) {\\n            dp[index] = 0;\\n            return false;\\n        }\\n        \\n        if (dp[index] != -1){\\n            return dp[index] == 1;\\n        } \\n        \\n        int jumps = nums[index];\\n        for (int i = 1; i <= jumps; i++) {\\n            if (canJump(nums, index+i, dp)) {\\n                dp[index] = 1;\\n                return true;\\n            }\\n        }\\n        \\n        dp[index] = 0;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return canJump(nums, 0, dp);\\n    }\\n    \\n    public boolean canJump(int[] nums, int index, int[] dp) {\\n        if (index >= nums.length-1) {\\n            return true;\\n        } \\n        \\n        if (nums[index] == 0) {\\n            dp[index] = 0;\\n            return false;\\n        }\\n        \\n        if (dp[index] != -1){\\n            return dp[index] == 1;\\n        } \\n        \\n        int jumps = nums[index];\\n        for (int i = 1; i <= jumps; i++) {\\n            if (canJump(nums, index+i, dp)) {\\n                dp[index] = 1;\\n                return true;\\n            }\\n        }\\n        \\n        dp[index] = 0;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21080,
                "title": "greedy-14ms-o-n-o-1-easy-c-solution-easy-understanding",
                "content": "\\n\\n    bool canJump(int A[], int n) { // Greedy\\n        \\n        n==1?({return true;}):({;});  // Return true if already reach the end\\n        \\n        int max_index_can_jump = 0; // So far the current max index we can jump to.\\n        \\n        for (int i = 0; i <= max_index_can_jump; ++i )\\n        {\\n            if( (A[i]+i) > max_index_can_jump ) // check if need to update the current max index we can jump to\\n            {\\n                if((A[i]+i) >= (n - 1)) // check if we can jump to the last index (end)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    max_index_can_jump = A[i]+i; // Then update\\n                }\\n            }\\n        }\\n        \\n        //return max_index_can_jump == (n-1); // First line is only one of the case\\n        \\n        return false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n    bool canJump(int A[], int n) { // Greedy\\n        \\n        n==1?({return true;}):({;});  // Return true if already reach the end\\n        \\n        int max_index_can_jump = 0; // So far the current max index we can jump to.\\n        \\n        for (int i = 0; i <= max_index_can_jump; ++i )\\n        {\\n            if( (A[i]+i) > max_index_can_jump ) // check if need to update the current max index we can jump to\\n            {\\n                if((A[i]+i) >= (n - 1)) // check if we can jump to the last index (end)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    max_index_can_jump = A[i]+i; // Then update\\n                }\\n            }\\n        }\\n        \\n        //return max_index_can_jump == (n-1); // First line is only one of the case\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2225627,
                "title": "python-3-brute-force-dp-greedy",
                "content": "**Brute Force Approach (TLE)**\\n\\\\\\nThe brute-force approach is to visit all possible paths (which can be achieved by using the DFS algorithm). The idea is to create a recursive function that accepts one parameter: `i`. It keeps track of the current index we\\'re in.\\n\\\\\\nWe\\'ll need to handle the following scenarios explicitly:\\n\\u2022 When `nums[i] == 0`\\n\\u2022\\xA0When `i == N - 1`\\n\\\\\\nIf `nums[i] == 0`, this implies we can no longer move forward b/c we have 0 jump - hence we\\'ll return false. If `i == N - 1`, this implies we\\'ve found a path that reaches the final element - hence we\\'ll return true.\\n\\nIt seems like there are `nums[i]` choices we can make per recursive function. We can jump from `i` to `i + 1` ~ `i + nums[i] `inclusive. We can use a for-loop to attempt all the possible jumps. *FYI: Its lowerbound is `i + 1` & its upperbound is `min(i + nums[i], N - 1) + 1`. This allows us to reduce the total # of iterations.*\\n\\\\\\nFor each iteration:\\n1) we\\'ll make a recursive call: `dfs(j)` (where `j` is an index of the for-loop)\\n2) If `dfs(j) == True` , then it implies the current element leads to the final element. Hence, we\\'ll immediately return true.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\\\\\nThe time complexity is O(N^N) b/c we must jump at most N times per recursive function. \\nThe space complexity is O(N) b/c we must store a reference of N recursive-calls in a call-stack.\\n\\n---\\n\\\\\\n**Top-down DP (Memoization) (TLE)**\\n\\\\\\nThe above solution seems to be inefficient b/c we\\'re visiting the same sub-paths on multiple occasions. To remedy this issue, we can store a precomputed value of the visited sub-paths into a dictionary or a list. *FYI: I\\'ll be using a dictionary for this example.*\\n\\nThe idea is to add an additional parameter, that stores a reference of the dictionary, in a recursive function. After the existing base cases, we\\'ll add a new conditional statement that checks whether the key: `i` already exists in the dictionary. If that\\'s the case, then it implies we\\'ve already visited the current path. Hence, we\\'ll return its precomputed value as an answer.\\n\\nOtherwise, we\\'ll compute the current path\\'s answer and store it in the dictionary.\\n\\\\\\n*Implementation w/ a dictionary*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            is_valid = False    \\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, {})\\n```\\n\\\\\\n*implementation w/ a list*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if memo[i] != None:\\n                return memo[i]\\n            \\n            is_valid = False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, [None] * N)\\n```\\n\\\\\\n*implementation w/ the lru_cache decorator*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        \\n        @lru_cache(N)\\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n                    \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\\\\\nThe time complexity is O(N^2) b/c we still need to jump at most N times per recursive function. However, we won\\'t need to visit the same path again b/c we\\'re storing the precomputed value (of the paths) in a dictionary (or a list). \\n\\nThe space complexity is O(N) b/c we must store N key-value pairs into the dictionary. *FYI: If we\\'re using a list, then we must allocate N additional space to initialize an N-sized list.*\\n\\n---\\n\\n\\\\\\n**Bottom-up DP (Iterative DP) (occasionally passes but TLE for the most part)**\\n\\\\\\nWe can convert the top-down DP into its iterative alternative. First, we\\'ll initialize an N-sized list and we\\'ll set the final element as true. Next, we\\'ll use a nested for-loop to visit all the paths - where the outer-loop iterates N times and an inner-loop iterates at most N times.\\n\\nBefore we execute the inner-loop, we\\'ll check whether `nums[i] == 0`. If that\\'s the case, then it implies we have 0 jump - which prevents us from moving any further. Hence, we\\'ll immediately skip to the next iteration.\\n\\nFor each iteration of the inner-loop, we\\'ll check whether `dp[j]` (where` j` is an index of the inner-loop) equals true. If that\\'s the case, then it implies the path reaches to the last element. Hence, we\\'ll assign true to `dp[i]` and break the inner-loop.\\n\\nAfter we finish executing the nested for-loop, we\\'ll return `dp[0] `as an answer.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        dp = [False] * N\\n        dp[-1] = True\\n        \\n        for i in range(N - 1, -1, -1):\\n            if nums[i] == 0:\\n                continue\\n            \\n            lowerbound = i + 1\\n            upperbound = min(i + nums[i], N - 1) + 1\\n            \\n            for j in range(lowerbound, upperbound):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[0]\\n```\\n\\\\\\nThe time complexity is O(N^2) b/c we must execute a nested for-loop where an outer-loop iterates N times. For each iteration of the outer-loop, we must execute an inner-loop that iterates at most N times.\\n\\nThe space complexity is O(N) b/c we must initialize an N-sized list.\\n\\n---\\n\\\\\\n**Greedy Approach**\\n\\\\\\nIf we look closely at the problem, we don\\'t necessarily have to visit all the paths to verify whether a valid path exists. As long as we can jump to the element t*hat ultimately leads to the final element,* then we should be able to verify whether the valid path exists.\\n\\nThe idea is to iterate through `nums` from right to left, and for each iteration, we\\'ll check whether `i + nums[i]` >= index of the element that leads to the final element (I\\'ll call it `valid_idx` for brevity\\'s sake). If that\\'s true, then it implies the current element leads to the final element. Hence, we\\'ll update `valid_idx` to store `i`. \\n\\nAfter we finish iterating through `nums`, we\\'ll check whether `valid_idx == 0`. If that\\'s true, then it implies the first element leads to the final element. Therefore, we\\'ll return true as an answer. Otherwise, we\\'ll return false as an answer.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        valid_idx = N - 1\\n        \\n        for i in range(N - 2, -1, -1):\\n            if i + nums[i] >= valid_idx:\\n                valid_idx = i\\n        \\n        return valid_idx == 0\\n```\\n\\\\\\nThe time complexity is O(N) b/c we must iterate through `nums` once.\\nThe space complexity is O(1) b/c we\\'re only initializing few variables throughout the implementation.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            is_valid = False    \\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, {})\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if memo[i] != None:\\n                return memo[i]\\n            \\n            is_valid = False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, [None] * N)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        \\n        @lru_cache(N)\\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n                    \\n            return False\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        dp = [False] * N\\n        dp[-1] = True\\n        \\n        for i in range(N - 1, -1, -1):\\n            if nums[i] == 0:\\n                continue\\n            \\n            lowerbound = i + 1\\n            upperbound = min(i + nums[i], N - 1) + 1\\n            \\n            for j in range(lowerbound, upperbound):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        valid_idx = N - 1\\n        \\n        for i in range(N - 2, -1, -1):\\n            if i + nums[i] >= valid_idx:\\n                valid_idx = i\\n        \\n        return valid_idx == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723975,
                "title": "jump-game-building-to-jump-game-2-c-solutions",
                "content": "(1) Jump Game 1\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        \\n        int maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(maxreach<i)\\n                return false;\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n(2) Jump Game 2\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        \\n        int jumps=0, currreach=0, maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(currreach<i){\\n                jumps++;\\n                currreach=maxreach;\\n            }\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return jumps;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        \\n        int maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(maxreach<i)\\n                return false;\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        \\n        int jumps=0, currreach=0, maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(currreach<i){\\n                jumps++;\\n                currreach=maxreach;\\n            }\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return jumps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21010,
                "title": "this-can-be-solved-by-using-car-and-fuel-tank-analogy",
                "content": "Lets rephrase the question, \\nWe want to reach the end of the road(end of the array), the numbers in the Array are fuelTanks one the road.\\nFor tarvelling to the next fuelTank(number) we will lose a fuel unit in your current tank.\\n\\nAns:\\nAt each number(fuel tank), we pick up whichever is highest our current fuelTank in the car OR the fuel tank that is in the road\\n\\n```\\npublic class Solution {\\n    public boolean canJump(int[] fuelRoad) {\\n        if(fuelRoad.length<=1){\\n            return true;\\n        }\\n        //there is no need for the fuel at the end- this just messes with my code, so making it zero\\n        fuelRoad[fuelRoad.length-1]=0;\\n        //lets initilize the car with the firstfuel tank in the road\\n        int carPosition=1, fuelTank=fuelRoad[0]-1;\\n        while(carPosition<fuelRoad.length && \\n            //there has to be fuel to travel\\n            fuelTank>=0){\\n            //this is just small optimization,checks whether we will have enough fuel to reach the end\\n            if(carPosition+fuelTank >= fuelRoad.length-1){\\n                return true;\\n            }\\n            //check which is bigger the fuel in the road or our tank\\n            if(fuelRoad[carPosition]>fuelTank){\\n                fuelTank=fuelRoad[carPosition];\\n            }\\n            carPosition++;\\n            fuelTank--;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canJump(int[] fuelRoad) {\\n        if(fuelRoad.length<=1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21156,
                "title": "simple-python-solution-o-n-1-55ms",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {boolean}\\n        def canJump(self, nums):\\n            stepsLeft = nums[0]\\n    \\n            if not stepsLeft and len(nums) > 1:\\n                return False\\n    \\n            for num in nums[1:-1]:\\n                stepsLeft = max(stepsLeft - 1, num)\\n                if not stepsLeft:\\n                    return False\\n    \\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3144678,
                "title": "c-easy-to-understand-dynamic-programming-tabulation-method-o-n-runtime",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDynamic Programming using Tabulation Method.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) {Extra space for DP array}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n\\n        // DP Tabulation method\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            //Check if that place is reachabale or not.\\n            if(dp[i-1]>0){\\n                //Counting the steps and updating the values after each iteration\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        //If that step is reachable, return true.\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n\\n        // DP Tabulation method\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            //Check if that place is reachabale or not.\\n            if(dp[i-1]>0){\\n                //Counting the steps and updating the values after each iteration\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        //If that step is reachable, return true.\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952469,
                "title": "brute-dp-o-n-greedy-w-images-explained",
                "content": "# Intuition & Approach [BRUTE]\\nFor Brute:\\nSo this part is pretty simple brute force approach. We recursively try to jump at every location we can starting from the first and see if we ever get at the target position which is `length of nums -1` or `len(nums)-1` as seen in python.\\n\\n\\nHere is a brute force code for the same.\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(ind, memo):\\n            if ind in memo:\\n                return memo[ind]\\n            if ind >= len(nums)-1:\\n                return True \\n            if nums[ind] == 0:\\n                return False\\n            for steps in range(nums[ind], 0, -1):\\n                goTo = ind + steps\\n                if dfs(goTo, memo):\\n                    memo[ind] = True\\n                    return True\\n            memo[ind] = False\\n            return False\\n        return dfs(0, {})\\n\\n```\\nAbove Code Explanation:\\n- Our dfs function is recursive.\\n- It returns `True` if current index, `ind` in code is `greater than or equal to our target_index` because it means we can reach it.\\n- It returns `False` if steps at cur index is 0, which means we cannot go any further.\\n- Lastly, we use dictionary/hashmap named `memo` to cache/memoize the path. Basic `caching/memoization`.\\n\\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n# Approach [Greedy]\\n\\nOkay so here we basically traverse reverse and keep shifting our Goal like so:\\n- if we can reach our current Goal from our current position then, we can shift our goal to current position because we no longer need to check if we can get to previous Goal because if we can get to the current position we can get to goal as well hence we can overall shift the goal itself.\\nWish I could say it better. LOL\\n\\n\\n# Code Explanation:\\nSo we start with Goal as `len(nums)-1`.\\n\\nConsider this pic:\\n - Goal marked with Green BOX.\\n - Indeces writeen with blue.\\n![jump1.PNG](https://assets.leetcode.com/users/images/3950dc19-e9c7-477f-849b-56bef24c6fa4_1672037205.3182197.png)\\n- So here we start with goal at INDEX 5.\\n- We Traverse from index 4 to 0.\\n- At Index 4 we see, Oh we can get to goal INDEX 5 from here so we set our new goal to Index 4.\\n![jump2.PNG](https://assets.leetcode.com/users/images/3323373d-d0c5-43b0-8b34-08959c72f096_1672037320.1121492.png)\\n- Again we check at Index 3, Oh we ca get to goal Index 4 from here, so we set our goal to Index 3.\\n![jump3.PNG](https://assets.leetcode.com/users/images/a4b46cd5-7b0f-4593-bb5f-ab9a5597a0bb_1672037373.798035.png)\\nAnd we keep moving on till the end of our traversal.\\nIf we end with Goal at 0, then we know oh yes we can actually reach the end. If not then NO.\\n\\n\\nConsider Example 2 of Example Testcases and we will see that we cannot reach the Goal and so our Goal does end at 0. Hence False.\\n\\nAlso, to check if we can get to a Goal or not we just check if the maximum number of steps from current position will lead us to position greater than or equal to our goal or not.\\nwritten in PYTHON as:\\n`if nums[ind]+ind >= goal:\\n    goal = ind`\\nBasically just shifting our GOAL if max capacity of cu rindex takes us on or farther than our GOAL.\\n\\n\\n# Code Python and JS\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        goal = len(nums)-1\\n        for ind in range(len(nums)-1, -1, -1):\\n            if (nums[ind] + ind) >= goal:\\n                goal = ind\\n        if goal == 0:\\n            return True\\n        return False\\n               \\n```\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    var goal = nums.length - 1;\\n    for (var i = (nums.length-1); i>=0; i--)\\n    {\\n        if (nums[i]+i >= goal)\\n            goal = i;\\n    }\\n\\n    if (goal == 0)\\n        return true;\\n    return false;\\n    \\n};\\n```\\n\\n# Time complexity:\\nBRUTE:\\n- O(n^2) after memoization O(a^n) before memo if a is avg of all elements in nums\\n\\nGreedy:\\n- O(n)\\n\\n# Space complexity:\\nIDK, O(1) for Greedy cause no extra space used, NOT SURE LOL!!\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(ind, memo):\\n            if ind in memo:\\n                return memo[ind]\\n            if ind >= len(nums)-1:\\n                return True \\n            if nums[ind] == 0:\\n                return False\\n            for steps in range(nums[ind], 0, -1):\\n                goTo = ind + steps\\n                if dfs(goTo, memo):\\n                    memo[ind] = True\\n                    return True\\n            memo[ind] = False\\n            return False\\n        return dfs(0, {})\\n\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        goal = len(nums)-1\\n        for ind in range(len(nums)-1, -1, -1):\\n            if (nums[ind] + ind) >= goal:\\n                goal = ind\\n        if goal == 0:\\n            return True\\n        return False\\n               \\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    var goal = nums.length - 1;\\n    for (var i = (nums.length-1); i>=0; i--)\\n    {\\n        if (nums[i]+i >= goal)\\n            goal = i;\\n    }\\n\\n    if (goal == 0)\\n        return true;\\n    return false;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833942,
                "title": "python-a-walrus-approved-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Python #1.** One-liner with walrus operator `:=` used to update state.\\n```\\nclass Solution:\\n    def canJump(self, nums, m = 0):\\n        return all(i <= m and 1+(m:=max(m,i+n)) for i,n in enumerate(nums))\\n```\\n\\n**Python #2.** The same logic, but using imperative style.\\n```\\nclass Solution:\\n    def canJump_(self, nums: List[int]) -> bool:\\n        m = 0\\n        for i,n in enumerate(nums):\\n            if i > m : return False\\n            m = max(m,i+n)\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums, m = 0):\\n        return all(i <= m and 1+(m:=max(m,i+n)) for i,n in enumerate(nums))\\n```\n```\\nclass Solution:\\n    def canJump_(self, nums: List[int]) -> bool:\\n        m = 0\\n        for i,n in enumerate(nums):\\n            if i > m : return False\\n            m = max(m,i+n)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045294,
                "title": "every-possible-simple-c-solution-additional-python-and-java-solutions-as-well",
                "content": "### Approach 1 : Brute Force\\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1) return true;\\n     \\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums);\\n        }\\n        return val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\\n\\nTime Complexity - O(K^N) where k is the max value in the array\\nSpace Complexity - O(N) - Recursive Stack Space\\n\\n### Approach 2 : Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1) return true;\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums, dp);\\n        }\\n        return dp[inx] = val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\\n\\nTime Complexity - O(K*N) where k is the max value in the array\\nSpace Complexity - O(N + N) - Recursive Stack Space + Memoization table\\n\\n### Approach 3 : Tabulation\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[nums.size()-1] = 1;\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            bool val = false;\\n            for(int i=1; i<=nums[inx]; i++){\\n               if(inx + i < nums.size()) val = val || dp[inx + i];\\n            }\\n            dp[inx] = val;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\nTime Complexity - O(K*N) where k is the max value in the array\\nSpace Complexity - O(N) - Dp Table\\n\\n### Approach 4 : Greedy\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size(), canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n};\\n```\\n\\nTime Complexity - O(N) \\nSpace Complexity - O(1)\\n\\n## **Java And Python Solutions**\\n\\n### Java Solution\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = Math.min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n}\\n```\\n\\n### Python Solution\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        canReach = n-1\\n        for curPos in range(n-1, -1, -1):\\n            if curPos + nums[curPos] >= canReach:\\n                canReach = min(curPos, canReach)\\n                \\n        return canReach == 0\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1) return true;\\n     \\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums);\\n        }\\n        return val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1) return true;\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums, dp);\\n        }\\n        return dp[inx] = val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[nums.size()-1] = 1;\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            bool val = false;\\n            for(int i=1; i<=nums[inx]; i++){\\n               if(inx + i < nums.size()) val = val || dp[inx + i];\\n            }\\n            dp[inx] = val;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size(), canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = Math.min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        canReach = n-1\\n        for curPos in range(n-1, -1, -1):\\n            if curPos + nums[curPos] >= canReach:\\n                canReach = min(curPos, canReach)\\n                \\n        return canReach == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732617,
                "title": "very-simple-and-fast-greedy-solution-with-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can found many Recursion with dp and tabulation solutions. But here we will discuss an ***very simple greedy solution that does not require any dynamic programming*** you just need a simple observation.\\n\\n---\\n\\n- Observation\\nfor any index ***i*** in the given array, if i know the nearest index value (*let it be **x***) from where i can reach to my destination then the only thing i need to check now is that\\nCan i reach at index ***x*** from my current position (that is index ***i***)?.\\n->this question can easily answered by checking a condition is ***(i+nums[i]>=x)*** true?\\n{\\nhere ***i+nums[i]*** -> the maximum distance(index value) that you can reach from ***i***th index. \\n}\\n- if the above condition is true -> then we can easily reach to x from our current index i and so on our destination.\\n- if the above condition is false -> then we can\\'t reach on our destination from our current index i.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nn=size of the given vector nums\\nOur destination is ***n-1***th index.\\n- Basic Fact -> we can always reach at ***n-1***th index from ***n-1***th index itself irrespective of value in ***nums[n-1]***\\n\\n- **Steps** :-\\n\\n1) We will maintain a variable (***x***) that stores the value of nearest index from which we can reach at n-1th index and initialize it with ***n-1***.\\n2) We will also maintain a *bool variable* (***ans***) that stores the truth value that can we reach at our destination from the current index? (initialize ans with value 0).\\n2) Now We will start a for loop from ***i=n-1*** to ***i=0*** and for each i we do :\\n    - if we can reach at ***x*** from ***i*** then we assign ***ans=1*** and update value of x as ***x=i***\\n    - else assign ***ans=0***\\n\\n\\n4. Finally return the ans.\\n\\n# Complexity\\n- Time complexity:\\n***O(n)***\\nAs we are Running a for loop from i=n-1 to i=0 So time complexity = O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* Time coplexity = O(n) || Space complexity = O(1). */\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n-1; //nearest variable from where we can reach (n-1)th index.(Greedy approach)\\n        bool ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+nums[i]>=x) //condition that can we reach to x from i.\\n            {\\n                ans=1;\\n                x=i; // update the value of x as we got a nearer point.\\n            }\\n            else ans=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n***Any Query/Suggestions are welcome***\\n\\n***\\uD83D\\uDC4D Upvote if you like***\\n\\n*for getting this code in other programming language you can comment here i will provide that ASAP.*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* Time coplexity = O(n) || Space complexity = O(1). */\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n-1; //nearest variable from where we can reach (n-1)th index.(Greedy approach)\\n        bool ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+nums[i]>=x) //condition that can we reach to x from i.\\n            {\\n                ans=1;\\n                x=i; // update the value of x as we got a nearer point.\\n            }\\n            else ans=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703697,
                "title": "c-solution-with-full-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- It passes **151 test cases** but ***Gives WRONG ANSWER!***\\n- This was the first approach that came to my mind.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- We took a variable temp to store the max jump possible.\\n- If at any point temp became equal to the current index ***i*** that means we can\\u2019t go to next position from here, simply return false.\\n- Any point if temp crosses the size of the given array, then simply return true.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]>=n-i-1) return true; \\n            if(nums[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n==1) return true;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            temp = max(temp, i+nums[i]);\\n            if(temp == i) return false;\\n            if(temp >= n-1) return true;\\n        }\\n        return false;\\n    }\\n    \\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]>=n-i-1) return true; \\n            if(nums[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n==1) return true;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            temp = max(temp, i+nums[i]);\\n            if(temp == i) return false;\\n            if(temp >= n-1) return true;\\n        }\\n        return false;\\n    }\\n    \\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545232,
                "title": "java-easy-to-understand-jump-game",
                "content": "Key for this problem **Think it from last index**, like we want to reach at last we can start from last and if reach at 0 or -ve index that means we find solution\\n\\n\\n```\\npublic boolean canJump(int[] nums) {\\n        int last = nums.length - 1; // last index/ position to reach \\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (i+nums[i] >= last) { // check if i+nums[i] >= last means we can reach to that index \\n\\t\\t\\t//with curr value and from current index and if yes then \\n\\t\\t\\t//change last to current index\\n                last = i;\\n            }\\n        }\\n        return last <= 0; // if last <= 0  then that means we can reach to solution if we start from begining also return true else false\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canJump(int[] nums) {\\n        int last = nums.length - 1; // last index/ position to reach \\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (i+nums[i] >= last) { // check if i+nums[i] >= last means we can reach to that index \\n\\t\\t\\t//with curr value and from current index and if yes then \\n\\t\\t\\t//change last to current index\\n                last = i;\\n            }\\n        }\\n        return last <= 0; // if last <= 0  then that means we can reach to solution if we start from begining also return true else false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500036,
                "title": "being-greedy-is-rewarding-sometimes-easy-to-understand-concise",
                "content": "## Approach 1:\\nThese type of problem can be solved using segmented bfs taking maximum element from a range it can go. Here my approach is to go as far as possible and once our index crosses the farthest then we return False as its not possible to reach the end.\\n\\n### Code\\n``` Python\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        farthest = 0\\n\\n        for index, value in enumerate(nums):\\n            if index > farthest:\\n                return False\\n            farthest = max(farthest, index+value)\\n        return True\\n```\\n\\n## Approach 2:\\nSimilar to problem 0045 Jump Game II, but here we need to check if we can reach the end. As in problem 0045 we can create cumulative maximum of i + nums[i] and check if for some element we have i == t[i]: if we have such place, we stuck and we can not reach the last cell, if not, we can reach.\\n\\n### Code:\\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\\nCerdits : [@Dmitry](https://leetcode.com/DBabichev/) \\n\\n## Approach 3:\\nI found it while searching for other answers and found it interesting \\nIdea:\\nConsider nums[i] to be the amount of fuel in the tank sitting at i that we can switch to. As moving from left to right, we lose 1 unit of fuel per step. At each index, we switch to the new tank if it has more fuel than what we have left. If the amount of fuel goes to zero somewhere in the middle, return False.\\n```\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        fuel = 0\\n        for i in range(len(nums)-1):\\n            fuel = max(fuel, nums[i])\\n            if fuel == 0:\\n                return False\\n            fuel -= 1\\n        return True\\n```\\n\\nCredits :- [Link Of Solution](https://leetcode.com/problems/jump-game/discuss/1500014/Python-O(N)-time-O(1)-space.-Switch-to-the-new-tank-whenever-you-can-gain-fuel.) \\n[Profile](https://leetcode.com/hkwu6013)\\n\\n## Complexity Analysis:\\nTime Complexity For Both is O(N)\\nSpace Complexity For approach 1 is O(1) and for Approach 2 is O(N)\\n\\n## Note:\\nIf You have any other answer in a different approach feel free to comment it down , I will add it and like you profile or page to the answer . **Hope you find it help full . If yes please Upvote it if no , feel free to place it down in the comment section.**",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "``` Python\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        farthest = 0\\n\\n        for index, value in enumerate(nums):\\n            if index > farthest:\\n                return False\\n            farthest = max(farthest, index+value)\\n        return True\\n```\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        fuel = 0\\n        for i in range(len(nums)-1):\\n            fuel = max(fuel, nums[i])\\n            if fuel == 0:\\n                return False\\n            fuel -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208231,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        int jump=nums[0];\\n        if(jump == 0) return false;\\n        \\n         for(int i=1; i<n; i++) \\n         {\\n             jump--;\\n             if(i==n-1) return true;\\n             jump = max(jump, nums[i]);\\n             if(jump==0) return false;\\n         }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        int jump=nums[0];\\n        if(jump == 0) return false;\\n        \\n         for(int i=1; i<n; i++) \\n         {\\n             jump--;\\n             if(i==n-1) return true;\\n             jump = max(jump, nums[i]);\\n             if(jump==0) return false;\\n         }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541554,
                "title": "dp-and-greedy",
                "content": "### DP\\n**state(i)** as whether we can jump to i.\\n**state(i) is true if any state(j) is true for j can jump to i.**\\nGoal state is **state(nums.length - 1)**.\\n```\\n    public boolean canJump(int[] nums) {\\n        boolean[] state = new boolean[nums.length];\\n        state[0] = true;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (state[j] && (j + nums[j] >= i)) { // from j, we can jump to i\\n                    state[i] = true;\\n                }\\n            }\\n        }\\n        return state[nums.length - 1];\\n    }\\n```\\n### Greedy\\nJump to the furthest place able to reach.\\n```\\n    public boolean canJump(int[] nums) {\\n        if (nums.length <= 1) {\\n            return true;\\n        }\\n        \\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > maxReach[i - 1]) {\\n                return false;\\n            }\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n            if (maxReach[i] >= nums.length - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        boolean[] state = new boolean[nums.length];\\n        state[0] = true;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (state[j] && (j + nums[j] >= i)) { // from j, we can jump to i\\n                    state[i] = true;\\n                }\\n            }\\n        }\\n        return state[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canJump(int[] nums) {\\n        if (nums.length <= 1) {\\n            return true;\\n        }\\n        \\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > maxReach[i - 1]) {\\n                return false;\\n            }\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n            if (maxReach[i] >= nums.length - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 153033,
                "title": "3-approaches-in-python-explained-clean",
                "content": "1) DP Recursive \\nResult: Ran out of stack space for this case\\n              [1,1,1,1,1,1,1...................................................................,1,1]\\nIdea is that from any given index say \\'idx\\' we can move to a next index in the range(1,nums[idx]+1) so we try all of them for all idx and check whether we can reach the last index. Since we may arrive at the same index  more than once, we memoize.\\n```\\nfrom functools import wraps\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        def memo(func):\\n            cache = {}\\n            @wraps(func)\\n            def wrap(*args):\\n                if args not in cache:\\n                    cache[args]=func(*args)\\n                return cache[args]\\n            return wrap\\n        @memo\\n        def solve(idx):\\n            if idx == len(nums)-1: \\n                return True\\n            if idx >= len(nums):\\n                return False\\n            return any([solve(idx+jumpDist) for jumpDist in range(1,nums[idx]+1)])\\n        \\n        return solve(0)\\n```\\n2) BFS\\nResult: Time Limist Exceeded (71/75 test cases passed)\\nIt is tempting to see that this just a search problem in an implicit graph. The nodes being indexes and edges connect one node to the next candidate neighboring (or) \"can jump to\" indexes. So we just perform a BFS carefully by not repeating ourselves, there is no need to construct the graph.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        fringe = deque([0])\\n        seen = set()\\n        canReachLast = False\\n        while fringe:\\n            idx = fringe.popleft()\\n            if idx == len(nums)-1: canReachLast = True\\n            seen.add(idx)\\n            for nextJump in range(1,nums[idx]+1):\\n                if idx+nextJump not in seen and idx+nextJump < len(nums):\\n                    fringe.append(idx+nextJump)\\n        return canReachLast\\n```\\n 3) Key observation that it is okay to overshoot in jumping process since we can easily choose to jump less. The only way you do not reach the end is when you do not have sufficient jumping capability or \\'jumpingPower\\' and that\\'s exactly what we check for.\\nResult: Accepted, beats 58%\\n ```\\n class Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # In general two cases arise when  we cannot reach the last index\\n        # 1) we overshoot as we can jump too far 2) we do not have enough jumping power to get there\\n        # 1) is not a possibility here as we can simply choose to jump less and get there\\n        # so we just have to check for 2)\\n        jumpingPower = 0\\n        for idx in range(len(nums)):\\n            # we reached an index that\\'s beyond the furthest we can reach\\n            # this is 2) we break out\\n            if idx > jumpingPower: break\\n            # update how far we can jump\\n            jumpingPower = max(nums[idx]+idx,jumpingPower)\\n        return jumpingPower >= len(nums)-1 \\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import wraps\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        def memo(func):\\n            cache = {}\\n            @wraps(func)\\n            def wrap(*args):\\n                if args not in cache:\\n                    cache[args]=func(*args)\\n                return cache[args]\\n            return wrap\\n        @memo\\n        def solve(idx):\\n            if idx == len(nums)-1: \\n                return True\\n            if idx >= len(nums):\\n                return False\\n            return any([solve(idx+jumpDist) for jumpDist in range(1,nums[idx]+1)])\\n        \\n        return solve(0)\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        fringe = deque([0])\\n        seen = set()\\n        canReachLast = False\\n        while fringe:\\n            idx = fringe.popleft()\\n            if idx == len(nums)-1: canReachLast = True\\n            seen.add(idx)\\n            for nextJump in range(1,nums[idx]+1):\\n                if idx+nextJump not in seen and idx+nextJump < len(nums):\\n                    fringe.append(idx+nextJump)\\n        return canReachLast\\n```\n```\\n class Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # In general two cases arise when  we cannot reach the last index\\n        # 1) we overshoot as we can jump too far 2) we do not have enough jumping power to get there\\n        # 1) is not a possibility here as we can simply choose to jump less and get there\\n        # so we just have to check for 2)\\n        jumpingPower = 0\\n        for idx in range(len(nums)):\\n            # we reached an index that\\'s beyond the furthest we can reach\\n            # this is 2) we break out\\n            if idx > jumpingPower: break\\n            # update how far we can jump\\n            jumpingPower = max(nums[idx]+idx,jumpingPower)\\n        return jumpingPower >= len(nums)-1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20894,
                "title": "c-simple-greedy-and-optimized",
                "content": "This one was fun.  I went from an O(N^2) algorithm to O(N) and learned how to be \"greedy\" :-)\\n\\nHere the difference from the other posts is that in for loop, the condition is optimized.  If we are going to check two conditions in the for loop, why not make sure those are optimal?  I believe the code is still readable but now the loop condition is optimized.\\n***\\n    /// <summary>\\n    /// Given an array of non-negative integers, you are initially positioned at \\n    /// the first index of the array. Each element in the array represents your \\n    /// maximum jump length at that position. Determine if you are able to reach\\n    /// the last index.\\n    /// </summary>\\n    /// <example>\\n    /// A = [2,3,1,1,4], return true.\\n    /// A = [3,2,1,0,4], return false.\\n    /// </example>\\n    public class Solution\\n    {\\n        public bool CanJump(int[] nums)\\n        {\\n            int maxJump = 0, lenMinus1 = nums.Length - 1;\\n\\n            for (int i=0; maxJump>=i && maxJump < lenMinus1; i++)\\n            {              \\n                if (i + nums[i] > maxJump)\\n                {\\n                    maxJump = i + nums[i];//if Ai=0, maxJump = i\\n                }\\n            }\\n\\n            return maxJump >= lenMinus1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public bool CanJump(int[] nums)\\n        {\\n            int maxJump = 0, lenMinus1 = nums.Length - 1;\\n\\n            for (int i=0; maxJump>=i && maxJump < lenMinus1; i++)\\n            {              \\n                if (i + nums[i] > maxJump)\\n                {\\n                    maxJump = i + nums[i];//if Ai=0, maxJump = i\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 21093,
                "title": "one-pass-solution-java",
                "content": "     public boolean canJump(int[] nums) {\\n            int max =0;\\n            for(int i=0;i<nums.length; i++){\\n                if(max<i) return false;\\n                max=Math.max(max, i+nums[i]);\\n            }\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "     public boolean canJump(int[] nums) {\\n            int max =0;\\n            for(int i=0;i<nums.length; i++){\\n                if(max<i) return false;\\n                max=Math.max(max, i+nums[i]);\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 21096,
                "title": "c-o-n-solution-with-comments",
                "content": "        \\n    bool canJump(vector<int>& nums) {\\n        unsigned int maxReach = 0;\\n        for (unsigned int i = 0; i < nums.size(); i++) {\\n            if (maxReach < i)  // cannot reach i \\n                return false;\\n            if (maxReach >= nums.size()-1)\\n                return true;  //early return \\n            maxReach = max(maxReach, i+nums[i]);\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "        \\n    bool canJump(vector<int>& nums) {\\n        unsigned int maxReach = 0;\\n        for (unsigned int i = 0; i < nums.size(); i++) {\\n            if (maxReach < i)  // cannot reach i \\n                return false;\\n            if (maxReach >= nums.size()-1)\\n                return true;  //early return \\n            maxReach = max(maxReach, i+nums[i]);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3573168,
                "title": "python-simple-solution-beats-81-14",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI can start from the finish line and problems only appear when there is a zero\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a greedy approach to iterate from the last index `j` towards the first index. It starts with `j` set to the last index of `nums`.\\n\\nIn each iteration, it checks if the element at index `j-1` is greater than 0. If it is, it means we can jump from index `j-1` to index `j`. In this case, it decrements `j` by 1 and continues to the next iteration.\\n\\nIf the element at index `j-1` is 0, it means we cannot jump from index `j-1` to index `j`. In this case, it enters a nested loop starting from index `i` set to `j-1` and iterates towards the first index (`i <= 0`).\\n\\nWithin the nested loop, it checks if the value at index `i` (`nums[i]`) is less than the distance between `j` and `i` (`j-i`). If it is, it means it is not possible to jump from index `i` to index `j` based on the value at index `i`. In this case, it decrements `i` by 1 and continues to check the previous indices.\\n\\nIf the nested loop reaches the first index (`i <= 0`) without finding a suitable index to jump from, it means it is not possible to reach the last index of `nums`. In this case, the code returns `False`.\\n\\nIf the outer loop completes and exits without encountering any issues, it means it is possible to reach the last index of `nums` based on the given jump values. The code then returns `True`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        j=len(nums)-1\\n\\n        while j>0:\\n            if nums[j-1]>0:\\n                j-=1\\n            else:\\n                i=j-1\\n                while nums[i]<j-i:\\n                    if i<=0:\\n                        return False\\n                    i-=1\\n                j=i\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        j=len(nums)-1\\n\\n        while j>0:\\n            if nums[j-1]>0:\\n                j-=1\\n            else:\\n                i=j-1\\n                while nums[i]<j-i:\\n                    if i<=0:\\n                        return False\\n                    i-=1\\n                j=i\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817477,
                "title": "c-5-lines-code-4-approaches-dp-easy-analysis-100",
                "content": "# Approach: Recursion\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n^10e5) [TLE]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) + space of Call Stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        \\n        bool res=false;\\n        for(int i=1; i<=nums[n]; i++){\\n            res= res||fn(nums, n+i);\\n        }\\n        return res;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        return fn(nums, 0);\\n    }\\n};\\n```\\n\\n# Approach: Recursion with DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [TLE]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + space of Call Stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1; i<=nums[n] and n+i < nums.size(); i++){\\n            if(fn(nums, n+i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        dp=vector<int>(nums.size()+1,-1);\\n        return fn(nums, 0);\\n    }\\n};\\n```\\n\\n# Approach: Iterative DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [Accepted, better than 18%]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n        dp[n-1] = true;\\n        for(int i = n-2; i >= 0; i--){\\n            for(int j=1; j<=nums[i] and i+j < n; j++){\\n                if(dp[i+j]){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n# Approach: Same concept no DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [Accepted, better than 100%]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(i+nums[i] >= last) last = i;\\n        }\\n        return last == 0;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        \\n        bool res=false;\\n        for(int i=1; i<=nums[n]; i++){\\n            res= res||fn(nums, n+i);\\n        }\\n        return res;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        return fn(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1; i<=nums[n] and n+i < nums.size(); i++){\\n            if(fn(nums, n+i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        dp=vector<int>(nums.size()+1,-1);\\n        return fn(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n        dp[n-1] = true;\\n        for(int i = n-2; i >= 0; i--){\\n            for(int j=1; j<=nums[i] and i+j < n; j++){\\n                if(dp[i+j]){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(i+nums[i] >= last) last = i;\\n        }\\n        return last == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310838,
                "title": "python3-solution-with-detailed-explanation-o-n-o-1",
                "content": "***Please upvote if this helps!***\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        # TC = O(n) ; SC = O(1) no extra space needed;\\n        # Greedy solution\\n        \\n        destination = len(nums) - 1\\n        for i in range(destination-1, -1 , -1):\\n            # start from the second last position of nums \\n            if i + nums[i] >= destination:\\n                # if from ith index, we can reach destination\\n                # update our destination to ith index\\n                destination = i\\n        # if destination reaches 0 meaning that we can reach end from first index\\n        # otherwise we can\\'t\\n        return destination == 0\\n        \\n        # Explanation:\\n        # Greedy approach:\\n        # We start at the last index of the array and work our way backwards\\n        # for eg: nums = [2,3,1,1,4]\\n        # so we start from our destination i.e. 4, and work our way towards it \\n        # meaning if we can reach 4 from its neighbour i.e. 1 , then it means \\n        # all we need to make sure is that we can reach 1;\\n        # because if we reach 1 we can obviously reach 4\\n        # similarly if we can reach first occurr of 1 from 3 then all we need to do is \\n\\t\\t# reach 3, because if we can, then we can reach 4 and so on.\\n        # NOTE: we dont want to minimize the number of steps to reach\\n        #       we just want to check if we can or cannot reach\\n        #       Thats why, this approach works.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "***Please upvote if this helps!***\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        # TC = O(n) ; SC = O(1) no extra space needed;\\n        # Greedy solution\\n        \\n        destination = len(nums) - 1\\n        for i in range(destination-1, -1 , -1):\\n            # start from the second last position of nums \\n            if i + nums[i] >= destination:\\n                # if from ith index, we can reach destination\\n                # update our destination to ith index\\n                destination = i\\n        # if destination reaches 0 meaning that we can reach end from first index\\n        # otherwise we can\\'t\\n        return destination == 0\\n        \\n        # Explanation:\\n        # Greedy approach:\\n        # We start at the last index of the array and work our way backwards\\n        # for eg: nums = [2,3,1,1,4]\\n        # so we start from our destination i.e. 4, and work our way towards it \\n        # meaning if we can reach 4 from its neighbour i.e. 1 , then it means \\n        # all we need to make sure is that we can reach 1;\\n        # because if we reach 1 we can obviously reach 4\\n        # similarly if we can reach first occurr of 1 from 3 then all we need to do is \\n\\t\\t# reach 3, because if we can, then we can reach 4 and so on.\\n        # NOTE: we dont want to minimize the number of steps to reach\\n        #       we just want to check if we can or cannot reach\\n        #       Thats why, this approach works.\\n",
                "codeTag": "Java"
            },
            {
                "id": 1255164,
                "title": "c-4-solutions-recursion-top-down-dp-bottom-up-dp-optimised-bottom-up-dp",
                "content": "**Solution 1 : Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        return canJump(nums, 0);\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 2 : Top Down DP**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr, vector <bool> dp) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        if (dp[curr]) {\\n            return dp[curr];\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i, dp)) {\\n                dp[curr] = true;\\n                return dp[curr];\\n            }\\n        }\\n        dp[curr] = false;\\n        return dp[curr];\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        vector <bool> dp(nums.size(), false);\\n        return canJump(nums, 0, dp);\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 3 : Bottom Up Way 1**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <bool> dp(n, false);\\n        dp[n - 1] = true;\\n        \\n        for (int curr = n - 2; curr >= 0; curr--) {    \\n            int last = min(n - 1, curr + nums[curr]);\\n            \\n            for (int next = curr + 1; next <= last; next++) {\\n                if (dp[next]) {\\n                    dp[curr] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 4 : Bottom Up Dp Way 2**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int target = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i + nums[i] >= target) {\\n                target = i;\\n            }\\n        }\\n        \\n        return target == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        return canJump(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr, vector <bool> dp) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        if (dp[curr]) {\\n            return dp[curr];\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i, dp)) {\\n                dp[curr] = true;\\n                return dp[curr];\\n            }\\n        }\\n        dp[curr] = false;\\n        return dp[curr];\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        vector <bool> dp(nums.size(), false);\\n        return canJump(nums, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <bool> dp(n, false);\\n        dp[n - 1] = true;\\n        \\n        for (int curr = n - 2; curr >= 0; curr--) {    \\n            int last = min(n - 1, curr + nums[curr]);\\n            \\n            for (int next = curr + 1; next <= last; next++) {\\n                if (dp[next]) {\\n                    dp[curr] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int target = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i + nums[i] >= target) {\\n                target = i;\\n            }\\n        }\\n        \\n        return target == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596403,
                "title": "python-really-kiss-solution",
                "content": "I started thinking of Dynamic Programming solution but in this case after re-reading the problem, I noticed that three interesting bits: \\n1. **non-negative integers** and \\n2. **Each element represents your maximum jump.** and \\n3. I only had to return **if I am able to find *a* solution** to the problem.\\n\\nThat means that I don\\'t really care about those values if they provide me enough *credit* to jump to the next cell.\\nGoing backwards, I always increment the `debit` of my cost to jump.\\nAs soon as I have a value that offsets my debit, I don\\'t really care of it\\'s value, and I can keep going.\\nOtherwise means that that cell doesn\\'t provide me enough `credits` to offset the `debit`, so I treat it as a `0 credit`: it\\'s a dead end.\\nIf I don\\'t have debit when I reach my first position, I know that there is A path.\\n\\nIf the problem wanted for example to count how many paths, then I was forced to do something more complex but we need to remember to KISS.\\nDynamic Programming is very powerful but also we shouldn\\'t immediately reach the most powerful tool for the job.\\n\\n-sorry, end of my preaching-\\n\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        debit = 0\\n        for i in reversed(nums[:-1]):\\n            debit += 1\\n            if i - debit >= 0:\\n                debit = 0\\n        return debit <= 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        debit = 0\\n        for i in reversed(nums[:-1]):\\n            debit += 1\\n            if i - debit >= 0:\\n                debit = 0\\n        return debit <= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182034,
                "title": "difference-between-dp-and-greedy",
                "content": "### Dynamic Programming\\nLooking from the end and at each point ahead checking the best possible way to reach the end\\n```\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> jump(n,false);\\n        jump[n-1]=true;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=nums[i] && j<n;j++)\\n            {\\n                if(jump[i+j]==true) \\n                {\\n                    jump[i]=true; \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return jump[0];\\n    }\\n```\\n\\n\\n### Greedy\\n[Reference](leetcode.com/problems/jump-game/discuss/20900/Simplest-O(N)-solution-with-constant-space/20948)\\nLooking from the start and selecting the locally optimum in the hope of reaching global optimum\\n```\\n    bool canJump(vector<int>& nums) {\\n      int n = nums.size(), farest = 0;\\n      for(int i = 0;i < n; i++)\\n      {\\n        if(farest < i) return false;\\n        farest = max(i + nums[i], farest);\\n      }\\n      \\n      return true;\\n    }\\n```\\n\\n\\n\\n\\n\\n\\n## Example\\n\\n\\t\\n![image](https://assets.leetcode.com/users/sohammehta/image_1539664091.png)\\n\\nIf we have a Greedy Approach here then we will take the path 1+99+1 as we select local optimum from the beggining\\n\\nBut if we take DP Approach then we start from back and find the cost of `reaching end` from `that specific node`. So when we reach the first node we will have two options\\n1. 99+1 path\\n2. 5+1 path\\nNow we simply have to decide between (1+(99+1)) and (20+(5+1)) path\\n\\n",
                "solutionTags": [],
                "code": "```\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> jump(n,false);\\n        jump[n-1]=true;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=nums[i] && j<n;j++)\\n            {\\n                if(jump[i+j]==true) \\n                {\\n                    jump[i]=true; \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return jump[0];\\n    }\\n```\n```\\n    bool canJump(vector<int>& nums) {\\n      int n = nums.size(), farest = 0;\\n      for(int i = 0;i < n; i++)\\n      {\\n        if(farest < i) return false;\\n        farest = max(i + nums[i], farest);\\n      }\\n      \\n      return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20897,
                "title": "recursive-and-non-recursive-solution-in-python-faster-than-100-python-solutions",
                "content": "At first I came up with this recursive solution, it is not difficult to think\\n```\\nif len(nums) == 1: return True\\nfor i in reversed(range(len(nums)-1)):\\n       if i + nums[i] >= len(nums) - 1:\\n           return self.canJump(nums[0:i+1])\\nreturn False\\n```\\nIt is like every time you look from the tail to see whether current index can get you into the last index and if we can reach last index from the current index, then current index becomes a new last index, we do the check again. \\n\\nThen I think it is not difficult to come up with the Non-recursive version evolved from the above solution:\\n\\n```\\n        last_index = len(nums) - 1\\n        for i in reversed(range(last_index)):\\n            if i + nums[i] >= last_index:\\n                last_index = i\\n        return last_index == 0\\n```",
                "solutionTags": [],
                "code": "```\\nif len(nums) == 1: return True\\nfor i in reversed(range(len(nums)-1)):\\n       if i + nums[i] >= len(nums) - 1:\\n           return self.canJump(nums[0:i+1])\\nreturn False\\n```\n```\\n        last_index = len(nums) - 1\\n        for i in reversed(range(last_index)):\\n            if i + nums[i] >= last_index:\\n                last_index = i\\n        return last_index == 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21165,
                "title": "easy-java-code-accepted-with-comments-for-understanding",
                "content": "just for record\\n\\n    public class Solution {\\n    public boolean canJump(int[] A) {\\n        int len=A.length;\\n        int ability=A[0];//the farmost grid index that can be reached\\n        for(int i=1;i<len;i++)\\n        {\\n            if(ability<i)//cannot reach beyond current grid by any means, return false\\n            return false;\\n            //update ability using the bigger grid index that can be reached\\n            ability=ability>i+A[i]?ability:i+A[i];\\n        }\\n        //loop finished, the last grid can be reached\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canJump(int[] A) {\\n        int len=A.length;\\n        int ability=A[0];//the farmost grid index that can be reached\\n        for(int i=1;i<len;i++)\\n        {\\n            if(ability<i)//cannot reach beyond current grid by any means, return false\\n            return false;\\n            //update ability using the bigger grid index that can be reached\\n            ability=ability>i+A[i]?ability:i+A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3541893,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "# #do upvote if u like solution #\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        if(nums[0]==0)\\n            return false;\\n        int dist=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==0 && dist==i)\\n            {\\n                return false;\\n            }\\n            dist=max(dist,nums[i]+i);\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        if(nums[0]==0)\\n            return false;\\n        int dist=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==0 && dist==i)\\n            {\\n                return false;\\n            }\\n            dist=max(dist,nums[i]+i);\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159874,
                "title": "c-greedy-dp-memiozation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is we can do recursion and check all the possiblities whther we are able to reach at the end or not. Then for optimization we can use DP or Memoization.\\nAlso there is a greedy apprpoach in which we check the maximum we can reach from an index . And using that we will check whther we can reach the end or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Greedy Appraoch:**\\n- We will keep track of max so far and also keep an end varaible which will be updated after checkig all the possiblites between curr and maxi beacuse  we are not sure initially what can be length of the jump we take . So after keeping track of max_so_far  and end we will check if our end >= n-1 i.e reached at the end or not and return true if reached else false.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**DP --> O(n^2) and O(n)**\\n```\\n bool rec(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind==arr.size()-1)return true;\\n        if(arr[ind]==0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){ \\n            if(i<arr.size() and rec(arr,i+ind,dp))\\n           return dp[ind]=true;\\n        }\\n        return dp[ind]=false;\\n    }\\n bool canJump(vector<int>& arr) {\\n        vector<int>dp(arr.size(),-1);\\n        return rec(arr,0,dp);\\n    }\\n```\\n**Greedy approach O(N) and O(1)**\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        int end=0,maxi=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,i+arr[i]);\\n            if(i==end){\\n                end=maxi;\\n            }\\n        }\\n        return end>=n-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n bool rec(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind==arr.size()-1)return true;\\n        if(arr[ind]==0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){ \\n            if(i<arr.size() and rec(arr,i+ind,dp))\\n           return dp[ind]=true;\\n        }\\n        return dp[ind]=false;\\n    }\\n bool canJump(vector<int>& arr) {\\n        vector<int>dp(arr.size(),-1);\\n        return rec(arr,0,dp);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        int end=0,maxi=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,i+arr[i]);\\n            if(i==end){\\n                end=maxi;\\n            }\\n        }\\n        return end>=n-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693089,
                "title": "c-easy-fast-and-clean-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<bool> dp(nums.size(), false);\\n        dp[0] = true;\\n        \\n        int n = nums.size();\\n        int i=0;\\n        while(i<n and !dp[n-1])\\n        {\\n            if(dp[i])\\n            {\\n                int step_length = nums[i];\\n                for(int j=0;j<=step_length and j+i<n; j++)\\n                dp[i+j] = true;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<bool> dp(nums.size(), false);\\n        dp[0] = true;\\n        \\n        int n = nums.size();\\n        int i=0;\\n        while(i<n and !dp[n-1])\\n        {\\n            if(dp[i])\\n            {\\n                int step_length = nums[i];\\n                for(int j=0;j<=step_length and j+i<n; j++)\\n                dp[i+j] = true;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367910,
                "title": "java-simple-5-lines-code-o-n-faster-than-100-o-1-space",
                "content": "```\\n public boolean canJump(int[] nums) {\\n        int last=nums.length-1;\\n        \\n        for(int i=last-1;i>=0;i--){\\n            if(i+nums[i] >= last)\\n                last=i;\\n        }\\n        return last==0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public boolean canJump(int[] nums) {\\n        int last=nums.length-1;\\n        \\n        for(int i=last-1;i>=0;i--){\\n            if(i+nums[i] >= last)\\n                last=i;\\n        }\\n        return last==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179976,
                "title": "straightforward-python-dp-accepted-and-recursive-mem-tle-solns-with-explanation",
                "content": "__DP:__\\nPretty straightforward dp case here, the main ideas:\\n-  We track that we can get to point dp[i] in our dp table.\\n-  To make it do dp[i] we search backward from the corresponding point nums[i] looking for a value that is >= the dist between the points.\\n-  If we find a point that contains such a value (```nums[j] >= (i-j)```) and has been reached (```dp[j]```) we know we can make this location.\\n-  We mark that we can make it and break the inner look to check the next location.\\n-  If ```dp[-1] == True``` it means that we can make it to the end.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = True\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if dp[j] and nums[j] >= (i-j):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n\\n__Recurison + Memoization (TLE):__\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) == 1:\\n            return True\\n        \\n        mem = {}\\n        \\n        def helper(idx):\\n            if idx >= len(nums):\\n                return False\\n            if idx == len(nums)-1:\\n                return True\\n            if idx in mem:\\n                return mem[idx]\\n            res = any([helper(i+idx) for i in range(nums[idx]+1) if (not (i+idx == idx) and i+idx not in mem)])\\n            mem[idx] = res\\n            return res\\n        \\n        return helper(0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```nums[j] >= (i-j)```\n```dp[j]```\n```dp[-1] == True```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = True\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if dp[j] and nums[j] >= (i-j):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) == 1:\\n            return True\\n        \\n        mem = {}\\n        \\n        def helper(idx):\\n            if idx >= len(nums):\\n                return False\\n            if idx == len(nums)-1:\\n                return True\\n            if idx in mem:\\n                return mem[idx]\\n            res = any([helper(i+idx) for i in range(nums[idx]+1) if (not (i+idx == idx) and i+idx not in mem)])\\n            mem[idx] = res\\n            return res\\n        \\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883692,
                "title": "python-dp-solution-with-explanation-for-time-limit-exceeded",
                "content": "This is an interesting problem. The DP solution is quite straight forward. \\n\\n**Idea:**\\n\\n- At pos `i`, check if there is a pos `j` (where `0<=j<i`), from where we can jump to pos `i`\\n\\n![image](https://assets.leetcode.com/users/images/980c7c13-abfb-4b76-bc70-899e26086894_1602089061.8129.png)\\n\\n\\nThe below solution is correct but it will throw `time limit exceeded` for the last test case which is a very large array of `1`s \\n\\n**Correct solutin but time limit exceeded**\\n\\nThe below solution is correct but due to `# line A` we encounter `time limit exceeded`. So we need to optimize there. \\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i):  # line A\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n               \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\\n\\n**Observation:**\\n\\n- As soon as `cond` (condition) is `True`, no need to iterate the inner loop.  `# line C`\\n- Run the `inner for loop` backward, thus you will encounter the required `True` condition earlier.  `# line B`\\n\\n**Final accepted solution**\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i-1,-1,-1):  # line B\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n\\t\\t\\t\\tif cond == True: break # line C\\n        \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\\n\\n_happy coding !!_",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i):  # line A\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n               \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i-1,-1,-1):  # line B\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n\\t\\t\\t\\tif cond == True: break # line C\\n        \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420615,
                "title": "javascript-solution-greedy",
                "content": "### The Idea\\n1. keep a record of the maximum feasible index\\n2. if an index is unfeasible, return false\\n\\n```\\nvar canJumpGreedy = function(nums) {\\n    let max = nums[0];\\n    for (let i=0;i<nums.length;i++) {\\n        if (max < i) return false\\n        max = Math.max(i+nums[i], max);\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canJumpGreedy = function(nums) {\\n    let max = nums[0];\\n    for (let i=0;i<nums.length;i++) {\\n        if (max < i) return false\\n        max = Math.max(i+nums[i], max);\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20898,
                "title": "java-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\n    //we can use dynamic programming.\\n    //for a given position i\\n    //OPT[i] represent whether it is possible to reach the last index or not.\\n    //OPT[i] = true if (i == last Index)\\n    //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]]\\n    //OPT[i] = false if (nums[i] == 0)\\n    //The result is opt[0];\\n    public boolean canJump(int[] nums) {\\n        boolean[] dp = new boolean[nums.length];\\n        Arrays.fill(dp, false);\\n        dp[nums.length-1] = true;\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] == 0)\\n                dp[i] = false;\\n            else{\\n                if(nums[i] + i >= nums.length)\\n                    dp[i] = true;\\n                else{\\n                   for(int j = 1; j <= nums[i]; j++){\\n                       dp[i] = dp[i] || dp[i + j];\\n                       //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them.\\n                       j += nums[i + j];\\n                   } \\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //we can use dynamic programming.\\n    //for a given position i\\n    //OPT[i] represent whether it is possible to reach the last index or not.\\n    //OPT[i] = true if (i == last Index)\\n    //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]]\\n    //OPT[i] = false if (nums[i] == 0)\\n    //The result is opt[0];\\n    public boolean canJump(int[] nums) {\\n        boolean[] dp = new boolean[nums.length];\\n        Arrays.fill(dp, false);\\n        dp[nums.length-1] = true;\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] == 0)\\n                dp[i] = false;\\n            else{\\n                if(nums[i] + i >= nums.length)\\n                    dp[i] = true;\\n                else{\\n                   for(int j = 1; j <= nums[i]; j++){\\n                       dp[i] = dp[i] || dp[i + j];\\n                       //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them.\\n                       j += nums[i + j];\\n                   } \\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20904,
                "title": "c-dp-solution-o-n",
                "content": "    bool canJump(vector<int>& nums) \\n    {\\n        int max_jump_index = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            max_jump_index = max(nums[i] + i, max_jump_index);\\n            if (max_jump_index < i + 1)\\n                break;\\n        }\\n        \\n        return max_jump_index >= nums.size() - 1;\\n    }",
                "solutionTags": [],
                "code": "    bool canJump(vector<int>& nums) \\n    {\\n        int max_jump_index = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            max_jump_index = max(nums[i] + i, max_jump_index);\\n            if (max_jump_index < i + 1)\\n                break;\\n        }\\n        \\n        return max_jump_index >= nums.size() - 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21075,
                "title": "short-c-implementation",
                "content": "Thanks the post from top voted solution.\\n\\nHere is the AC c++ implementation \\n\\n       class Solution {\\n        public:\\n            bool canJump(vector<int>& nums) {\\n                int n=nums.size();\\n                int i=0, reach=0;\\n                for(; i<n && i<=reach; i++)\\n                    reach=max(reach, i+nums[i]);\\n                return reach+1>=n;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            bool canJump(vector<int>& nums) {\\n                int n=nums.size();\\n                int i=0, reach=0;\\n                for(; i<n && i<=reach; i++)\\n                    reach=max(reach, i+nums[i]);\\n                return reach+1>=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 21127,
                "title": "python-different-solutions",
                "content": "        \\n    # DP (like Word Break I) LTE\\n    def canJump1(self, nums):\\n        dp = [True] * len(nums)\\n        for i in xrange(1, len(nums)):\\n            for j in xrange(i):\\n                dp[i] = dp[j] and nums[j] >= i-j\\n        return dp[-1]\\n      \\n    def canJump2(self, nums):\\n        maxReach = 0\\n        for i in xrange(len(nums)):\\n            if i > maxReach:\\n                return False\\n            maxReach = max(maxReach, i+nums[i])\\n        return True\\n        \\n    def canJump3(self, nums):\\n        remain = 0\\n        for i in xrange(len(nums)):\\n            remain = max(remain-1, nums[i])\\n            if remain == 0 and i < len(nums)-1:\\n                return False\\n        return True\\n        \\n    def canJump(self, nums):\\n        maxReach = 0\\n        i = 0\\n        while i < len(nums) and i <= maxReach:\\n            maxReach = max(maxReach, i+nums[i])\\n            i += 1\\n        return i == len(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # DP (like Word Break I) LTE\\n    def canJump1(self, nums):\\n        dp = [True] * len(nums)\\n        for i in xrange(1, len(nums)):\\n            for j in xrange(i):\\n                dp[i] = dp[j] and nums[j] >= i-j\\n        return dp[-1]\\n      \\n    def canJump2(self, nums):\\n        maxReach = 0\\n        for i in xrange(len(nums)):\\n            if i > maxReach:\\n                return False\\n            maxReach = max(maxReach, i+nums[i])\\n        return True\\n        \\n    def canJump3(self, nums):\\n        remain = 0\\n        for i in xrange(len(nums)):\\n            remain = max(remain-1, nums[i])\\n            if remain == 0 and i < len(nums)-1:\\n                return False\\n        return True\\n        \\n    def canJump(self, nums):\\n        maxReach = 0\\n        i = 0\\n        while i < len(nums) and i <= maxReach:\\n            maxReach = max(maxReach, i+nums[i])\\n            i += 1\\n        return i == len(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3653785,
                "title": "python-dp-memo-solution",
                "content": "# Approach\\nCreate an array containing information whether you can get to the i-th position.\\nWe can simply go through all elements of the array and then iterate over all possible jump lengths updating information in our boolean array.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where k is a sum of all jumps (sum of nums array)\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        dp=[False for _ in range(n)]\\n        dp[0]=True\\n\\n        for i in range(n):\\n            if dp[i]:   # if this position is reachable\\n                for j in range(1,nums[i]+1):\\n                    if i+j<n:\\n                        dp[i+j]=True\\n                    if i+j==n-1:\\n                        return True\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        dp=[False for _ in range(n)]\\n        dp[0]=True\\n\\n        for i in range(n):\\n            if dp[i]:   # if this position is reachable\\n                for j in range(1,nums[i]+1):\\n                    if i+j<n:\\n                        dp[i+j]=True\\n                    if i+j==n-1:\\n                        return True\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952145,
                "title": "java-simple-100-faster-video-explanation",
                "content": "\\nLook at the video to understand the approach[https://youtu.be/aeohnY2FQBI]()\\n\\n# Code\\n```\\n// Approach 1\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int reachable = 0;\\n        for(int i=0; i<n; i++){\\n            if(reachable < i) return false;\\n            reachable = Math.max(reachable, i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n-> Make sure to Upvote , it keeps me motivated.\\uD83D\\uDCAA \\n```\\n//Approach 2\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int index = nums.length-1;\\n        boolean answer;\\n        for(int i=nums.length-2; i > -1; i--){\\n            if(i+nums[i] >= index) index = i;\\n        }\\n        return answer = (index == 0)? true: false;\\n    }\\n}\\n```\\n- Time complexity : O(n)\\n- Space complexity : O(1)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n// Approach 1\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int reachable = 0;\\n        for(int i=0; i<n; i++){\\n            if(reachable < i) return false;\\n            reachable = Math.max(reachable, i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n//Approach 2\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int index = nums.length-1;\\n        boolean answer;\\n        for(int i=nums.length-2; i > -1; i--){\\n            if(i+nums[i] >= index) index = i;\\n        }\\n        return answer = (index == 0)? true: false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951793,
                "title": "greedy-o-n",
                "content": "```farthestPos``` represent the farthest position we can go\\nAt each position (index) in ```nums```, we find the farthest position we can go by comparing the ```farthestPos``` with the current position + jumpLength.\\nAt any time, if the ```farthestPos``` is larger than the last position (index) in ```nums```, return True\\nAt any time, if the ```farthestPos``` is smaller than the current position (index) in ```nums```, return False\\n\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        farthestPos = 0\\n        for curPos,jumpLength in enumerate(nums):\\n            \\n            # We CAN go to the curPos since it is covered by farthestPos\\n            # Update farthestPos\\n            if curPos <= farthestPos:\\n                farthestPos = max(farthestPos, curPos+jumpLength)\\n            \\n            # farthestPos doesn\\'t cover the curPos, we CAN NOT get to curPos, return False\\n            else:\\n                return False\\n            \\n            # Earlier return if the farthestPos covers our target position\\n            if farthestPos>=len(nums)-1:\\n                return True\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```farthestPos```\n```nums```\n```farthestPos```\n```farthestPos```\n```nums```\n```farthestPos```\n```nums```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        farthestPos = 0\\n        for curPos,jumpLength in enumerate(nums):\\n            \\n            # We CAN go to the curPos since it is covered by farthestPos\\n            # Update farthestPos\\n            if curPos <= farthestPos:\\n                farthestPos = max(farthestPos, curPos+jumpLength)\\n            \\n            # farthestPos doesn\\'t cover the curPos, we CAN NOT get to curPos, return False\\n            else:\\n                return False\\n            \\n            # Earlier return if the farthestPos covers our target position\\n            if farthestPos>=len(nums)-1:\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260211,
                "title": "2-solutions-dp-greedy",
                "content": "```\\n//Method-1 Greedy\\n//By just checking whether we are able to reach or not\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int maxReachable=0;\\n        for(int i=0;i<=maxReachable;i++)\\n        {\\n           if(maxReachable>=nums.size()-1)return true;\\n            maxReachable=max(maxReachable,i+nums[i]);\\n        }\\n        return maxReachable>=nums.size()-1;\\n    }\\n};\\n```\\n\\n```\\n//Method -2 Part 1Recursive\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(nums[i]==0)return false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j))return true;\\n        }\\n        return false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return util(nums,0);\\n    }\\n};\\n\\n```\\n```\\n//Method -2 Part 2 Memoized\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(nums[i]==0)return dp[i]=false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j,dp))return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return util(nums,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n//Method-1 Greedy\\n//By just checking whether we are able to reach or not\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int maxReachable=0;\\n        for(int i=0;i<=maxReachable;i++)\\n        {\\n           if(maxReachable>=nums.size()-1)return true;\\n            maxReachable=max(maxReachable,i+nums[i]);\\n        }\\n        return maxReachable>=nums.size()-1;\\n    }\\n};\\n```\n```\\n//Method -2 Part 1Recursive\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(nums[i]==0)return false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j))return true;\\n        }\\n        return false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return util(nums,0);\\n    }\\n};\\n\\n```\n```\\n//Method -2 Part 2 Memoized\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(nums[i]==0)return dp[i]=false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j,dp))return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return util(nums,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500046,
                "title": "c-greedy-approach-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& a) {\\n        int i,n=a.size(),maxi=0;\\n        if(n==1) return 1;\\n        for(i=0;i<n;i++){\\n            if(maxi>=i) maxi=max(maxi, i+a[i]);\\n        }\\n        return maxi>=(n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& a) {\\n        int i,n=a.size(),maxi=0;\\n        if(n==1) return 1;\\n        for(i=0;i<n;i++){\\n            if(maxi>=i) maxi=max(maxi, i+a[i]);\\n        }\\n        return maxi>=(n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889494,
                "title": "easiest-code-u-can-get",
                "content": "\\n# Approach\\nIterating from the End: The algorithm starts iterating through the array from the end towards the beginning. The variable index is used to keep track of the last known position that can reach the end of the array.\\n\\nUpdating index: For each element in reverse order, check if the sum of the current element\\'s value (nums[i]) and its index (i) is greater than or equal to the current value of index. If it is, update index to the current index i.\\n\\nFinal Check: After the loop finishes, if index is at the beginning (index 0), it means that you can jump from the start to the end of the array using the given jump values. In this case, return true, indicating that it\\'s possible to reach the end. Otherwise, return false\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index= nums.size()-1;\\n        for(int i = nums.size()-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=index)\\n            {\\n                index= i ;\\n            }\\n        }\\n        if(index==0)return true;\\n        else\\n        {\\n            return false;\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index= nums.size()-1;\\n        for(int i = nums.size()-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=index)\\n            {\\n                index= i ;\\n            }\\n        }\\n        if(index==0)return true;\\n        else\\n        {\\n            return false;\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500987,
                "title": "cool-c-o-n-o-1-in-5-lines-i-call-it-momentum",
                "content": "# Intuition\\nmaybe the easiest way?\\n\\n# Approach\\nmomentum: how further i can go\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int momentum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            momentum--;\\n            if (nums[i] > momentum) momentum = nums[i];\\n            if (i != nums.size() - 1 && momentum == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int momentum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            momentum--;\\n            if (nums[i] > momentum) momentum = nums[i];\\n            if (i != nums.size() - 1 && momentum == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952081,
                "title": "c-easy-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int dev=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(dev<i){\\n                return false;\\n            }\\n            dev=max(dev,i+nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int dev=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(dev<i){\\n                return false;\\n            }\\n            dev=max(dev,i+nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866646,
                "title": "golang-simple-solution",
                "content": "```\\nfunc canJump(nums []int) bool {\\n    if len(nums) == 0 {\\n        return false\\n    }\\n        \\n    if len(nums) == 1 {\\n        return true\\n    }\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    record := make(map[int]bool)\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = true\\n        } else {\\n            for key, _ := range record {\\n                if nums[i] >= key - i {\\n                    record[i] = true\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canJump(nums []int) bool {\\n    if len(nums) == 0 {\\n        return false\\n    }\\n        \\n    if len(nums) == 1 {\\n        return true\\n    }\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    record := make(map[int]bool)\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = true\\n        } else {\\n            for key, _ := range record {\\n                if nums[i] >= key - i {\\n                    record[i] = true\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825025,
                "title": "java-3-approaches-recursion-visited-bottom-up-dp-no-dp-explained",
                "content": "**What does the question ask for?**\\nThe question asks us to determine whether the end index is reachable from index 0.\\n\\n**How may we approach this problem?**\\nThe basic idea for this problem is to check the reachability of intermediate indexes to determine the reachability of some index\\n\\n# Approach #1 : Recursion + Visited\\n\\nWrite another method wherein we check whether the end index is reachable from the current index\\nIf we can reach to the current index from 0 and then from current index to end index,\\nthen we can surely reach from 0 to end index (0-> current index -> end index)\\n\\n**What is the purpose of visited?**\\nWhile calculating the reach. we may end up at the same index multiple times. If that index has been processed earlier -> Either it would have returned true, in which case, no more calculations would have been done, but since we encountered this index again, means that its result was false.\\n\\n```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        visited = new boolean[len];\\n        return canJump(0,len, nums, visited);\\n    }\\n    private boolean canJump(int ind, int len, int[] nums, boolean[] visited){\\n        if(ind>=len-1){\\n            return true;\\n        }\\n        if(visited[ind]){\\n            return false;\\n        }\\n        visited[ind]=true;\\n        int maxJumps = nums[ind];\\n        if(maxJumps==0){\\n            return false;\\n        }\\n        for(int i=maxJumps;i>=1;i--){\\n            if(canJump(ind+i, len, nums, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# Approach #2 : Bottom-up DP/Tabulation\\n\\n**How else can we solve the problem?**\\nIf the problem is solvable recursively, there will be an iterative solution as well.\\nThe idea for this approach is:\\nMaintain an array to check whether the current index is reachable from zero\\n\\n**How will we update reachable array?**\\nWe will use the idea of intermediate indexes:\\nSay we want to update index i\\nWe will consider some intermediate index j, s.t., 0<=j<i\\nThen:\\na) We will check that j is reachable from zero (using our reachable array)\\nb) We will check that i is reachable from j (Maximum index reachable from j = j+nums[j], if i<=max_index, then i is reachable otherwise not)\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        boolean[] isReachableFromZero = new boolean[len];\\n        isReachableFromZero[0] = true;\\n        for(int i=1;i<len;i++){\\n            for(int j=i-1;j>=0;j--){\\n                // If j is reachable from zero\\n                // and from j, we can reach i\\n                // Means we can reach i from Zero\\n                if(isReachableFromZero[j]&&j+nums[j]>=i){\\n                    isReachableFromZero[i]=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return isReachableFromZero[len-1];\\n    }\\n}\\n```\\n\\n# Approach #3: No DP\\n**What can we improve in the previous approach?**\\nWhat if instead of maintaining an array to check the reachability, we maintain a single variable that determines the maximum reachable index from 0 at a given iteration? In that case, we can simply check if the current index is within reach or out of reach, all the while updating max reach if current index is within reach.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        int maxReachFromZero = 0;\\n        for(int i=0;i<len;i++){\\n            if(i<=maxReachFromZero){\\n                maxReachFromZero = Math.max(maxReachFromZero,i+nums[i]);\\n            } else{\\n                return false;\\n            }\\n            if(maxReachFromZero>=len-1){\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**References:**\\n1.  https://leetcode.com/problems/jump-game/discuss/1819771/C%2B%2B-Memoization-(Top-Down)-and-Tabulation-(Bottom-Up)\\n2. https://leetcode.com/problems/jump-game/discuss/1820513/C%2B%2B-No-DP-Needed-Single-Traversal",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        visited = new boolean[len];\\n        return canJump(0,len, nums, visited);\\n    }\\n    private boolean canJump(int ind, int len, int[] nums, boolean[] visited){\\n        if(ind>=len-1){\\n            return true;\\n        }\\n        if(visited[ind]){\\n            return false;\\n        }\\n        visited[ind]=true;\\n        int maxJumps = nums[ind];\\n        if(maxJumps==0){\\n            return false;\\n        }\\n        for(int i=maxJumps;i>=1;i--){\\n            if(canJump(ind+i, len, nums, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        boolean[] isReachableFromZero = new boolean[len];\\n        isReachableFromZero[0] = true;\\n        for(int i=1;i<len;i++){\\n            for(int j=i-1;j>=0;j--){\\n                // If j is reachable from zero\\n                // and from j, we can reach i\\n                // Means we can reach i from Zero\\n                if(isReachableFromZero[j]&&j+nums[j]>=i){\\n                    isReachableFromZero[i]=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return isReachableFromZero[len-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        int maxReachFromZero = 0;\\n        for(int i=0;i<len;i++){\\n            if(i<=maxReachFromZero){\\n                maxReachFromZero = Math.max(maxReachFromZero,i+nums[i]);\\n            } else{\\n                return false;\\n            }\\n            if(maxReachFromZero>=len-1){\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668712,
                "title": "dp-greedy-c-soln-two-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& A) {\\n        int i = 0;\\n    for (int reach = 0; i < A.size() && i <= reach; ++i)\\n        reach = max(i + A[i], reach);\\n    return i == A.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& A) {\\n        int i = 0;\\n    for (int reach = 0; i < A.size() && i <= reach; ++i)\\n        reach = max(i + A[i], reach);\\n    return i == A.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576539,
                "title": "simple-python-solution-with-explanation",
                "content": "**explanation :** **https://github.com/midnightbot/leetcode_solutions/blob/main/55.%20Jump%20Game.pdf**\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        lastreached = len(nums)-1\\n        \\n        for x in range(len(nums)-2,-1,-1):\\n            if x+nums[x]>=lastreached:\\n                lastreached = x\\n                \\n                \\n        if lastreached == 0:\\n            return True\\n        \\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        lastreached = len(nums)-1\\n        \\n        for x in range(len(nums)-2,-1,-1):\\n            if x+nums[x]>=lastreached:\\n                lastreached = x\\n                \\n                \\n        if lastreached == 0:\\n            return True\\n        \\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557203,
                "title": "c-easy-solution-96-fast-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool canJump(vector<int>& v) {\\n        int n=v.size();\\n\\t\\t// res indicates that maximum on which index we can reach till now\\n        int res=0;\\n        int t=n-1;\\n\\t\\t// if only one elements is present then answer is always is true n=1 means t=0 , (t=n-1)\\n        if(t==0)return true;\\n        \\n\\t\\t// if first element is 0 and n>1 then answer is false\\n        if(v[0]==0)return false;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(v[i]+i>res and res>=i){\\n                res=v[i]+i;\\n            }\\n        }\\n        if(res>=t)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\nHope you like it.\\n\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool canJump(vector<int>& v) {\\n        int n=v.size();\\n\\t\\t// res indicates that maximum on which index we can reach till now\\n        int res=0;\\n        int t=n-1;\\n\\t\\t// if only one elements is present then answer is always is true n=1 means t=0 , (t=n-1)\\n        if(t==0)return true;\\n        \\n\\t\\t// if first element is 0 and n>1 then answer is false\\n        if(v[0]==0)return false;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(v[i]+i>res and res>=i){\\n                res=v[i]+i;\\n            }\\n        }\\n        if(res>=t)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501210,
                "title": "c-recursive-memoization-dp-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10005];\\n    bool solve(vector<int>& nums, int n, int idx){\\n        if(idx==n-1) return true;\\n        if(idx>=n) return false;\\n        if(!dp[idx]) return dp[idx];\\n        for(int i=1;i<=nums[idx];i++){\\n            if(solve(nums,n,idx+i)) return dp[idx] = true;\\n        }\\n        return dp[idx] = false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,n,0);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10005];\\n    bool solve(vector<int>& nums, int n, int idx){\\n        if(idx==n-1) return true;\\n        if(idx>=n) return false;\\n        if(!dp[idx]) return dp[idx];\\n        for(int i=1;i<=nums[idx];i++){\\n            if(solve(nums,n,idx+i)) return dp[idx] = true;\\n        }\\n        return dp[idx] = false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362214,
                "title": "two-solutions-using-dp-and-pointer",
                "content": "using dp and inserting index at most one can jump\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) \\n    {\\n        int n=nums.length;\\n       int[] dp=new int[n];\\n       dp[0]=nums[0];\\n        if(n==1) return true;\\n       for(int i=1;i<n-1;i++)\\n       {\\n            if(dp[i-1]<i) return false;\\n            \\n            dp[i]=Math.max(dp[i-1],nums[i]+i);\\n           \\n            if(dp[i]>=n-1) return true; \\n       }\\n       return dp[n-2]>=n-1?true:false;\\n    }\\n}\\n```\\nusing a pointer to keep data that index is reachable or not in reverse direction \\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int lastGoodIndex=nums[nums.length-1];// [3,2,1,0,4]\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=lastGoodIndex)\\n            {\\n                lastGoodIndex=i;\\n            }\\n        }\\n        return lastGoodIndex==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) \\n    {\\n        int n=nums.length;\\n       int[] dp=new int[n];\\n       dp[0]=nums[0];\\n        if(n==1) return true;\\n       for(int i=1;i<n-1;i++)\\n       {\\n            if(dp[i-1]<i) return false;\\n            \\n            dp[i]=Math.max(dp[i-1],nums[i]+i);\\n           \\n            if(dp[i]>=n-1) return true; \\n       }\\n       return dp[n-2]>=n-1?true:false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int lastGoodIndex=nums[nums.length-1];// [3,2,1,0,4]\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=lastGoodIndex)\\n            {\\n                lastGoodIndex=i;\\n            }\\n        }\\n        return lastGoodIndex==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087640,
                "title": "recursive-dp-bfs-greedy",
                "content": "recursion, time = exponential\\n```\\n//optimal substructure\\n//f(s,e) = if(f(v,e)) true, for all vertices  reachable from s, with e fixed\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return recur(nums,0);\\n    }\\n    \\n    boolean recur(int[] nums, int index) {\\n        if (nums.length-1==index) return true;\\n        int reach = nums[index] + index;\\n        for(int i = index+1; i<=reach;i++)\\n            if(recur(nums,i)) return true;\\n        return false;\\n    }\\n   \\n}\\n```\\ndp, time = O(n^2), space = O(n)\\n```\\n//optimal substructure\\n//f(s,e) = if(f(s,v)) true, for all vertices reachable to e, with s fixed\\nclass Solution {\\n \\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n];\\n        //base\\n        dp[0] =true;\\n        for(int e= 1; e<n;e++) {\\n            for(int v= e-1;v>=0;v--) {\\n                int v_reach = v+nums[v];\\n                if(e<=v_reach && dp[v]) {\\n                    dp[e] =true; \\n                    break;\\n                }       \\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n\\nbfs, time = O(V+E) = O(n^2), space= O(n)\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = v+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                    if(!visited[c]) {\\n                        q.offer(c);\\n                        visited[c] = true;\\n                    }\\n                }       \\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\\noptimized bfs, time = O(V+E) = O(n), space= O(n) \\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        int maxReach=-1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = maxReach+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                        q.offer(c);\\n                }      \\n                maxReach = Math.max(maxReach,v_reach);\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\\n\\ngreedy- maxReach/globalMaxReach approach, time O(n), space O(1), \\n```\\n//maxReach/globalMaxReach approach\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = -1;\\n        int globalMaxReach = -1;\\n        for(int i=0;i<n-1;i++) {\\n            maxReach = i + nums[i];\\n            globalMaxReach = Math.max(globalMaxReach,maxReach);\\n            if (i == globalMaxReach) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n//optimal substructure\\n//f(s,e) = if(f(v,e)) true, for all vertices  reachable from s, with e fixed\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return recur(nums,0);\\n    }\\n    \\n    boolean recur(int[] nums, int index) {\\n        if (nums.length-1==index) return true;\\n        int reach = nums[index] + index;\\n        for(int i = index+1; i<=reach;i++)\\n            if(recur(nums,i)) return true;\\n        return false;\\n    }\\n   \\n}\\n```\n```\\n//optimal substructure\\n//f(s,e) = if(f(s,v)) true, for all vertices reachable to e, with s fixed\\nclass Solution {\\n \\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n];\\n        //base\\n        dp[0] =true;\\n        for(int e= 1; e<n;e++) {\\n            for(int v= e-1;v>=0;v--) {\\n                int v_reach = v+nums[v];\\n                if(e<=v_reach && dp[v]) {\\n                    dp[e] =true; \\n                    break;\\n                }       \\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = v+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                    if(!visited[c]) {\\n                        q.offer(c);\\n                        visited[c] = true;\\n                    }\\n                }       \\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        int maxReach=-1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = maxReach+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                        q.offer(c);\\n                }      \\n                maxReach = Math.max(maxReach,v_reach);\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n//maxReach/globalMaxReach approach\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = -1;\\n        int globalMaxReach = -1;\\n        for(int i=0;i<n-1;i++) {\\n            maxReach = i + nums[i];\\n            globalMaxReach = Math.max(globalMaxReach,maxReach);\\n            if (i == globalMaxReach) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596250,
                "title": "c-o-n-time-o-1-space",
                "content": "At first I submitted a *O(N^2)* DP solution. However it will TLE.\\nIn fact, you only need to greedily keep updating the rightmost position you can jump to.\\n```class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxRight = 0;\\n        for (int i = 0; i < n; i++){\\n            if (i > maxRight) return false;\\n            maxRight = max(i + nums[i], maxRight);            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxRight = 0;\\n        for (int i = 0; i < n; i++){\\n            if (i > maxRight) return false;\\n            maxRight = max(i + nums[i], maxRight);            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443266,
                "title": "dp-or-top-down-memoized-solution-tles",
                "content": "Unlike what the solution may suggest DP or top down memoized solution TLEs in C++. \\n\\nI wasted a lot of time trying to figure out if there is a bug in my code and there isn\\'t. They just want it in o(n) time.\\n\\nThe only o(n^2) dp that worked for me is the following code\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), -1);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == -1){\\n                jumpable[i] = false;\\n            } else if(jumpable[i]){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```\\n\\nAnd even still slight modifications won\\'t allow this to work, like when I changed the ```vector<int>``` to ```vector<bool>```\\n\\nEdit:\\nDP solutioon that beats 97% in time complexity\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), 0);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == 1){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    if(jumpable[j] == 1){\\n                        break;\\n                    }\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), -1);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == -1){\\n                jumpable[i] = false;\\n            } else if(jumpable[i]){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```\n```vector<int>```\n```vector<bool>```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), 0);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == 1){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    if(jumpable[j] == 1){\\n                        break;\\n                    }\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414459,
                "title": "c-o-n-iterative",
                "content": "``` csharp\\npublic bool CanJump(int[] nums)\\n{\\n    int maxLength = 0;\\n    for (int i = 0; i < nums.Length - 1; i++)\\n    {\\n        if (nums[i] == 0 && maxLength == 0)\\n        {\\n            return false;\\n        }\\n        if (nums[i] >= maxLength)\\n        {\\n            maxLength = nums[i];\\n        }\\n        maxLength--;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic bool CanJump(int[] nums)\\n{\\n    int maxLength = 0;\\n    for (int i = 0; i < nums.Length - 1; i++)\\n    {\\n        if (nums[i] == 0 && maxLength == 0)\\n        {\\n            return false;\\n        }\\n        if (nums[i] >= maxLength)\\n        {\\n            maxLength = nums[i];\\n        }\\n        maxLength--;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114802,
                "title": "python-dp-o-n-solution-accepted",
                "content": "Here, I share my python solution using dynamic programing. The key to reduce the time complexity from ```O(n^2)``` to ```O(n)``` is to define the state ```dp[i]``` as the maximum index one can jump after reach index ```i```. \\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<2:\\n            return True\\n        dp    = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            if dp[i-1]<i:\\n                return False\\n            dp[i] = max(dp[i-1], i + nums[i])\\n        return dp[-1]>=len(nums)-1\\n```",
                "solutionTags": [],
                "code": "```O(n^2)```\n```O(n)```\n```dp[i]```\n```i```\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<2:\\n            return True\\n        dp    = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            if dp[i-1]<i:\\n                return False\\n            dp[i] = max(dp[i-1], i + nums[i])\\n        return dp[-1]>=len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20896,
                "title": "python-and-91-fast-time-idon-t-know-if-it-s-greedy-maybe-not",
                "content": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n         \\n        if len(nums) <= 1:\\n            return True\\n        j = len(nums) - 2\\n        i = len(nums) - 1    \\n        while j > -1:\\n            if j + nums[j] >= i:\\n                i = j\\n                j -= 1\\n                \\n            else:\\n                j -= 1\\n        #print('i', i, 'j', j)\\n        if i <= 0:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n         \\n        if len(nums) <= 1:\\n            return True\\n        j = len(nums) - 2\\n        i = len(nums) - 1    \\n        while j > -1:\\n            if j + nums[j] >= i:\\n                i = j\\n                j -= 1\\n                \\n            else:\\n                j -= 1\\n        #print('i', i, 'j', j)\\n        if i <= 0:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 4018177,
                "title": "use-a-counter-to-count-on-your-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key mindset here is to use a counter to count on residual steps.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake k as your residual steps. Everytime you move, k-1. If nums[i] offers you more steps, take it! If you run out of your move and can\\'t move to finishing line, you fail. Otherwise, return True.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return True\\n        k = nums[0]\\n        for i in range(len(nums)-1):\\n            if nums[i] > k:\\n                k = nums[i]\\n            k = k - 1\\n            if k < 0 :\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return True\\n        k = nums[0]\\n        for i in range(len(nums)-1):\\n            if nums[i] > k:\\n                k = nums[i]\\n            k = k - 1\\n            if k < 0 :\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779748,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]+i>=index)index=i;\\n        }\\n        if(index==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]+i>=index)index=i;\\n        }\\n        if(index==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652039,
                "title": "beats-99-runtime-and-80-memory-very-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGoing from the backward. If you can reach the final point from right before one, replace the goal with the index of the right before point.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]: #4,3,2,1,0\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]: #4,3,2,1,0\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078478,
                "title": "very-easy-c-solution-in-o-n-time-beats-99-12",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n     int target=0;\\n\\n     for(int i=0; i<=target; i++){\\ntarget= max(target, i+nums[i]);\\n\\nif(target>=nums.size()-1){\\nreturn true;\\n}\\n     }   \\n   return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n     int target=0;\\n\\n     for(int i=0; i<=target; i++){\\ntarget= max(target, i+nums[i]);\\n\\nif(target>=nums.size()-1){\\nreturn true;\\n}\\n     }   \\n   return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951498,
                "title": "python-3-7-lines-iteration-w-explanation-t-m-94-98",
                "content": "The problem reduces to whether there is a zero in any position other than position n[-1], and if so, whether there is a reachable cell beyond each such zero. \\n```\\nclass Solution:     \\n \\n\\n    def canJump(self, n: list[int]) -> bool:\\n        \\n        if 0 not in n[:-1] or len(n) == 1: return True\\n\\n        pt = n.index(0)            \\n\\n        for i in range(len(n)):\\n\\n            if i <= pt and  i + n[i] > pt: pt = i + n[i]\\n\\n            if i == pt and not n[i]: return False\\n            if pt >= len(n)-1      : return True\\n\\n        return True\\n```\\n[https://leetcode.com/problems/jump-game/submissions/865477602/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1) .\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:     \\n \\n\\n    def canJump(self, n: list[int]) -> bool:\\n        \\n        if 0 not in n[:-1] or len(n) == 1: return True\\n\\n        pt = n.index(0)            \\n\\n        for i in range(len(n)):\\n\\n            if i <= pt and  i + n[i] > pt: pt = i + n[i]\\n\\n            if i == pt and not n[i]: return False\\n            if pt >= len(n)-1      : return True\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531333,
                "title": "simple-ts-with-explanation",
                "content": "Practically speaking, if the array contains no stopping points (`nums[i] = 0 ` for any `i`) then we can always reach the end index by always jumping 1 step forward regardless of the value we are standing at \\nFor example: `[2, 3, 4, 5, 1, 6, 7]` we can always just use 1 step at each point to reach the end\\nWith that being said, the tricky part is when zeroes are involved, and that is basically the whole point of the problem\\nLet us say we want to move one step at a time and store how many steps are left to carry us forward, and if we have none left then we break early and return false\\nCan we skip past **all** zeroes with the number of steps we have left? If so then we return true\\nLet us store how many steps are `left` for the previous index, and if we are standing on a new index whose `nums[i]` value gives us more steps, then we \"reimburse\" ourselves with that new value by replacing `left`  with `nums[i]`\\nIf `left == 0` then there are no ways to move forward and we have ran out of steps because we must have encountered a zero value that stops us dead in our tracks with no more steps in the \"bank\"\\n```\\nfunction canJump(nums: number[]): boolean {\\n    let left = nums[0]\\n    for(let i = 1; i < nums.length; i++) {\\n        if(left == 0) {\\n            return false\\n        }\\n        left = Math.max(left - 1, nums[i])\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction canJump(nums: number[]): boolean {\\n    let left = nums[0]\\n    for(let i = 1; i < nums.length; i++) {\\n        if(left == 0) {\\n            return false\\n        }\\n        left = Math.max(left - 1, nums[i])\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488405,
                "title": "python-backtracking-greedy-interview-pov",
                "content": "Intutions that pops up during an interview:\\nIf we are not able to think about the solutions right off the bat , think about base cases/invalid cases. \\nPoints to consider : \\n1. The only hurdle that stops us moving towards the destination is \"0\" ,So we can check if the value at 0th index is 0 then directly return False as we cannot move ahead.\\n2. How about checking 0s on every index before taking a call to jump? will it work? lets see\\n [1,2,0,1,1]\\nFrom 2nd position(1 based index) you either need to jump 1 step or 2 steps , since 1 step is giving you 0, you have to **BackTrack** and jump 2 steps to reach the destination. \\n\\nHence from the above 2 points we can say that from every step we need to decide and consider all the paths by BackTracking \\nGood , atleast we were able to give some bruteforce algo now, Lets code it up with some help :\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def recurJump(index):\\n            if index>=len(nums)-1:\\n                return True\\n\\t\\t\\t#Checking all the possible values by backTracking starting from 1 , if the value is 0 , our code would return False as it would not enter the for loop\\n            for i in range(1,nums[index]+1):\\n                if(recurJump(index+i)):\\n                    return True\\n            return False\\n        return(recurJump(0))\\n```\\nNow , The above solution works perfectly in the case of smaller inputs , what if the values are 10^something then we end up looping /backTracking every value to reach the destination which is very expensive .\\nCan we think of something else ?\\nhmmmm.....\\n.hmmmm....\\n.hmmm...\\nAt this moment inteviwer would give some hints : \\n1. Why dont you try from the last ?\\n2. Do you really need backTracking if you try from the last ? \\n\\n\\nOhhh, okay Lemme think ...\\nif i get to try from the last position (ie my destination) , i will jus have to validate if am able to reach the destination by visting destination-1 th position\\n for eg : \\n [4,2,3,1,5] ---> 1 based index\\n To reach 5th position, i will jus have to validate if am able to reach5th index from 4th index , by checking if the (value at 4th index+4th index ) should be equal or greater than than the destination position ie 5th index here  Hence for the above example i would be checking \\n \\n 1(value at 4th index)+4(index) >= destination index(5) \\n Yeah am able to reach , okay now change the destionation to 4th position and redo the same for every value and finally return True if your destination is at 0th index after all the movements else return False \\n ```\\n  currDestination=len(nums)-1\\n        for i in range(len(nums)-2,-1,-1):\\n            if (i+nums[i])>=currDestination:\\n                currDestination=i\\n        return True if currDestination==0 else False",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def recurJump(index):\\n            if index>=len(nums)-1:\\n                return True\\n\\t\\t\\t#Checking all the possible values by backTracking starting from 1 , if the value is 0 , our code would return False as it would not enter the for loop\\n            for i in range(1,nums[index]+1):\\n                if(recurJump(index+i)):\\n                    return True\\n            return False\\n        return(recurJump(0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381515,
                "title": "o-n-python-solution",
                "content": "Please Upvote if you like the solution\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==0:\\n            return False\\n        elif len(nums)==1:\\n            return True\\n        reach=nums[0]\\n        for i in range(0,len(nums)):\\n            if i>reach:\\n                return False\\n            reach=max(reach,i+nums[i])\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==0:\\n            return False\\n        elif len(nums)==1:\\n            return True\\n        reach=nums[0]\\n        for i in range(0,len(nums)):\\n            if i>reach:\\n                return False\\n            reach=max(reach,i+nums[i])\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188884,
                "title": "java-in-depth-explanation-o-n-time-and-o-1-space",
                "content": "I have my solution in Java here w/  **O(n) time** and **O(1) space**. I think my solution is much easier to understand and implement. \\n\\n  The first step is to declare a int variable `max_reach` to track what\\'s the max index we can reach to. Eventually, we know we can return true once `max_reach >= nums.length - 1`. Hence, we can use a for-loop to update `max_reach`. \\n\\n  (1) if `max_reach < i` then return **false**. We do so because if max_reach is smaller than i, that means we are not able to reach to `idx i`. Then we return false for sure.\\n\\n  (2) `max_reach = Math.max(max_reach, i + nums[i])`. When come to here, we know that we are able to reach `idx i` already. Now we want to update our `max_reach`. We are at `idx i` so let\\'s compare `max_reach` and `i + nums[i]`. Why it\\'s `i + nums[i]` ? We are at `idx i` so `i + nums[i]` would be the max index we can reach at `idx i`. \\n\\n```\\nclass Solution \\n{\\n    public boolean canJump(int[] nums) \\n    {\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(max_reach < i)\\n                return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean canJump(int[] nums) \\n    {\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(max_reach < i)\\n                return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043503,
                "title": "weeb-explains-python-c-dp-o-n-time-o-1-space",
                "content": "I will explain my thought process on how i solved this problem.\\n\\n# Understanding the question:\\nOur goal is to check whether we can reach the **last index**, given that we start on the **first index**\\nEach nums[i] represents the **maximum** jump distance from i to some index j.\\n\\n# Observations:\\n***1st Observation***\\nMy first thought was that **if a path exists**, then that means there must be **at least one** possible path to reach the last index.\\nSince we just want to know whether we can reach the last index, then **it does not matter which path we take to reach the last index**, we **only need to reach the last index, regardless of which path we take**.\\n\\n***2nd Observation***\\nWe now know that it doesn\\'t matter which path we take to reach the last index. This subproblem is solved.\\nSo, **what is the next subproblem?**\\nFor me, the question was,**how do we figure out which path(out of all the valid paths) do we take to reach the last index?**\\nLets assume that a path exists, we shall represent the path as some nodes.\\nlet the nodes be A, B, C, D, E respectively. Where **A is the first index**, and **E is the last index**, **B, C, and D are some nodes in between to contribute the the path to reach the last index**.\\nI noticed that, to go from A to E, we need to go through B, C and D.\\nThen, that means **D is dependent on E, and C is dependent on D, and B is dependent on C.**\\nIn simpler terms, **to get to E, we need to start on D, to get to D, we need to start on C, to get to C, we need to start on B and so on.**\\nSo, A -> B -> C -> D -> E.\\nfrom this, I deduced that the the **current node is dependent on the on the previous node**, which leads to the **idea of backtracking from the last index to the first index.**\\n\\n***3rd Observation***\\nNotice that, if nums does not contain a 0, that is, nums[i] != 0 for 0<=i<=len(nums)-1, then **there is always a path**.\\nWhy? Because from the 1st observation , we deduced that it we **only need to reach the last index, regardless of which path we take**.\\nBut, what if nums[i] == 0?\\n\\n***4th Observation***\\nThe idea is to check whether its possible to  **\"skip\"** nums[i] == 0. But how?\\nLet nums = [2,0,1,0], the result for this is True\\nwe know that the path is 2 -> 1 -> 0\\nSince, **from the 2nd observation**, we know that we need to use **backtracking**, we woud\\'nt know that \\n2->1->0 is valid path without iterating through nums[1], which is 0.\\nFor me, i thought of the idea **using a count, and to accumulate this count to compare it the previous indexes, i.e index 0 to index i**\\nWhen we encounter a number greater than or equal to count, i.e **nums[j] >= count**. We **reset the count**, and repeat this step again when we encounter another nums[i] == 0.\\nif **nums[j] < count**, then we still continue until we reach the last index(**while adding count by 1 for each iteration**), if count is still > 0 at the first index, then we cannot skip that nums[i] == 0, so we **return False**\\n\\n**Why do we add 1 to count for each iteration?** \\nBecause, as we backtrack by 1 step for each iteration, we need 1 more step to skip nums[i] == 0.\\n\\n**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef canJump(self, nums: List[int]) -> bool:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\t\\t\\tif nums[i] == 0: count += 1\\n\\n\\t\\t\\t\\tif count != 0 and nums[i] != 0:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif nums[i] >= count:\\n\\t\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\treturn True if count == 0 else False\\n\\t\\n**C++**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canJump(vector<int>& nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i = nums.size()-2; i>-1; i--){\\n\\t\\t\\t\\tif (nums[i] == 0) count += 1;\\n\\n\\t\\t\\t\\tif (count != 0 && nums[i] !=0){\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t\\tif (nums[i] >= count) count = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn (count == 0) ? true : false;\\n\\t\\t}\\n\\t};\\n\\nTake a break from dp, watch some anime instead\\nCheck out **\\u65F6\\u5149\\u4EE3\\u7406\\u4EBA (Link Click)**\\n\\n# Episodes: 11\\n# Genres: Drama, Supernatural\\n# Theme: Time Travel\\n\\nThis show is a good one, pls watch it.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution:\\n\\t\\tdef canJump(self, nums: List[int]) -> bool:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\t\\t\\tif nums[i] == 0: count += 1\\n\\n\\t\\t\\t\\tif count != 0 and nums[i] != 0:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif nums[i] >= count:\\n\\t\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\treturn True if count == 0 else False\\n\\t\\n**C++**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canJump(vector<int>& nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i = nums.size()-2; i>-1; i--){\\n\\t\\t\\t\\tif (nums[i] == 0) count += 1;\\n\\n\\t\\t\\t\\tif (count != 0 && nums[i] !=0){\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t\\tif (nums[i] >= count) count = 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1737483,
                "title": "fast-c-simple-tc-o-n-sc-o-1-single-loop",
                "content": "- we find the max reach distance at every point\\n- if at any point less then last index, max-reach point is 0, we return \"false\"\\n\\n```cpp\\nbool canJump(vector<int>& nums) {\\n        int maxReach=nums[0];\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(maxReach == 0) return 0;\\n            maxReach--;\\n            if(nums[i] > maxReach) maxReach = nums[i];\\n        }\\n        return 1;\\n    }\\n```\\n\\n- please upvote my solution if you like it, as it motivates a lot. THANK YOU",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nbool canJump(vector<int>& nums) {\\n        int maxReach=nums[0];\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(maxReach == 0) return 0;\\n            maxReach--;\\n            if(nums[i] > maxReach) maxReach = nums[i];\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734799,
                "title": "brute-force-recursion-both-explained",
                "content": "**!!!!!!...Please upvote if you like it/........**\\n**Brute force:**\\n```\\nclass Solution {\\npublic:\\n \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0;//couting the current reaching positon\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>reach)\\n            {\\n                return false;//is cuurent value extend the reach value we have to return false\\n            }\\n            reach=max(reach,i+nums[i]);// move and find the maximum possible reach \\n            \\n        }\\n        return true;\\n    \\n    }\\n};\\n```\\n**-------------------------------------------------**\\n**Recursion+Memorisation**\\n```\\nclass Solution {\\npublic:\\n    int dp[100001];//intialsation of value\\n    \\n    bool solve(int s,int n, vector<int>&nums)\\n    {\\n        if(s>=n)\\n        {\\n\\t\\t// if we able to reach the end point of array ie: `n-1` return true\\n            return dp[s]=1;\\n        }\\n        if(s>n)\\n        {\\n            return dp[s]=0;//if we reach  beyond the end point of array ie:(n,n+1,n+2......)return false\\n        }\\n\\t\\t//if answer is already present in dp array we only return it\\n        if(dp[s]!=-1)\\n        {\\n            return dp[s];\\n        }\\n\\t\\t// now we check every possible positon and combination=>(s+i)\\n        for(int i=1;i<=nums[s];i++)\\n        {\\n            if(solve(s+i,n,nums))\\n            {\\n                return dp[s]=1;\\n            }\\n           \\n        }\\n         return dp[s]=0;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//intitalstaion of dp\\n        for(int i=0;i<100001;i++)\\n        {\\n            dp[i]=-1;\\n        }\\n\\t\\t// recursion start===>start with intial value 0 and reach at n-1\\n        return solve(0,n-1,nums);\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0;//couting the current reaching positon\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>reach)\\n            {\\n                return false;//is cuurent value extend the reach value we have to return false\\n            }\\n            reach=max(reach,i+nums[i]);// move and find the maximum possible reach \\n            \\n        }\\n        return true;\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100001];//intialsation of value\\n    \\n    bool solve(int s,int n, vector<int>&nums)\\n    {\\n        if(s>=n)\\n        {\\n\\t\\t// if we able to reach the end point of array ie: `n-1` return true\\n            return dp[s]=1;\\n        }\\n        if(s>n)\\n        {\\n            return dp[s]=0;//if we reach  beyond the end point of array ie:(n,n+1,n+2......)return false\\n        }\\n\\t\\t//if answer is already present in dp array we only return it\\n        if(dp[s]!=-1)\\n        {\\n            return dp[s];\\n        }\\n\\t\\t// now we check every possible positon and combination=>(s+i)\\n        for(int i=1;i<=nums[s];i++)\\n        {\\n            if(solve(s+i,n,nums))\\n            {\\n                return dp[s]=1;\\n            }\\n           \\n        }\\n         return dp[s]=0;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//intitalstaion of dp\\n        for(int i=0;i<100001;i++)\\n        {\\n            dp[i]=-1;\\n        }\\n\\t\\t// recursion start===>start with intial value 0 and reach at n-1\\n        return solve(0,n-1,nums);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1558758,
                "title": "super-easy-c-solution-100-speed-greedy",
                "content": "**Intuition:**\\nCan  anyone reach to lastindex - starting from lastindex itself\\n\\n**Technique - Greedy**\\nUsing index+nums[i] >= lastindex, then true;\\n        \\n**CODE with Explaination**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int last_best_index_pos =nums.size()-1; // at last position \\n        \\n        //Using index+nums[i] >= lastindex, then true;\\n        //Intuition: Can I anyone reach to lastindex - starting from lastindex itself\\n        \\n        \\n        for(int i=nums.size()-1; i>=0;i--)\\n        {\\n            if(i+nums[i] >=last_best_index_pos)\\n            {\\n                last_best_index_pos =i; // can anyone reach to current index\\n            }\\n        }\\n        \\n        \\n        return (last_best_index_pos ==0); //if TRUE, reachable index is 0,then it means that OFCOURSE none of the index can reach index 0, \\n        // You did it!\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int last_best_index_pos =nums.size()-1; // at last position \\n        \\n        //Using index+nums[i] >= lastindex, then true;\\n        //Intuition: Can I anyone reach to lastindex - starting from lastindex itself\\n        \\n        \\n        for(int i=nums.size()-1; i>=0;i--)\\n        {\\n            if(i+nums[i] >=last_best_index_pos)\\n            {\\n                last_best_index_pos =i; // can anyone reach to current index\\n            }\\n        }\\n        \\n        \\n        return (last_best_index_pos ==0); //if TRUE, reachable index is 0,then it means that OFCOURSE none of the index can reach index 0, \\n        // You did it!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520508,
                "title": "any-beginner-looking-for-recursive-top-down-approach-dynamic-programming",
                "content": "just reverse the array and follow it up recursively\\n```\\nclass Solution {\\n    vector<int>dp;\\n    int helper(vector<int>& nums,int n){\\n        if(n<0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        for (int  i = 1; i <=nums[n]; i++)\\n        {\\n            if(helper(nums,n-i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        reverse(nums.begin(),nums.end());\\n        dp.resize(nums.size(),-1);\\n        dp[0]=1;\\n        return helper(nums,nums.size()-1);\\n    }\\n};\\n```\\nIt\\'s not the best optimised version . But I think it\\'s good for any beginner who is looking for dp solution but not able to find it . It\\'s also called Dynamic programming solution since we have memosized the recursive solution.\\nThanks",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>dp;\\n    int helper(vector<int>& nums,int n){\\n        if(n<0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        for (int  i = 1; i <=nums[n]; i++)\\n        {\\n            if(helper(nums,n-i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        reverse(nums.begin(),nums.end());\\n        dp.resize(nums.size(),-1);\\n        dp[0]=1;\\n        return helper(nums,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429371,
                "title": "java-1ms-faster-than-100-o-n-with-comment",
                "content": "```\\n// Approach: Iterate from the end of array till the begening\\n// At each position, check if u r able to reach to the next position with given number of jumps at that position\\npublic boolean canJump(int[] nums) {\\n    int n = nums.length - 1;\\n\\n    int goodIndex = n;\\n    for (int i = n; i >= 0; i--) {\\n        if (i + nums[i] >= goodIndex) {\\n            goodIndex = i;\\n        }\\n    }\\n    return goodIndex == 0;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach: Iterate from the end of array till the begening\\n// At each position, check if u r able to reach to the next position with given number of jumps at that position\\npublic boolean canJump(int[] nums) {\\n    int n = nums.length - 1;\\n\\n    int goodIndex = n;\\n    for (int i = n; i >= 0; i--) {\\n        if (i + nums[i] >= goodIndex) {\\n            goodIndex = i;\\n        }\\n    }\\n    return goodIndex == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378537,
                "title": "simple-easy-c-solution",
                "content": "1. \\tWe just need to chec our itreter is reach at last poistion or not.\\n2. \\tso,we make one tamparary varieble r \\n3. \\tnow we traverse into vector frome 0 index to last.\\n4. \\tand update our r with max valur of vector[i] or previous r.\\n5. \\tand check if we reach or not \\n6. \\tif we reach at vector[i] with value 0 than direct false Bcz we dont have any forther move!\\n\\n```\\n        int r=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(r<i) return false;\\n            r=max(r,i+nums[i]);\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n        int r=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(r<i) return false;\\n            r=max(r,i+nums[i]);\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233260,
                "title": "easy-python-solution",
                "content": "```\\ndef canJump(self, nums: List[int]) -> bool:\\n        j=0\\n        for i in range(len(nums)):\\n            if i>j:\\n                return False\\n            j=max(j,i+nums[i])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef canJump(self, nums: List[int]) -> bool:\\n        j=0\\n        for i in range(len(nums)):\\n            if i>j:\\n                return False\\n            j=max(j,i+nums[i])\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854051,
                "title": "simple-2-pointer-approach-using-java",
                "content": "```\\n/**\\n * Complexity : Time : O(n), Space : O(1), Single pass\\n */\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        if (n==1)\\n            return true;\\n        int i=0,j=1;\\n        while(i<j && j<n) {\\n            if ((j-i) <= nums[i]) {\\n                if(j==n-1)\\n                    return true;\\n                j++;\\n            } else\\n                i++;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Complexity : Time : O(n), Space : O(1), Single pass\\n */\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        if (n==1)\\n            return true;\\n        int i=0,j=1;\\n        while(i<j && j<n) {\\n            if ((j-i) <= nums[i]) {\\n                if(j==n-1)\\n                    return true;\\n                j++;\\n            } else\\n                i++;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 829178,
                "title": "python-in-place-dp",
                "content": "Using the input array itself to keep track of the available jump at current index (memoization):\\n- If the previous index has 0, then there\\'s no way to reach the current index, so update current index to eqaul to 0.\\n- Else we can make at least one jump from previous index, store the max jump available at current index.\\n- Lastly check the 2nd to last index(right before the target) should has available jump >= 1 else it can\\'t jump one more to reach the end\\n\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = max(nums[i-1]-1, nums[i])\\n            \\n        \\n        return nums[-2] >= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = max(nums[i-1]-1, nums[i])\\n            \\n        \\n        return nums[-2] >= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769699,
                "title": "quick-and-simple-c-solution-with-explanations-o-n",
                "content": "```\\nbool canJump(int* nums, int numsSize){\\n    int max_index = nums[0];\\n    if (numsSize < 2) // if only one element - always true\\n        return true;\\n    \\n    if (max_index == 0) // can\\'t jump at all\\n        return false;\\n    \\n    if (max_index >= numsSize) // first jump can reach end\\n        return true;\\n    \\n    for (int i=1; (i <= max_index) && (i < numsSize); ++i) //loop through all reachable indexes\\n    {\\n        if (i + nums[i] > max_index)\\n            max_index = i + nums[i];\\n    }\\n    \\n    if (max_index >= numsSize-1) // if maximum jump is more than last index, can reach end\\n        return true;\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canJump(int* nums, int numsSize){\\n    int max_index = nums[0];\\n    if (numsSize < 2) // if only one element - always true\\n        return true;\\n    \\n    if (max_index == 0) // can\\'t jump at all\\n        return false;\\n    \\n    if (max_index >= numsSize) // first jump can reach end\\n        return true;\\n    \\n    for (int i=1; (i <= max_index) && (i < numsSize); ++i) //loop through all reachable indexes\\n    {\\n        if (i + nums[i] > max_index)\\n            max_index = i + nums[i];\\n    }\\n    \\n    if (max_index >= numsSize-1) // if maximum jump is more than last index, can reach end\\n        return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 713591,
                "title": "python-linear-constant-space",
                "content": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        current_max = 0\\n        \\n        for i in range(len(nums)):\\n            if current_max < i: return False\\n            current_max = max(current_max, i + nums[i])\\n            if current_max >= len(nums)-1: return True\\n            \\n        return current_max >= len(nums)-1\\n```\\n\\nthe idea is we initialize a variable, current_max, which keeps track of the maximum index we can reach in the array. Through each pass of the loop, we check if the index i of the array can be reached. If not, we can terminate early. Otherwise, we check the current_max vs the current element of the array. For example, we have:\\n\\n[2,0,6,8,1,2]\\n\\nAt i = 0, our curent_max is 2 - we can reach up to index 2 in the array\\nAt i = 1, our current_max is max(2, 1 + 0) = 2, meaning we can still only reach index 2\\nAt i = 2, our current_max is max(2, 2 + 6) = 8, so we can reach up to index 8\\n\\nWe can also terminate early if our current max is greater than the array length minus one, because we are dealing with indices. \\n\\n\\n\\n\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        current_max = 0\\n        \\n        for i in range(len(nums)):\\n            if current_max < i: return False\\n            current_max = max(current_max, i + nums[i])\\n            if current_max >= len(nums)-1: return True\\n            \\n        return current_max >= len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669672,
                "title": "javascript-recursive-dp-memoization-top-down-approach",
                "content": "```javascript\\nvar canJump = function(nums) {\\n    const memo = new Map();\\n    \\n    function permute(idx) {\\n        if(memo.has(idx)) return memo.get(idx)\\n        if(idx >= nums.length-1) return true;\\n        if(nums[idx] === 0) return false;\\n        \\n        for(let i = nums[idx]; i >= 1; i--) {\\n            if(permute(idx + i)) {\\n                memo.set(idx, true);\\n                return true\\n            }\\n        }\\n        memo.set(idx, false);\\n        return false;\\n    }\\n    return permute(0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canJump = function(nums) {\\n    const memo = new Map();\\n    \\n    function permute(idx) {\\n        if(memo.has(idx)) return memo.get(idx)\\n        if(idx >= nums.length-1) return true;\\n        if(nums[idx] === 0) return false;\\n        \\n        for(let i = nums[idx]; i >= 1; i--) {\\n            if(permute(idx + i)) {\\n                memo.set(idx, true);\\n                return true\\n            }\\n        }\\n        memo.set(idx, false);\\n        return false;\\n    }\\n    return permute(0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 596976,
                "title": "o-n-c-better-than-99-81-with-o-1-with-explanation",
                "content": "This guy explains each and every concept and logic behind any question so clearly.\\nYou will definately like it.\\nhttps://www.youtube.com/watch?v=muDPTDrpS28\\n\\nComment if you have any question\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n = arr.size();\\n        int maxReach = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(maxReach < i)\\n                return false;\\n            maxReach = max(maxReach, arr[i]+i);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n = arr.size();\\n        int maxReach = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(maxReach < i)\\n                return false;\\n            maxReach = max(maxReach, arr[i]+i);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596291,
                "title": "javascript-javascript-minimum-variables",
                "content": "```\\nvar canJump = function(nums) {\\n    let last = nums.length - 1;\\n    for (let i = last - 1; i >= 0; i--) {\\n        if (i + nums[i] >= last) {\\n            last = i;\\n        };\\n    };\\n    return last === 0;\\n};\\n```\\n```\\nvar canJump = function(nums) {\\n    if (nums.length < 2) {\\n        return true;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (i + nums[i] >= nums.length - 1) {\\n            return true;\\n        };\\n        if (nums[i] === 0) {\\n            return false;\\n        }\\n        if (i + nums[i] > i + 1 + nums[i + 1]) {\\n            nums[i + 1] = nums[i] - 1;\\n        };\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canJump = function(nums) {\\n    let last = nums.length - 1;\\n    for (let i = last - 1; i >= 0; i--) {\\n        if (i + nums[i] >= last) {\\n            last = i;\\n        };\\n    };\\n    return last === 0;\\n};\\n```\n```\\nvar canJump = function(nums) {\\n    if (nums.length < 2) {\\n        return true;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (i + nums[i] >= nums.length - 1) {\\n            return true;\\n        };\\n        if (nums[i] === 0) {\\n            return false;\\n        }\\n        if (i + nums[i] > i + 1 + nums[i + 1]) {\\n            nums[i + 1] = nums[i] - 1;\\n        };\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215616,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [True]+[False]*(len(nums)-1)\\n        for i in range (1,len(nums)):\\n            for j in range (i)[::-1]:\\n                if i-j<=nums[j] and dp[j]:\\n                    dp[i]=True\\n                    break\\n        \\n        return (dp[-1])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [True]+[False]*(len(nums)-1)\\n        for i in range (1,len(nums)):\\n            for j in range (i)[::-1]:\\n                if i-j<=nums[j] and dp[j]:\\n                    dp[i]=True\\n                    break\\n        \\n        return (dp[-1])",
                "codeTag": "Java"
            },
            {
                "id": 20899,
                "title": "fastest-python-o-n-constant-space-solution-6-lines",
                "content": "Checking the range of the current element, decreasing by 1 and comparing to the next element. Currently the fastest Python solution.\\n\\n``` \\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cur_range = nums[0]\\n        for i in range(0, len(nums)-1):\\n            cur_range = max(cur_range - 1, nums[i])\\n            if cur_range == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cur_range = nums[0]\\n        for i in range(0, len(nums)-1):\\n            cur_range = max(cur_range - 1, nums[i])\\n            if cur_range == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21017,
                "title": "python-4-liner-beats-96-other-solutions",
                "content": "This question appeared to be a bit confusing to me at first... Then I realised it should be \\na easy question... lol\\n\\n'''\\n\\n    class Solution(object):\\n        def canJump(self, nums):\\n            reach = 0\\n            for i in xrange(len(nums)):\\n                if reach >= i and i+nums[i] > reach: reach = i+nums[i]            \\n            return reach >= len(nums)-1\\n\\n'''\\n\\nreach is the farthest position to which nums[i] can jump.",
                "solutionTags": [],
                "code": "This question appeared to be a bit confusing to me at first... Then I realised it should be \\na easy question... lol\\n\\n'''\\n\\n    class Solution(object):\\n        def canJump(self, nums):\\n            reach = 0\\n            for i in xrange(len(nums)):\\n                if reach >= i and i+nums[i] > reach: reach = i+nums[i]            \\n            return reach >= len(nums)-1\\n\\n'''\\n\\nreach is the farthest position to which nums[i] can jump.",
                "codeTag": "Java"
            },
            {
                "id": 21117,
                "title": "java-4-line-solution-can-you-beat-it",
                "content": "    public boolean canJump(int[] nums) {\\n           int maxReach = 0;\\n           for (int i = 0; i < nums.length && i <= maxReach; i++) \\n                maxReach=Math.max(maxReach, nums[i]+i);\\n           return maxReach >= nums.length - 1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean canJump(int[] nums) {\\n           int maxReach = 0;\\n           for (int i = 0; i < nums.length && i <= maxReach; i++) \\n                maxReach=Math.max(maxReach, nums[i]+i);\\n           return maxReach >= nums.length - 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21120,
                "title": "clear-greedy-solution-for-c",
                "content": "    class Solution {\\n    public:\\n        bool canJump(vector<int>& nums) {\\n           if(nums.size() <= 1)return true;\\n           int step = nums[0];\\n           for(int i = 1; i < nums.size() - 1 && step != 0; i++){\\n               step--;\\n               step = max(step,nums[i]);//keep the step or change to the biggest step we can go now\\n           }\\n           return step != 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(vector<int>& nums) {\\n           if(nums.size() <= 1)return true;\\n           int step = nums[0];\\n           for(int i = 1; i < nums.size() - 1 && step != 0; i++){\\n               step--;\\n               step = max(step,nums[i]);//keep the step or change to the biggest step we can go now\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 21177,
                "title": "my-5-lines-dp-solution-in-o-n-time-with-constant-space-19ms",
                "content": "This a DP solution, and the idea is to save the maximum jump length every time, if the maximum length be zero, than return false.\\n\\n    class Solution {\\n    public:\\n        bool canJump(std::vector<int> &nums) {\\n    \\t\\tint maxJumpNow = 0, len = static_cast<int>(nums.size());\\n            for (int i = 0; i < len - 1 && maxJumpNow < len - i; ++i)\\n                if (!(maxJumpNow = std::max(maxJumpNow - 1, nums[i])))\\n                    return false;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(std::vector<int> &nums) {\\n    \\t\\tint maxJumpNow = 0, len = static_cast<int>(nums.size());\\n            for (int i = 0; i < len - 1 && maxJumpNow < len - i; ++i)\\n                if (!(maxJumpNow = std::max(maxJumpNow - 1, nums[i])))\\n                    return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21197,
                "title": "5-lines-code-solution-with-o-n",
                "content": "    class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n        if (n<=1) return true;        \\n    \\n        // step means max step it can go from i-1\\n        // when it go one further step, compare the (previous step - 1) with the step of current node can go, keep the max\\n        // when step goes to 0, it means it can't go further, fail the jump. otherwise, it will end to the end\\n    \\tint step = A[0];\\n    \\tfor(int i=1;step>0 && i+step < n; i++)\\n    \\t\\tstep = max(step-1,A[i]);\\n    \\treturn step!=0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n        if (n<=1) return true;        \\n    \\n        // step means max step it can go from i-1\\n        // when it go one further step, compare the (previous step - 1) with the step of current node can go, keep the max\\n        // when step goes to 0, it means it can't go further, fail the jump. otherwise, it will end to the end\\n    \\tint step = A[0];\\n    \\tfor(int i=1;step>0 && i+step < n; i++)\\n    \\t\\tstep = max(step-1,A[i]);\\n    \\treturn step!=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21211,
                "title": "help-me-improve-it-thx",
                "content": "    class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n            int max = A[0];\\n            for(int i=1;i<=max && max<n-1;i++) {\\n                if(A[i]+i > max) {\\n                    max = A[i]+i;\\n                }\\n            }\\n            return max>n-2;\\n        }\\n    };\\ntried my best. but i think its not good enough.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n            int max = A[0];\\n            for(int i=1;i<=max && max<n-1;i++) {\\n                if(A[i]+i > max) {\\n                    max = A[i]+i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4049323,
                "title": "easy-c-solution-beat-97",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i =0;\\n        for(int reach=0;i<nums.size()&&i<=reach;i++){\\n            reach=max(i+nums[i],reach);\\n        }\\n        if(i==nums.size())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i =0;\\n        for(int reach=0;i<nums.size()&&i<=reach;i++){\\n            reach=max(i+nums[i],reach);\\n        }\\n        if(i==nums.size())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976142,
                "title": "python-every-possible-solution-greedy-dp-recurssive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n### Greedy TO(n) SO(1)\\nMaintain a reachable variable and update it on every iteration, if we are ahead of reachable that means it\\'s not possible. else reachle will be equal to n\\n\\n### DP TO(n^2) SO(n)\\nUsing a 1d array to mark evry reachable destination by True and then check if we reached on then end or not.\\n\\n\\n### Recurssive TO(n^n) SO(1)\\nTry running DFS on every possible value and check if reached in the end or not.\\n\\n\\n\\n# Code\\n```\\n#Greedy\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reacable = 0\\n        for i in range(len(nums)):\\n            if reacable < i :\\n                return False\\n            reacable = max(reacable, i+nums[i])\\n        return True\\n```\\n```\\n#DP\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n =len(nums)\\n        dp = [False for i in range(n)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for j in range(i+1, i+nums[i]+1):\\n                    if j < n:\\n                        dp[j] = True\\n                    if j == n - 1:\\n                        return True\\n        return dp[n-1]\\n```\\n```\\n#Recurssive\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(i, n, nums):\\n            if i > n:\\n                return False\\n            if i == n:\\n                return True\\n            ans = False\\n            for e in range(1, nums[i]+1):\\n                ans = ans or dfs(e+i, n, nums)\\n            return ans\\n        return dfs(0, len(nums)-1, nums)\\n```\\n\\n# Upvote if it\\'s helpfulll.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Greedy\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reacable = 0\\n        for i in range(len(nums)):\\n            if reacable < i :\\n                return False\\n            reacable = max(reacable, i+nums[i])\\n        return True\\n```\n```\\n#DP\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n =len(nums)\\n        dp = [False for i in range(n)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for j in range(i+1, i+nums[i]+1):\\n                    if j < n:\\n                        dp[j] = True\\n                    if j == n - 1:\\n                        return True\\n        return dp[n-1]\\n```\n```\\n#Recurssive\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(i, n, nums):\\n            if i > n:\\n                return False\\n            if i == n:\\n                return True\\n            ans = False\\n            for e in range(1, nums[i]+1):\\n                ans = ans or dfs(e+i, n, nums)\\n            return ans\\n        return dfs(0, len(nums)-1, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664370,
                "title": "java-greedy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to use a greedy approach to determine if it is possible to reach the last index of the array nums using the maximum jump length at each position. The idea is to iteratively update the maximum reachable index while traversing the array from left to right. If the maximum reachable index ever reaches or exceeds the last index, it means we can reach the end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the variable last as the index of the last element in the array (nums.length - 1).\\n- Initialize the variable maxReach as 0, representing the maximum index we can currently reach from the starting position.\\n- Iterate through the array nums from left to right using the loop variable i.\\n    - Update maxReach using the expression Math.max(maxReach, i + nums[i]). This calculates the maximum index we can reach by taking a jump from the current position i.\\n    - If maxReach ever reaches or exceeds the last index, return true as we can reach the end.\\n- If the loop finishes without returning true, it means we cannot reach the last index. In this case, return false.\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int last = nums.length - 1;\\n        int maxReach = 0; // Maximum index we can reach\\n        \\n        for (int i = 0; i <= maxReach; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            \\n            if (maxReach >= last) {\\n                return true; // We can reach the last index\\n            }\\n        }\\n        \\n        return false; // Cannot reach the last index\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int last = nums.length - 1;\\n        int maxReach = 0; // Maximum index we can reach\\n        \\n        for (int i = 0; i <= maxReach; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            \\n            if (maxReach >= last) {\\n                return true; // We can reach the last index\\n            }\\n        }\\n        \\n        return false; // Cannot reach the last index\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579417,
                "title": "best-solution-only-by-basic-array",
                "content": "# Intuition\\nI solve this question only by some basic array.\\n\\n# Approach\\nWe have to find zeo in the array after that go back in array and check if element is greater than predefined variable than index should pass that zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums[0]==0 && nums.length!=1){\\n            return false;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(i==nums.length-1){\\n                return true;\\n            }\\n            if(nums[i]==0){\\n                int flag=1;\\n                for(int j=i-1;j>=0;j--){\\n                    if(nums[j]>flag){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        return false;\\n                    }\\n                    flag++;\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums[0]==0 && nums.length!=1){\\n            return false;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(i==nums.length-1){\\n                return true;\\n            }\\n            if(nums[i]==0){\\n                int flag=1;\\n                for(int j=i-1;j>=0;j--){\\n                    if(nums[j]>flag){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        return false;\\n                    }\\n                    flag++;\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258854,
                "title": "greedy-algorithm-python3",
                "content": "# 1.Simple Start and End Approach\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        if len(nums)<2:\\n            return True\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                if start>=len(nums)-1:\\n                    return True\\n        return False\\n  #please upvote me it would encourage me alot\\n\\n```\\n# 2.Greedy Approach\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal=len(nums)-1\\n        for i in range(len(nums),0,-1):\\n            if nums[i-1]>=goal-(i-1):\\n                goal=i-1\\n        return True if goal==0 else False\\n#please upvote me it would encourage me alot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        if len(nums)<2:\\n            return True\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                if start>=len(nums)-1:\\n                    return True\\n        return False\\n  #please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal=len(nums)-1\\n        for i in range(len(nums),0,-1):\\n            if nums[i-1]>=goal-(i-1):\\n                goal=i-1\\n        return True if goal==0 else False\\n#please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233306,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(dp[i-1]>0){\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(dp[i-1]>0){\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161183,
                "title": "solution",
                "content": "```C++ []\\nint speedUp = []\\n{std::ios::sync_with_stdio(0); std::cin.tie(0); return 0; }();\\n\\nint digit(char c)\\n{\\n    return c & 15;\\n}\\nbool isDigit(char c)\\n{\\n    return \\'0\\' <= c && c <= \\'9\\';\\n}\\nint init = []\\n{\\n    std::ofstream out(\"user.out\");\\n    std::cout.rdbuf(out.rdbuf());\\n    for (std::string s; std::getline(std::cin, s); std::cout << \\'\\\\n\\')\\n    {\\n        int prev = 1;\\n        bool ans = true;\\n        for (int _i = 1, _n = s.length(), v; _i < _n; ++_i)\\n        {\\n            v = digit(s[_i]);\\n            while (isDigit(s[++_i]))\\n                v = v * 10 + digit(s[_i]);\\n            \\n            if (prev == 0)\\n                ans = false;\\n            else if (v > --prev)\\n                prev = v;\\n        }\\n        std::cout << (ans ? \"true\" : \"false\");\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution\\n{\\npublic:\\n    bool canJump(std::vector<int> &)\\n    {\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:  \\n    if \"[0]\" in line: print(\"true\", file=f)\\n    elif \"[0,\" in line: print(\"false\", file=f)\\n    elif \"[0,\" not in line and \",0,\" not in line and \",0]\" not in line: print(\"true\", file=f)\\n    else:\\n        maxJ, check = 0, 0 \\n        for i,j in enumerate(line.rstrip()[1:-1].split(\\',\\')):       \\n            if i>maxJ: print(\"false\", file=f); break\\n            else:\\n                if int(j)+i > maxJ: maxJ=int(j)+i             \\n        else: \\n            print(\"true\", file = f)\\n\\nexit() \\n```\\n\\n```Java []\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length - 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (nums[i] + i >= goal) {\\n                goal = i;\\n            }\\n        }\\n        return goal == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nint speedUp = []\\n{std::ios::sync_with_stdio(0); std::cin.tie(0); return 0; }();\\n\\nint digit(char c)\\n{\\n    return c & 15;\\n}\\nbool isDigit(char c)\\n{\\n    return \\'0\\' <= c && c <= \\'9\\';\\n}\\nint init = []\\n{\\n    std::ofstream out(\"user.out\");\\n    std::cout.rdbuf(out.rdbuf());\\n    for (std::string s; std::getline(std::cin, s); std::cout << \\'\\\\n\\')\\n    {\\n        int prev = 1;\\n        bool ans = true;\\n        for (int _i = 1, _n = s.length(), v; _i < _n; ++_i)\\n        {\\n            v = digit(s[_i]);\\n            while (isDigit(s[++_i]))\\n                v = v * 10 + digit(s[_i]);\\n            \\n            if (prev == 0)\\n                ans = false;\\n            else if (v > --prev)\\n                prev = v;\\n        }\\n        std::cout << (ans ? \"true\" : \"false\");\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution\\n{\\npublic:\\n    bool canJump(std::vector<int> &)\\n    {\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:  \\n    if \"[0]\" in line: print(\"true\", file=f)\\n    elif \"[0,\" in line: print(\"false\", file=f)\\n    elif \"[0,\" not in line and \",0,\" not in line and \",0]\" not in line: print(\"true\", file=f)\\n    else:\\n        maxJ, check = 0, 0 \\n        for i,j in enumerate(line.rstrip()[1:-1].split(\\',\\')):       \\n            if i>maxJ: print(\"false\", file=f); break\\n            else:\\n                if int(j)+i > maxJ: maxJ=int(j)+i             \\n        else: \\n            print(\"true\", file = f)\\n\\nexit() \\n```\n```Java []\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length - 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (nums[i] + i >= goal) {\\n                goal = i;\\n            }\\n        }\\n        return goal == 0;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3153958,
                "title": "java-4-solutions-with-clear-explanation-and-real-life-application-brute-force-dp-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Jump Game is a type of dynamic programming problem. The purpose is to determine if it is possible to reach the index in an array by jumping from index to index. The number at each index represents the maximum steps that can be jump from that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are many approaches to this problem. The most simple and efficience approach is to use `Greedy Algorithm`. If you want to check out for different approach please check the code and explanation in the #Code Section\\n\\n1. Create a variable called `lastPos` initialized to last index of the array. \\n2. Iterate the array from the second last index to the first index, checking if the current index `k` + `nums[k]` is greater than or equal to the distance to the `lastPos` index. If so, update the `lastPos` index to the current index.\\n3. Return true if the first index is greater than or equal to the distance to the `lastPos` index, else return false.\\n\\n\\n\\n# Code\\n#### **1) Brute force solution (Recursive) [TLE] \\u274C**\\nThe idea is to start from the first index and try every possible jump from that index, checking if the jump leads to the end of the array. The`DFS` takes in 2 parameters, the `nums` array and the current index position `index`. \\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        //this is the part where it would lead to a TLE.\\n        int jump = nums[index];\\n        boolean result = false;\\n        while(jump > 0)\\n        {\\n            result = result || DFS(nums, index  + jump);\\n            jump--;\\n        }    \\n        return result;\\n    }\\n}\\n\\n```\\n- Time complexity: $$O(2^n)$$ in the worst case, where n is the number of elements in the array. For each jump, the algorithm tries every possible jump length and this leads to an exponential number of possible paths to explore.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n#### **Optimized version:**\\nUsing the same code above, instead of storing the current index in variable `jump`, I decrement the `nums[index]` after checking it. The reason is if that index position has been checked for all possible jumps, the value in the array will be set to 0. Which will not be checked later if we backtrack to try another jump from the previous index.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        boolean result = false;\\n        while(nums[index] > 0)\\n        {\\n            result = result || DFS(nums, index  + nums[index]);\\n            nums[index]--;\\n        }\\n        return result;\\n    }\\n}\\n```\\n- Time complexity: $$O(n^2)$$ in the worst case, where n is the number of elements in the array. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n#### **2) Dynamic programming solutions**\\n##### 1. Recursive - Memoization - Top Down \\u2705\\n\\nWhen calculating, we might end up at the same index again. By creating an array call `dp`, we store `true` if that index has been processed earlier. In the case which we encountered this index again, we will return false.\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        return DFS(nums, 0,dp);\\n    }\\n    public boolean DFS(int [] nums, int index, boolean [] dp)\\n    {\\n       if(index >= nums.length-1) return true;\\n       if(dp[index] == true) return false;\\n       dp[index] = true;\\n       int jump = nums[index];\\n       if(jump == 0) return false;\\n     \\n       \\n        for(int k = jump; k >= 1; k--)\\n        {\\n            if(DFS(nums, index + k,dp))\\n            {   \\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n- Time complexity: $$O(n^2)$$ in the worst case, where n is the length of the nums array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array. This is because we need to store the dp array which has n elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n##### 2. Iterative - Tabulation - Bottom Up \\u2705\\n\\nThe dea behind this solution is to iterate through the `nums` array from the end to the start and keep track of the last position that can be reach. \\n\\nHere a steps to understand this problem:\\n\\nStep 1 - First, we initialize a boolean array `dp` of length `nums.length` with the last element of the dp array set to true.\\n\\nStep 2 - Next, a loop is used to iterate backwards from the second to last element `nums.length-2` to the first element `0`.\\n\\nStep 3 - For each iteration, a variable `furthestJump` is intialized to hold the maximum jump possible from the current position. You may ask why it compares the min of `k + nums[k]` and `nums.length - 1`. Think about an array containing [1,4,1,1]. At position `k = 1`, the maximum jump distance is `1 + nums[1] = 1 + 4 = 5`. However this distance goes beyond the length of they array (4). So the actual maximum jump distance from position `k = 1` is `4`. The distance is stored in the `furthestJump` variable and used to control the range of the inner loop.\\n\\nStep 4 - A nested loop is then used to iterate from `k + 1` to `furthestJump`. If dp[j] is true (meaning it is possible to reach the end of the array from position j), then set dp[k] to true (since it is now possible to reach the end of the array from position k), and break out of the nested loop.\\n\\nStep 5 - Finally, return the value of dp[0] which indicates whether it is possible to reach the end of the array from the start (dp[0] being true means it is possible, dp[0] being false means it is not possible).\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        dp[nums.length-1] = true;\\n        for(int k = nums.length-2; k >= 0; k--)\\n        {\\n            int furthestJump = Math.min(k + nums[k], nums.length-1);\\n            for(int j = k + 1; j <= furthestJump; j++)\\n            {\\n                if(dp[j] == true) \\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n^2)$$ where n is the length of the array. This is because we make two passes through the array, one from `nums.length-2` to 0 and one inner loop that goes from `k + 1` to the `furthestJump`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n i s the length of the array because we use a `dp` array of length `n` to keep track of the result.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n##### 3. Greedy Solution \\u2705\\n\\nThis solution is built on top of the previous solution. This one has a time complexity of $$O(n)$$ and a space complexity of $$O(1)$$.\\n\\nBy keeping track of the last position that can be reached by starting from the end of the array. We can return true if the last position that can be reached is the first index (which is 0). Otherwise, we can just return false.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int lastPos = nums.length-1;\\n        for(int k = nums.length - 2; k >= 0; k--)\\n        {\\n            if(k + nums[k] >= lastPos)\\n            lastPos = k;\\n        }\\n        return lastPos == 0;\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n)$$ where n is the length of the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ because we only need to store a single variable `lastPos` to keep track of the last position that can be reached.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Application\\n\\n###### The Jump Game problem have several real-life applications, including the following: \\n1. Game Development: model the movement of a character in a 2D game, where the character need to jump over an obstacle to reach the end of the level.\\n2. Robotics: the Jump Game problem can be applied to robotic motion planning, where a robot needs to determine the optimal path to reach a destination by jumping over obstacles.\\n3. Network Routing: model the process of finding a path in a network, for example, computer network or a transportation network, where nodes represent the index of the array and edges represent the jumps between nodes.\\n4. Financial Investment: whenever an investor needs to determine if they can reach the target value by making a series of investments, with each investment representing a jump in the array.\\n\\n\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        //this is the part where it would lead to a TLE.\\n        int jump = nums[index];\\n        boolean result = false;\\n        while(jump > 0)\\n        {\\n            result = result || DFS(nums, index  + jump);\\n            jump--;\\n        }    \\n        return result;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        boolean result = false;\\n        while(nums[index] > 0)\\n        {\\n            result = result || DFS(nums, index  + nums[index]);\\n            nums[index]--;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        return DFS(nums, 0,dp);\\n    }\\n    public boolean DFS(int [] nums, int index, boolean [] dp)\\n    {\\n       if(index >= nums.length-1) return true;\\n       if(dp[index] == true) return false;\\n       dp[index] = true;\\n       int jump = nums[index];\\n       if(jump == 0) return false;\\n     \\n       \\n        for(int k = jump; k >= 1; k--)\\n        {\\n            if(DFS(nums, index + k,dp))\\n            {   \\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        dp[nums.length-1] = true;\\n        for(int k = nums.length-2; k >= 0; k--)\\n        {\\n            int furthestJump = Math.min(k + nums[k], nums.length-1);\\n            for(int j = k + 1; j <= furthestJump; j++)\\n            {\\n                if(dp[j] == true) \\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int lastPos = nums.length-1;\\n        for(int k = nums.length - 2; k >= 0; k--)\\n        {\\n            if(k + nums[k] >= lastPos)\\n            lastPos = k;\\n        }\\n        return lastPos == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124885,
                "title": "95-javascript-fast-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/miUgur9WUCc\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let max = 0;\\n\\n    for(let i =0; i<nums.length;i++){\\n        max = Math.max(nums[i] + i,max);\\n        if(max >= nums.length-1) return true;\\n        if(max == i && nums[i] == 0) return false;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let max = 0;\\n\\n    for(let i =0; i<nums.length;i++){\\n        max = Math.max(nums[i] + i,max);\\n        if(max >= nums.length-1) return true;\\n        if(max == i && nums[i] == 0) return false;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2954777,
                "title": "java-0ms-fast-solution-with-mountain-and-valley-approach",
                "content": "**Aprroach:**\\nWe will keep counting the reach from each index and check whether we can cross the zeros (valleys) or not.\\nFor every projectile if reach is able to get to the last index we will return true and if index exceeds reach we will return false.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int reach=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(reach<i)\\n                return false;\\n            reach=Math.max(reach,i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int reach=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(reach<i)\\n                return false;\\n            reach=Math.max(reach,i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953407,
                "title": "c-solution-beats-95",
                "content": "# Approach\\nIterate the nums array from the start and always jump the maximum value i.e nums[i].\\n\\nAs soon as you encounter a 0, start moving backward till you find a position from where you can cross that 0 you encountered.\\n\\nIf there is a nums[x] which can cross the 0, then move i to that index. If while backtracking the count pointer reaches -1 means no other way is possible.\\n\\ncount indicates number of backward jumps.\\nflag is used to mark if last index is unreachable.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums)\\n    {\\n        int flag = 0;\\n        for(int i = 0;!flag && i<nums.size()-1;)\\n        {\\n            if(nums[i]==0)\\n            {\\n                int count = 1;\\n                while(true)\\n                {\\n                    if((i-count)==-1)\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        if(nums[i-count]>count)\\n                        {\\n                            i = (i-count) + nums[i-count];\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                i += nums[i];\\n            }\\n        }\\n        return !flag;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums)\\n    {\\n        int flag = 0;\\n        for(int i = 0;!flag && i<nums.size()-1;)\\n        {\\n            if(nums[i]==0)\\n            {\\n                int count = 1;\\n                while(true)\\n                {\\n                    if((i-count)==-1)\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        if(nums[i-count]>count)\\n                        {\\n                            i = (i-count) + nums[i-count];\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                i += nums[i];\\n            }\\n        }\\n        return !flag;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952650,
                "title": "java-o-n-tc-o-1-sc-fully-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/31149a94-94d4-4c1f-974e-1fc6bd560f88_1672041162.8356094.png)\\n\\n\\n\\n# Intuition\\nThe idea is to continuously improve the position we can jump to.\\n\\nInitially, we  can think of jumping to all available `k` position from each index where `k = nums[i]`, because we want to find the best reach from any index.\\n\\nInstead of doing that we can simply pass all the elements in nums and see what is the furthest reach any of them places us at. If we step on an index we can\\'t reach because the previous elements don\\'t allow us to get there, then we exist by returning `false`. Otherwise we greedily update the best index we can reach until we can reach the end of the array.\\n\\nThe code is super simple and readable.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > maxReach) return false;\\n            maxReach = Math.max(i + nums[i], maxReach);\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > maxReach) return false;\\n            maxReach = Math.max(i + nums[i], maxReach);\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952386,
                "title": "simple-solution-c-greedy-easy-to-understand",
                "content": "# Intuition\\n\\n\\n# Approach\\nEdge case: check if first element itself is 0 that means it can not take a move further and size of nums is greater than 1----> in this case return false\\n\\nstore first element of the array in a variable jump=nums[0];\\n\\nafter that iterate over a loop and decrement jump by -1 and check jump is lesser than the current value if so then assign jump to the current value;\\n\\nin case if jump becomes 0 and you have not reached at the end point then return false\\n\\nif false statement doesn\\'t execute then true statemnt automatically will be executed just after completion of the loop\\n\\n# Complexity\\n- Time complexity:\\nO(nums.size())---->as we are only iterating through a loop of vector nums\\n\\n\\n- Space complexity:\\nO(1)--->constant space there is no auxillary space as we are not using any othe data structure\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i=1,n=nums.size(),jump=nums[0];\\n        if(jump==0&&n!=1) return false;\\n        while(i<n){\\n            jump--;\\n            if(nums[i]>jump)\\n            jump=nums[i];\\n            if(jump==0&&i!=n-1)\\n            return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i=1,n=nums.size(),jump=nums[0];\\n        if(jump==0&&n!=1) return false;\\n        while(i<n){\\n            jump--;\\n            if(nums[i]>jump)\\n            jump=nums[i];\\n            if(jump==0&&i!=n-1)\\n            return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931403,
                "title": "simple-python-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #We have to check that if we are iterating over last element or not\\n        #we dont have to check if we are on last element or not\\n        elem = 0 \\n        # Iterating over index and values in nums\\n        for index,val in enumerate(nums):\\n            #if element < index (if this condition is true that means we have not iterated over last element in array)\\n            if elem < index:\\n                return False \\n            #else element = max(element, val+index)\\n            elem = max(elem,val+index)\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #We have to check that if we are iterating over last element or not\\n        #we dont have to check if we are on last element or not\\n        elem = 0 \\n        # Iterating over index and values in nums\\n        for index,val in enumerate(nums):\\n            #if element < index (if this condition is true that means we have not iterated over last element in array)\\n            if elem < index:\\n                return False \\n            #else element = max(element, val+index)\\n            elem = max(elem,val+index)\\n        return True\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567150,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728717,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565175,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565593,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728463,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567827,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1569608,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1572245,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568004,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568878,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567150,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728717,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565175,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565593,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728463,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567827,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1569608,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1572245,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568004,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568878,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1950634,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1573636,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1817005,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1575624,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1574057,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1571133,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 2013967,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1999361,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1956248,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1909957,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1885550,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1876186,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1716792,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1715657,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571131,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571136,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571137,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571135,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1570631,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1728755,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571134,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2071226,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2066762,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2061211,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2056179,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2055277,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2052657,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2043836,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2041386,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2037473,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2035614,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2025633,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2019101,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2009316,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999890,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999790,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999365,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1997192,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1993904,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1992904,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1967563,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1963454,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1958989,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1953532,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1949988,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1941195,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1939852,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1939688,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1938777,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1936621,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1928861,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1922826,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1921105,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1914294,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1889410,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1888207,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1887591,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1883647,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1883460,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1879418,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1863355,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1833843,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1822608,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1821171,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1814185,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1809557,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1798533,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1798323,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1793397,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1790352,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1776260,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1771623,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1766844,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1749261,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1744459,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1741937,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1740711,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1734900,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1734596,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1730109,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1729283,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729235,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729219,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729162,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729002,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728842,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728768,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728663,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728638,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728546,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            }
        ]
    },
    {
        "title": "Min Stack",
        "question_content": "<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n\n<p>Implement the <code>MinStack</code> class:</p>\n\n<ul>\n\t<li><code>MinStack()</code> initializes the stack object.</li>\n\t<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>\n\t<li><code>void pop()</code> removes the element on the top of the stack.</li>\n\t<li><code>int top()</code> gets the top element of the stack.</li>\n\t<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>\n</ul>\n\n<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>Output</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>Explanation</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 49010,
                "title": "clean-6ms-java-solution",
                "content": "```\\nclass MinStack {\\n\\tprivate Node head;\\n        \\n    public void push(int x) {\\n        if (head == null) \\n            head = new Node(x, x, null);\\n        else \\n            head = new Node(x, Math.min(x, head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n        \\n    private class Node {\\n        int val;\\n        int min;\\n        Node next;\\n            \\n        private Node(int val, int min, Node next) {\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n\\tprivate Node head;\\n        \\n    public void push(int x) {\\n        if (head == null) \\n            head = new Node(x, x, null);\\n        else \\n            head = new Node(x, Math.min(x, head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n        \\n    private class Node {\\n        int val;\\n        int min;\\n        Node next;\\n            \\n        private Node(int val, int min, Node next) {\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 49014,
                "title": "java-accepted-solution-using-one-stack",
                "content": "````\\nclass MinStack {\\n    int min = Integer.MAX_VALUE;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public void push(int x) {\\n        // only push the old minimum value when the current \\n        // minimum value changes after pushing the new value x\\n        if(x <= min){          \\n            stack.push(min);\\n            min=x;\\n        }\\n        stack.push(x);\\n    }\\n\\n    public void pop() {\\n        // if pop operation could result in the changing of the current minimum value, \\n        // pop twice and change the current minimum value to the last minimum value.\\n        if(stack.pop() == min) min=stack.pop();\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass MinStack {\\n    int min = Integer.MAX_VALUE;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public void push(int x) {\\n        // only push the old minimum value when the current \\n        // minimum value changes after pushing the new value x\\n        if(x <= min){          \\n            stack.push(min);\\n            min=x;\\n        }\\n        stack.push(x);\\n    }\\n\\n    public void pop() {\\n        // if pop operation could result in the changing of the current minimum value, \\n        // pop twice and change the current minimum value to the last minimum value.\\n        if(stack.pop() == min) min=stack.pop();\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49031,
                "title": "share-my-java-solution-with-only-one-stack",
                "content": "The question is ask to construct One stack. So I am using one stack.\\n\\nThe idea is to store the gap between the min value and the current value; \\n\\nThe problem for my solution is the cast. I have no idea to avoid the cast. Since the possible gap between the current value and the min value could be Integer.MAX_VALUE-Integer.MIN_VALUE;\\n\\n\\n\\n\\n\\n    public class MinStack {\\n        long min;\\n        Stack<Long> stack;\\n    \\n        public MinStack(){\\n            stack=new Stack<>();\\n        }\\n        \\n        public void push(int x) {\\n            if (stack.isEmpty()){\\n                stack.push(0L);\\n                min=x;\\n            }else{\\n                stack.push(x-min);//Could be negative if min value needs to change\\n                if (x<min) min=x;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if (stack.isEmpty()) return;\\n            \\n            long pop=stack.pop();\\n            \\n            if (pop<0)  min=min-pop;//If negative, increase the min value\\n            \\n        }\\n    \\n        public int top() {\\n            long top=stack.peek();\\n            if (top>0){\\n                return (int)(top+min);\\n            }else{\\n               return (int)(min);\\n            }\\n        }\\n    \\n        public int getMin() {\\n            return (int)min;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The question is ask to construct One stack. So I am using one stack.\\n\\nThe idea is to store the gap between the min value and the current value; \\n\\nThe problem for my solution is the cast. I have no idea to avoid the cast. Since the possible gap between the current value and the min value could be Integer.MAX_VALUE-Integer.MIN_VALUE;\\n\\n\\n\\n\\n\\n    public class MinStack {\\n        long min;\\n        Stack<Long> stack;\\n    \\n        public MinStack(){\\n            stack=new Stack<>();\\n        }\\n        \\n        public void push(int x) {\\n            if (stack.isEmpty()){\\n                stack.push(0L);\\n                min=x;\\n            }else{\\n                stack.push(x-min);//Could be negative if min value needs to change\\n                if (x<min) min=x;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if (stack.isEmpty()) return;\\n            \\n            long pop=stack.pop();\\n            \\n            if (pop<0)  min=min-pop;//If negative, increase the min value\\n            \\n        }\\n    \\n        public int top() {\\n            long top=stack.peek();\\n            if (top>0){\\n                return (int)(top+min);\\n            }else{\\n               return (int)(min);\\n            }\\n        }\\n    \\n        public int getMin() {\\n            return (int)min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49016,
                "title": "c-using-two-stacks-quite-short-and-easy-to-understand",
                "content": "    class MinStack {\\n    private:\\n\\t    stack<int> s1;\\n\\t    stack<int> s2;\\n    public:\\n\\t    void push(int x) {\\n\\t\\t    s1.push(x);\\n\\t\\t    if (s2.empty() || x <= getMin())  s2.push(x);\\t    \\n        }\\n        void pop() {\\n\\t\\t    if (s1.top() == getMin())  s2.pop();\\n\\t\\t    s1.pop();\\n\\t    }\\n        int top() {\\n\\t\\t    return s1.top();\\n\\t    }\\n        int getMin() {\\n\\t\\t    return s2.top();\\n\\t    }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    private:\\n\\t    stack<int> s1;\\n\\t    stack<int> s2;\\n    public:\\n\\t    void push(int x) {\\n\\t\\t    s1.push(x);\\n\\t\\t    if (s2.empty() || x <= getMin())  s2.push(x);\\t    \\n        }\\n        void pop() {\\n\\t\\t    if (s1.top() == getMin())  s2.pop();\\n\\t\\t    s1.pop();\\n\\t    }\\n        int top() {\\n\\t\\t    return s1.top();\\n\\t    }\\n        int getMin() {\\n\\t\\t    return s2.top();\\n\\t    }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1209254,
                "title": "c-simple-code-with-one-stack",
                "content": "I came up with this simple solution using just a single stack.\\nHere I am using **Stack of Pair of Int**. The first value of the pair would store the element of the normal stack and the second value would store the minimum up to that point in the stack. \\nSo even if the minimum element of the stack is removed from the top, we still have a backup of the next minimum element in the pair. So for every element pushed in the stack, it stores its corresponding minimum value.\\n\\nFor example, let\\'s do a **Dry Run** of an example.\\n```\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"pop\",\"top\",\"push\",\"getMin\"]\\n[[],[5],[-2],[3],[-10],[20],[],[],[],[],[30],[]]\\n```\\n1. We push 5,-2,3,-10,20 in the stack.\\n2. If the stack is empty we push {val,val} in the stack\\n   else we push {val,min(s.top().second,val)} which is basically minimum upto that point.\\n3. Hence {5,5},{-2,-2},{3,-2},{-10,-10},{20,-10} are pushed in the stack.\\n4. To pop simply do stack.pop()\\n5. To get the top return stack.top().first;\\n6. Now we pop 20 and -10 from the stack\\n    The elements in the stack would be {5,5},{-2,-2},{3,-2}\\n7. On pushing 30 to the stack\\n   The elements in the stack would be {5,5},{-2,-2},{3,-2},{30,-2}.\\n\\nThe **Output** of the code would be:\\n```\\n[null,null,null,null,null,null,-10,null,null,3,null,-2]\\n```\\n\\nAll the operations are one liners expect the Push operation which is a 2 liner.\\n```\\nclass MinStack {\\npublic:\\n    vector< pair<int,int> > s;\\n\\t\\n    MinStack() { }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n            s.push_back({val,val});\\n        else\\n            s.push_back({val,min(s.back().second,val)});    \\n    }\\n    \\n    void pop() { s.pop_back(); }\\n    \\n    int top() { return s.back().first; }\\n    \\n    int getMin() { return s.back().second; }\\n};\\n```\\n```\\nThe Time complexity of each operation is O(1)\\nThe Space complexity is O(N)\\n```\\n\\nGuys, please give an **upvote** to acknowledge the efforts of the writer.\\nDo clarify your doubts in the comments section. Thank-you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"pop\",\"top\",\"push\",\"getMin\"]\\n[[],[5],[-2],[3],[-10],[20],[],[],[],[],[30],[]]\\n```\n```\\n[null,null,null,null,null,null,-10,null,null,3,null,-2]\\n```\n```\\nclass MinStack {\\npublic:\\n    vector< pair<int,int> > s;\\n\\t\\n    MinStack() { }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n            s.push_back({val,val});\\n        else\\n            s.push_back({val,min(s.back().second,val)});    \\n    }\\n    \\n    void pop() { s.pop_back(); }\\n    \\n    int top() { return s.back().first; }\\n    \\n    int getMin() { return s.back().second; }\\n};\\n```\n```\\nThe Time complexity of each operation is O(1)\\nThe Space complexity is O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49022,
                "title": "my-python-solution",
                "content": "    class MinStack:\\n    \\n    def __init__(self):\\n        self.q = []\\n\\n    # @param x, an integer\\n    # @return an integer\\n    def push(self, x):\\n        curMin = self.getMin()\\n        if curMin == None or x < curMin:\\n            curMin = x\\n        self.q.append((x, curMin));\\n\\n    # @return nothing\\n    def pop(self):\\n        self.q.pop()\\n\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][0]\\n\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][1]",
                "solutionTags": [],
                "code": "    class MinStack:\\n    \\n    def __init__(self):\\n        self.q = []\\n\\n    # @param x, an integer\\n    # @return an integer\\n    def push(self, x):\\n        curMin = self.getMin()\\n        if curMin == None or x < curMin:\\n            curMin = x\\n        self.q.append((x, curMin));\\n\\n    # @return nothing\\n    def pop(self):\\n        self.q.pop()\\n\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][0]\\n\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][1]",
                "codeTag": "Java"
            },
            {
                "id": 3176175,
                "title": "solution",
                "content": "```C++ []\\nclass MinStack {\\npublic:\\n    typedef struct node{\\n        int v;\\n        int minUntilNow;\\n        node* next;\\n    }node;\\n\\n    MinStack() : topN(nullptr){\\n        \\n    }\\n    \\n    void push(int val) {\\n        node* n = new node;\\n        n->v = n->minUntilNow = val;\\n        n->next = nullptr;\\n        \\n        if(topN == nullptr){\\n            topN = n;\\n        }\\n\\n        else{\\n            n->minUntilNow = min(n->v,topN->minUntilNow);\\n            n->next = topN;\\n            topN = n;\\n        }\\n    }\\n    \\n    void pop() {\\n        topN = topN->next;\\n    }\\n    \\n    int top() {\\n        return topN->v;\\n    }\\n    \\n    int getMin() {\\n        return topN->minUntilNow;\\n    }\\n\\n    private:\\n    node* topN;\\n};\\n```\\n\\n```Python3 []\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        if self.minStack:\\n            val = min(self.minStack[-1],val)\\n        self.minStack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minStack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minStack[-1]\\n```\\n\\n```Java []\\nclass MinStack {\\n    LinkedList<TplusMin> stack;\\n    private class TplusMin {\\n        int val;\\n        int min;\\n        public TplusMin(int val, int min) {\\n            this.val = val;\\n            this.min = min;\\n        }\\n    }\\n\\n    public MinStack() {\\n        stack = new LinkedList<>();\\n    }\\n    \\n    public void push(int val) {\\n        int newMin;\\n        if (stack.size() == 0){\\n            newMin = val;\\n        }\\n        else {\\n            int currentMin = stack.getFirst().min;\\n            newMin = val < currentMin ? val : currentMin;\\n        }\\n        stack.addFirst(new TplusMin(val, newMin));\\n    }\\n    \\n    public void pop() {\\n        stack.removeFirst();\\n    }\\n    \\n    public int top() {\\n        return stack.peekFirst().val;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peekFirst().min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass MinStack {\\npublic:\\n    typedef struct node{\\n        int v;\\n        int minUntilNow;\\n        node* next;\\n    }node;\\n\\n    MinStack() : topN(nullptr){\\n        \\n    }\\n    \\n    void push(int val) {\\n        node* n = new node;\\n        n->v = n->minUntilNow = val;\\n        n->next = nullptr;\\n        \\n        if(topN == nullptr){\\n            topN = n;\\n        }\\n\\n        else{\\n            n->minUntilNow = min(n->v,topN->minUntilNow);\\n            n->next = topN;\\n            topN = n;\\n        }\\n    }\\n    \\n    void pop() {\\n        topN = topN->next;\\n    }\\n    \\n    int top() {\\n        return topN->v;\\n    }\\n    \\n    int getMin() {\\n        return topN->minUntilNow;\\n    }\\n\\n    private:\\n    node* topN;\\n};\\n```\n```Python3 []\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        if self.minStack:\\n            val = min(self.minStack[-1],val)\\n        self.minStack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minStack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minStack[-1]\\n```\n```Java []\\nclass MinStack {\\n    LinkedList<TplusMin> stack;\\n    private class TplusMin {\\n        int val;\\n        int min;\\n        public TplusMin(int val, int min) {\\n            this.val = val;\\n            this.min = min;\\n        }\\n    }\\n\\n    public MinStack() {\\n        stack = new LinkedList<>();\\n    }\\n    \\n    public void push(int val) {\\n        int newMin;\\n        if (stack.size() == 0){\\n            newMin = val;\\n        }\\n        else {\\n            int currentMin = stack.getFirst().min;\\n            newMin = val < currentMin ? val : currentMin;\\n        }\\n        stack.addFirst(new TplusMin(val, newMin));\\n    }\\n    \\n    public void pop() {\\n        stack.removeFirst();\\n    }\\n    \\n    public int top() {\\n        return stack.peekFirst().val;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peekFirst().min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49221,
                "title": "c-solution-using-pair-and-one-stack",
                "content": "    class MinStack {\\n         stack<pair<int, int>> st;\\n    \\n    public:\\n        void push(int x) {\\n            int min;\\n            if (st.empty()) {\\n                min = x;\\n            }\\n            else {\\n                min = std::min(st.top().second,x);\\n            }\\n            st.push({x, min});\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n         stack<pair<int, int>> st;\\n    \\n    public:\\n        void push(int x) {\\n            int min;\\n            if (st.empty()) {\\n                min = x;\\n            }\\n            else {\\n                min = std::min(st.top().second,x);\\n            }\\n            st.push({x, min});\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49217,
                "title": "6ms-java-solution-using-linked-list-clean-self-explanatory-and-efficient",
                "content": "    class MinStack {\\n        class Node{\\n            int value;\\n            int min;\\n            Node next;\\n            \\n            Node(int x, int min){\\n                this.value=x;\\n                this.min=min;\\n                next = null;\\n            }\\n        }\\n        Node head;\\n        public void push(int x) {\\n            if(null==head){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(x,head.min));\\n                n.next=head;\\n                head=n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head =head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n            return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(null!=head)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class MinStack {\\n        class Node{\\n            int value;\\n            int min;\\n            Node next;\\n            \\n            Node(int x, int min){\\n                this.value=x;\\n                this.min=min;\\n                next = null;\\n            }\\n        }\\n        Node head;\\n        public void push(int x) {\\n            if(null==head){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(x,head.min));\\n                n.next=head;\\n                head=n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head =head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n            return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(null!=head)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1539330,
                "title": "c-99-74-faster-simple-better-and-optimal-solutions-using-stacks",
                "content": "### Simple Solution\\n\\n**Using Stack and Multiset Approach** *(RunTime : 56 ms (43.75%) & Memory Usage : 35.5%)*\\nIdea behind this logic is to have one stack todo stack operations and multiset to get min element\\n\\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tmultiset<int>m;   \\n\\n\\t\\tvoid push(int val) {//insert elements on both set and stack\\n\\t\\t\\ts.push(val); \\n\\t\\t\\tm.insert(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {//poping elements on both set and stack\\n\\t\\t\\tint top = s.top();\\n\\t\\t\\ts.pop();\\n\\t\\t\\tm.erase(m.find(top)); \\n\\t\\t}\\n\\n\\t\\tint top() { //return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {// return set first element \\n\\t\\t\\treturn *m.begin();\\n\\t\\t}\\n\\t};\\n```\\n\\n### Better Solution\\n\\n**Using Two Stack Approach** *(RunTime : 16 ms (97.50%) & Memory Usage : 78.95%)*\\nThe logic is to have one stack todo stack operations and another stack to store history of min elements.\\n\\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s,minKeeper;\\n\\t\\tvoid push(int val) {\\n\\t\\t\\ts.push(val); // push val in stack\\n\\n\\t\\t\\tif(minKeeper.size()==0||val<=minKeeper.top()){//push in when empty or lesser than current minElement\\n\\t\\t\\t\\tminKeeper.push(val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\n\\t\\t\\tif(minKeeper.top() == s.top())//pop when last element was min element \\n\\t\\t\\t\\tminKeeper.pop();\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {//return top of stack\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return top of minKeeper\\n\\t\\t\\treturn minKeeper.top();\\n\\t\\t}\\n\\t};\\n```\\n\\n### Optimal Solution\\n**Using only One stack** *(RunTime : 12 ms (99.74%) & Memory Usage :88.88%)*\\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tint minElement = INT_MAX;//initalize with max value\\n\\n\\t\\tvoid push(int val) {\\n\\t\\t\\tif(minElement>=val){// whenever val is lesser than current minElement, store current minElement in stack and make val as current minElement\\n\\t\\t\\t\\ts.push(minElement);\\n\\t\\t\\t\\t minElement = val;\\n\\t\\t\\t}\\n\\t\\t\\t  s.push(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\t\\t\\tif(minElement==s.top()){//top is minElement then previous element will be previous minElement, so pop and store current top as current MinElement\\n\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\tminElement = s.top();\\n\\t\\t\\t}\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {// return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return minElement\\n\\t\\t\\treturn minElement;\\n\\t\\t}\\n\\t};\\n```\\n\\n\\n\\nThank you\\n\\n```\\n\\t\\tif(Useful == true)\\n\\t\\t\\tupvote();\\n\\t\\telse\\n\\t\\t\\tcomment();\\n```\\n\\nBy \\uD83D\\uDC93 JS",
                "solutionTags": [],
                "code": "```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tmultiset<int>m;   \\n\\n\\t\\tvoid push(int val) {//insert elements on both set and stack\\n\\t\\t\\ts.push(val); \\n\\t\\t\\tm.insert(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {//poping elements on both set and stack\\n\\t\\t\\tint top = s.top();\\n\\t\\t\\ts.pop();\\n\\t\\t\\tm.erase(m.find(top)); \\n\\t\\t}\\n\\n\\t\\tint top() { //return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {// return set first element \\n\\t\\t\\treturn *m.begin();\\n\\t\\t}\\n\\t};\\n```\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s,minKeeper;\\n\\t\\tvoid push(int val) {\\n\\t\\t\\ts.push(val); // push val in stack\\n\\n\\t\\t\\tif(minKeeper.size()==0||val<=minKeeper.top()){//push in when empty or lesser than current minElement\\n\\t\\t\\t\\tminKeeper.push(val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\n\\t\\t\\tif(minKeeper.top() == s.top())//pop when last element was min element \\n\\t\\t\\t\\tminKeeper.pop();\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {//return top of stack\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return top of minKeeper\\n\\t\\t\\treturn minKeeper.top();\\n\\t\\t}\\n\\t};\\n```\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tint minElement = INT_MAX;//initalize with max value\\n\\n\\t\\tvoid push(int val) {\\n\\t\\t\\tif(minElement>=val){// whenever val is lesser than current minElement, store current minElement in stack and make val as current minElement\\n\\t\\t\\t\\ts.push(minElement);\\n\\t\\t\\t\\t minElement = val;\\n\\t\\t\\t}\\n\\t\\t\\t  s.push(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\t\\t\\tif(minElement==s.top()){//top is minElement then previous element will be previous minElement, so pop and store current top as current MinElement\\n\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\tminElement = s.top();\\n\\t\\t\\t}\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {// return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return minElement\\n\\t\\t\\treturn minElement;\\n\\t\\t}\\n\\t};\\n```\n```\\n\\t\\tif(Useful == true)\\n\\t\\t\\tupvote();\\n\\t\\telse\\n\\t\\t\\tcomment();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49183,
                "title": "python-one-stack-solution-without-linklist",
                "content": "\\nclass MinStack(object):\\n    \\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack= []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: nothing\\n        \"\"\"\\n        if not self.stack:self.stack.append((x,x)) \\n        else:\\n           self.stack.append((x,min(x,self.stack[-1][1])))\\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: nothing\\n        \"\"\"\\n        if self.stack: self.stack.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][0]\\n        else: return None\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][1]\\n        else: return None",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nclass MinStack(object):\\n    \\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack= []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: nothing\\n        \"\"\"\\n        if not self.stack:self.stack.append((x,x)) \\n        else:\\n           self.stack.append((x,min(x,self.stack[-1][1])))\\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: nothing\\n        \"\"\"\\n        if self.stack: self.stack.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][0]\\n        else: return None\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][1]\\n        else: return None",
                "codeTag": "Java"
            },
            {
                "id": 288686,
                "title": "javascript-solution-beats-100-submission",
                "content": "```\\nvar MinStack = function() {\\n  this.elements = [];\\n};\\n\\n/**\\n\\n @param {number} x\\n @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.elements.push({\\n    value: x,\\n    min: this.elements.length === 0 ? x : Math.min(x, this.getMin()),\\n  });\\n};\\n/**\\n\\n @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.elements.pop();\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  return this.elements[this.elements.length - 1].value;\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  return this.elements[this.elements.length - 1].min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar MinStack = function() {\\n  this.elements = [];\\n};\\n\\n/**\\n\\n @param {number} x\\n @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.elements.push({\\n    value: x,\\n    min: this.elements.length === 0 ? x : Math.min(x, this.getMin()),\\n  });\\n};\\n/**\\n\\n @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.elements.pop();\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  return this.elements[this.elements.length - 1].value;\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  return this.elements[this.elements.length - 1].min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49078,
                "title": "simple-java-solution-12-line",
                "content": "class MinStack {\\n\\n    Stack<Integer> stack=new Stack<>();\\n    int min=Integer.MAX_VALUE;\\n    public void push(int x) {\\n        if(x<=min) {stack.push(min); min=x;}\\n        stack.push(x);\\n    }\\n    public void pop() {\\n        if(stack.peek()==min){ stack.pop(); min=stack.pop(); }\\n        else stack.pop();\\n    }\\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class MinStack {\\n\\n    Stack<Integer> stack=new Stack<>();\\n    int min=Integer.MAX_VALUE;\\n    public void push(int x) {\\n        if(x<=min) {stack.push(min); min=x;}\\n        stack.push(x);\\n    }\\n    public void pop() {\\n        if(stack.peek()==min){ stack.pop(); min=stack.pop(); }\\n        else stack.pop();\\n    }\\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 572006,
                "title": "python3-solution-with-o-1-time-as-expected",
                "content": "The insight is to keep track of the minimum value so far and push it, along with the number we are pushing, onto the stack.\\n\\nSo, in this implementation, we push a tuple, with the first number being the number we are pushing, and the second being the minimum value so far. That way, retrieving the minimum value is also an O(1) operation.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.__a = []\\n\\n    def push(self, x: int) -> None:\\n        m = x\\n        if self.__a:\\n            m = self.__a[-1][1]\\n            if m > x:\\n                m = x\\n        self.__a.append((x, m))\\n\\n    def pop(self) -> None:\\n        self.__a.pop()\\n        \\n    def top(self) -> int:\\n        return self.__a[-1][0]\\n\\n    def getMin(self) -> int:\\n        return self.__a[-1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.__a = []\\n\\n    def push(self, x: int) -> None:\\n        m = x\\n        if self.__a:\\n            m = self.__a[-1][1]\\n            if m > x:\\n                m = x\\n        self.__a.append((x, m))\\n\\n    def pop(self) -> None:\\n        self.__a.pop()\\n        \\n    def top(self) -> int:\\n        return self.__a[-1][0]\\n\\n    def getMin(self) -> int:\\n        return self.__a[-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49062,
                "title": "c-o-1-solution",
                "content": "    class MinStack {\\n    public:\\n        vector<int> a;\\n        vector<int> min;\\n        MinStack() {\\n            min.push_back(2147483647);\\n        }\\n        void push(int x) {\\n            a.push_back(x);\\n            if (x < min.back()) {\\n                min.push_back(x);\\n            } else {\\n                min.push_back(min.back());\\n            }\\n        }\\n    \\n        void pop() {\\n            a.pop_back();\\n            min.pop_back();\\n        }\\n    \\n        int top() {\\n            return a.back();\\n        }\\n    \\n        int getMin() {\\n            return min.back();\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class MinStack {\\n    public:\\n        vector<int> a;\\n        vector<int> min;\\n        MinStack() {\\n            min.push_back(2147483647);\\n        }\\n        void push(int x) {\\n            a.push_back(x);\\n            if (x < min.back()) {\\n                min.push_back(x);\\n            } else {\\n                min.push_back(min.back());\\n            }\\n        }\\n    \\n        void pop() {\\n            a.pop_back();\\n            min.pop_back();\\n        }\\n    \\n        int top() {\\n            return a.back();\\n        }\\n    \\n        int getMin() {\\n            return min.back();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 725290,
                "title": "c-simple-easy-solution",
                "content": "```\\nprivate:\\n    stack<int> s1;    \\n    stack<int> s2;   //for containing min value at top \\npublic:\\n    void push(int x) {\\n\\t    s1.push(x);\\n\\t    if(s2.empty() || x<=s2.top()) s2.push(x);\\t    \\n    }\\n    void pop() {\\n\\t    if(s1.top()==s2.top()) s2.pop();\\n\\t    s1.pop();\\n    }\\n    int top() {\\n\\t    return s1.top();\\n    }\\n    int getMin() {\\n\\t    return s2.top();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nprivate:\\n    stack<int> s1;    \\n    stack<int> s2;   //for containing min value at top \\npublic:\\n    void push(int x) {\\n\\t    s1.push(x);\\n\\t    if(s2.empty() || x<=s2.top()) s2.push(x);\\t    \\n    }\\n    void pop() {\\n\\t    if(s1.top()==s2.top()) s2.pop();\\n\\t    s1.pop();\\n    }\\n    int top() {\\n\\t    return s1.top();\\n    }\\n    int getMin() {\\n\\t    return s2.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003721,
                "title": "easy-python-high-speed",
                "content": "**Easy Python | High Speed**\\n\\nEasy Python solution using an array ```A``` to store the elements placed in the stack, and an additional array ```M``` tracking the minimum element seen so far. It can be proven that this approach always works, although it uses ```O(N)``` extra space. (It doesn\\'t change the overall space complexity though).\\n\\nI hope the explanation was helpful.\\nCheers,\\n\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.A = []\\n        self.M = []\\n    def push(self, x):\\n        self.A.append(x)\\n        self.M.append( x if not self.M else min(x, self.M[-1]) )\\n    def pop(self):\\n        self.A.pop()\\n        self.M.pop()\\n    def top(self):\\n        return self.A[-1]\\n    def getMin(self):\\n        return self.M[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```A```\n```M```\n```O(N)```\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.A = []\\n        self.M = []\\n    def push(self, x):\\n        self.A.append(x)\\n        self.M.append( x if not self.M else min(x, self.M[-1]) )\\n    def pop(self):\\n        self.A.pop()\\n        self.M.pop()\\n    def top(self):\\n        return self.A[-1]\\n    def getMin(self):\\n        return self.M[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201044,
                "title": "python-single-stack-o-1-all-operations",
                "content": "```python\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, x):\\n        if self.stack:\\n\\t\\t\\tself.stack.append(min(self.stack[-2], x))\\n        else:\\n            self.stack.append(x)\\n        self.stack.append(x)\\n        \\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1]\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-2]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, x):\\n        if self.stack:\\n\\t\\t\\tself.stack.append(min(self.stack[-2], x))\\n        else:\\n            self.stack.append(x)\\n        self.stack.append(x)\\n        \\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1]\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730013,
                "title": "3-approaches-two-stack-only-one-stack-and-linked-list",
                "content": "**1. Using two stack : Pushing min element in s2**\\n\\nTime: O(1) space: O(2n)\\n\\n**Cons**: Extra O(n) space\\n\\n**Code**: \\n```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>s1, s2;\\n    \\n    void push(int x) {\\n        if(s1.empty()){\\n            s2.push(x);\\n        }\\n        else if(x <= s2.top()){\\n            s2.push(x);\\n        }\\n        s1.push(x);\\n    }\\n    \\n    void pop() {\\n        if(s1.empty())return;\\n        if(s1.top() == s2.top()){\\n            s2.pop();\\n        }\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        if(s1.empty())return -1;\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        if(s1.empty())return -1;\\n        return s2.top();\\n    }\\n};\\n\\n```\\n**2. Using a variable min_element:** \\n\\nTime: O(1) space: O(n)\\n\\n**Cons**: Integer overflow\\n\\n\\n**Intuition**: mn variable will always hold minimum value but if it doesn\\'t, it means s.top contains flag, so before popping the stack top, update the min. \\n\\n**Algo**: \\n\\t\\t While pushing \\n\\t\\t\\t\\t ```\\n\\t\\t\\t\\t if x < mn : push 2*x-mn and put the provided x in mn\\n\\t\\t\\t\\t ```\\n\\t\\t Similarly while popping \\n\\t\\t\\t\\t ```if s.top() < mn(indicates the flag): Restore the mn before popping: mn = 2* mn -s.top()```\\n\\t\\t\\t\\t \\n**Code**: \\n```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<long> s;\\n    long mn;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()){\\n            s.push(x);\\n            mn = x;\\n        }\\n        else if(x <= mn){\\n            // put 2*x - mn into stack\\n            s.push(2ll*x - mn);\\n            mn = x;\\n        }\\n        else{\\n            s.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        // stack top can never be smaller than mn, if it is then it indicates a flag which means before popping, you have to update mn\\n        if(s.top() < mn){\\n            // mn = 2*mn - s.top()\\n            mn = 2ll*mn - s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    // critical part\\n    int top() {\\n        if(s.empty()) return -1;\\n        if(s.top() < mn){\\n            return mn;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(s.empty()) return -1;\\n        return mn;\\n    }\\n};\\n\\n```\\n\\n\\n\\n**3. Using a linked list:** \\n\\nTime: O(1) space: O(2n)\\n\\n**Cons**: O(2n) space since each node has two integer variable and there will be n such nodes\\n\\n**Algo:**\\n```\\n\\t\\ta. Make every new element the new head with updated min. \\n\\t\\tb. And put the previous element next to the new head.\\n```\\n\\n**Code**: \\n```\\nclass MinStack {\\npublic:\\n    struct Node{\\n        int val, mn;\\n        Node* next;\\n        Node(int _val, int _mn, Node*_next = NULL){\\n            val = _val;\\n            mn = _mn;\\n            next = _next;\\n        }\\n    }*head;\\n    void push(int val) {\\n        if(!head){\\n            head = new Node(val, val);\\n        } \\n        else{\\n            head = new Node(val, min(val, head->mn), head);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(!head) return ;\\n        Node* temp = head;\\n        head = head->next;\\n        delete(temp);\\n    }\\n    \\n    int top() {\\n        if(!head) return -1;\\n        return head->val;\\n    }\\n    \\n    int getMin() {\\n        if(!head) return -1;\\n        return head->mn;\\n    }\\n};\\n\\n```\\n**Which is the best solution from interview point of view?** \\n\\nFeel free to correct me!\\nEdit: Space complexity added from valuable comments. \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>s1, s2;\\n    \\n    void push(int x) {\\n        if(s1.empty()){\\n            s2.push(x);\\n        }\\n        else if(x <= s2.top()){\\n            s2.push(x);\\n        }\\n        s1.push(x);\\n    }\\n    \\n    void pop() {\\n        if(s1.empty())return;\\n        if(s1.top() == s2.top()){\\n            s2.pop();\\n        }\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        if(s1.empty())return -1;\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        if(s1.empty())return -1;\\n        return s2.top();\\n    }\\n};\\n\\n```\n```\\n\\t\\t\\t\\t if x < mn : push 2*x-mn and put the provided x in mn\\n\\t\\t\\t\\t ```\n```if s.top() < mn(indicates the flag): Restore the mn before popping: mn = 2* mn -s.top()```\n```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<long> s;\\n    long mn;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()){\\n            s.push(x);\\n            mn = x;\\n        }\\n        else if(x <= mn){\\n            // put 2*x - mn into stack\\n            s.push(2ll*x - mn);\\n            mn = x;\\n        }\\n        else{\\n            s.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        // stack top can never be smaller than mn, if it is then it indicates a flag which means before popping, you have to update mn\\n        if(s.top() < mn){\\n            // mn = 2*mn - s.top()\\n            mn = 2ll*mn - s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    // critical part\\n    int top() {\\n        if(s.empty()) return -1;\\n        if(s.top() < mn){\\n            return mn;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(s.empty()) return -1;\\n        return mn;\\n    }\\n};\\n\\n```\n```\\n\\t\\ta. Make every new element the new head with updated min. \\n\\t\\tb. And put the previous element next to the new head.\\n```\n```\\nclass MinStack {\\npublic:\\n    struct Node{\\n        int val, mn;\\n        Node* next;\\n        Node(int _val, int _mn, Node*_next = NULL){\\n            val = _val;\\n            mn = _mn;\\n            next = _next;\\n        }\\n    }*head;\\n    void push(int val) {\\n        if(!head){\\n            head = new Node(val, val);\\n        } \\n        else{\\n            head = new Node(val, min(val, head->mn), head);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(!head) return ;\\n        Node* temp = head;\\n        head = head->next;\\n        delete(temp);\\n    }\\n    \\n    int top() {\\n        if(!head) return -1;\\n        return head->val;\\n    }\\n    \\n    int getMin() {\\n        if(!head) return -1;\\n        return head->mn;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49181,
                "title": "java-solution-accepted",
                "content": "    private Stack<Integer> mStack = new Stack<Integer>();\\n\\tprivate Stack<Integer> mMinStack = new Stack<Integer>();\\n\\t\\n\\tpublic void push(int x) {\\n\\t\\tmStack.push(x);\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tint min = mMinStack.peek();\\n\\t\\t\\tif (x <= min) {\\n\\t\\t\\t\\tmMinStack.push(x);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tmMinStack.push(x);\\n\\t\\t}\\n    }\\n\\n    public void pop() {\\n    \\tint x = mStack.pop();\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tif (x == mMinStack.peek()) {\\n\\t\\t\\t\\tmMinStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\n    public int top() {\\n    \\treturn mStack.peek();\\n    }\\n\\n    public int getMin() {\\n        return mMinStack.peek();\\n    }",
                "solutionTags": [],
                "code": "    private Stack<Integer> mStack = new Stack<Integer>();\\n\\tprivate Stack<Integer> mMinStack = new Stack<Integer>();\\n\\t\\n\\tpublic void push(int x) {\\n\\t\\tmStack.push(x);\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tint min = mMinStack.peek();\\n\\t\\t\\tif (x <= min) {\\n\\t\\t\\t\\tmMinStack.push(x);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tmMinStack.push(x);\\n\\t\\t}\\n    }\\n\\n    public void pop() {\\n    \\tint x = mStack.pop();\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tif (x == mMinStack.peek()) {\\n\\t\\t\\t\\tmMinStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\n    public int top() {\\n    \\treturn mStack.peek();\\n    }\\n\\n    public int getMin() {\\n        return mMinStack.peek();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49030,
                "title": "simple-java-solution-using-two-build-in-stacks",
                "content": "Here is my simple code for minStack, using two build in Java stack to store the stack and min values separately.\\n\\n    class MinStack {\\n        // stack: store the stack numbers\\n        private Stack<Integer> stack = new Stack<Integer>();\\n        // minStack: store the current min values\\n        private Stack<Integer> minStack = new Stack<Integer>();\\n        \\n        public void push(int x) {\\n            // store current min value into minStack\\n            if (minStack.isEmpty() || x <= minStack.peek())\\n                minStack.push(x);\\n            stack.push(x);\\n        }\\n    \\n        public void pop() {\\n            // use equals to compare the value of two object, if equal, pop both of them\\n            if (stack.peek().equals(minStack.peek()))\\n                minStack.pop();\\n            stack.pop();\\n        }\\n    \\n        public int top() {\\n            return stack.peek();\\n        }\\n    \\n        public int getMin() {\\n            return minStack.peek();\\n        }\\n    }",
                "solutionTags": [],
                "code": "Here is my simple code for minStack, using two build in Java stack to store the stack and min values separately.\\n\\n    class MinStack {\\n        // stack: store the stack numbers\\n        private Stack<Integer> stack = new Stack<Integer>();\\n        // minStack: store the current min values\\n        private Stack<Integer> minStack = new Stack<Integer>();\\n        \\n        public void push(int x) {\\n            // store current min value into minStack\\n            if (minStack.isEmpty() || x <= minStack.peek())\\n                minStack.push(x);\\n            stack.push(x);\\n        }\\n    \\n        public void pop() {\\n            // use equals to compare the value of two object, if equal, pop both of them\\n            if (stack.peek().equals(minStack.peek()))\\n                minStack.pop();\\n            stack.pop();\\n        }\\n    \\n        public int top() {\\n            return stack.peek();\\n        }\\n    \\n        public int getMin() {\\n            return minStack.peek();\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 237368,
                "title": "python-1-line",
                "content": "<iframe src=\"https://leetcode.com/playground/najATENy/shared\" frameBorder=\"0\" width=\"900\" height=\"450\"></iframe>",
                "solutionTags": [
                    "Python"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/najATENy/shared\" frameBorder=\"0\" width=\"900\" height=\"450\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 49185,
                "title": "minstack-javascript-solution",
                "content": "    /**\\n     * @constructor\\n     */\\n    var MinStack = function() {\\n        this.minStack = [];\\n        this.container = [];\\n    };\\n    \\n    /**\\n     * @param {number} x\\n     * @returns {void}\\n     */\\n    MinStack.prototype.push = function(x) {\\n        this.container.push(x);\\n        if (this.minStack.length === 0 || x <= this.minStack[this.minStack.length - 1]) {\\n            this.minStack.push(x);\\n        }\\n    };\\n    \\n    /**\\n     * @returns {void}\\n     */\\n    MinStack.prototype.pop = function() {\\n        var x = this.container.pop();\\n        if (x === this.minStack[this.minStack.length - 1]) {\\n            this.minStack.pop();\\n        }\\n    };\\n    \\n    /**\\n     * @returns {number}\\n     */\\n    MinStack.prototype.top = function() {\\n        return this.container[this.container.length - 1];\\n    };\\n    \\n    MinStack.prototype.getMin = function() {\\n        return this.minStack[this.minStack.length - 1];\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @constructor\\n     */\\n    var MinStack = function() {\\n        this.minStack = [];\\n        this.container = [];\\n    };\\n    \\n    /**\\n     * @param {number} x\\n     * @returns {void}\\n     */\\n    MinStack.prototype.push = function(x) {\\n        this.container.push(x);\\n        if (this.minStack.length === 0 || x <= this.minStack[this.minStack.length - 1]) {\\n            this.minStack.push(x);\\n        }\\n    };\\n    \\n    /**\\n     * @returns {void}\\n     */\\n    MinStack.prototype.pop = function() {\\n        var x = this.container.pop();\\n        if (x === this.minStack[this.minStack.length - 1]) {\\n            this.minStack.pop();\\n        }\\n    };\\n    \\n    /**\\n     * @returns {number}\\n     */\\n    MinStack.prototype.top = function() {\\n        return this.container[this.container.length - 1];\\n    };\\n    \\n    MinStack.prototype.getMin = function() {\\n        return this.minStack[this.minStack.length - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 572005,
                "title": "super-easy-c-solution-with-explanation",
                "content": "**EXPLANATION**  Create two vectors one for stack and other for minimum number entered(min). \\n**Push**: Push every element into the stack vector but only push element in min  if it is empty or the current number is smaller than or equal to the last enterd number in min vector. \\n**POP**: If last elements entered of stack and min are same then pop both of them. Else just pop out back element of stack.\\n\\n\\n\\n```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    vector<int> min;\\n    vector<int> stack;\\n    public:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        stack.push_back(x);\\n        if(min.empty()||min.back()>=x)\\n            min.push_back(x);\\n    }\\n    \\n    void pop() {\\n        if(stack.back()==min.back())\\n            min.pop_back();\\n        \\n        stack.pop_back();\\n    }\\n    \\n    int top() {\\n        if(!stack.empty())\\n        return stack.back();\\n        \\n        return -1;\\n    }\\n    \\n    int getMin() {\\n        if(!min.empty())\\n        return min.back();\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n**Kachow**",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    vector<int> min;\\n    vector<int> stack;\\n    public:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        stack.push_back(x);\\n        if(min.empty()||min.back()>=x)\\n            min.push_back(x);\\n    }\\n    \\n    void pop() {\\n        if(stack.back()==min.back())\\n            min.pop_back();\\n        \\n        stack.pop_back();\\n    }\\n    \\n    int top() {\\n        if(!stack.empty())\\n        return stack.back();\\n        \\n        return -1;\\n    }\\n    \\n    int getMin() {\\n        if(!min.empty())\\n        return min.back();\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204269,
                "title": "javascript",
                "content": "```\\nvar MinStack = function() {\\n    this.stack = []\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    let min = this.stack.length === 0 ? x : this.stack[this.stack.length - 1].min\\n    this.stack.push({val: x, min: Math.min(min, x)})\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.stack.length > 0){\\n        this.stack.pop()\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].val\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].min\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar MinStack = function() {\\n    this.stack = []\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    let min = this.stack.length === 0 ? x : this.stack[this.stack.length - 1].min\\n    this.stack.push({val: x, min: Math.min(min, x)})\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.stack.length > 0){\\n        this.stack.pop()\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].val\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].min\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545225,
                "title": "c-java-python-javascript-simple-solution-with-o-1-time-complexity-for-each-function-as-asked",
                "content": "# Intuition\\nThe intuition behind this approach is to store the minimum value encountered so far along with each element in the stack. By doing so, the minimum value can be retrieved in constant time by accessing the second element of the pair at the top of the stack.\\n\\n# Approach\\n1. The class `MinStack` has a member variable `st`, which is a stack of pairs of integers. Each pair consists of the element and the minimum element encountered so far.\\n\\n2. The constructor `MinStack()` is empty and does not perform any operations.\\n\\n3. The `push` function takes an integer `val` as input and pushes it onto the stack. If the stack is empty, it sets the minimum value encountered as `val` and pushes the pair `{val, val}` onto the stack. If the stack is not empty, it calculates the new minimum value by taking the minimum of the current minimum value (`st.top().second`) and `val`, and pushes the pair `{val, mn}` onto the stack, where `mn` is the new minimum value.\\n\\n4. The `pop` function removes the top element from the stack if it is not empty.\\n\\n5. The `top` function returns the element at the top of the stack if it is not empty. If the stack is empty, it returns 0 as a default value.\\n\\n6. The `getMin` function returns the minimum element encountered so far, which is stored as the second element of the pair at the top of the stack.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- The time complexity of the `push`, `pop`, `top`, and `getMin` functions is O(1) since all operations are performed directly on the stack and do not depend on the stack\\'s size.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- The space complexity of the code is O(n), where n is the number of elements pushed onto the stack. This is because the stack `st` stores pairs of integers for each element, resulting in additional space proportional to the number of elements in the stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>> st;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            int mn = val;\\n            st.push({val,val});\\n        }\\n        else{\\n            int mn = min(st.top().second,val);\\n            st.push({val,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(!st.empty()){\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.empty()){\\n            return 0;\\n        }\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```\\n# Java\\n```\\nclass MinStack {\\n    private Stack<Pair<Integer, Integer>> stack;\\n\\n    public MinStack() {\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int val) {\\n        if (stack.isEmpty()) {\\n            stack.push(new Pair<>(val, val));\\n        } else {\\n            int min = Math.min(stack.peek().getValue(), val);\\n            stack.push(new Pair<>(val, min));\\n        }\\n    }\\n\\n    public void pop() {\\n        if (!stack.isEmpty()) {\\n            stack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getKey();\\n    }\\n\\n    public int getMin() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getValue();\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val):\\n        if not self.stack:\\n            self.stack.append((val, val))\\n        else:\\n            mn = min(self.stack[-1][1], val)\\n            self.stack.append((val, mn))\\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1][0]\\n        return 0\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-1][1]\\n        return 0\\n\\n```\\n# JavaScript\\n```\\nvar MinStack = function() {\\n  this.stack = [];\\n};\\n\\nMinStack.prototype.push = function(val) {\\n  if (this.stack.length === 0) {\\n    this.stack.push({ val: val, min: val });\\n  } else {\\n    var min = Math.min(this.stack[this.stack.length - 1].min, val);\\n    this.stack.push({ val: val, min: min });\\n  }\\n};\\n\\nMinStack.prototype.pop = function() {\\n  if (this.stack.length > 0) {\\n    this.stack.pop();\\n  }\\n};\\n\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].val;\\n  }\\n  return null;\\n};\\n\\nMinStack.prototype.getMin = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].min;\\n  }\\n  return null;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>> st;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            int mn = val;\\n            st.push({val,val});\\n        }\\n        else{\\n            int mn = min(st.top().second,val);\\n            st.push({val,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(!st.empty()){\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.empty()){\\n            return 0;\\n        }\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```\n```\\nclass MinStack {\\n    private Stack<Pair<Integer, Integer>> stack;\\n\\n    public MinStack() {\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int val) {\\n        if (stack.isEmpty()) {\\n            stack.push(new Pair<>(val, val));\\n        } else {\\n            int min = Math.min(stack.peek().getValue(), val);\\n            stack.push(new Pair<>(val, min));\\n        }\\n    }\\n\\n    public void pop() {\\n        if (!stack.isEmpty()) {\\n            stack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getKey();\\n    }\\n\\n    public int getMin() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getValue();\\n    }\\n}\\n\\n```\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val):\\n        if not self.stack:\\n            self.stack.append((val, val))\\n        else:\\n            mn = min(self.stack[-1][1], val)\\n            self.stack.append((val, mn))\\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1][0]\\n        return 0\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-1][1]\\n        return 0\\n\\n```\n```\\nvar MinStack = function() {\\n  this.stack = [];\\n};\\n\\nMinStack.prototype.push = function(val) {\\n  if (this.stack.length === 0) {\\n    this.stack.push({ val: val, min: val });\\n  } else {\\n    var min = Math.min(this.stack[this.stack.length - 1].min, val);\\n    this.stack.push({ val: val, min: min });\\n  }\\n};\\n\\nMinStack.prototype.pop = function() {\\n  if (this.stack.length > 0) {\\n    this.stack.pop();\\n  }\\n};\\n\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].val;\\n  }\\n  return null;\\n};\\n\\nMinStack.prototype.getMin = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].min;\\n  }\\n  return null;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539700,
                "title": "python-two-stacks-solution-explained",
                "content": "Here we need to maintain two stacks: one is original one and another is min_stack, where we keep elements in descending order. So, when we pop element from main stack, we also check if it is also on the top of min stack and if it is, delete it. To get `top` and `getMin` just look at the top of main and min stack.\\n\\n#### Complexity\\nIt is `O(1)` for all operations for time and `O(n)` for space after `n` queries.\\n\\n#### Code\\n```python\\nclass MinStack:\\n    def __init__(self):\\n        self.stack_main = []\\n        self.stack_min = []\\n        \\n    def push(self, x):\\n        self.stack_main.append(x)\\n        if not self.stack_min or self.stack_min[-1] >= x:\\n            self.stack_min.append(x)\\n\\n    def pop(self):\\n        last = self.stack_main.pop()\\n        if last == self.stack_min[-1]:\\n            self.stack_min.pop()\\n\\n    def top(self):\\n        return self.stack_main[-1]\\n\\n    def getMin(self):\\n        return self.stack_min[-1]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass MinStack:\\n    def __init__(self):\\n        self.stack_main = []\\n        self.stack_min = []\\n        \\n    def push(self, x):\\n        self.stack_main.append(x)\\n        if not self.stack_min or self.stack_min[-1] >= x:\\n            self.stack_min.append(x)\\n\\n    def pop(self):\\n        last = self.stack_main.pop()\\n        if last == self.stack_min[-1]:\\n            self.stack_min.pop()\\n\\n    def top(self):\\n        return self.stack_main[-1]\\n\\n    def getMin(self):\\n        return self.stack_min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269091,
                "title": "c-one-stack",
                "content": "```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        min = INT_MAX;\\n    }\\n    \\n    void push(int x) {\\n        if (x <= min)\\n        {\\n            s.push(min);\\n            min = x;\\n        }\\n        s.push(x);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == min)\\n        {\\n            s.pop();\\n            min = s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        min = INT_MAX;\\n    }\\n    \\n    void push(int x) {\\n        if (x <= min)\\n        {\\n            s.push(min);\\n            min = x;\\n        }\\n        s.push(x);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == min)\\n        {\\n            s.pop();\\n            min = s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3813687,
                "title": "5-line-c-code-clear-intuition-line-by-line-code-explanation",
                "content": "# Intuition\\nwe will maintain 2 stack , 1st one(named s1 ) will having normal values but 2nd one (min_st)having always minimum value on it\\'s top.\\n\\n# Approach\\n1. push and pop operation will be always for 1st one stack(s1).\\n2. push and pop operation will be done for 2nd one stack in below cases:\\n\\n   **a). if 2nd one stack is empty or value which is going to be push in 2nd stack is <= top of 2nd stack**\\n    **b). if both stack\\'s top element is equal to each-other then top element is also pop from 2nd one stack.**\\n \\n **NOTE: push and pop operation will be always for 1st stack(s1)**\\n\\n**minimum element will be always having 2nd one stack(min_st.top)*\\n \\n           **\\uD83D\\uDD25Kindly upvote if you find this helpful\\uD83D\\uDD25**\\n\\n# Complexity\\n**Time complexity:\\n   O(1)**\\n# Space Complexity \\n  **O(N)**\\n    \\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<int>s1,min_st; // we created 2 stack (1st stack is normal,min_st.top() always having minimun element)\\n    MinStack() {\\n        int val;\\n    }\\n    void push(int val) {\\n        // for normal stack, val will be always push\\n        s1.push(val);\\n        // for min stack(min_st), val will be push in below case\\n        if(min_st.empty() || val <= min_st.top()){\\n            min_st.push(val);\\n        }\\n    }\\n    void pop() {\\n        // pop and push operation will be alwayas from s1 stack\\n        if(s1.top()== min_st.top()){ //if min_st ka top,s1 top ke equal h to dono stack se pop\\n           min_st.pop();\\n        }\\n        s1.pop(); \\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        //min. val having always with min_st.top()\\n        return min_st.top();\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int>s1,min_st; // we created 2 stack (1st stack is normal,min_st.top() always having minimun element)\\n    MinStack() {\\n        int val;\\n    }\\n    void push(int val) {\\n        // for normal stack, val will be always push\\n        s1.push(val);\\n        // for min stack(min_st), val will be push in below case\\n        if(min_st.empty() || val <= min_st.top()){\\n            min_st.push(val);\\n        }\\n    }\\n    void pop() {\\n        // pop and push operation will be alwayas from s1 stack\\n        if(s1.top()== min_st.top()){ //if min_st ka top,s1 top ke equal h to dono stack se pop\\n           min_st.pop();\\n        }\\n        s1.pop(); \\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        //min. val having always with min_st.top()\\n        return min_st.top();\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620642,
                "title": "using-one-stack-simple-and-concise-c",
                "content": "Implementation\\n\\n**Time Complexity = O(1)**\\n\\n```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min = INT_MAX;\\n    \\npublic:    \\n    MinStack() {        \\n    }\\n    \\n    void push(int val) {\\n        if(val <= min){\\n            s.push(min);    \\n            min = val;\\n        }        \\n        s.push(val);\\n    }\\n    \\n    void pop() {        \\n        if(s.top() == min) {\\n            s.pop();\\n            min = s.top();            \\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min = INT_MAX;\\n    \\npublic:    \\n    MinStack() {        \\n    }\\n    \\n    void push(int val) {\\n        if(val <= min){\\n            s.push(min);    \\n            min = val;\\n        }        \\n        s.push(val);\\n    }\\n    \\n    void pop() {        \\n        if(s.top() == min) {\\n            s.pop();\\n            min = s.top();            \\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747181,
                "title": "clear-python-code-faster-than-96",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.currentMin = float(\\'inf\\')\\n        self.prevMins = []\\n        \\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if x <= self.currentMin:\\n            self.prevMins.append(self.currentMin)\\n            self.currentMin = x\\n\\n    def pop(self) -> None:\\n        if self.stack[-1] == self.currentMin:\\n            self.currentMin = self.prevMins.pop()\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.currentMin\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.currentMin = float(\\'inf\\')\\n        self.prevMins = []\\n        \\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if x <= self.currentMin:\\n            self.prevMins.append(self.currentMin)\\n            self.currentMin = x\\n\\n    def pop(self) -> None:\\n        if self.stack[-1] == self.currentMin:\\n            self.currentMin = self.prevMins.pop()\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.currentMin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49196,
                "title": "6-lines-concise-and-easy-understand-c-solution",
                "content": "    class MinStack {\\n    public:\\n        void push(int x) {\\n            int minnum = st.empty() ? x : min(st.top().second, x);\\n            st.push(make_pair(x, minnum));\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    private:\\n        stack<pair<int, int>> st;\\n    };",
                "solutionTags": [],
                "code": "    class MinStack {\\n    public:\\n        void push(int x) {\\n            int minnum = st.empty() ? x : min(st.top().second, x);\\n            st.push(make_pair(x, minnum));\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    private:\\n        stack<pair<int, int>> st;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49383,
                "title": "mle-and-accept-after-change-all-the-vector-to-stack",
                "content": "Below is my accepted code. If you change all the stack to vector, as well as all the top to back and push to push_back, pop to pop_back, then you'll get a MLE.\\n\\nWHY?\\n**Is there a tricky implement of stack in STL or does the vector brings me the fuss?**\\nthanks for your attention and answer!\\n\\n    class MinStack {\\n    private:\\n        stack<int> sta;\\n        stack<int> minSta;\\n    public:\\n        void push(int x) {\\n            sta.push(x);\\n            if(!minSta.size() || minSta.top() >= x)\\n                minSta.push(x);\\n        }\\n    \\n        void pop() {\\n            if(!sta.empty()) {\\n                if(!minSta.empty() && sta.top() == minSta.top())\\n                    minSta.pop();\\n                sta.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            if(!sta.empty()) return sta.top();\\n        }\\n    \\n        int getMin() {\\n            if(!minSta.empty()) return minSta.top();\\n        }\\n    };",
                "solutionTags": [
                    "Stack"
                ],
                "code": "Below is my accepted code. If you change all the stack to vector, as well as all the top to back and push to push_back, pop to pop_back, then you'll get a MLE.\\n\\nWHY?\\n**Is there a tricky implement of stack in STL or does the vector brings me the fuss?**\\nthanks for your attention and answer!\\n\\n    class MinStack {\\n    private:\\n        stack<int> sta;\\n        stack<int> minSta;\\n    public:\\n        void push(int x) {\\n            sta.push(x);\\n            if(!minSta.size() || minSta.top() >= x)\\n                minSta.push(x);\\n        }\\n    \\n        void pop() {\\n            if(!sta.empty()) {\\n                if(!minSta.empty() && sta.top() == minSta.top())\\n                    minSta.pop();\\n                sta.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            if(!sta.empty()) return sta.top();\\n        }\\n    \\n        int getMin() {\\n            if(!minSta.empty()) return minSta.top();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3208735,
                "title": "155-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo implement the MinStack, we can use two stacks. One stack will store the actual elements, and the other stack will store the minimum values seen so far. When we push a new element onto the stack, we check if it\\'s smaller than the current minimum value, and if so, we push it onto the minimum stack. When we pop an element from the stack, we also pop the corresponding element from the minimum stack if it\\'s the current minimum value.\\n\\nLet\\'s go through the time and space complexity analysis for each function:\\n\\n- push: O(1) time complexity for pushing an element onto the main stack and the minimum stack, and O(1) space complexity for storing the two stacks.\\n- pop: O(1) time complexity for popping an element from the main stack and the minimum stack, and O(1) space complexity for the two stacks.\\n- top: O(1) time complexity for returning the top element of the main stack, and O(1) space complexity for the two stacks.\\n- getMin: O(1) time complexity for returning the minimum value from the minimum stack, and O(1) space complexity for the two stacks.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []  # initialize main stack\\n        self.min_stack = []  # initialize minimum value stack\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)  # push value onto main stack\\n        if not self.min_stack or val <= self.min_stack[-1]:  # if minimum stack is empty or the value is smaller or equal to current minimum\\n            self.min_stack.append(val)  # push value onto minimum stack\\n\\n    def pop(self) -> None:\\n        if self.stack:  # check if main stack is not empty\\n            if self.stack[-1] == self.min_stack[-1]:  # if the element to pop is the current minimum\\n                self.min_stack.pop()  # pop from minimum stack\\n            self.stack.pop()  # always pop from main stack\\n\\n    def top(self) -> int:\\n        if self.stack:  # check if main stack is not empty\\n            return self.stack[-1]  # return the top element\\n\\n    def getMin(self) -> int:\\n        if self.min_stack:  # check if minimum stack is not empty\\n            return self.min_stack[-1]  # return the current minimum value\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []  # initialize main stack\\n        self.min_stack = []  # initialize minimum value stack\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)  # push value onto main stack\\n        if not self.min_stack or val <= self.min_stack[-1]:  # if minimum stack is empty or the value is smaller or equal to current minimum\\n            self.min_stack.append(val)  # push value onto minimum stack\\n\\n    def pop(self) -> None:\\n        if self.stack:  # check if main stack is not empty\\n            if self.stack[-1] == self.min_stack[-1]:  # if the element to pop is the current minimum\\n                self.min_stack.pop()  # pop from minimum stack\\n            self.stack.pop()  # always pop from main stack\\n\\n    def top(self) -> int:\\n        if self.stack:  # check if main stack is not empty\\n            return self.stack[-1]  # return the top element\\n\\n    def getMin(self) -> int:\\n        if self.min_stack:  # check if minimum stack is not empty\\n            return self.min_stack[-1]  # return the current minimum value\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346649,
                "title": "simple-and-very-short-solution-o-1-time-for-all-operations",
                "content": "Very short solution and simple idea. Instead of keeping integer in the underlying stack, we also keep the min value for the moment item was pushed into the stack. Think of it as a photography of the min value taken and stored with each value pushed into the stack at that moment.\\n\\nImplementation is trivial. The only line that needs explanation is below:\\n\\n```\\nvoid push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n```\\n\\nSo we take the minimum of last pushed item\\'s min, or x itself, and x if the stack is yet empty.\\n\\nThis capturing technique is useful for a range of other problems as well. Hope it helps, and enjoy:\\n\\n```\\nclass MinStack {\\nprivate:\\n    class Data {\\n    public:\\n        Data(int v, int m) : val(v), min(m) {}\\n        int val;\\n        int min;\\n    };\\n    stack<Data> s;\\npublic:\\n    void push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n    void pop() { s.pop(); }\\n    int top() { return s.top().val; }\\n    int getMin() { return s.top().min; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n```\n```\\nclass MinStack {\\nprivate:\\n    class Data {\\n    public:\\n        Data(int v, int m) : val(v), min(m) {}\\n        int val;\\n        int min;\\n    };\\n    stack<Data> s;\\npublic:\\n    void push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n    void pop() { s.pop(); }\\n    int top() { return s.top().val; }\\n    int getMin() { return s.top().min; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49207,
                "title": "share-my-clean-ac-c-solution-with-explanation",
                "content": "The key idea is use a another stack to store the `minimum value` of the corresponding stack. Put differently, `min[i]` equals the minimum element where `data[i]` is the top of this sub-stack.\\n\\nWe can use a full size of `min` where its size equals the data's, but it's not necessary.\\n\\n**Idea**\\n\\n*  We should `pop` the element in `min` IFF there's match of `data.top()`.\\n\\n* If we have multiple same minima, for example `[0, 1, 0]` in `data`, then the `min` should be `[0, 0]`.\\nOtherwise, the the `pop` operation wouldn't work properly, since that you need 2 `0`s.\\nAs a result, we should push the element if `x <= min.top()`.\\n\\n\\n**Code**\\n\\n    class MinStack {\\n        \\n        stack<int> data;\\n        stack<int> min;\\n\\n    public:\\n\\n        void push(int x) {\\n            \\n            // If empty\\n            if (min.empty()) {\\n                data.push(x);\\n                min.push(x);\\n            }\\n            \\n            // Not empty\\n            else {\\n                data.push(x);\\n                if (x <= min.top())\\n                    min.push(x);\\n            }\\n\\n        }\\n\\n        void pop() {\\n            \\n            if (!min.empty()) {\\n                if (data.top() == min.top())\\n                    min.pop();\\n                data.pop();\\n            }\\n        }\\n\\n        int top() {\\n            return data.top();\\n        }\\n\\n        int getMin() {\\n            return min.top();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "The key idea is use a another stack to store the `minimum value` of the corresponding stack. Put differently, `min[i]` equals the minimum element where `data[i]` is the top of this sub-stack.\\n\\nWe can use a full size of `min` where its size equals the data's, but it's not necessary.\\n\\n**Idea**\\n\\n*  We should `pop` the element in `min` IFF there's match of `data.top()`.\\n\\n* If we have multiple same minima, for example `[0, 1, 0]` in `data`, then the `min` should be `[0, 0]`.\\nOtherwise, the the `pop` operation wouldn't work properly, since that you need 2 `0`s.\\nAs a result, we should push the element if `x <= min.top()`.\\n\\n\\n**Code**\\n\\n    class MinStack {\\n        \\n        stack<int> data;\\n        stack<int> min;\\n\\n    public:\\n\\n        void push(int x) {\\n            \\n            // If empty\\n            if (min.empty()) {\\n                data.push(x);\\n                min.push(x);\\n            }\\n            \\n            // Not empty\\n            else {\\n                data.push(x);\\n                if (x <= min.top())\\n                    min.push(x);\\n            }\\n\\n        }\\n\\n        void pop() {\\n            \\n            if (!min.empty()) {\\n                if (data.top() == min.top())\\n                    min.pop();\\n                data.pop();\\n            }\\n        }\\n\\n        int top() {\\n            return data.top();\\n        }\\n\\n        int getMin() {\\n            return min.top();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 544220,
                "title": "simple-c-solution-using-a-single-stack-no-struct-needed-too-100-time-and-space-efficient",
                "content": "I decided to post this solution as I found in the discussion tab that mainly people discussed about solutions using 2 stacks or using 2 lists or using structs along with list. This solution is **100% TIME and SPACE efficient**  and uses a simple trick to get us the minimum element in the stack using O(1) time. See the top( ), pop( ) and push( ) methods to see the little tweak used. \\n\\nInstead of pushing in the element which is smaller than the current minimum we push in **2 * x - min** (where x is the element we are currently pushing and min is the current minimum) and update the variable min. Similarly, when we pop, if the top element is smaller than the current min, we update min by, **min = 2 * min - s.top()** and then pop the element. We also have to keep in mind that in the top( ) function if the current top element is smaller than min then we need to **return min**.\\n\\n```\\n\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack< long double > s ;\\n    long double min ;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(long double x) {\\n        if( s.empty() == true ){\\n           s.push(x) ;\\n           min = x ;\\n        }else{\\n           if( x < min ){\\n               s.push( 2 * x - min ) ;\\n               min = x ;\\n               \\n           }else{\\n              s.push( x ) ;\\n           }\\n        }\\n    }\\n    \\n    void pop() {\\n        if( s.empty() == false ){\\n            if( s.top() > min ){\\n                s.pop() ;\\n            }else{\\n                min = 2 * min - s.top() ;\\n                s.pop() ;\\n            }\\n        }\\n    }\\n    \\n    int top() {\\n        if( s.top() > min )\\n            return s.top() ;\\n        else\\n            return min ;\\n    }\\n    \\n    int getMin() {\\n        return min ;\\n    }\\n};\\n \\n ```",
                "solutionTags": [],
                "code": "```\\n\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack< long double > s ;\\n    long double min ;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(long double x) {\\n        if( s.empty() == true ){\\n           s.push(x) ;\\n           min = x ;\\n        }else{\\n           if( x < min ){\\n               s.push( 2 * x - min ) ;\\n               min = x ;\\n               \\n           }else{\\n              s.push( x ) ;\\n           }\\n        }\\n    }\\n    \\n    void pop() {\\n        if( s.empty() == false ){\\n            if( s.top() > min ){\\n                s.pop() ;\\n            }else{\\n                min = 2 * min - s.top() ;\\n                s.pop() ;\\n            }\\n        }\\n    }\\n    \\n    int top() {\\n        if( s.top() > min )\\n            return s.top() ;\\n        else\\n            return min ;\\n    }\\n    \\n    int getMin() {\\n        return min ;\\n    }\\n};\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 49176,
                "title": "thoroughly-explaining-what-s-going-on-a-very-concise-solution-accepted-as-best-submission-in-c",
                "content": "Before we really get started, let\\'s first make some points clear about this problem and also there are some complaints about the specification of the problem -> so misleading!    Here is the detailed specification of the problem: \\n\\n- push will push the value to the stack - add a new top value;\\n- pop will delete the top value of the stack - the only removing operation;\\n- top will just return he top value of the stack - no removing;\\n- getMin will just get the minimal value among the values in stack - no removing;\\n\\nThe true question comes around now, how can we just get the minimal of the stack in constant time? First we need to think about this -> it\\'s a stack -> values comes and goes at the rear of an array -> so we can just use another array <font color=\"#0000ff\">mins</font> to store the so-far minimals which exactly means that when we are pushing values to the stack from the very beginning, we need to check whether the so-far minimal will be changed, if it\\'s changed for the incoming new value, we need to push this value to the <font color=\"#0000ff\">mins</font> array and so on and so on.\\n\\n> the other array <font color=\"#0000ff\">mins</font> will store the so-far minimals and should be updated in each push and pop operation to maintain this feature\\n\\n- so-far minimals means the minimals among values from the bottom till the top of the stack\\n\\nBang! End of Story!\\n\\nAnother typical example using space to reduce time cost:\\n\\n- space cost O(n)\\n- time cost O(1)\\n\\n----------\\n\\n\\n    typedef struct\\n    {\\n        int *arr;\\n        int count;\\n        int *mins;\\n        int minCount;\\n    } MinStack;\\n    \\n    void minStackCreate(MinStack *stack, int maxSize)\\n    {\\n        stack->arr = (int*)malloc(sizeof(int)*maxSize);\\n        stack->mins = (int*)malloc(sizeof(int)*maxSize); //record the mins till the top of the arr;\\n        stack->count = 0;\\n        stack->minCount = 0;\\n    }\\n    \\n    void minStackPush(MinStack *stack, int element) //push it to arr normally, but meantime check whether we should push it to mins;\\n    {\\n        stack->arr[stack->count++] = element;\\n        if(stack->minCount==0 || element<=stack->mins[stack->minCount-1])\\n            stack->mins[stack->minCount++] = element;\\n    }\\n    \\n    void minStackPop(MinStack *stack) //pop will always pop the top -> the top of mins and arr;\\n    {\\n        int top = stack->arr[stack->count-1];\\n        if(stack->mins[stack->minCount-1] == top)\\n            stack->minCount--;\\n        stack->count--;\\n    }\\n    \\n    int minStackTop(MinStack *stack) //just return the top, needless to remove it;\\n    {\\n        return stack->arr[stack->count-1];\\n    }\\n    \\n    int minStackGetMin(MinStack *stack) //just return the min, needless to remove it;\\n    {\\n        return stack->mins[stack->minCount-1];\\n    }\\n    \\n    void minStackDestroy(MinStack *stack)\\n    {\\n        free(stack->arr);\\n        free(stack->mins);\\n    }",
                "solutionTags": [],
                "code": "Before we really get started, let\\'s first make some points clear about this problem and also there are some complaints about the specification of the problem -> so misleading!    Here is the detailed specification of the problem: \\n\\n- push will push the value to the stack - add a new top value;\\n- pop will delete the top value of the stack - the only removing operation;\\n- top will just return he top value of the stack - no removing;\\n- getMin will just get the minimal value among the values in stack - no removing;\\n\\nThe true question comes around now, how can we just get the minimal of the stack in constant time? First we need to think about this -> it\\'s a stack -> values comes and goes at the rear of an array -> so we can just use another array <font color=\"#0000ff\">mins</font> to store the so-far minimals which exactly means that when we are pushing values to the stack from the very beginning, we need to check whether the so-far minimal will be changed, if it\\'s changed for the incoming new value, we need to push this value to the <font color=\"#0000ff\">mins</font> array and so on and so on.\\n\\n> the other array <font color=\"#0000ff\">mins</font> will store the so-far minimals and should be updated in each push and pop operation to maintain this feature\\n\\n- so-far minimals means the minimals among values from the bottom till the top of the stack\\n\\nBang! End of Story!\\n\\nAnother typical example using space to reduce time cost:\\n\\n- space cost O(n)\\n- time cost O(1)\\n\\n----------\\n\\n\\n    typedef struct\\n    {\\n        int *arr;\\n        int count;\\n        int *mins;\\n        int minCount;\\n    } MinStack;\\n    \\n    void minStackCreate(MinStack *stack, int maxSize)\\n    {\\n        stack->arr = (int*)malloc(sizeof(int)*maxSize);\\n        stack->mins = (int*)malloc(sizeof(int)*maxSize); //record the mins till the top of the arr;\\n        stack->count = 0;\\n        stack->minCount = 0;\\n    }\\n    \\n    void minStackPush(MinStack *stack, int element) //push it to arr normally, but meantime check whether we should push it to mins;\\n    {\\n        stack->arr[stack->count++] = element;\\n        if(stack->minCount==0 || element<=stack->mins[stack->minCount-1])\\n            stack->mins[stack->minCount++] = element;\\n    }\\n    \\n    void minStackPop(MinStack *stack) //pop will always pop the top -> the top of mins and arr;\\n    {\\n        int top = stack->arr[stack->count-1];\\n        if(stack->mins[stack->minCount-1] == top)\\n            stack->minCount--;\\n        stack->count--;\\n    }\\n    \\n    int minStackTop(MinStack *stack) //just return the top, needless to remove it;\\n    {\\n        return stack->arr[stack->count-1];\\n    }\\n    \\n    int minStackGetMin(MinStack *stack) //just return the min, needless to remove it;\\n    {\\n        return stack->mins[stack->minCount-1];\\n    }\\n    \\n    void minStackDestroy(MinStack *stack)\\n    {\\n        free(stack->arr);\\n        free(stack->mins);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1292689,
                "title": "runtime-3-ms-faster-than-100-00-of-java-online-submissions-for-min-stack",
                "content": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716384,
                "title": "python-stack-linked-list-solution-easy-to-understand",
                "content": "```\\nclass Node:\\n    def __init__(self, val=None, mini=None, next=None):\\n        # Initialize Node\\n        self.val = val\\n        self.minimum = mini\\n        self.next = next\\n\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.head = None\\n        \\n\\n    def push(self, x: int) -> None:\\n\\t# insert at beginning of the list\\n\\t# check if head is Null\\n        if self.head is None:\\n            node = Node(x, x)\\n            self.head = node\\n        else:\\n\\t\\t# using min inbuilt function to check for minimum value between the current inserted value and previous minimum value\\n            node = Node(x, min(x, self.head.minimum), self.head)\\n            self.head = node\\n        \\n\\n    def pop(self) -> None:\\n\\t# just change the head pointer to next node\\n        self.head = self.head.next\\n        \\n\\n    def top(self) -> int:\\n\\t# returns top of the linked list\\n        return self.head.val\\n        \\n\\n    def getMin(self) -> int:\\n\\t# returns minimum value\\n        return self.head.minimum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val=None, mini=None, next=None):\\n        # Initialize Node\\n        self.val = val\\n        self.minimum = mini\\n        self.next = next\\n\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.head = None\\n        \\n\\n    def push(self, x: int) -> None:\\n\\t# insert at beginning of the list\\n\\t# check if head is Null\\n        if self.head is None:\\n            node = Node(x, x)\\n            self.head = node\\n        else:\\n\\t\\t# using min inbuilt function to check for minimum value between the current inserted value and previous minimum value\\n            node = Node(x, min(x, self.head.minimum), self.head)\\n            self.head = node\\n        \\n\\n    def pop(self) -> None:\\n\\t# just change the head pointer to next node\\n        self.head = self.head.next\\n        \\n\\n    def top(self) -> int:\\n\\t# returns top of the linked list\\n        return self.head.val\\n        \\n\\n    def getMin(self) -> int:\\n\\t# returns minimum value\\n        return self.head.minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691876,
                "title": "python-simples-o-1-solution-using-tuples",
                "content": "```\\n        ## RC ##\\n        ## APPROACH : make tuples (x,y) \\n        # where x is element directly given and y is always minElement i.e y will have minElement in the current existing list ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(1) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n    def push(self, x: int) -> None:\\n        if self.stack:\\n            self.stack.append((x, min(x, self.getMin())))\\n        else:\\n            self.stack.append((x,x))\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1][0] if self.stack else None\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1][1] if self.stack else None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        ## RC ##\\n        ## APPROACH : make tuples (x,y) \\n        # where x is element directly given and y is always minElement i.e y will have minElement in the current existing list ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(1) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n    def push(self, x: int) -> None:\\n        if self.stack:\\n            self.stack.append((x, min(x, self.getMin())))\\n        else:\\n            self.stack.append((x,x))\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1][0] if self.stack else None\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1][1] if self.stack else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49202,
                "title": "very-concise-java-solution-with-deque-interface",
                "content": "The solution is pretty straightforward, keep a minStack besides the underlying stack. During push: push a new item if it's smaller or equals than the current minimum. During pop: if the current item to be popped equals to the top of minStack then pop that one aswell.\\n\\n    Deque<Integer> stack = new LinkedList<>();\\n    Deque<Integer> minStack = new LinkedList<>();\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if(minStack.isEmpty() || minStack.peek() >= x) {\\n            minStack.push(x);\\n        }\\n    }\\n\\n    public void pop() {\\n        int x = stack.pop();\\n        if(x == minStack.peek()) {\\n            minStack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return minStack.peek();\\n    }",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "The solution is pretty straightforward, keep a minStack besides the underlying stack. During push: push a new item if it's smaller or equals than the current minimum. During pop: if the current item to be popped equals to the top of minStack then pop that one aswell.\\n\\n    Deque<Integer> stack = new LinkedList<>();\\n    Deque<Integer> minStack = new LinkedList<>();\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if(minStack.isEmpty() || minStack.peek() >= x) {\\n            minStack.push(x);\\n        }\\n    }\\n\\n    public void pop() {\\n        int x = stack.pop();\\n        if(x == minStack.peek()) {\\n            minStack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return minStack.peek();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 571962,
                "title": "easy-c-solution-using-stack-of-pairs",
                "content": "Create a stack of pairs \\nwhere first element of pair stores the element\\nsecond element of pair stores the min element seen so far\\n1. INSERTION\\npush element and min_element\\n\\n2. TOP\\nreturn element from the top of stack\\n\\n3. MIN ELEMENT\\nreturn min_element from the pair on top of the stack\\n\\n4. POP\\npop the pair on top of stack \\n\\nCODE:\\n```\\nclass MinStack {\\n    stack<pair<int,int>> sp;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(sp.empty())\\n        sp.push({x,x});\\n        else\\n            sp.push({x,min(sp.top().second,x)});\\n    }\\n    \\n    void pop() {\\n        sp.pop();\\n    }\\n    \\n    int top() {\\n        return sp.top().first;\\n    }\\n    \\n    int getMin() {\\n        return sp.top().second;\\n    }\\n};",
                "solutionTags": [],
                "code": "Create a stack of pairs \\nwhere first element of pair stores the element\\nsecond element of pair stores the min element seen so far\\n1. INSERTION\\npush element and min_element\\n\\n2. TOP\\nreturn element from the top of stack\\n\\n3. MIN ELEMENT\\nreturn min_element from the pair on top of the stack\\n\\n4. POP\\npop the pair on top of stack \\n\\nCODE:\\n```\\nclass MinStack {\\n    stack<pair<int,int>> sp;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(sp.empty())\\n        sp.push({x,x});\\n        else\\n            sp.push({x,min(sp.top().second,x)});\\n    }\\n    \\n    void pop() {\\n        sp.pop();\\n    }\\n    \\n    int top() {\\n        return sp.top().first;\\n    }\\n    \\n    int getMin() {\\n        return sp.top().second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3528770,
                "title": "o-1-solution-python",
                "content": "\\n# Approach\\nCreate two seperate stacks, one is the main stack and the other is the minimum stack which holds the corresponding minimum value for each value in our main stack.\\n\\nWhen we want to push a value into our stack, we first check to see if the stack is empty. If it is, then we push the value in both our main stack and our minimum stack.\\n\\nIf the stack is not empty, we want to then compare the given value with the value at the top of our minimum stack. If the value if less than the top value of our minimum stack, we append the value in our minimum stack and our main stack. If the value is greater than the top of our minimum stack, we then push the value into our main stack but this time, we push the top of our minimum value in our minimum stack back into the minimum stack.\\n\\nThis way we can tell what value is the minimum of the stack without using any O(n) approaches.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minstack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append(val)\\n            self.minstack.append(val)\\n        else:\\n            if val < self.minstack[-1]:\\n                self.minstack.append(val)\\n                self.stack.append(val)\\n            else:\\n                self.stack.append(val)\\n                self.minstack.append(self.minstack[-1])\\n\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minstack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append(val)\\n            self.minstack.append(val)\\n        else:\\n            if val < self.minstack[-1]:\\n                self.minstack.append(val)\\n                self.stack.append(val)\\n            else:\\n                self.stack.append(val)\\n                self.minstack.append(self.minstack[-1])\\n\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748459,
                "title": "java-two-stacks-so-simple",
                "content": "```\\nclass MinStack {\\n\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        minStack = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if (minStack.isEmpty() || x <= minStack.peek()) {\\n            minStack.push(x);\\n        }\\n    }\\n    \\n    public void pop() {\\n        if (stack.peek().equals(minStack.peek())) minStack.pop();\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        minStack = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if (minStack.isEmpty() || x <= minStack.peek()) {\\n            minStack.push(x);\\n        }\\n    }\\n    \\n    public void pop() {\\n        if (stack.peek().equals(minStack.peek())) minStack.pop();\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49296,
                "title": "shortest-and-fastest-1-stack-and-2-stack-solutions",
                "content": "2-stack solution may use less memory (ironically) since we don't save the 'min' for every pushed element. \\nIf there are a lot of repeated elements, we may save even more memory by  introducing a 'count' for each 'min'.\\n\\nCannot use vector (will get memory limit error), as vector doubles its capacity when full, whereas deque has a better capacity management strategy.\\n\\n2 deque:\\n\\n        deque<int> stack;\\n        deque<int> mins;\\n        \\n        void push(int x) {\\n            int themin = mins.size() ? mins.back() : x;\\n            stack.push_back(x);\\n            if (x<=themin)\\n                mins.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (stack.back()==mins.back())\\n                mins.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back();\\n        }\\n    \\n        int getMin() {\\n            return mins.back();\\n        }\\n   \\n1 deque (save current min for every pushed elem):\\n\\n\\n    typedef pair<int,int> pairt;\\n\\n        deque<pairt> stack;\\n\\n        void push(int x) {\\n            if (stack.size())\\n                stack.push_back(make_pair(x, min(x,getMin()) ));\\n            else \\n                stack.push_back(make_pair(x, x));\\n        }\\n    \\n        void pop() {\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back().first;\\n        }\\n    \\n        int getMin() {\\n            return stack.back().second;\\n        }",
                "solutionTags": [],
                "code": "2-stack solution may use less memory (ironically) since we don't save the 'min' for every pushed element. \\nIf there are a lot of repeated elements, we may save even more memory by  introducing a 'count' for each 'min'.\\n\\nCannot use vector (will get memory limit error), as vector doubles its capacity when full, whereas deque has a better capacity management strategy.\\n\\n2 deque:\\n\\n        deque<int> stack;\\n        deque<int> mins;\\n        \\n        void push(int x) {\\n            int themin = mins.size() ? mins.back() : x;\\n            stack.push_back(x);\\n            if (x<=themin)\\n                mins.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (stack.back()==mins.back())\\n                mins.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back();\\n        }\\n    \\n        int getMin() {\\n            return mins.back();\\n        }\\n   \\n1 deque (save current min for every pushed elem):\\n\\n\\n    typedef pair<int,int> pairt;\\n\\n        deque<pairt> stack;\\n\\n        void push(int x) {\\n            if (stack.size())\\n                stack.push_back(make_pair(x, min(x,getMin()) ));\\n            else \\n                stack.push_back(make_pair(x, x));\\n        }\\n    \\n        void pop() {\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back().first;\\n        }\\n    \\n        int getMin() {\\n            return stack.back().second;\\n        }",
                "codeTag": "Python3"
            },
            {
                "id": 49367,
                "title": "my-java-solution-without-build-in-stack",
                "content": "Do not use the java stack.\\n\\n       class MinStack {\\n            \\n            Node top = null;\\n            \\n            public void push(int x) {\\n                if (top == null) {\\n                    top = new Node(x);\\n                    top.min = x;\\n                }\\n                else {\\n                    Node temp = new Node(x);\\n                    temp.next = top;\\n                    top = temp;\\n                    top.min = Math.min(top.next.min, x);\\n                }\\n                \\n                return;\\n            }\\n        \\n            public void pop() {\\n                top = top.next;\\n                return;\\n            }\\n        \\n            public int top() {\\n                return top == null ? 0 : top.val;\\n            }\\n        \\n            public int getMin() {\\n                return top == null ? 0 : top.min;\\n            }\\n        }\\n        \\n        class Node {\\n            int val;\\n            int min;\\n            Node next;\\n            \\n            public Node(int val) {\\n                this.val = val;\\n            }\\n        }",
                "solutionTags": [],
                "code": "Do not use the java stack.\\n\\n       class MinStack {\\n            \\n            Node top = null;\\n            \\n            public void push(int x) {\\n                if (top == null) {\\n                    top = new Node(x);\\n                    top.min = x;\\n                }\\n                else {\\n                    Node temp = new Node(x);\\n                    temp.next = top;\\n                    top = temp;\\n                    top.min = Math.min(top.next.min, x);\\n                }\\n                \\n                return;\\n            }\\n        \\n            public void pop() {\\n                top = top.next;\\n                return;\\n            }\\n        \\n            public int top() {\\n                return top == null ? 0 : top.val;\\n            }\\n        \\n            public int getMin() {\\n                return top == null ? 0 : top.min;\\n            }\\n        }\\n        \\n        class Node {\\n            int val;\\n            int min;\\n            Node next;\\n            \\n            public Node(int val) {\\n                this.val = val;\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 571959,
                "title": "java-solution-using-o-1-time-for-getmin-and-o-1-space",
                "content": "```\\nclass MinStack {\\n    \\n    Stack<int[]> stack;\\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<int[]>();\\n        \\n    }\\n    \\n    // method to push a new element along with the min value till that point\\n    public void push(int x) {\\n        // if the stack is empty push the element to stack, min=element itself\\n\\t\\tif (stack.empty()) {\\n\\t\\t\\tstack.push(new int[] { x, x });\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// compare the top min element with the new element, if new element is\\n\\t\\t// smaller\\n\\t\\t// then add the new min as the current element\\n\\t\\tint currentMin = stack.peek()[1];\\n\\t\\tstack.push(new int[] { x, Math.min(currentMin, x) });\\n        \\n        \\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek()[0];\\n        \\n    }\\n    \\n    public int getMin() {\\n        return stack.peek()[1];\\n        \\n    }\\n    \\n    public boolean isEmpty() {\\n        return stack.empty();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(x);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n    \\n    Stack<int[]> stack;\\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<int[]>();\\n        \\n    }\\n    \\n    // method to push a new element along with the min value till that point\\n    public void push(int x) {\\n        // if the stack is empty push the element to stack, min=element itself\\n\\t\\tif (stack.empty()) {\\n\\t\\t\\tstack.push(new int[] { x, x });\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// compare the top min element with the new element, if new element is\\n\\t\\t// smaller\\n\\t\\t// then add the new min as the current element\\n\\t\\tint currentMin = stack.peek()[1];\\n\\t\\tstack.push(new int[] { x, Math.min(currentMin, x) });\\n        \\n        \\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek()[0];\\n        \\n    }\\n    \\n    public int getMin() {\\n        return stack.peek()[1];\\n        \\n    }\\n    \\n    public boolean isEmpty() {\\n        return stack.empty();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(x);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775651,
                "title": "python-99-95-faster-only-one-stack",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.st=[] #stack\\n        self.min=None #min element\\n\\n    def push(self, val: int) -> None:\\n        if len(self.st)==0:\\n            self.st.append(val)\\n            self.min=val\\n        else:\\n            if val>=self.min:\\n                self.st.append(val)\\n            else:\\n                self.st.append(2*val-self.min)\\n                self.min=val\\n                \\n    def pop(self) -> None:\\n        x=self.st.pop() \\n        if x<self.min:\\n            self.min=2*self.min-x\\n    \\n    def top(self) -> int:\\n        x=self.st[-1]\\n        if x>=self.min:\\n            return x\\n        return self.min\\n\\n    def getMin(self) -> int:\\n        return self.min\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.st=[] #stack\\n        self.min=None #min element\\n\\n    def push(self, val: int) -> None:\\n        if len(self.st)==0:\\n            self.st.append(val)\\n            self.min=val\\n        else:\\n            if val>=self.min:\\n                self.st.append(val)\\n            else:\\n                self.st.append(2*val-self.min)\\n                self.min=val\\n                \\n    def pop(self) -> None:\\n        x=self.st.pop() \\n        if x<self.min:\\n            self.min=2*self.min-x\\n    \\n    def top(self) -> int:\\n        x=self.st[-1]\\n        if x>=self.min:\\n            return x\\n        return self.min\\n\\n    def getMin(self) -> int:\\n        return self.min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544688,
                "title": "c-solution-using-single-stack-t-c-o-1-s-c-o-n",
                "content": "# Intuition\\nWe must have to maintain minimum element track for every push and pop.\\nSo we have to think accordingly.\\n\\n# Approach\\nMaintaining minimum element along with the current query \\n(we can also use two arrays for the same, one for maintaining queries and second one for maintainig minimum elements).\\n\\n# Complexity\\n- Time complexity:\\n    O(1)  (for every operation)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n\\nvector<pair<int,int>> arr;\\n    MinStack() {\\n\\n    }\\n    \\n    void push(int val) {\\n        if(arr.empty()){\\n            arr.push_back({val,val});\\n        }else{\\n            arr.push_back({val,min(val,arr.back().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        arr.pop_back();\\n    }\\n    \\n    int top() {\\n        return arr.back().first;\\n    }\\n    \\n    int getMin() {\\n        return arr.back().second;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n\\nvector<pair<int,int>> arr;\\n    MinStack() {\\n\\n    }\\n    \\n    void push(int val) {\\n        if(arr.empty()){\\n            arr.push_back({val,val});\\n        }else{\\n            arr.push_back({val,min(val,arr.back().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        arr.pop_back();\\n    }\\n    \\n    int top() {\\n        return arr.back().first;\\n    }\\n    \\n    int getMin() {\\n        return arr.back().second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749605,
                "title": "c-stack-with-val-min-pair",
                "content": "```\\nclass MinStack {\\npublic:\\n    //pair.first = actual value\\n\\t//pair.second = min value from the top (current value) to bottom of the stack\\n    stack<pair<int, int>> s; \\n    int minVal;\\n    \\n    MinStack() {\\n        minVal = INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if (s.size() == 0) {\\n            minVal = val;\\n        } else {\\n            minVal = s.top().second;\\n        }\\n        minVal = min(minVal, val);\\n        s.push({val, minVal});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    //pair.first = actual value\\n\\t//pair.second = min value from the top (current value) to bottom of the stack\\n    stack<pair<int, int>> s; \\n    int minVal;\\n    \\n    MinStack() {\\n        minVal = INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if (s.size() == 0) {\\n            minVal = val;\\n        } else {\\n            minVal = s.top().second;\\n        }\\n        minVal = min(minVal, val);\\n        s.push({val, minVal});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 572554,
                "title": "javascript-easy-to-understand-es6-class-solution",
                "content": "```\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = Infinity;\\n    }\\n    push(x) {\\n        const valMinPair = {val: x, prevMin: this.min};\\n        this.stack.push(valMinPair);\\n        this.min = Math.min(this.min, x);\\n    }\\n    pop() {\\n        const {val, prevMin} = this.stack.pop();\\n        this.min = prevMin;\\n        return val;\\n    }\\n    top() {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n    getMin() {\\n        return this.min;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = Infinity;\\n    }\\n    push(x) {\\n        const valMinPair = {val: x, prevMin: this.min};\\n        this.stack.push(valMinPair);\\n        this.min = Math.min(this.min, x);\\n    }\\n    pop() {\\n        const {val, prevMin} = this.stack.pop();\\n        this.min = prevMin;\\n        return val;\\n    }\\n    top() {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n    getMin() {\\n        return this.min;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354773,
                "title": "js-very-simple-idea",
                "content": "```\\n//solves in O(1) time & O(n) extra space \\nvar MinStack = function() {\\n    this.arr = [];\\n    //keeps track of min element at every point in lifetime of stack \\n    this.min = [];\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    this.arr.push(x);\\n    //if stack is empty\\n    if(this.min.length === 0) this.min.push(x);\\n    else {\\n        //if stack is non empty push the min element between current ele and top of this.min\\n        //for instance our stack was [-1, -0, -3]\\n        //push(-1) this.arr = [-1] | this.min = [-1]\\n        //push(0) this.arr = [-1, 0] | this.min = [-1, -1]\\n        //push(-3) this.arr = [-1,0,-3] | this.min = [-1,-1,-3]\\n        this.min.push(Math.min(this.min[this.min.length - 1], x));\\n    }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.arr.length != 0) {\\n        //pop ele from both this.arr and this.min\\n        this.arr.pop();\\n        this.min.pop();\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    //if this.arr non empty return element at last index of this.arr\\n    if(this.arr.length != 0) return this.arr[this.arr.length -1];\\n    return null\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    //if this.min non empty return element at last index of this.min\\n    if(this.min.length != 0) return this.min[this.min.length -1];\\n    return null\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//solves in O(1) time & O(n) extra space \\nvar MinStack = function() {\\n    this.arr = [];\\n    //keeps track of min element at every point in lifetime of stack \\n    this.min = [];\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    this.arr.push(x);\\n    //if stack is empty\\n    if(this.min.length === 0) this.min.push(x);\\n    else {\\n        //if stack is non empty push the min element between current ele and top of this.min\\n        //for instance our stack was [-1, -0, -3]\\n        //push(-1) this.arr = [-1] | this.min = [-1]\\n        //push(0) this.arr = [-1, 0] | this.min = [-1, -1]\\n        //push(-3) this.arr = [-1,0,-3] | this.min = [-1,-1,-3]\\n        this.min.push(Math.min(this.min[this.min.length - 1], x));\\n    }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.arr.length != 0) {\\n        //pop ele from both this.arr and this.min\\n        this.arr.pop();\\n        this.min.pop();\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    //if this.arr non empty return element at last index of this.arr\\n    if(this.arr.length != 0) return this.arr[this.arr.length -1];\\n    return null\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    //if this.min non empty return element at last index of this.min\\n    if(this.min.length != 0) return this.min[this.min.length -1];\\n    return null\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032506,
                "title": "simple-c-o-1-2-liner-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe either have to  use some other stack to keep track of  minimum till each index or we can have a stack pair. So actually what we will do is for each incoming element we will compare it with previous minimum element if it smaller then update the min else keep our min as it is.Also when stack is empty then we just have to push only..\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo create a `stack<pair<int,int>>` and then in push function we can compare the incoming val that is to be pushed with the minimum till now and update accordingly and also check if stack is empty or not .\\nAnd rest all other fucntions are same and in getmin() function just return top.second beacuse minimum of every index is stored in its second.\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(!st.empty()){\\n             int mini=min(st.top().second,val);\\n             st.push({val,mini});\\n        }\\n        else st.push({val,val});\\n    }\\n    \\n    void pop() {\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(!st.empty()){\\n             int mini=min(st.top().second,val);\\n             st.push({val,mini});\\n        }\\n        else st.push({val,val});\\n    }\\n    \\n    void pop() {\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539426,
                "title": "javascript-easy-to-understand-detailed-explanation-o-1-for-all",
                "content": "For this problem, we need to implement the `push`, `pop`, `top`, and `getMin` these 4 methods. Since there is an `Array` object in JS already, so it\\'s straightforward to think about we could be based on it.\\n\\nThe original `Array` has `push` and `pop` already like a stack. And the `top` method could be easily implemented via `Array.length`. So, the key point for this problem is how to implement the `getMin`.\\n\\nFor sure, we could sort the array after each `push` operation, but it\\'s a general solution and will cost too much. In order to optimize  performance, we need to find out the uniqueness of the current scene and design the strategy based on it.\\n\\nLet me ask a question, what kinds of positions do we have when we remove values from an array? It\\'s straightforward, the middle, the head, and the tail. But, for this problem, it\\'s a stack with only `pop` and `push` operations to remove and add values, which means we could only modify the stack at the tail.\\n\\nWhy this question is so important? Let\\'s think, in which situation will the min value change? Bingo - when and only when we modify values. Then, about removing value, since all the previous values are the same, so actually, the min value we have already known won\\'t change. In other words, the only situation that we need to compare and get a new min value is when we add a new value.\\n\\nIf it\\'s a little bit abstract, let\\'s take a look at an example:\\n\\nFor array [3, 1, 4, 2, 5, 7], the min value for each index with its previous values is [3, 1, 1, 1, 1].  Whether we remove the last `7` or add new values, then previous min values will always be `[3, 1, 1, 1]`.\\n\\nAccording to this, we could save all the min values we\\'ve known already, this could makes the `getMin` O(1) time complexity.\\n\\nWe could use another array to save them, but I choose to use just one array - min values and real values are saved one by one. Here\\' the code:\\n\\n```js\\nclass MinStack {\\n  constructor() {\\n    this._top = -1;\\n    this.data = [];\\n    this.min = Number.MAX_SAFE_INTEGER;\\n  }\\n  push(n) {\\n    this.data[++this._top] = this.min;\\n    this.data[++this._top] = n;\\n    n < this.min && (this.min = n);\\n  }\\n  pop() {\\n    this.min = this.data[--this._top];\\n    --this._top;\\n  }\\n  top() {\\n    return this.data[this._top];\\n  }\\n  getMin() {\\n    return this.min;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass MinStack {\\n  constructor() {\\n    this._top = -1;\\n    this.data = [];\\n    this.min = Number.MAX_SAFE_INTEGER;\\n  }\\n  push(n) {\\n    this.data[++this._top] = this.min;\\n    this.data[++this._top] = n;\\n    n < this.min && (this.min = n);\\n  }\\n  pop() {\\n    this.min = this.data[--this._top];\\n    --this._top;\\n  }\\n  top() {\\n    return this.data[this._top];\\n  }\\n  getMin() {\\n    return this.min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539383,
                "title": "python-o-1-time-stores-only-n-1-ints-less-space-than-94-one-stack",
                "content": "Please feel free to ask questions or give suggestions. **Upvote** if you liked the solution.\\n\\n**Idea**: \\n* We keep track of the minimum element separately. \\n* For minimums so far, instead of storing the value directly, we store a value less than minimum from which we can compute the minimum after this value has been removed. \\n* Eg. say stack had minimum 3, and we wanted to push 1, we\\'d push 2\\\\*val-min=-1 instead and save minimum as 1. Then, when we see the top of the stack is less than our minimum i.e. we\\'re popping this element next, we can compute the minimum in stack after this has been popped as 2\\\\*min-stored_val=2\\\\*1-(-1)=3.\\n* How this works: \\n\\t* Since val<min, 2\\\\*val<2*min=>2\\\\*val-min<min, everything greater than min is stored directly. \\n\\t* All values greater than min get stored directly. So, while popping, if we encounter a value smaller than min, it must be the value where min was in the stack and we stored 2\\\\*val-previous_min in stack.\\n\\t* When popping this value, 2\\\\*min-stored _val=2\\\\*min-(2\\\\*this_val-previous_min), but we stored this_val in min \\n\\t* So, 2\\\\*min-stored _val = previous_min.\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        # Note: Does not hold actual values for minimums encountered\\n        self._stack = []\\n        # Current minimum\\n        self._min = None\\n\\n    def push(self, val: int) -> None:\\n        # Note: Append here is amortised O(1), could use a different stack implementation for every call O(1). Logic remains same.\\n        # Empty stack\\n        if not self._stack:\\n            self._stack.append(val)\\n            self._min = val\\n        # Normal add\\n        elif val>=self._min:\\n            self._stack.append(val)\\n        # Val is min, add computed value that tells us the min when this is removed\\n        else:\\n            self._stack.append(2*val-self._min)\\n            self._min = val     \\n\\n    def pop(self) -> None:\\n        el = self._stack.pop()\\n        # This was the minimum, extract the next minimum from value stored in stack\\n        if el<self._min:\\n            el, self._min = self._min, 2*self._min-el\\n        return el\\n\\n    def top(self) -> int:\\n        # stack[-1]>=min => stack[-1] is unmodified last pushed element, \\n        # min>stack[-1] implies top is min and stack[-1] has computed value instead\\n        return max(self._stack[-1], self._min)\\n\\n    def getMin(self) -> int:\\n        return self._min\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        # Note: Does not hold actual values for minimums encountered\\n        self._stack = []\\n        # Current minimum\\n        self._min = None\\n\\n    def push(self, val: int) -> None:\\n        # Note: Append here is amortised O(1), could use a different stack implementation for every call O(1). Logic remains same.\\n        # Empty stack\\n        if not self._stack:\\n            self._stack.append(val)\\n            self._min = val\\n        # Normal add\\n        elif val>=self._min:\\n            self._stack.append(val)\\n        # Val is min, add computed value that tells us the min when this is removed\\n        else:\\n            self._stack.append(2*val-self._min)\\n            self._min = val     \\n\\n    def pop(self) -> None:\\n        el = self._stack.pop()\\n        # This was the minimum, extract the next minimum from value stored in stack\\n        if el<self._min:\\n            el, self._min = self._min, 2*self._min-el\\n        return el\\n\\n    def top(self) -> int:\\n        # stack[-1]>=min => stack[-1] is unmodified last pushed element, \\n        # min>stack[-1] implies top is min and stack[-1] has computed value instead\\n        return max(self._stack[-1], self._min)\\n\\n    def getMin(self) -> int:\\n        return self._min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217452,
                "title": "c-solution-using-o-1-extra-space-simple-math-trick",
                "content": "One of the simple way to solve this problem is using an auxillary stack keeping track of all the minimum elements. \\nHowever using simple math trick we can solve without using any auxillary stack.\\nIdea :\\n1. At any point let the current minimum be minn.\\n2. Suppose we are pushing any element e , such that e>= minn. Then there is no need to update minn. Simply push the element in to the stack.\\n3. If e < minn, we will push e and  we will also need to update minn. Let us do the update as minn=e. However there will be a problem.  Let us see what.\\n4.  If now a pop operation is called since the minimum is now at the top of the stack we need to update minn to the previous minn. But since we are not using any auxillary stack how to retrive the previous min?\\n5.  This can be acheived if in step 3 instead of pushing e into the stack we push **2\\\\*e-minn** instead.   Why?\\n\\tWe know, e<minn\\n\\t=> e-minn<0\\n\\t=> e-minn+e<e\\n\\t=>2\\\\*e-minn<e\\n\\tSo we can say the instead of pushing e in step 3 we are pushing a number even less than e. After doing this update minn=e. How will this help? \\n\\t**Note - Update is done after pushing 2\\\\*e-minn in the stack. It means the \"minn\" in \"2\\\\*e-minn\" is actually the minn before encountering e which thus the becomes the previous_min after updating.**\\n6. Now if we perform a pop operation the top of the stack will have a number less than minn (As top_of_the_stack = 2\\\\*e-previous_minn and minn=e). So now we can easily say **previous_min = 2\\\\*minn- top_of_stack**. This is important as we are keeping track of previous min also but using any extra space. So now we can pop the element and update minn=previous_min;\\nIts very simple to implement.\\nCode :- \\n```\\n#define ll long long int \\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    vector<ll> s;\\n    int minn;\\n    MinStack() {\\n        minn=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push_back(val);\\n            minn=val;\\n        }\\n        else if(val>=minn)\\n            s.push_back(val);\\n        else{\\n            s.push_back(2LL*val-minn);//Insert a number even less then val\\n            minn=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn)\\n        {\\n            minn=2LL*minn-e;//Retrive the prev min\\n            \\n        }\\n          s.erase(it);         \\n    }\\n    \\n    int top() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn) return minn;\\n        return e;\\n    }\\n    \\n    int getMin() {\\n        return minn;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long int \\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    vector<ll> s;\\n    int minn;\\n    MinStack() {\\n        minn=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push_back(val);\\n            minn=val;\\n        }\\n        else if(val>=minn)\\n            s.push_back(val);\\n        else{\\n            s.push_back(2LL*val-minn);//Insert a number even less then val\\n            minn=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn)\\n        {\\n            minn=2LL*minn-e;//Retrive the prev min\\n            \\n        }\\n          s.erase(it);         \\n    }\\n    \\n    int top() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn) return minn;\\n        return e;\\n    }\\n    \\n    int getMin() {\\n        return minn;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572212,
                "title": "c-two-stacks",
                "content": "```cpp\\nvector<int> v, m;\\nvoid push(int x) {\\n    v.push_back(x);\\n    if (m.empty() || m.back() >= x)\\n        m.push_back(x);\\n}\\nvoid pop() {\\n    if (m.back() == v.back())\\n        m.pop_back();\\n    v.pop_back();\\n}\\nint top() {\\n    return v.back();\\n}\\nint getMin() {\\n    return m.back();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> v, m;\\nvoid push(int x) {\\n    v.push_back(x);\\n    if (m.empty() || m.back() >= x)\\n        m.push_back(x);\\n}\\nvoid pop() {\\n    if (m.back() == v.back())\\n        m.pop_back();\\n    v.pop_back();\\n}\\nint top() {\\n    return v.back();\\n}\\nint getMin() {\\n    return m.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449337,
                "title": "c-stack-valuetuple-int-int",
                "content": "Using a Named ValueTuple you can make your Stack clean and efficient. \\nRead more about it here https://docs.microsoft.com/en-us/dotnet/csharp/tuples and please like if this helped!\\n```\\npublic class MinStack\\n{\\n    private Stack<(int Value, int Min)> _stack;\\n\\n    public MinStack()\\n    {\\n        _stack = new Stack<(int, int)>();\\n    }\\n\\n    public void Push(int x)\\n    {\\n        var min = _stack.Any() ? Math.Min(x, GetMin()) : x;\\n        _stack.Push(new ValueTuple<int, int>(x, min));\\n    }\\n\\n    public void Pop()\\n    {\\n        _stack.Pop();\\n    }\\n\\n    public int Top()\\n    {\\n        return _stack.Peek().Value;\\n    }\\n\\n    public int GetMin()\\n    {\\n        return _stack.Peek().Min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MinStack\\n{\\n    private Stack<(int Value, int Min)> _stack;\\n\\n    public MinStack()\\n    {\\n        _stack = new Stack<(int, int)>();\\n    }\\n\\n    public void Push(int x)\\n    {\\n        var min = _stack.Any() ? Math.Min(x, GetMin()) : x;\\n        _stack.Push(new ValueTuple<int, int>(x, min));\\n    }\\n\\n    public void Pop()\\n    {\\n        _stack.Pop();\\n    }\\n\\n    public int Top()\\n    {\\n        return _stack.Peek().Value;\\n    }\\n\\n    public int GetMin()\\n    {\\n        return _stack.Peek().Min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360444,
                "title": "java-amortized-approach",
                "content": "```java\\nclass Node{\\n    int data, min;\\n    Node next;\\n    \\n    Node(int x){\\n        this.data = this.min = x;\\n        this.next = null;\\n    }\\n}\\n\\nclass MinStack {\\n    private Node head;\\n    public void push(int x) {\\n        if (head == null){\\n            head = new Node(x);\\n            return;\\n        }\\n        Node newNode = new Node(x);\\n        newNode.min = Math.min(newNode.min, head.min);\\n        newNode.next = head;\\n        head = newNode;\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.data;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Node{\\n    int data, min;\\n    Node next;\\n    \\n    Node(int x){\\n        this.data = this.min = x;\\n        this.next = null;\\n    }\\n}\\n\\nclass MinStack {\\n    private Node head;\\n    public void push(int x) {\\n        if (head == null){\\n            head = new Node(x);\\n            return;\\n        }\\n        Node newNode = new Node(x);\\n        newNode.min = Math.min(newNode.min, head.min);\\n        newNode.next = head;\\n        head = newNode;\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.data;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49178,
                "title": "sharing-my-28ms-c-solution",
                "content": "    class MinStack {\\n    private:\\n        vector<int> myVector;\\n        vector<int> myMins;\\n    public:\\n        void push(int x) {\\n            myVector.push_back(x);\\n            if(myMins.size()==0)\\n                myMins.push_back(x);\\n            else\\n            {\\n                int temp = myMins.back();\\n                if(x<temp)\\n                    temp = x;\\n                myMins.push_back(temp);\\n            }\\n        }\\n    \\n        void pop() {\\n            myVector.pop_back();\\n            myMins.pop_back();\\n        }\\n    \\n        int top() {\\n            return myVector.back();\\n        }\\n    \\n        int getMin() {\\n            return myMins.back();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    private:\\n        vector<int> myVector;\\n        vector<int> myMins;\\n    public:\\n        void push(int x) {\\n            myVector.push_back(x);\\n            if(myMins.size()==0)\\n                myMins.push_back(x);\\n            else\\n            {\\n                int temp = myMins.back();\\n                if(x<temp)\\n                    temp = x;\\n                myMins.push_back(temp);\\n            }\\n        }\\n    \\n        void pop() {\\n            myVector.pop_back();\\n            myMins.pop_back();\\n        }\\n    \\n        int top() {\\n            return myVector.back();\\n        }\\n    \\n        int getMin() {\\n            return myMins.back();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2659344,
                "title": "3-approaches-time-space-o-1-c",
                "content": "APPROACH 1: TIME O(1) SPACE O(N)\\nusing vector pair <val, minimum val til current element>\\n\\n```\\nclass MinStack {\\npublic:\\n    vector<pair<int, int>> v;\\n    void push(int val) \\n    {\\n        if (v.empty())  v.push_back({val, val}); \\n        else  \\n            v.push_back({val, min(val, v.back().second)}); //v.back() == v[v.size()-1]\\n    }\\n    void pop() { v.pop_back(); }\\n    int top() { return v.back().first; }\\n    int getMin() { return v.back().second; }\\n};\\n```\\n\\n#APPROACH 2: TIME O(1) SPACE O(N)\\nusing 2 stack implementation.\\n\\nLogic: maintain minimum in mini stack while pushing(push if val <= mini.top()) and popping (pop from mini if val == mini.top() )\\n\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> mini;\\n    \\n    void push(int val) {\\n        if (mini.empty() || val <= mini.top())\\n            mini.push(val);\\n        s.push(val);    \\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini.top())\\n            mini.pop();\\n        s.pop();\\n    }\\n    \\n    int top() { return s.top(); }\\n    int getMin() { return mini.top(); }\\n};\\n```\\n#Approach 3: OPTIMAL: TIME O(1) SPACE O(1) //no extra space except the stack itself\\n\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    int mini = INT_MAX;\\n    \\n    void push(int val) {\\n        if (val <= mini) //we\\'ll push previous min value into the stack before pushing new min val, coz when we\\'ll pop eg. min element then we need to update mini with prev min value   \\n        {\\n            s.push(mini); //we\\'ll use it to update mini when popping min element!\\n            mini = val; //update mini with min val\\n        }\\n        s.push(val);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini) //this means mini got updated here, and we know that we have stored previous min value in stack before pushing new minimum!\\n        {\\n            s.pop(); //popping curr min value \\n            mini = s.top(); //this is our previous min value, we\\'ll update mini, and now we\\'ll pop it as well!\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {return s.top(); } \\n    int getMin() { return mini; }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    vector<pair<int, int>> v;\\n    void push(int val) \\n    {\\n        if (v.empty())  v.push_back({val, val}); \\n        else  \\n            v.push_back({val, min(val, v.back().second)}); //v.back() == v[v.size()-1]\\n    }\\n    void pop() { v.pop_back(); }\\n    int top() { return v.back().first; }\\n    int getMin() { return v.back().second; }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> mini;\\n    \\n    void push(int val) {\\n        if (mini.empty() || val <= mini.top())\\n            mini.push(val);\\n        s.push(val);    \\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini.top())\\n            mini.pop();\\n        s.pop();\\n    }\\n    \\n    int top() { return s.top(); }\\n    int getMin() { return mini.top(); }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    int mini = INT_MAX;\\n    \\n    void push(int val) {\\n        if (val <= mini) //we\\'ll push previous min value into the stack before pushing new min val, coz when we\\'ll pop eg. min element then we need to update mini with prev min value   \\n        {\\n            s.push(mini); //we\\'ll use it to update mini when popping min element!\\n            mini = val; //update mini with min val\\n        }\\n        s.push(val);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini) //this means mini got updated here, and we know that we have stored previous min value in stack before pushing new minimum!\\n        {\\n            s.pop(); //popping curr min value \\n            mini = s.top(); //this is our previous min value, we\\'ll update mini, and now we\\'ll pop it as well!\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {return s.top(); } \\n    int getMin() { return mini; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799603,
                "title": "java-using-2-stacks-with-image-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/4f70590b-1b14-4a3f-ae5b-1049c90b86d3_1645821355.42753.jpeg)\\n\\n\\n\\n\\n\\n\\nclass MinStack {\\n    \\n    Stack<Integer> stack = new Stack(); // Normal Stack\\n    Stack<Integer> minStack = new Stack();// Keeps the current min on top \\n    \\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n\\n        // First time insert. If new min found add to minStack\\n        if(minStack.isEmpty() || val <=minStack.peek())\\n        {\\n            minStack.push(val);\\n        }\\n        \\n        stack.push(val);\\n    }\\n    \\n    \\n    public void pop() {\\n        // Pop from minStack only if top elements are same in both stacks\\n        if(stack.peek().equals(minStack.peek()))\\n        {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n        \\n        \\n    }\\n    \\n    public int top() {\\n       return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n       return minStack.peek();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/4f70590b-1b14-4a3f-ae5b-1049c90b86d3_1645821355.42753.jpeg)\\n\\n\\n\\n\\n\\n\\nclass MinStack {\\n    \\n    Stack<Integer> stack = new Stack(); // Normal Stack\\n    Stack<Integer> minStack = new Stack();// Keeps the current min on top \\n    \\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n\\n        // First time insert. If new min found add to minStack\\n        if(minStack.isEmpty() || val <=minStack.peek())\\n        {\\n            minStack.push(val);\\n        }\\n        \\n        stack.push(val);\\n    }\\n    \\n    \\n    public void pop() {\\n        // Pop from minStack only if top elements are same in both stacks\\n        if(stack.peek().equals(minStack.peek()))\\n        {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n        \\n        \\n    }\\n    \\n    public int top() {\\n       return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n       return minStack.peek();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1496281,
                "title": "96-faster-javascript-solution-with-comments-please-let-me-know-if-i-can-clarify-more",
                "content": "```\\n\\nvar MinStack = function() {\\n  this.storage = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n  // push an object containing the value and current min with this new val added\\n  this.storage.push({\\n    value: val,\\n    // if we\\'re pushing into an empty stack then our min val would be this val we\\'re pushing\\n    // if we pushed into a non empty stack then we would assign the Math.min of the val we\\'re pushing or the min value we assigned at the bottom most of our stack\\n    min: !this.storage.length ? val : Math.min(val, this.getMin())\\n  })\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  // currently our stack is implemented in reverse order so our top of stack is  at the bottom so we can pop from the end which is technically our top\\n  this.storage.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  // since our stack is reverse ordered returning the end of our stack is actually our top\\n  return this.storage[this.storage.length - 1].value;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  // since our stack is reverse ordered the min of our stack would be the min value we assigned to this el when we called our push method\\n  return this.storage[this.storage.length - 1].min;\\n};\\n\\n\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar MinStack = function() {\\n  this.storage = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n  // push an object containing the value and current min with this new val added\\n  this.storage.push({\\n    value: val,\\n    // if we\\'re pushing into an empty stack then our min val would be this val we\\'re pushing\\n    // if we pushed into a non empty stack then we would assign the Math.min of the val we\\'re pushing or the min value we assigned at the bottom most of our stack\\n    min: !this.storage.length ? val : Math.min(val, this.getMin())\\n  })\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  // currently our stack is implemented in reverse order so our top of stack is  at the bottom so we can pop from the end which is technically our top\\n  this.storage.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  // since our stack is reverse ordered returning the end of our stack is actually our top\\n  return this.storage[this.storage.length - 1].value;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  // since our stack is reverse ordered the min of our stack would be the min value we assigned to this el when we called our push method\\n  return this.storage[this.storage.length - 1].min;\\n};\\n\\n\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393500,
                "title": "c-stack-of-pair-tc-o-1-sc-o-n",
                "content": "here i had created stack of pair\\nin pair first element is origin element which is pushed but second is for maintain minimum.\\nso this way we maintain **min stack**\\n**Time Complexity : O(1)\\nSpace Complexity : O(n)**  *(specifically Space Complexity is O(2 * n) as we store 2 value for one pushed value)*\\n```\\nclass MinStack {\\npublic:\\n\\tstack<pair<int, int>>s;\\n\\tMinStack() {\\n\\n\\t}\\n\\n\\tvoid push(int val) {\\n\\t\\tif (!s.empty()) {\\n\\t\\t\\ts.push({val, min(val, s.top().second)});\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ts.push({val, val});\\n\\t\\t}\\n\\t}\\n\\n\\tvoid pop() {\\n\\t\\ts.pop();\\n\\t}\\n\\n\\tint top() {\\n\\t\\treturn s.top().first;\\n\\t}\\n\\n\\tint getMin() {\\n\\t\\treturn s.top().second;\\n\\t}\\n};\\n```\\n\\n**If you find it helpful *Upvote it* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n\\tstack<pair<int, int>>s;\\n\\tMinStack() {\\n\\n\\t}\\n\\n\\tvoid push(int val) {\\n\\t\\tif (!s.empty()) {\\n\\t\\t\\ts.push({val, min(val, s.top().second)});\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ts.push({val, val});\\n\\t\\t}\\n\\t}\\n\\n\\tvoid pop() {\\n\\t\\ts.pop();\\n\\t}\\n\\n\\tint top() {\\n\\t\\treturn s.top().first;\\n\\t}\\n\\n\\tint getMin() {\\n\\t\\treturn s.top().second;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963777,
                "title": "swift-tuple",
                "content": "```\\n\\nclass MinStack {\\n    var stack: [(element: Int, min: Int)] = []\\n\\n    func push(_ x: Int) {\\n        \\n        if stack.count == 0 {\\n            stack.append((x, x))\\n        } else {\\n            let top = self.getMin()\\n            stack.append((x, x > top ? top : x))\\n        }\\n    }\\n    \\n    func pop() {\\n        stack.popLast()\\n    }\\n    \\n    func top() -> Int {\\n        stack.last?.element ?? -1\\n    }\\n    \\n    func getMin() -> Int {\\n        stack.last?.min ?? -1\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * let obj = MinStack()\\n * obj.push(x)\\n * obj.pop()\\n * let ret_3: Int = obj.top()\\n * let ret_4: Int = obj.getMin()\\n */",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n\\nclass MinStack {\\n    var stack: [(element: Int, min: Int)] = []\\n\\n    func push(_ x: Int) {\\n        \\n        if stack.count == 0 {\\n            stack.append((x, x))\\n        } else {\\n            let top = self.getMin()\\n            stack.append((x, x > top ? top : x))\\n        }\\n    }\\n    \\n    func pop() {\\n        stack.popLast()\\n    }\\n    \\n    func top() -> Int {\\n        stack.last?.element ?? -1\\n    }\\n    \\n    func getMin() -> Int {\\n        stack.last?.min ?? -1\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * let obj = MinStack()\\n * obj.push(x)\\n * obj.pop()\\n * let ret_3: Int = obj.top()\\n * let ret_4: Int = obj.getMin()\\n */",
                "codeTag": "Java"
            },
            {
                "id": 572860,
                "title": "c-solutions-one-stack-two-stack-list",
                "content": "**Two-stack solution**\\n```\\npublic class MinStack {\\n\\n    private Stack<int> stack1;\\n    private Stack<int> stack2;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack1 = new Stack<int>();\\n        stack2 = new Stack<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack1.Count == 0)\\n        {         \\n            stack1.Push(x);\\n            stack2.Push(x);\\n        }\\n        else\\n        {\\n            stack1.Push(x);\\n            int currMin = stack2.Peek();\\n            stack2.Push(Math.Min(x, currMin));\\n        }\\n    }\\n    \\n    public void Pop() {\\n        stack1.Pop();\\n        stack2.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack1.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return stack2.Peek();    \\n    }\\n}\\n```\\n\\n**One-stack solution**\\n```\\npublic class MinStack {\\n\\n    private Stack<(int,int)> stack;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<(int, int)>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack.Count == 0)\\n            stack.Push((x, x));\\n        else\\n            stack.Push((x, Math.Min(x, stack.Peek().Item2)));\\n    }\\n    \\n    public void Pop() {\\n        stack.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack.Peek().Item1;\\n    }\\n    \\n    public int GetMin() {\\n        return stack.Peek().Item2;\\n    }\\n}\\n```\\n\\n**List solution**\\n```\\npublic class MinStack {\\n\\n    private List<int> list;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        list = new List<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        list.Add(x);\\n    }\\n    \\n    public void Pop() {\\n        list.RemoveAt(list.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        return list[list.Count - 1];\\n    }\\n    \\n    public int GetMin() {\\n        return list.Min();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MinStack {\\n\\n    private Stack<int> stack1;\\n    private Stack<int> stack2;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack1 = new Stack<int>();\\n        stack2 = new Stack<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack1.Count == 0)\\n        {         \\n            stack1.Push(x);\\n            stack2.Push(x);\\n        }\\n        else\\n        {\\n            stack1.Push(x);\\n            int currMin = stack2.Peek();\\n            stack2.Push(Math.Min(x, currMin));\\n        }\\n    }\\n    \\n    public void Pop() {\\n        stack1.Pop();\\n        stack2.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack1.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return stack2.Peek();    \\n    }\\n}\\n```\n```\\npublic class MinStack {\\n\\n    private Stack<(int,int)> stack;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<(int, int)>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack.Count == 0)\\n            stack.Push((x, x));\\n        else\\n            stack.Push((x, Math.Min(x, stack.Peek().Item2)));\\n    }\\n    \\n    public void Pop() {\\n        stack.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack.Peek().Item1;\\n    }\\n    \\n    public int GetMin() {\\n        return stack.Peek().Item2;\\n    }\\n}\\n```\n```\\npublic class MinStack {\\n\\n    private List<int> list;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        list = new List<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        list.Add(x);\\n    }\\n    \\n    public void Pop() {\\n        list.RemoveAt(list.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        return list[list.Count - 1];\\n    }\\n    \\n    public int GetMin() {\\n        return list.Min();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536177,
                "title": "swift-solution-with-detailed-explanation",
                "content": "**This implementation uses Linked List data structure approach.**\\n\\nFirst of all we need to define linked list node.\\nWe can use generic parameter \"Value\" to create more flexible data structure. Every instance of \"Node\" - contains current value, minimum value and a reference to the next instance as well.\\n```\\nclass Node<Value> {\\n\\n    var next: Node?\\n    var value: Value\\n    var min: Value\\n    \\n    init(value: Value, min: Value, next: Node? = .none) {\\n        self.value = value\\n        self.min = min\\n        self.next = next\\n    }\\n    \\n}\\n```\\n**Minimum stack data structure implementation is straightforward:**\\n1.  Private instance of \"Node\", which is nil by default.\\n2.  First call of  push(_ x: Int) will init head node with brand new values of current value and min value. By the next calls we will check whether \"head\" is nill, if \"head\" is not nil - current \"head\" become new instance of \"Node\", where new minimum value will be calculated from current \"min\" and \"x\" parameter that was passed in.\\n3.  To pop the top most element of stack we simply assign the next node after current to \"head\".\\n4.  As \"head\" is the top element in stack, to get its value we simply look to its \"value\" value.\\n5.  A \"min()\" operation works same as the top(), the only difference is that we look for \"min\" value.\\n```\\nclass MinStack {\\n    \\n    private var head: Node<Int>!\\n    \\n    func push(_ x: Int) {\\n        if head == nil {\\n            head = Node(value: x, min: x)\\n        } else {\\n            head = Node(value: x, min: min(head.min, x), next: head)\\n        }\\n    }\\n    \\n    func pop() {\\n        head = head.next\\n    }\\n    \\n    func top() -> Int {\\n        return head.value\\n    }\\n    \\n    func getMin() -> Int {\\n        return head.min\\n    }\\n    \\n}\\n```\\n**The Big-O notation for common operations is next:**\\n1. push(_ x: Int) works in constant time complexity O(1).\\n2. pop() works in constant time complexity O(1).\\n3. top() works in constant time complexity O(1).\\n4. getMin() works in constant time complexity O(1) as well.\\n",
                "solutionTags": [
                    "Swift",
                    "Linked List"
                ],
                "code": "```\\nclass Node<Value> {\\n\\n    var next: Node?\\n    var value: Value\\n    var min: Value\\n    \\n    init(value: Value, min: Value, next: Node? = .none) {\\n        self.value = value\\n        self.min = min\\n        self.next = next\\n    }\\n    \\n}\\n```\n```\\nclass MinStack {\\n    \\n    private var head: Node<Int>!\\n    \\n    func push(_ x: Int) {\\n        if head == nil {\\n            head = Node(value: x, min: x)\\n        } else {\\n            head = Node(value: x, min: min(head.min, x), next: head)\\n        }\\n    }\\n    \\n    func pop() {\\n        head = head.next\\n    }\\n    \\n    func top() -> Int {\\n        return head.value\\n    }\\n    \\n    func getMin() -> Int {\\n        return head.min\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49212,
                "title": "solution-using-a-linked-list-clean-and-self-explanatory",
                "content": "    class MinStack {\\n        class Node{\\n        int value;\\n        int min;\\n        Node next=null;\\n            Node(int x, int min){\\n                value=x;\\n                this.min=min;\\n            }\\n        }\\n        Node head=null;\\n        public void push(int x) {\\n            if(head ==null){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(head.min,x));\\n                n.next = head;\\n                head = n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head=head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n             return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(head!=null)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class MinStack {\\n        class Node{\\n        int value;\\n        int min;\\n        Node next=null;\\n            Node(int x, int min){\\n                value=x;\\n                this.min=min;\\n            }\\n        }\\n        Node head=null;\\n        public void push(int x) {\\n            if(head ==null){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(head.min,x));\\n                n.next = head;\\n                head = n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head=head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n             return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(head!=null)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49244,
                "title": "8-line-single-stack-time-o-1-for-all-4-operations",
                "content": "    public class MinStack {\\n        private readonly Stack<long> stack = new Stack<long>();\\n        private long min = 0l;\\n        public void Push(int x){\\n            stack.Push((long)x - (min = stack.Count == 0 ? (long)x : min));\\n            if ((long)x < min) min = (long)x;\\n        }\\n        public void Pop(){\\n            if(stack.Peek() < 0) min -= stack.Peek();\\n            stack.Pop();\\n        }\\n        public int Top(){\\n            return stack.Peek() < 0 ? (int)min : (int)(min + stack.Peek());\\n        }\\n        public int GetMin(){\\n            return (int)min;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class MinStack {\\n        private readonly Stack<long> stack = new Stack<long>();\\n        private long min = 0l;\\n        public void Push(int x){\\n            stack.Push((long)x - (min = stack.Count == 0 ? (long)x : min));\\n            if ((long)x < min) min = (long)x;\\n        }\\n        public void Pop(){\\n            if(stack.Peek() < 0) min -= stack.Peek();\\n            stack.Pop();\\n        }\\n        public int Top(){\\n            return stack.Peek() < 0 ? (int)min : (int)(min + stack.Peek());\\n        }\\n        public int GetMin(){\\n            return (int)min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49209,
                "title": "19-lines-simple-answer-31ms",
                "content": "class MinStack {\\npublic:\\n\\n    stack<int> Data, Min;\\n\\n    void push(int x) {\\n        Data.push(x);\\n        if(Min.empty()||x<Min.top()) Min.push(x);\\n        else Min.push(Min.top());\\n    }\\n\\n    void pop() {\\n        if(Data.empty()) return;\\n        Data.pop();\\n        Min.pop();\\n    }\\n\\n    int top() {\\n        if(!Data.empty())\\n            return Data.top();\\n    }\\n\\n    int getMin() {\\n        if(!Min.empty());\\n            return Min.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class MinStack {\\npublic:\\n\\n    stack<int> Data, Min;\\n\\n    void push(int x) {\\n        Data.push(x);\\n        if(Min.empty()||x<Min.top()) Min.push(x);\\n        else Min.push(Min.top());\\n    }\\n\\n    void pop() {\\n        if(Data.empty()) return;\\n        Data.pop();\\n        Min.pop();\\n    }\\n\\n    int top() {\\n        if(!Data.empty())\\n            return Data.top();\\n    }\\n\\n    int getMin() {\\n        if(!Min.empty());\\n            return Min.top();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3341044,
                "title": "beats-86-o-1-6-lines-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<int> st1,st2;\\n    void push(int val) {\\n        if(st1.empty()){st1.push(val);st2.push(val);return ;}\\n        st1.push(val); st2.push(min(val,st2.top()));\\n    }\\n    void pop() {\\n        if(st1.empty()){return ;}\\n        st1.pop();st2.pop();\\n    }\\n    int top(){ return st1.top();}\\n    int getMin(){ return st2.top();}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> st1,st2;\\n    void push(int val) {\\n        if(st1.empty()){st1.push(val);st2.push(val);return ;}\\n        st1.push(val); st2.push(min(val,st2.top()));\\n    }\\n    void pop() {\\n        if(st1.empty()){return ;}\\n        st1.pop();st2.pop();\\n    }\\n    int top(){ return st1.top();}\\n    int getMin(){ return st2.top();}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539741,
                "title": "c-super-simple-and-clean-solution",
                "content": "**Idea:**\\nWe use a stack that stores pairs of `{ val, min_so_far }`.\\nWe also have a `curr_min` for the current min.\\nWith this idea, implementation is super simple.\\n```\\nclass MinStack {\\npublic:\\n    MinStack() {}\\n    \\n    void push(int val) {\\n        if (val < curr_min) {\\n            s.push({val, val});\\n            curr_min = val;\\n        }\\n        else s.push({val, curr_min});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n        curr_min = s.empty() ? INT_MAX : s.top().second;\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return curr_min;\\n    }\\n    \\nprivate:\\n    stack<pair<int, int>> s;\\n    int curr_min = INT_MAX;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    MinStack() {}\\n    \\n    void push(int val) {\\n        if (val < curr_min) {\\n            s.push({val, val});\\n            curr_min = val;\\n        }\\n        else s.push({val, curr_min});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n        curr_min = s.empty() ? INT_MAX : s.top().second;\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return curr_min;\\n    }\\n    \\nprivate:\\n    stack<pair<int, int>> s;\\n    int curr_min = INT_MAX;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539209,
                "title": "simple-to-understand-2-ways-stack-list-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nThis solution is inspired by the hint ```Consider each node in the stack having a minimum value.```\\n\\nThe main idea of this solution is to have a way to keep track of the minimum value every time an item is pushed onto the stack. \\n\\nWhen a new value is pushed onto the stack, it is checked against the last minimum to see if the current value is a minimum. Every time a new item is added, we keep track of the minimum value for each push.\\n\\nIn both solutions:\\n* When the ```Top``` function is called, the current top value is returned.\\n* When the ```GetMin``` function is called, the minimum value at the time top value was pushed onto the stack is returned\\n* When the ```Push``` function is called, the value and the current minimum value is pushed onto the stack\\n\\n**1. Using Stack**\\n\\nIn this solution, we use a stack<pair<int, int>> to keep track of the current item pushed onto the stack, and the minimum value at the time the item was pushed onto the stack.\\n\\n```\\npublic class MinStack {\\n    private Stack<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the stack\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new Stack<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Push(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.Pop();\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data.Peek().Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data.Peek().Value;        \\n    }\\n}\\n ```\\n \\n \\n**2. Using List**\\n\\nIn this solution, we use a list<pair<int, int>> to keep track of the current item pushed onto the stack, and the minimum value at the time the item was pushed onto the stack.\\n\\n ```\\npublic class MinStack {\\n    private List<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the list\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new List<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Add(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.RemoveAt(data.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data[data.Count - 1].Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data[data.Count - 1].Value;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Consider each node in the stack having a minimum value.```\n```Top```\n```GetMin```\n```Push```\n```\\npublic class MinStack {\\n    private Stack<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the stack\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new Stack<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Push(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.Pop();\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data.Peek().Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data.Peek().Value;        \\n    }\\n}\\n ```\n```\\npublic class MinStack {\\n    private List<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the list\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new List<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Add(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.RemoveAt(data.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data[data.Count - 1].Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data[data.Count - 1].Value;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938346,
                "title": "simple-and-fast-python-solution-using-2-lists-86-51-faster",
                "content": "key concept: Appending and popping a list is faster than inserting/removing from front.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stk=[]\\n        self.min=[float(\\'inf\\')]\\n\\n    def push(self, x: int) -> None:\\n        self.stk.append(x)\\n        if x <= self.min[-1]: self.min.append(x)\\n        \\n    def pop(self) -> None:\\n        x=self.stk.pop()\\n        if x == self.min[-1]: self.min.pop()\\n        return self.stk\\n\\n    def top(self) -> int:\\n        return self.stk[-1]\\n\\n    def getMin(self) -> int:\\n        return self.min[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stk=[]\\n        self.min=[float(\\'inf\\')]\\n\\n    def push(self, x: int) -> None:\\n        self.stk.append(x)\\n        if x <= self.min[-1]: self.min.append(x)\\n        \\n    def pop(self) -> None:\\n        x=self.stk.pop()\\n        if x == self.min[-1]: self.min.pop()\\n        return self.stk\\n\\n    def top(self) -> int:\\n        return self.stk[-1]\\n\\n    def getMin(self) -> int:\\n        return self.min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696208,
                "title": "java-one-stack-o-1-and-o-n",
                "content": "```\\nclass MinStack {\\n    private Stack<Integer> stack;\\n    private int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        min = Integer.MAX_VALUE;\\n    }\\n    \\n    public void push(int x) {\\n        if(x <= min){   // memorize the previous min by pushing it to the stack\\n            stack.push(min);\\n            min = x;\\n        }\\n        stack.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stack.pop() == min){\\n            min = stack.pop();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n    private Stack<Integer> stack;\\n    private int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        min = Integer.MAX_VALUE;\\n    }\\n    \\n    public void push(int x) {\\n        if(x <= min){   // memorize the previous min by pushing it to the stack\\n            stack.push(min);\\n            min = x;\\n        }\\n        stack.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stack.pop() == min){\\n            min = stack.pop();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158351,
                "title": "javascript-68ms-beats-100",
                "content": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MinStack = function() {\\n  this.stack = [];\\n  this.min = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.stack.push(x);\\n\\n  var min = this.getMin();\\n  if (min !== undefined) {\\n    this.min.push(Math.min(x, min));\\n  } else {\\n    this.min.push(x);\\n  }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.stack.pop();\\n  this.min.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1];\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  if (this.min.length > 0) {\\n    return this.min[this.min.length - 1];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MinStack = function() {\\n  this.stack = [];\\n  this.min = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.stack.push(x);\\n\\n  var min = this.getMin();\\n  if (min !== undefined) {\\n    this.min.push(Math.min(x, min));\\n  } else {\\n    this.min.push(x);\\n  }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.stack.pop();\\n  this.min.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1];\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  if (this.min.length > 0) {\\n    return this.min[this.min.length - 1];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49171,
                "title": "implement-with-stack-and-pair-all-operations-have-o-1-time-complexity",
                "content": "**each element in stack is a pair of two int. The first is the int that we want to push into the stack. And the other one is the minimum value of the stack at this moment.**\\n\\n    class MinStack {\\n    private:\\n    stack<pair<int, int>> sta;\\n    public:\\n    void push(int x) {\\n        if(sta.empty()) \\n            sta.push(make_pair(x, x));\\n        else {\\n            auto top = sta.top();\\n            sta.push(make_pair(x, x < top.second ? x : top.second));\\n        }\\n    }\\n\\n    void pop() {\\n        if(!sta.empty())\\n            sta.pop();\\n    }\\n\\n    int top() {\\n        if(!sta.empty())\\n            return sta.top().first;\\n        else\\n            return -1;\\n    }\\n\\n    int getMin() {\\n        if(!sta.empty())\\n            return sta.top().second;\\n        else \\n            return -1;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "**each element in stack is a pair of two int. The first is the int that we want to push into the stack. And the other one is the minimum value of the stack at this moment.**\\n\\n    class MinStack {\\n    private:\\n    stack<pair<int, int>> sta;\\n    public:\\n    void push(int x) {\\n        if(sta.empty()) \\n            sta.push(make_pair(x, x));\\n        else {\\n            auto top = sta.top();\\n            sta.push(make_pair(x, x < top.second ? x : top.second));\\n        }\\n    }\\n\\n    void pop() {\\n        if(!sta.empty())\\n            sta.pop();\\n    }\\n\\n    int top() {\\n        if(!sta.empty())\\n            return sta.top().first;\\n        else\\n            return -1;\\n    }\\n\\n    int getMin() {\\n        if(!sta.empty())\\n            return sta.top().second;\\n        else \\n            return -1;\\n    }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49274,
                "title": "c-two-stacks",
                "content": "Use one stack `data` to store the elements and the other stack `minimum` to store the minimum.\\n\\nFor `push`, push the element to `data`. If the element is not larger than the top of `minimum`, push it to `minimum`. For `pop`, if the top of the two stacks are equal, pop both; otherwise pop `data`. For `top` and `getMin`, just return the top of `data` and `minimum` respectively.\\n\\n```cpp\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x);\\n        if (minimum.empty() || minimum.top() >= x) {\\n            minimum.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if (top() == getMin()) {\\n            minimum.pop();\\n        }\\n        data.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minimum.top();\\n    }\\nprivate:\\n    stack<int> data, minimum;\\n};\\n ```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```cpp\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x);\\n        if (minimum.empty() || minimum.top() >= x) {\\n            minimum.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if (top() == getMin()) {\\n            minimum.pop();\\n        }\\n        data.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minimum.top();\\n    }\\nprivate:\\n    stack<int> data, minimum;\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 49251,
                "title": "python-ac-solution-and-memory-limit-exceeded-mle-problem-using-tuple-element",
                "content": "My AC code:\\n\\n    class MinStack:\\n    # @param x, an integer\\n    def __init__(self):\\n        # the stack it self\\n        self.A = []\\n        self.minS=[]\\n    # @return an integer\\n    def push(self, x):\\n        n=len(self.A)\\n        if n==0:\\n            self.minS.append(x)\\n        else:\\n            lastmin=self.minS[-1]\\n            if x<=lastmin:\\n                self.minS.append(x)\\n        self.A.append(x)\\n    # @return nothing\\n    def pop(self):\\n        if len(self.A)>0 and self.A.pop()==self.minS[-1]:\\n            self.minS.pop()\\n    # @return an integer\\n    def top(self):\\n        return self.A[-1]\\n        \\n\\n    # @return an integer\\n    def getMin(self):\\n        return self.minS[-1]\\n        \\nHowever, at my first try, I use tuples in list [(element, min_value_sofar)] and got MLE. Can anyone explain the reason? I thought that the memory is still O(n).\\n\\nMy complete solution blog: [http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html][1]\\n\\n\\n  [1]: http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html",
                "solutionTags": [
                    "Python"
                ],
                "code": "My AC code:\\n\\n    class MinStack:\\n    # @param x, an integer\\n    def __init__(self):\\n        # the stack it self\\n        self.A = []\\n        self.minS=[]\\n    # @return an integer\\n    def push(self, x):\\n        n=len(self.A)\\n        if n==0:\\n            self.minS.append(x)\\n        else:\\n            lastmin=self.minS[-1]\\n            if x<=lastmin:\\n                self.minS.append(x)\\n        self.A.append(x)\\n    # @return nothing\\n    def pop(self):\\n        if len(self.A)>0 and self.A.pop()==self.minS[-1]:\\n            self.minS.pop()\\n    # @return an integer\\n    def top(self):\\n        return self.A[-1]\\n        \\n\\n    # @return an integer\\n    def getMin(self):\\n        return self.minS[-1]\\n        \\nHowever, at my first try, I use tuples in list [(element, min_value_sofar)] and got MLE. Can anyone explain the reason? I thought that the memory is still O(n).\\n\\nMy complete solution blog: [http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html][1]\\n\\n\\n  [1]: http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html",
                "codeTag": "Java"
            },
            {
                "id": 3595971,
                "title": "o-1-time-two-stacks-explaned-c-easiest",
                "content": "# Approach\\n- The push function adds the given value to s1 (the main stack). It then checks if s2 (the stack used to store the minimum values) is empty or if the new value is less than or equal to the current minimum (getMin()). If either condition is true, the new value is pushed onto s2.\\n- The pop function removes the top element from s1. It also checks if the top elements of s1 and s2 are equal. If they are equal, it means that the minimum element is being removed, so the top element is also popped from s2.\\n- The top function simply returns the top element of s1.\\n- The getMin function returns the top element of s2, which represents the current minimum element in the stack.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(no of function calls)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s1;\\n    stack<int> s2;\\n   \\n    void push(int val) {\\n        s1.push(val);\\n        if(s2.empty() or val<=getMin()) s2.push(val);\\n        \\n    }\\n    \\n    void pop() {\\n        if(s1.top()==s2.top()) s2.pop();\\n        s1.pop();\\n    }\\n\\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();        \\n    }\\n};\\n\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> s1;\\n    stack<int> s2;\\n   \\n    void push(int val) {\\n        s1.push(val);\\n        if(s2.empty() or val<=getMin()) s2.push(val);\\n        \\n    }\\n    \\n    void pop() {\\n        if(s1.top()==s2.top()) s2.pop();\\n        s1.pop();\\n    }\\n\\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481996,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\nThe idea is to create a doubly linkedlist and along with each node push current minimum till that point so that if any pop operation occur and the min value got deleted , we still have the data of prev min value in the last node. Before pushing any node we recalculate the min value as we are storing min value in last node we just grab the last node and compare the min value and push it along with the new node and update the last pointer to current pushed node.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here,.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\n    \\n    // private int min=Integer.MAX_VALUE;\\n    private Node lst_point=null;\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        int min=Math.min(val,lst_point==null? Integer.MAX_VALUE:lst_point.min);\\n        Node temp=new Node(min,val);\\n        if(lst_point==null)\\n        {\\n            lst_point=temp;\\n        }\\n        else{\\n            lst_point.next=temp;\\n            temp.prev=lst_point;\\n            lst_point=lst_point.next;\\n        }\\n    }\\n    \\n    public void pop() {\\n        Node temp=lst_point.prev;\\n        if(temp!=null)\\n        temp.next=null;\\n        \\n        lst_point.prev=null;\\n        lst_point=temp;\\n    }\\n    \\n    public int top() {\\n        return lst_point.val;\\n    }\\n    \\n    public int getMin() {\\n        return lst_point.min;\\n    }\\n\\n    private class Node{\\n        int min;\\n        int val;\\n        Node next;\\n        Node prev;\\n        Node(int min,int val)\\n        {\\n            this.min=min;\\n            this.val=val;\\n            this.next=null;\\n            this.prev=null;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n`\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\nThe idea is to create a doubly linkedlist and along with each node push current minimum till that point so that if any pop operation occur and the min value got deleted , we still have the data of prev min value in the last node. Before pushing any node we recalculate the min value as we are storing min value in last node we just grab the last node and compare the min value and push it along with the new node and update the last pointer to current pushed node.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here,.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\n    \\n    // private int min=Integer.MAX_VALUE;\\n    private Node lst_point=null;\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        int min=Math.min(val,lst_point==null? Integer.MAX_VALUE:lst_point.min);\\n        Node temp=new Node(min,val);\\n        if(lst_point==null)\\n        {\\n            lst_point=temp;\\n        }\\n        else{\\n            lst_point.next=temp;\\n            temp.prev=lst_point;\\n            lst_point=lst_point.next;\\n        }\\n    }\\n    \\n    public void pop() {\\n        Node temp=lst_point.prev;\\n        if(temp!=null)\\n        temp.next=null;\\n        \\n        lst_point.prev=null;\\n        lst_point=temp;\\n    }\\n    \\n    public int top() {\\n        return lst_point.val;\\n    }\\n    \\n    public int getMin() {\\n        return lst_point.min;\\n    }\\n\\n    private class Node{\\n        int min;\\n        int val;\\n        Node next;\\n        Node prev;\\n        Node(int min,int val)\\n        {\\n            this.min=min;\\n            this.val=val;\\n            this.next=null;\\n            this.prev=null;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n`\\n",
                "codeTag": "Java"
            },
            {
                "id": 2633818,
                "title": "clean-95-faster-python3-solution-easiest-and-0-1",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack=[]\\n        self.minstack=[]\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        val=min(val,self.minstack[-1] if self.minstack else val)\\n        self.minstack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack=[]\\n        self.minstack=[]\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        val=min(val,self.minstack[-1] if self.minstack else val)\\n        self.minstack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252739,
                "title": "python-99-9-faster-with-explanation-and-comments",
                "content": "This solution is fast, but relies on increased memory usage. Beat 99.87% in time complexity and 15.8% in memory. \\n\\nMain idea:\\nUse python list as stack storage. Push tuple of (value, minimum element) in the list.  This way at every \"push\", \"pop\" we can easily get minimum value by unpacking our tuple.\\n\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.min_val = 0\\n\\n    def push(self, val: int) -> None:\\n        #When empty, set first element as min_val\\n        if not self.stack:\\n            self.min_val = val\\n    \\n        cur_min = self.getMin()\\n        if val < cur_min:\\n            self.min_val = val\\n            \\n        #Append tuple of (value,minimum value at the time)    \\n        self.stack.append((val,self.min_val))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        val, _ = self.stack[-1]\\n        return val\\n\\n    def getMin(self) -> int:\\n        #If empty, return default min_val\\n        if not self.stack:\\n            return self.min_val\\n        #Unpack tuple into min_val\\n        _, self.min_val = self.stack[-1]\\n        return self.min_val\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.min_val = 0\\n\\n    def push(self, val: int) -> None:\\n        #When empty, set first element as min_val\\n        if not self.stack:\\n            self.min_val = val\\n    \\n        cur_min = self.getMin()\\n        if val < cur_min:\\n            self.min_val = val\\n            \\n        #Append tuple of (value,minimum value at the time)    \\n        self.stack.append((val,self.min_val))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        val, _ = self.stack[-1]\\n        return val\\n\\n    def getMin(self) -> int:\\n        #If empty, return default min_val\\n        if not self.stack:\\n            return self.min_val\\n        #Unpack tuple into min_val\\n        _, self.min_val = self.stack[-1]\\n        return self.min_val\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885112,
                "title": "c-70-faster-stacks-with-comments",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<int> st;  //main stack\\n    stack<int> mn;   //handle minimum element\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push(val); \\n        if(mn.size()==0 or val<=mn.top())   //if min stack is empty or val is smaller or equal to mn.top() which is current min element then push \\n            mn.push(val);\\n    }\\n    \\n    void pop() {\\n        if(st.top()==mn.top())    //if element we remove is also current min element then pop it from min stack too\\n            mn.pop();\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top();\\n    }\\n    \\n    int getMin() {\\n        return mn.top();\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> st;  //main stack\\n    stack<int> mn;   //handle minimum element\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push(val); \\n        if(mn.size()==0 or val<=mn.top())   //if min stack is empty or val is smaller or equal to mn.top() which is current min element then push \\n            mn.push(val);\\n    }\\n    \\n    void pop() {\\n        if(st.top()==mn.top())    //if element we remove is also current min element then pop it from min stack too\\n            mn.pop();\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top();\\n    }\\n    \\n    int getMin() {\\n        return mn.top();\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "codeTag": "Java"
            },
            {
                "id": 1796099,
                "title": "95-fasterr-c-easy-solution-using-linked-list",
                "content": "We will create a **Linked List Node** which will have its value, the current minimum value of the stack and the address of the next top element of the stack.\\n\\n```\\nclass MinStack {\\nprivate:\\n    //Creating our structure Node\\n    struct Node{   \\n        \\n          int val;\\n          int minn;\\n          Node* next;\\n        \\n          Node(int val,int minn,Node* next = NULL){\\n               this->val = val;\\n               this->minn = minn;\\n               this->next = next;\\n        }\\n    };\\n    \\n    Node* head; //head will always point to the top value of stack\\n    \\n   \\npublic:\\n    MinStack() {\\n        head = NULL;  //initialising head with NULL\\n    }\\n    \\n    void push(int val) {\\n        if(head==NULL)\\n            head = new Node(val,val,NULL); // checking if the stack is empty then assigning min value as same as the value that\\'s being pushed on to the stack and the next variable as NULL\\n        else{\\n            head = new Node(val, min(val,head->minn),head); //The new top of the stack and maintaining the minimum value of stack by comparing the current minimum with the value thats being added\\n        }\\n       \\n    }\\n    \\n    void pop() {\\n        \\n        head = head->next; //moving our head pointer to the next element in the stack\\n       \\n        \\n    }\\n    \\n    int top() {\\n        return head->val;  //the top value\\n       \\n    }\\n    \\n    int getMin() {\\n        return head->minn; //returning the current minimum\\n        \\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass MinStack {\\nprivate:\\n    //Creating our structure Node\\n    struct Node{   \\n        \\n          int val;\\n          int minn;\\n          Node* next;\\n        \\n          Node(int val,int minn,Node* next = NULL){\\n               this->val = val;\\n               this->minn = minn;\\n               this->next = next;\\n        }\\n    };\\n    \\n    Node* head; //head will always point to the top value of stack\\n    \\n   \\npublic:\\n    MinStack() {\\n        head = NULL;  //initialising head with NULL\\n    }\\n    \\n    void push(int val) {\\n        if(head==NULL)\\n            head = new Node(val,val,NULL); // checking if the stack is empty then assigning min value as same as the value that\\'s being pushed on to the stack and the next variable as NULL\\n        else{\\n            head = new Node(val, min(val,head->minn),head); //The new top of the stack and maintaining the minimum value of stack by comparing the current minimum with the value thats being added\\n        }\\n       \\n    }\\n    \\n    void pop() {\\n        \\n        head = head->next; //moving our head pointer to the next element in the stack\\n       \\n        \\n    }\\n    \\n    int top() {\\n        return head->val;  //the top value\\n       \\n    }\\n    \\n    int getMin() {\\n        return head->minn; //returning the current minimum\\n        \\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1541188,
                "title": "c-o-n-stack",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass MinStack {\\npublic:\\n    \\n    #define ll long long\\n    \\n    stack<ll int> st;\\n    ll int minval;\\n    \\n    MinStack() {\\n        minval=10000000000;\\n    }\\n    \\n    void push(int val) {\\n        if(st.size()==0){\\n            st.push(val);\\n            minval=val;\\n        }else if(val>=minval){\\n            st.push(val);\\n        }else{\\n            ll int dummy=val+(val-minval); // this value will be smaller than current min, detection point that min val changes\\n            st.push(dummy);\\n            minval=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        if(st.top()>=minval){\\n            st.pop();\\n        }else{\\n            minval=minval + (minval-st.top()); // retrieving previous min value (for remaining elements)\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.top()>=minval){\\n            return st.top();\\n        }\\n        return (int)minval;\\n    }\\n    \\n    int getMin() {\\n        return (int)minval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    #define ll long long\\n    \\n    stack<ll int> st;\\n    ll int minval;\\n    \\n    MinStack() {\\n        minval=10000000000;\\n    }\\n    \\n    void push(int val) {\\n        if(st.size()==0){\\n            st.push(val);\\n            minval=val;\\n        }else if(val>=minval){\\n            st.push(val);\\n        }else{\\n            ll int dummy=val+(val-minval); // this value will be smaller than current min, detection point that min val changes\\n            st.push(dummy);\\n            minval=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        if(st.top()>=minval){\\n            st.pop();\\n        }else{\\n            minval=minval + (minval-st.top()); // retrieving previous min value (for remaining elements)\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.top()>=minval){\\n            return st.top();\\n        }\\n        return (int)minval;\\n    }\\n    \\n    int getMin() {\\n        return (int)minval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383608,
                "title": "c-tc-o-1-sc-o-n-2-stacks",
                "content": "# *Store minimum value at each stage in another stack, pop and push them simultaneously* \\n```\\nclass MinStack {\\npublic:\\n    int Stack[100000];\\n    int minStack[100000];\\n    int i=-1;\\n    \\n    MinStack() {\\n        i=-1;\\n    }\\n    \\n    void push(int val) {\\n        i++;\\n        Stack[i] = val;\\n        if(i>0)\\n            minStack[i] = min( minStack[i-1] , val ) ;\\n        else\\n            minStack[i] = val;\\n    }\\n    \\n    void pop() {\\n        i--;\\n    }\\n    \\n    int top() {\\n        return Stack[i];\\n    }\\n    \\n    int getMin() {\\n        return minStack[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    int Stack[100000];\\n    int minStack[100000];\\n    int i=-1;\\n    \\n    MinStack() {\\n        i=-1;\\n    }\\n    \\n    void push(int val) {\\n        i++;\\n        Stack[i] = val;\\n        if(i>0)\\n            minStack[i] = min( minStack[i-1] , val ) ;\\n        else\\n            minStack[i] = val;\\n    }\\n    \\n    void pop() {\\n        i--;\\n    }\\n    \\n    int top() {\\n        return Stack[i];\\n    }\\n    \\n    int getMin() {\\n        return minStack[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973517,
                "title": "java-tme-o-1-o-1-o-1-o-1-space-o-n",
                "content": "```\\nclass MinStack {\\n    class Node{\\n        Node(int x, int min, Node prev){\\n            this.x=x;\\n            this.min=min;\\n            this.prev = prev;\\n        }\\n        int x;\\n        int min;\\n        Node prev;\\n    }\\n    \\n    Node tail = null;\\n    \\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        if(tail == null){\\n            tail = new Node(x, x, tail);\\n        } else{\\n            tail = new Node(x, Math.min(x, tail.min), tail);\\n        }\\n    }\\n    \\n    public void pop() {\\n        tail = tail.prev;\\n    }\\n    \\n    public int top() {\\n        return tail.x;\\n    }\\n    \\n    public int getMin() {\\n        return tail.min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n    class Node{\\n        Node(int x, int min, Node prev){\\n            this.x=x;\\n            this.min=min;\\n            this.prev = prev;\\n        }\\n        int x;\\n        int min;\\n        Node prev;\\n    }\\n    \\n    Node tail = null;\\n    \\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        if(tail == null){\\n            tail = new Node(x, x, tail);\\n        } else{\\n            tail = new Node(x, Math.min(x, tail.min), tail);\\n        }\\n    }\\n    \\n    public void pop() {\\n        tail = tail.prev;\\n    }\\n    \\n    public int top() {\\n        return tail.x;\\n    }\\n    \\n    public int getMin() {\\n        return tail.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878213,
                "title": "python-3-faster-than-94-two-stacks-comments-attached",
                "content": "The tricky part is the getMin requires constant time, therefore we need to store the min value for constant time access. Every push or pop, we need to update the min value correspondingly. So I use two stacks. The self.min stack stores the min values. Thanks for upvoting if you feel this solution helps.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.min = list()\\n        \\n\\n    def push(self, x: int) -> None:\\n        if not self.stack or x < self.min[-1]:\\n            self.min.append(x)\\n        else:\\n            self.min.append(self.min[-1])\\n        self.stack.append(x)\\n\\n    def pop(self) -> None:\\n        self.stack = self.stack[:-1]\\n        self.min = self.min[:-1]\\n        \\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        if not self.min: return None\\n        return self.min[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.min = list()\\n        \\n\\n    def push(self, x: int) -> None:\\n        if not self.stack or x < self.min[-1]:\\n            self.min.append(x)\\n        else:\\n            self.min.append(self.min[-1])\\n        self.stack.append(x)\\n\\n    def pop(self) -> None:\\n        self.stack = self.stack[:-1]\\n        self.min = self.min[:-1]\\n        \\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        if not self.min: return None\\n        return self.min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241983,
                "title": "java-simple-two-stack-beats-100",
                "content": "Used two stacks. \\n- Main stack keeps track of everything that goes in called stk.\\n- Other stack keeps track of all mins, called stkTrackmin.\\n\\n```\\nclass MinStack {\\n\\n    Stack<Integer> stk = new Stack<>();\\n    Stack<Integer> stk2 = new Stack<>();\\n    \\n    public void push(int x) {\\n        stk.push(x);                             //Always push into main stack\\n        if(stk2.isEmpty() || x <= stk2.peek())   //Push when empty OR x<= current smallest value\\n            stk2.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stk.pop().equals(stk2.peek()))    //Main stk always pop\\n            stk2.pop();                      //Other stk pops only if it equal to main stk\\'s min\\n    }\\n    \\n    public int top() {\\n        return stk.peek();\\n    }\\n    \\n    public int getMin() {\\n        return stk2.peek();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n\\n    Stack<Integer> stk = new Stack<>();\\n    Stack<Integer> stk2 = new Stack<>();\\n    \\n    public void push(int x) {\\n        stk.push(x);                             //Always push into main stack\\n        if(stk2.isEmpty() || x <= stk2.peek())   //Push when empty OR x<= current smallest value\\n            stk2.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stk.pop().equals(stk2.peek()))    //Main stk always pop\\n            stk2.pop();                      //Other stk pops only if it equal to main stk\\'s min\\n    }\\n    \\n    public int top() {\\n        return stk.peek();\\n    }\\n    \\n    public int getMin() {\\n        return stk2.peek();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49249,
                "title": "a-32ms-c-solution-using-two-vectors",
                "content": "    class MinStack {\\n    public:\\n        vector<int> stack; \\n        vector<int> stmin = {INT_MAX};\\n        void push(int x) {\\n            if(x <= stmin[stmin.size() - 1]) stmin.push_back(x);\\n            stack.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if(stack[stack.size() - 1] == stmin[stmin.size() - 1]) stmin.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            if(stack.size() == 0) return 0;\\n            return stack[stack.size() - 1];\\n        }\\n    \\n        int getMin() {\\n            return stmin[stmin.size() - 1];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    public:\\n        vector<int> stack; \\n        vector<int> stmin = {INT_MAX};\\n        void push(int x) {\\n            if(x <= stmin[stmin.size() - 1]) stmin.push_back(x);\\n            stack.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if(stack[stack.size() - 1] == stmin[stmin.size() - 1]) stmin.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            if(stack.size() == 0) return 0;\\n            return stack[stack.size() - 1];\\n        }\\n    \\n        int getMin() {\\n            return stmin[stmin.size() - 1];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49316,
                "title": "solution-without-using-java-s-stack",
                "content": "    class MinStack {\\n        private int size = 0;\\n        private Node head = null;\\n        \\n        class Node {\\n            int val;\\n            // every node contains min value at the moment it was pushed\\n            int min;\\n            Node next;\\n            Node(int v, int m) {val = v; min = m;}\\n        }\\n        \\n        public void push(int x) {\\n            int curMin = getMin();\\n            int newMin = x < curMin ? x : curMin;\\n    \\n            Node n = new Node(x, newMin);\\n            n.next = head;\\n    \\n            head = n;\\n            size++;\\n        }\\n    \\n        public void pop() {\\n            if (size <= 0)\\n                return;\\n    \\n            head = head.next;\\n            size--;\\n        }\\n    \\n        public int top() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n                \\n            return head.val;\\n        }\\n    \\n        public int getMin() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n    \\n            return head.min;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class MinStack {\\n        private int size = 0;\\n        private Node head = null;\\n        \\n        class Node {\\n            int val;\\n            // every node contains min value at the moment it was pushed\\n            int min;\\n            Node next;\\n            Node(int v, int m) {val = v; min = m;}\\n        }\\n        \\n        public void push(int x) {\\n            int curMin = getMin();\\n            int newMin = x < curMin ? x : curMin;\\n    \\n            Node n = new Node(x, newMin);\\n            n.next = head;\\n    \\n            head = n;\\n            size++;\\n        }\\n    \\n        public void pop() {\\n            if (size <= 0)\\n                return;\\n    \\n            head = head.next;\\n            size--;\\n        }\\n    \\n        public int top() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n                \\n            return head.val;\\n        }\\n    \\n        public int getMin() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n    \\n            return head.min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49371,
                "title": "deque-is-the-right-structure",
                "content": "I tried three data structure: vector, list and deque. Only deque is accepted, the others got MLE.\\n\\nThere are some explanation:\\n\\n> A deque is very much like a vector: like vector, it is a sequence that supports random access to elements, constant time insertion and removal of elements at the end of the sequence, and linear time insertion and removal of elements in the middle.\\n\\n> The main way in which deque differs from vector is that deque also supports constant time insertion and removal of elements at the beginning of the sequence. Additionally, deque does not have any member functions analogous to vector's capacity() and reserve(), and does not provide any of the guarantees on iterator validity that are associated with those member functions.\\n\\nAnd my code:\\n\\n    class MinStack {\\n    private:\\n        deque<int> st;\\n        deque<int> mi;\\n    public:\\n        void push(int x) {\\n            st.push_back(x);\\n            if (mi.empty() || x <= mi.back()) mi.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (st.empty()) return;\\n            if (st.back() == mi.back()) mi.pop_back();\\n            st.pop_back();\\n        }\\n    \\n        int top() {\\n            if (st.empty()) return -1;\\n            return st.back();\\n        }\\n    \\n        int getMin() {\\n            if (mi.empty()) return -1;\\n            return mi.back();\\n        }\\n    };",
                "solutionTags": [],
                "code": "I tried three data structure: vector, list and deque. Only deque is accepted, the others got MLE.\\n\\nThere are some explanation:\\n\\n> A deque is very much like a vector: like vector, it is a sequence that supports random access to elements, constant time insertion and removal of elements at the end of the sequence, and linear time insertion and removal of elements in the middle.\\n\\n> The main way in which deque differs from vector is that deque also supports constant time insertion and removal of elements at the beginning of the sequence. Additionally, deque does not have any member functions analogous to vector's capacity() and reserve(), and does not provide any of the guarantees on iterator validity that are associated with those member functions.\\n\\nAnd my code:\\n\\n    class MinStack {\\n    private:\\n        deque<int> st;\\n        deque<int> mi;\\n    public:\\n        void push(int x) {\\n            st.push_back(x);\\n            if (mi.empty() || x <= mi.back()) mi.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (st.empty()) return;\\n            if (st.back() == mi.back()) mi.pop_back();\\n            st.pop_back();\\n        }\\n    \\n        int top() {\\n            if (st.empty()) return -1;\\n            return st.back();\\n        }\\n    \\n        int getMin() {\\n            if (mi.empty()) return -1;\\n            return mi.back();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 4050505,
                "title": "best-o-1-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass MinStack {\\n    stack <long long> st;\\n    long long minEle;\\npublic:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if (st.empty()) {\\n            st.push(val);\\n            minEle = val;\\n        } else if (val < minEle){\\n            st.push((long long) 2 * val - minEle);\\n            minEle = val;\\n        } else {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        long long popped = st.top();\\n        st.pop();\\n        if (popped < minEle)\\n            minEle = 2 * minEle - popped;\\n    }\\n    \\n    int top() {\\n        return (st.top() < minEle) ? minEle : st.top();\\n    }\\n    \\n    int getMin() {\\n        return minEle;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\n    stack <long long> st;\\n    long long minEle;\\npublic:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if (st.empty()) {\\n            st.push(val);\\n            minEle = val;\\n        } else if (val < minEle){\\n            st.push((long long) 2 * val - minEle);\\n            minEle = val;\\n        } else {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        long long popped = st.top();\\n        st.pop();\\n        if (popped < minEle)\\n            minEle = 2 * minEle - popped;\\n    }\\n    \\n    int top() {\\n        return (st.top() < minEle) ? minEle : st.top();\\n    }\\n    \\n    int getMin() {\\n        return minEle;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409487,
                "title": "c-fast-fully-explained-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe thought is to somehow store the elements in such an order that we can quickly get the first element, delete it and add to the top. All in O(1). Now there is obviously stack that can do it. There is queue, vector and others that can do it. But in those cases to find the smallest element, you need to traverse the whole data structure.\\nIf you think it, you will not be able to manage the smallest element thoughout because with each deletion you might loose your smallest element and then you need to find the new smallest.\\n\\nSo Idea is here to somehow keep storing the minimum element till the current topmost element. Thus if we delete the topmost element, we will know the new smallest at the new topmost element in O(1) time. \\n\\nThis can be done easily using LinkedList. We will insert the new elements at front of LL so as to match the stack implementation. In addition to each element, we would also keep in each node the minimum element found till here. Thus you can simply know the minimum element at each node. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is simply to use a LL with an extra field for minimum element till the point. Refer to code you can easily understand.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    struct Node\\n    {\\n        int num;\\n        Node *next;\\n        int min;\\n    };\\n    struct Node *head=NULL;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        Node *temp = new Node();\\n        temp->num=val;\\n        temp->min=val;\\n        temp->next=NULL;\\n        if(!head)\\n        {\\n            head=temp;\\n        }\\n        else\\n        {\\n            temp->min = min(temp->min, head->min);\\n            temp->next=head;\\n            head=temp;\\n        }\\n    }\\n    \\n    void pop() {\\n        Node *temp = head;\\n        head=head->next;\\n        //delete(temp);\\n    }\\n    \\n    int top() {\\n        return head->num;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    struct Node\\n    {\\n        int num;\\n        Node *next;\\n        int min;\\n    };\\n    struct Node *head=NULL;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        Node *temp = new Node();\\n        temp->num=val;\\n        temp->min=val;\\n        temp->next=NULL;\\n        if(!head)\\n        {\\n            head=temp;\\n        }\\n        else\\n        {\\n            temp->min = min(temp->min, head->min);\\n            temp->next=head;\\n            head=temp;\\n        }\\n    }\\n    \\n    void pop() {\\n        Node *temp = head;\\n        head=head->next;\\n        //delete(temp);\\n    }\\n    \\n    int top() {\\n        return head->num;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385582,
                "title": "typescript-stack-val-min-solution",
                "content": "# Code\\n```\\nclass MinStack {\\n    private stack;\\n    constructor() {\\n        this.stack = [];\\n    }\\n\\n    push(val: number): void {\\n        this.stack.push({\\n            val,\\n            min: this.stack.length == 0 ? val: Math.min(val, this.getMin())\\n        });\\n    }\\n\\n    pop(): void {\\n        this.stack.pop();\\n    }\\n\\n    top(): number {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n\\n    getMin(): number {\\n        return this.stack.length == 0 ? 0: this.stack[this.stack.length - 1].min;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass MinStack {\\n    private stack;\\n    constructor() {\\n        this.stack = [];\\n    }\\n\\n    push(val: number): void {\\n        this.stack.push({\\n            val,\\n            min: this.stack.length == 0 ? val: Math.min(val, this.getMin())\\n        });\\n    }\\n\\n    pop(): void {\\n        this.stack.pop();\\n    }\\n\\n    top(): number {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n\\n    getMin(): number {\\n        return this.stack.length == 0 ? 0: this.stack[this.stack.length - 1].min;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014352,
                "title": "o-1-optimal-java-solution-o-n-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. for Push operation :\\npush(2 * value * min)\\n2. for Top operation : \\nmodified value < min \\n3. for Pop operation :  \\nmin = (2 * min) - modified value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we take a variable that stores our minimum number.\\n\\n2. Push operation :\\n--> check whether the number is less that the min number, if yes, we push the modified value.\\n--> if above case is false, we push the number as it is.\\n\\n3. getMin() operation : returns the value of min.\\n\\n4. Top operation :\\n--> while returning, if the top value is a modified value, we check if the top value is lesser than min, if yes, we return the min as our top value.\\n\\n5. Pop operation : \\n--> we check if the top value is lesser than min, if yes, we update the current min to our previous min, and then pop the element.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack \\n{\\n\\n    Stack<Long> stack = new Stack<>();\\n    Long mini;\\n\\n    public MinStack() \\n    {\\n        mini = Long.MAX_VALUE;\\n    }\\n    \\n    public void push(int val) \\n    {\\n        Long value = Long.valueOf(val);\\n        if(stack.isEmpty())\\n        {\\n            mini =  value;\\n            stack.push(value);\\n        }\\n        else\\n        {\\n            if(value < mini)\\n            {\\n                stack.push(2 * value - mini);\\n                mini = value;\\n            }\\n            else\\n            {\\n                stack.push(value);\\n            }\\n        }\\n    }\\n    \\n    public void pop() \\n    {\\n        if(stack.isEmpty())\\n        {\\n            return;\\n        }\\n\\n        Long value = stack.pop();\\n        if(value < mini)\\n        {\\n            mini = 2 * mini - value;\\n        }\\n            \\n    }\\n    \\n    public int top() \\n    {\\n        Long value = stack.peek();\\n        if(value < mini)\\n        {\\n            return mini.intValue();\\n        }\\n        return value.intValue();\\n    }\\n    \\n    public int getMin() \\n    {\\n        return mini.intValue();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass MinStack \\n{\\n\\n    Stack<Long> stack = new Stack<>();\\n    Long mini;\\n\\n    public MinStack() \\n    {\\n        mini = Long.MAX_VALUE;\\n    }\\n    \\n    public void push(int val) \\n    {\\n        Long value = Long.valueOf(val);\\n        if(stack.isEmpty())\\n        {\\n            mini =  value;\\n            stack.push(value);\\n        }\\n        else\\n        {\\n            if(value < mini)\\n            {\\n                stack.push(2 * value - mini);\\n                mini = value;\\n            }\\n            else\\n            {\\n                stack.push(value);\\n            }\\n        }\\n    }\\n    \\n    public void pop() \\n    {\\n        if(stack.isEmpty())\\n        {\\n            return;\\n        }\\n\\n        Long value = stack.pop();\\n        if(value < mini)\\n        {\\n            mini = 2 * mini - value;\\n        }\\n            \\n    }\\n    \\n    public int top() \\n    {\\n        Long value = stack.peek();\\n        if(value < mini)\\n        {\\n            return mini.intValue();\\n        }\\n        return value.intValue();\\n    }\\n    \\n    public int getMin() \\n    {\\n        return mini.intValue();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129330,
                "title": "c-clean-fast-solution-o-1",
                "content": "```\\ntypedef struct {\\n    int s[30001];\\n    int idx;\\n    int min;\\n} MinStack;\\n\\nMinStack* minStackCreate() {\\n    MinStack *new = calloc(1, sizeof(MinStack));\\n    new->idx = 0;\\n    new->min = INT_MAX;\\n    return new;\\n}\\n\\nvoid minStackPush(MinStack* obj, int val) {\\n    if (val <= obj->min) {\\n        obj->s[obj->idx++] = obj->min;\\n        obj->min = val;\\n    }\\n    obj->s[obj->idx++] = val;\\n}\\n\\nvoid minStackPop(MinStack* obj) {\\n    if (obj->s[--obj->idx] == obj->min)\\n        obj->min = obj->s[--obj->idx];\\n}\\n\\nint minStackTop(MinStack* obj) {\\n    return obj->s[obj->idx - 1];\\n}\\n\\nint minStackGetMin(MinStack* obj) {\\n    return obj->min;     \\n}\\n\\nvoid minStackFree(MinStack* obj) {\\n    free(obj); \\n}\\n```\\n***If this was helpful, don\\'t hesitate to upvote! :)***\\nHave a nice day!",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\ntypedef struct {\\n    int s[30001];\\n    int idx;\\n    int min;\\n} MinStack;\\n\\nMinStack* minStackCreate() {\\n    MinStack *new = calloc(1, sizeof(MinStack));\\n    new->idx = 0;\\n    new->min = INT_MAX;\\n    return new;\\n}\\n\\nvoid minStackPush(MinStack* obj, int val) {\\n    if (val <= obj->min) {\\n        obj->s[obj->idx++] = obj->min;\\n        obj->min = val;\\n    }\\n    obj->s[obj->idx++] = val;\\n}\\n\\nvoid minStackPop(MinStack* obj) {\\n    if (obj->s[--obj->idx] == obj->min)\\n        obj->min = obj->s[--obj->idx];\\n}\\n\\nint minStackTop(MinStack* obj) {\\n    return obj->s[obj->idx - 1];\\n}\\n\\nint minStackGetMin(MinStack* obj) {\\n    return obj->min;     \\n}\\n\\nvoid minStackFree(MinStack* obj) {\\n    free(obj); \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1637230,
                "title": "easiest-solution-using-linkedlist",
                "content": "\\nclass MinStack {\\n   class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "\\nclass MinStack {\\n   class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1539711,
                "title": "beginner-friendly-solution-using-two-stack-c",
                "content": "* Easy to understand, must upvote! \\uD83D\\uDE43\\n\\n```\\nclass MinStack {\\npublic:\\n    stack<int> myStack;\\n    stack<int> minStack;\\n    \\n    MinStack() {}\\n    \\n    void push(int val) {\\n        myStack.push(val);\\n        if(minStack.empty()){\\n            minStack.push(val);\\n        }\\n        else{\\n            int top = minStack.top();\\n            minStack.push(min(top, val));\\n        }\\n    }\\n    \\n    void pop() {\\n        myStack.pop();\\n        minStack.pop();\\n    }\\n    \\n    int top() {\\n        return myStack.top();\\n    }\\n    \\n    int getMin() {\\n        return minStack.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> myStack;\\n    stack<int> minStack;\\n    \\n    MinStack() {}\\n    \\n    void push(int val) {\\n        myStack.push(val);\\n        if(minStack.empty()){\\n            minStack.push(val);\\n        }\\n        else{\\n            int top = minStack.top();\\n            minStack.push(min(top, val));\\n        }\\n    }\\n    \\n    void pop() {\\n        myStack.pop();\\n        minStack.pop();\\n    }\\n    \\n    int top() {\\n        return myStack.top();\\n    }\\n    \\n    int getMin() {\\n        return minStack.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502873,
                "title": "c-using-2-stacks-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/bf471aae-ac51-47ea-b874-1290adaf1df7_1633348531.7451518.png)\\n\\n\\n```\\nclass MinStack {\\n    stack<int> data;\\n    stack<int> minData;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        data.push(val);\\n      if (minData.size() == 0 || val <= minData.top()) \\n        minData.push(val);\\n    }\\n    \\n    void pop() {\\n        int val = data.top();\\n            data.pop();\\n        if (val == minData.top()) \\n          minData.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minData.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\n    stack<int> data;\\n    stack<int> minData;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        data.push(val);\\n      if (minData.size() == 0 || val <= minData.top()) \\n        minData.push(val);\\n    }\\n    \\n    void pop() {\\n        int val = data.top();\\n            data.pop();\\n        if (val == minData.top()) \\n          minData.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minData.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267399,
                "title": "c-simple-solution-easy-to-understand",
                "content": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>stk1;\\n    stack<int>stk2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val)\\n    {\\n        stk1.push(val);\\n        if(stk2.size() == 0)\\n        {\\n            stk2.push(val);\\n        }\\n        else\\n        {\\n            stk2.push(min(stk2.top(),val));\\n        }\\n    }\\n    \\n    void pop()\\n    {\\n        stk1.pop();\\n        stk2.pop();\\n    }\\n    \\n    int top()\\n    {\\n        return stk1.top();    \\n    }\\n    \\n    int getMin()\\n    {\\n        return stk2.top();    \\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t able to understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>stk1;\\n    stack<int>stk2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val)\\n    {\\n        stk1.push(val);\\n        if(stk2.size() == 0)\\n        {\\n            stk2.push(val);\\n        }\\n        else\\n        {\\n            stk2.push(min(stk2.top(),val));\\n        }\\n    }\\n    \\n    void pop()\\n    {\\n        stk1.pop();\\n        stk2.pop();\\n    }\\n    \\n    int top()\\n    {\\n        return stk1.top();    \\n    }\\n    \\n    int getMin()\\n    {\\n        return stk2.top();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090123,
                "title": "clean-code-of-python-with-comments-without-additional-variable-for-size",
                "content": "```\\n#The idea here is to keep track of min element using a seperate stack.\\n#without the additional stack of min elements, we will have to traverse the entire stack and it will not be constant time,\\n#As there is no constraint for spacer complexity, we will user additional data strcuture.\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack =[] #main stack\\n        self.min=[]  #To keep track of minimum element in the stack\\n                \\n\\n    def push(self, x: int) -> None:                \\n            #Push all into the main stack.\\n            self.stack.append(x)  \\n            \\n            # If min stack present. Check the top element of min stack. \\n            # If X is less than top-element, append into the min stack. \\n            # It will ensure that top element is always minimum.\\n            if self.min: \\n                # Compare and push into min stack only if new element is \\n                # smaller than top element of min stack.\\n                if x <= self.min[-1]: \\n                    self.min.append(x)\\n            else:\\n                self.min.append(x)  \\n\\n    def pop(self) -> None:\\n            #Remove and return the top element.\\n            #Assigning it to a variable to compare if the popped out value is same as min\\'s top element. \\n            #if its same, pop from min stack as well.\\n            check= self.stack.pop() \\n            if check == self.min[-1]:\\n                self.min.pop()\\n                \\n    def top(self) -> int:\\n            if self.stack: \\n                return self.stack[-1] #Read and return the top element from mainstack.\\n\\n\\n    \\n    def getMin(self) -> int:\\n        if self.stack: \\n            return self.min[-1] #Read and return the top element from min stack.\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#The idea here is to keep track of min element using a seperate stack.\\n#without the additional stack of min elements, we will have to traverse the entire stack and it will not be constant time,\\n#As there is no constraint for spacer complexity, we will user additional data strcuture.\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack =[] #main stack\\n        self.min=[]  #To keep track of minimum element in the stack\\n                \\n\\n    def push(self, x: int) -> None:                \\n            #Push all into the main stack.\\n            self.stack.append(x)  \\n            \\n            # If min stack present. Check the top element of min stack. \\n            # If X is less than top-element, append into the min stack. \\n            # It will ensure that top element is always minimum.\\n            if self.min: \\n                # Compare and push into min stack only if new element is \\n                # smaller than top element of min stack.\\n                if x <= self.min[-1]: \\n                    self.min.append(x)\\n            else:\\n                self.min.append(x)  \\n\\n    def pop(self) -> None:\\n            #Remove and return the top element.\\n            #Assigning it to a variable to compare if the popped out value is same as min\\'s top element. \\n            #if its same, pop from min stack as well.\\n            check= self.stack.pop() \\n            if check == self.min[-1]:\\n                self.min.pop()\\n                \\n    def top(self) -> int:\\n            if self.stack: \\n                return self.stack[-1] #Read and return the top element from mainstack.\\n\\n\\n    \\n    def getMin(self) -> int:\\n        if self.stack: \\n            return self.min[-1] #Read and return the top element from min stack.\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825972,
                "title": "python-3-91-faster-using-namedtuple",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\n**Solution 1:** using collections.namedtuple\\n```\\nclass MinStack:\\n\\n    stackWithMinElements = collections.namedtuple(\"stackWithMinElements\", (\"element\", \"minimum\"))\\n    \\n    def __init__(self):        \\n        self.stack : List[self.stackWithMinElements] = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(self.stackWithMinElements(\\n                        x, min(x, self.getMin()) if len(self.stack)>0 else x))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1].element\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1].minimum\\n```\\n\\n**Solution 2:** Regular method where we store a tuple (value and minimum stack value) on top of the stack.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.count = 0\\n\\n    def push(self, val: int) -> None:\\n        topMin = val\\n        if self.count > 0:\\n            topMin = min(self.stack[-1][1], val)\\n        self.stack.append((val, topMin))\\n        self.count += 1\\n            \\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.count -= 1\\n        \\n    def top(self) -> int:\\n        return self.stack[-1][0] \\n        \\n    def getMin(self) -> int:\\n        return self.stack[-1][1]\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    stackWithMinElements = collections.namedtuple(\"stackWithMinElements\", (\"element\", \"minimum\"))\\n    \\n    def __init__(self):        \\n        self.stack : List[self.stackWithMinElements] = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(self.stackWithMinElements(\\n                        x, min(x, self.getMin()) if len(self.stack)>0 else x))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1].element\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1].minimum\\n```\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.count = 0\\n\\n    def push(self, val: int) -> None:\\n        topMin = val\\n        if self.count > 0:\\n            topMin = min(self.stack[-1][1], val)\\n        self.stack.append((val, topMin))\\n        self.count += 1\\n            \\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.count -= 1\\n        \\n    def top(self) -> int:\\n        return self.stack[-1][0] \\n        \\n    def getMin(self) -> int:\\n        return self.stack[-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740132,
                "title": "javascript-clean-es6-class-using-2-arrays",
                "content": "## Solution 1\\n```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = [];\\n    }\\n    \\n    push(x) {\\n        if (!this.min.length) this.min.push(x);\\n        else this.min.push(Math.min(x, this.getMin()));\\n        this.stack.push(x);\\n    }\\n    \\n    pop() {\\n        this.min.pop()\\n        return this.stack.pop()\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.min[this.min.length-1];\\n    }\\n}\\n\\n```\\n\\n## Solution 2: Optimized space\\n```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.minArr = [{val: Infinity, count: 1}];\\n    }\\n    \\n    push(x) {\\n        this.stack.push(x);\\n        let min = this.minArr[this.minArr.length-1];\\n        if(x === min.val) min.count++;\\n        else if(x < min.val) this.minArr.push({val: x, count: 1});\\n    }\\n    \\n    pop() {\\n        let item = this.stack.pop();\\n        let min = this.minArr[this.minArr.length-1];\\n        if(item === min.val) min.count--;\\n        if(!min.count) this.minArr.pop();\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.minArr[this.minArr.length-1].val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = [];\\n    }\\n    \\n    push(x) {\\n        if (!this.min.length) this.min.push(x);\\n        else this.min.push(Math.min(x, this.getMin()));\\n        this.stack.push(x);\\n    }\\n    \\n    pop() {\\n        this.min.pop()\\n        return this.stack.pop()\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.min[this.min.length-1];\\n    }\\n}\\n\\n```\n```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.minArr = [{val: Infinity, count: 1}];\\n    }\\n    \\n    push(x) {\\n        this.stack.push(x);\\n        let min = this.minArr[this.minArr.length-1];\\n        if(x === min.val) min.count++;\\n        else if(x < min.val) this.minArr.push({val: x, count: 1});\\n    }\\n    \\n    pop() {\\n        let item = this.stack.pop();\\n        let min = this.minArr[this.minArr.length-1];\\n        if(item === min.val) min.count--;\\n        if(!min.count) this.minArr.pop();\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.minArr[this.minArr.length-1].val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733245,
                "title": "stack-with-pair-in-c-is-the-simplest-way",
                "content": "Declare, `stack< pair<int,int> > container;`\\n\\n*Lets, observe some test cases  :*\\n\\n\\n* \\t\\t\\tCommand     -      Data     -    Minvalue\\n* \\t\\t\\tPush                 10               10\\n* \\t\\t\\tPush                  9                 9    (Compare 9 with previous min value 10 , min(9,10)= 9)           \\n* \\t\\t\\tPush                 15               9    (Compare 15 with previous min value 9 , min(9,15)= 9)   \\n*   \\t\\tPop                                            ( (15 , 9 ) will be poped)\\n*   \\t\\tTop                    9                     (Top value of stack is (9,9) and first value is 9 )\\n* \\t\\t\\tPush                  -7               -7  (Compare -7 with previous min value 9, min(-7,9)=-7 )           \\n* \\t\\t\\tPush                  20              -7  (Compare 20 with previous min value -7, min(20, -7)=-7)\\n* \\t\\t\\tPop                                         ( (20 , -7 ) will be poped)\\n* \\t\\t\\tgetMin              -7                   (top value of stack (-7,-7) and second value is the min value)\\n\\n\\n\\n**Code-**\\n\\n```\\nclass MinStack {\\npublic:\\n    \\n    stack< pair<int,int> > container;\\n    int mn=0;\\n \\n    void push(int x) {\\n        \\n        if(container.size()==0){\\n        container.push({x,x});\\n        mn=x;\\n        }\\n        else{\\n            pair<int,int> sq = container.top();   \\n            mn = sq.second;\\n            mn=min(x,mn);  // checking with previous min value;\\n            container.push({x,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(container.size()>0)\\n        container.pop();\\n    }\\n    \\n    int top() {\\n        pair<int,int> m = container.top();  \\n        return m.first;   //first value of pair is the top value;\\n    }\\n    \\n    int getMin() {\\n        pair<int,int> m = container.top();\\n        return m.second;  //second value is the min value;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    stack< pair<int,int> > container;\\n    int mn=0;\\n \\n    void push(int x) {\\n        \\n        if(container.size()==0){\\n        container.push({x,x});\\n        mn=x;\\n        }\\n        else{\\n            pair<int,int> sq = container.top();   \\n            mn = sq.second;\\n            mn=min(x,mn);  // checking with previous min value;\\n            container.push({x,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(container.size()>0)\\n        container.pop();\\n    }\\n    \\n    int top() {\\n        pair<int,int> m = container.top();  \\n        return m.first;   //first value of pair is the top value;\\n    }\\n    \\n    int getMin() {\\n        pair<int,int> m = container.top();\\n        return m.second;  //second value is the min value;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548716,
                "title": "python3-solution-using-2-stacks",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.minstack = list()\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if len(self.minstack) == 0 or x <= self.minstack[-1]:\\n            self.minstack.append(x)\\n\\n    def pop(self) -> None:\\n        e = self.stack.pop()\\n        if e == self.minstack[-1]:\\n            self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(x)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```\\n\\nSomething to note, if len(self.minstack) == 0 or x <= self.minstack[-1] can be done because Python3 supports short circuting. Refer here : https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not\\n\\nThis means, for the or operation, if either one is true the other one is not operated. So even if len(self.minstack) is 0, we don\\'t have to worry about self.minstack[-1] raising an exception.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.minstack = list()\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if len(self.minstack) == 0 or x <= self.minstack[-1]:\\n            self.minstack.append(x)\\n\\n    def pop(self) -> None:\\n        e = self.stack.pop()\\n        if e == self.minstack[-1]:\\n            self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(x)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446983,
                "title": "simple-java-solution-without-any-extra-data-structure",
                "content": "````\\n\\nclass MinStack {\\n\\n   private class Node {\\n       int min;\\n       int value ; \\n       Node next;\\n       \\n       Node(int val, int m) {\\n           value = val;\\n           min = m;\\n       }\\n   }\\n    \\n        Node top;\\n        public MinStack() {\\n        }\\n\\n        public void push(int x) {\\n            if(top == null) {\\n                top = new Node(x, x);\\n            } else {\\n                Node node = new Node(x, Math.min(top.min, x));\\n                node.next = top;\\n                top = node;\\n            }\\n        }\\n\\n        public void pop() {\\n           if(top != null){\\n               top = top.next;\\n           }\\n        }\\n\\n        public int top() {\\n            return top != null ? top.value : -1;\\n        }\\n\\n        public int getMin() {\\n           if(top != null) return top.min;\\n            \\n            return -1;\\n        }\\n}\\n\\n\\n\\n````",
                "solutionTags": [],
                "code": "````\\n\\nclass MinStack {\\n\\n   private class Node {\\n       int min;\\n       int value ; \\n       Node next;\\n       \\n       Node(int val, int m) {\\n           value = val;\\n           min = m;\\n       }\\n   }\\n    \\n        Node top;\\n        public MinStack() {\\n        }\\n\\n        public void push(int x) {\\n            if(top == null) {\\n                top = new Node(x, x);\\n            } else {\\n                Node node = new Node(x, Math.min(top.min, x));\\n                node.next = top;\\n                top = node;\\n            }\\n        }\\n\\n        public void pop() {\\n           if(top != null){\\n               top = top.next;\\n           }\\n        }\\n\\n        public int top() {\\n            return top != null ? top.value : -1;\\n        }\\n\\n        public int getMin() {\\n           if(top != null) return top.min;\\n            \\n            return -1;\\n        }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402558,
                "title": "python-method-faster-than-92-and-very-little-line-of-code",
                "content": "Initialize two lists(stack, min). list stack records all push and pop elements and list min keeps the latest minimal at the end of the list.\\n```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min = []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: None\\n        \"\"\"\\n        self.stack.append(x)\\n        self.min.append(min(self.min[-1], x)) if self.min else self.min.append(x)\\n\\n            \\n    def pop(self):\\n        \"\"\"\\n        :rtype: None\\n        \"\"\"\\n        self.stack.pop()\\n        self.min.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min = []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: None\\n        \"\"\"\\n        self.stack.append(x)\\n        self.min.append(min(self.min[-1], x)) if self.min else self.min.append(x)\\n\\n            \\n    def pop(self):\\n        \"\"\"\\n        :rtype: None\\n        \"\"\"\\n        self.stack.pop()\\n        self.min.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388851,
                "title": "java-easy-to-understand-solution",
                "content": "The approach is to use regular java `Stack` with each entry having value + min value at the time of push.\\n\\n```\\nclass MinStack {    \\n    class Record {\\n        public final int value;\\n        public final int minValue;\\n        \\n        public Record(int value, int minValue) {\\n            this.value = value;\\n            this.minValue = minValue;\\n        }\\n    }\\n    \\n    private final Stack<Record> _stack = new Stack();\\n\\n    public void push(int x) {\\n        int minValue = _stack.size() == 0 ? x : Math.min(x, getMin());\\n        _stack.push(new Record(x, minValue));\\n    }\\n    \\n    public void pop() {\\n        _stack.pop();\\n    }\\n    \\n    public int top() {\\n        return _stack.peek().value;\\n    }\\n    \\n    public int getMin() {\\n        return _stack.peek().minValue;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {    \\n    class Record {\\n        public final int value;\\n        public final int minValue;\\n        \\n        public Record(int value, int minValue) {\\n            this.value = value;\\n            this.minValue = minValue;\\n        }\\n    }\\n    \\n    private final Stack<Record> _stack = new Stack();\\n\\n    public void push(int x) {\\n        int minValue = _stack.size() == 0 ? x : Math.min(x, getMin());\\n        _stack.push(new Record(x, minValue));\\n    }\\n    \\n    public void pop() {\\n        _stack.pop();\\n    }\\n    \\n    public int top() {\\n        return _stack.peek().value;\\n    }\\n    \\n    public int getMin() {\\n        return _stack.peek().minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329631,
                "title": "c-90-beaten-stackson-jackson-all-o-1-requires-o-n-extra-memory",
                "content": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<int> mStack;\\n    stack<int> mMinStack;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        mStack.push(x);\\n        if (!mMinStack.empty()) {\\n            mMinStack.push(min(mMinStack.top(), x));\\n        } else {\\n            mMinStack.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        mStack.pop();\\n        mMinStack.pop();\\n    }\\n    \\n    int top() {\\n        return mStack.top();\\n    }\\n    \\n    int getMin() {\\n        return mMinStack.top();\\n    }\\n};\\n```\\n\\nThe trick is to keep an extra stack for your minimum values.\\n\\nStack Values:\\n[bottom] [5 4 4 5 3 4 3 1 1 3] [top]\\n\\nMin Stack:\\n[bottom] [5 4 4 4 3 3 3 1 1 1] [top]\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<int> mStack;\\n    stack<int> mMinStack;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        mStack.push(x);\\n        if (!mMinStack.empty()) {\\n            mMinStack.push(min(mMinStack.top(), x));\\n        } else {\\n            mMinStack.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        mStack.pop();\\n        mMinStack.pop();\\n    }\\n    \\n    int top() {\\n        return mStack.top();\\n    }\\n    \\n    int getMin() {\\n        return mMinStack.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309781,
                "title": "shortest-and-readable-java-solution",
                "content": "```\\nclass MinStack {\\n    private static class Entry{\\n        int value;\\n        int min;\\n        Entry previous;\\n        Entry(int value, Entry previous){\\n            this.value = value;\\n            this.previous = previous;\\n            this.min = previous==null?value:Math.min(value,previous.min);\\n        }\\n    }\\n    private Entry top = null;    \\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        top = new Entry(x,top);\\n    }\\n    \\n    public void pop() {\\n        top = top.previous;\\n    }\\n    \\n    public int top() {\\n        return top.value;\\n    }\\n    \\n    public int getMin() {\\n        return top.min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n    private static class Entry{\\n        int value;\\n        int min;\\n        Entry previous;\\n        Entry(int value, Entry previous){\\n            this.value = value;\\n            this.previous = previous;\\n            this.min = previous==null?value:Math.min(value,previous.min);\\n        }\\n    }\\n    private Entry top = null;    \\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        top = new Entry(x,top);\\n    }\\n    \\n    public void pop() {\\n        top = top.previous;\\n    }\\n    \\n    public int top() {\\n        return top.value;\\n    }\\n    \\n    public int getMin() {\\n        return top.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260088,
                "title": "java-short-solution",
                "content": "```\\n    Stack<int[]> s;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        s = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        s.push(new int[]{x, Math.min(x, s.isEmpty() ? Integer.MAX_VALUE : s.peek()[1])});\\n    }\\n    \\n    public void pop() {\\n        s.pop();\\n    }\\n    \\n    public int top() {\\n        return s.peek()[0];\\n    }\\n    \\n    public int getMin() {\\n        return s.peek()[1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Stack<int[]> s;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        s = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        s.push(new int[]{x, Math.min(x, s.isEmpty() ? Integer.MAX_VALUE : s.peek()[1])});\\n    }\\n    \\n    public void pop() {\\n        s.pop();\\n    }\\n    \\n    public int top() {\\n        return s.peek()[0];\\n    }\\n    \\n    public int getMin() {\\n        return s.peek()[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159466,
                "title": "python-solution",
                "content": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min_stack = []\\n        \\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        self.stack.append(x)\\n        if not self.min_stack:\\n            self.min_stack.append(x)\\n        else:\\n            if x < self.min_stack[-1]:\\n                self.min_stack.append(x)\\n            else:\\n                self.min_stack.append(self.min_stack[-1])\\n                \\n        \\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: void\\n        \"\"\"\\n        self.stack.pop()\\n        self.min_stack.pop()\\n        \\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min_stack[-1]\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min_stack = []\\n        \\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        self.stack.append(x)\\n        if not self.min_stack:\\n            self.min_stack.append(x)\\n        else:\\n            if x < self.min_stack[-1]:\\n                self.min_stack.append(x)\\n            else:\\n                self.min_stack.append(self.min_stack[-1])\\n                \\n        \\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: void\\n        \"\"\"\\n        self.stack.pop()\\n        self.min_stack.pop()\\n        \\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min_stack[-1]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49071,
                "title": "java-solution-with-just-one-stack",
                "content": "This approach is pushing the min of the stack after every push methods. And retrieve the min after pop.\\n\\n```java\\npublic class MinStack {\\n    Stack<Integer> stack;\\n    int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        min = Integer.MAX_VALUE;\\n        stack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        min = Math.min(min, x);\\n        stack.push(x);\\n        stack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        stack.pop();\\n        min = stack.isEmpty() ? Integer.MAX_VALUE : stack.peek();\\n    }\\n    \\n    public int top() {\\n        int temp = stack.pop();\\n        int res = stack.peek();\\n        stack.push(temp);\\n        return res;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\npublic class MinStack {\\n    Stack<Integer> stack;\\n    int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        min = Integer.MAX_VALUE;\\n        stack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        min = Math.min(min, x);\\n        stack.push(x);\\n        stack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        stack.pop();\\n        min = stack.isEmpty() ? Integer.MAX_VALUE : stack.peek();\\n    }\\n    \\n    public int top() {\\n        int temp = stack.pop();\\n        int res = stack.peek();\\n        stack.push(temp);\\n        return res;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49162,
                "title": "c-simple-solution",
                "content": "    class MinStack {\\n    public:\\n        stack<int> st;\\n        stack<int> nextMin;\\n        \\n        void push(int x) {\\n            if(st.empty()){\\n                nextMin.push(x);\\n            }else if(nextMin.top() >= x){\\n                nextMin.push(x);\\n            }\\n            st.push(x);\\n        }\\n    \\n        void pop() {\\n            int tmp = st.top();\\n            st.pop();\\n            if(tmp == nextMin.top()){\\n                nextMin.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            return st.top();\\n        }\\n    \\n        int getMin() {\\n            return nextMin.top();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    public:\\n        stack<int> st;\\n        stack<int> nextMin;\\n        \\n        void push(int x) {\\n            if(st.empty()){\\n                nextMin.push(x);\\n            }else if(nextMin.top() >= x){\\n                nextMin.push(x);\\n            }\\n            st.push(x);\\n        }\\n    \\n        void pop() {\\n            int tmp = st.top();\\n            st.pop();\\n            if(tmp == nextMin.top()){\\n                nextMin.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            return st.top();\\n        }\\n    \\n        int getMin() {\\n            return nextMin.top();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49219,
                "title": "simple-java-solution-using-two-stacks-in-o-1",
                "content": "Feel free to share my solution using an auxiliary stack to store the minimum element(s).\\n\\n    class MinStack {\\n            Stack<Integer> mainStack = new Stack<Integer>();\\n            Stack<Integer> minStack = new Stack<Integer>();\\n            \\n            public void push(int x) {\\n                mainStack.push(x);\\n                if (minStack.empty()) {\\n                    minStack.push(x);\\n                } else if (minStack.peek() >= x) {\\n                    minStack.push(x);\\n                }\\n            }\\n        \\n            public void pop() {\\n                int poppedElement = mainStack.pop();\\n                if (poppedElement == minStack.peek()) {\\n                    minStack.pop();\\n                }\\n            }\\n        \\n            public int top() {\\n                return mainStack.peek();\\n            }\\n        \\n            public int getMin() {\\n                return minStack.peek();\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "Feel free to share my solution using an auxiliary stack to store the minimum element(s).\\n\\n    class MinStack {\\n            Stack<Integer> mainStack = new Stack<Integer>();\\n            Stack<Integer> minStack = new Stack<Integer>();\\n            \\n            public void push(int x) {\\n                mainStack.push(x);\\n                if (minStack.empty()) {\\n                    minStack.push(x);\\n                } else if (minStack.peek() >= x) {\\n                    minStack.push(x);\\n                }\\n            }\\n        \\n            public void pop() {\\n                int poppedElement = mainStack.pop();\\n                if (poppedElement == minStack.peek()) {\\n                    minStack.pop();\\n                }\\n            }\\n        \\n            public int top() {\\n                return mainStack.peek();\\n            }\\n        \\n            public int getMin() {\\n                return minStack.peek();\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 49234,
                "title": "python-easy-to-understand-solution-using-two-stacks",
                "content": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n        \\n    def push(self, x):\\n        self.stack.append(x)\\n        if not self.minStack or self.minStack[-1] >= x:\\n            self.minStack.append(x)\\n        \\n    def pop(self):\\n        tmp = self.stack.pop()\\n        if tmp == self.minStack[-1]:\\n            self.minStack.pop()\\n            \\n    def top(self):\\n        return self.stack[-1]\\n        \\n    def getMin(self):\\n        return self.minStack[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n        \\n    def push(self, x):\\n        self.stack.append(x)\\n        if not self.minStack or self.minStack[-1] >= x:\\n            self.minStack.append(x)\\n        \\n    def pop(self):\\n        tmp = self.stack.pop()\\n        if tmp == self.minStack[-1]:\\n            self.minStack.pop()\\n            \\n    def top(self):\\n        return self.stack[-1]\\n        \\n    def getMin(self):\\n        return self.minStack[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49257,
                "title": "my-solution-not-super-space-efficient",
                "content": "    class MinStack {\\n        // a vector of (val, mininal_val) \\n        std::vector<std::pair<int, int>>  data;\\n    \\n    public:\\n        void push(int x) {\\n            int min_val = data.empty() ? x : (std::min(getMin(), x));\\n            data.push_back(std::make_pair(x, min_val));\\n        }\\n    \\n        void pop() {\\n            assert(!data.empty());\\n            data.pop_back();\\n        }\\n    \\n        int top() {\\n            assert(!data.empty());\\n            return data.back().first;\\n        }\\n    \\n        int getMin() {\\n            assert(!data.empty());\\n            return data.back().second;\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class MinStack {\\n        // a vector of (val, mininal_val) \\n        std::vector<std::pair<int, int>>  data;\\n    \\n    public:\\n        void push(int x) {\\n            int min_val = data.empty() ? x : (std::min(getMin(), x));\\n            data.push_back(std::make_pair(x, min_val));\\n        }\\n    \\n        void pop() {\\n            assert(!data.empty());\\n            data.pop_back();\\n        }\\n    \\n        int top() {\\n            assert(!data.empty());\\n            return data.back().first;\\n        }\\n    \\n        int getMin() {\\n            assert(!data.empty());\\n            return data.back().second;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49323,
                "title": "smart-accepted-java-solution-linked-list",
                "content": "\\n    class Element{\\n        int value;\\n        int currentMin;\\n        Element next = null;\\n        Element(int value, int minBefore){\\n            this.value = value;\\n            this.currentMin = Math.min(minBefore,value);\\n     }\\n    \\n    Element top = null;\\n    public void push(int x) {\\n        Element newElement;\\n        if (top == null){\\n            newElement = new Element(x,x);\\n            top = newElement;\\n        }else{\\n            newElement = new Element(x,top.currentMin);\\n            newElement.next=top;\\n            top = newElement;\\n        }\\n    }\\n\\n    public void pop() {\\n        if (top != null){\\n            top = top.next;\\n        }\\n    }\\n\\n    public int top() {\\n        return top.value;\\n    }\\n\\n    public int getMin() {\\n        return top.currentMin;\\n    }",
                "solutionTags": [],
                "code": "\\n    class Element{\\n        int value;\\n        int currentMin;\\n        Element next = null;\\n        Element(int value, int minBefore){\\n            this.value = value;\\n            this.currentMin = Math.min(minBefore,value);\\n     }\\n    \\n    Element top = null;\\n    public void push(int x) {\\n        Element newElement;\\n        if (top == null){\\n            newElement = new Element(x,x);\\n            top = newElement;\\n        }else{\\n            newElement = new Element(x,top.currentMin);\\n            newElement.next=top;\\n            top = newElement;\\n        }\\n    }\\n\\n    public void pop() {\\n        if (top != null){\\n            top = top.next;\\n        }\\n    }\\n\\n    public int top() {\\n        return top.value;\\n    }\\n\\n    public int getMin() {\\n        return top.currentMin;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49315,
                "title": "share-my-java-solution-of-min-stack-in-253-ms-a-litter-faster-than-other-answers-by-now",
                "content": "    class MinStack {\\n           private static final int DEFAULT_INITIAL_CAPACITY = 16;\\n    \\t   private int index = 0;\\n    \\t   private int elementCount = 0;\\n    \\t   int [] elementData = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   int [] minValues = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   private int  minValue = 0;\\n    \\t   \\n                public void push(int x) {\\n    \\t\\t  ensureCapacityHelper(elementCount + 1);\\n    \\t          elementData[index]=x;\\n    \\t          if(index==0){\\n    \\t          minValue = x;\\n    \\t          }else{\\n    \\t          minValue = Math.min(minValue, x);\\n    \\t          }\\n    \\t          minValues[index] = minValue;\\n    \\t          elementCount++;\\n    \\t          index++;\\n    \\t    }\\n    \\n    \\t    public void pop() {\\n    \\t    \\tif (elementCount == 0)\\n    \\t\\t\\treturn;\\n    \\t        index--;\\n    \\t        elementData[index]=0;\\n    \\t        minValues[index]=0;\\n    \\t        elementCount--;\\n    \\t        \\n    \\t        if(index-1<0){\\n    \\t        minValue = 0;\\n    \\t        }else{\\n    \\t        minValue = minValues[index-1];\\n    \\t        }\\n    \\t    }\\n    \\n    \\n    \\t    public int top() {\\n    \\t\\t  if(index-1<0)\\n    \\t\\t  return elementData[0];\\n    \\t      return elementData[index-1]; \\n    \\t    }\\n    \\n    \\t    public int getMin() {\\n    \\t        return minValue;\\n    \\t    }\\n    \\t    \\n    \\t    private void ensureCapacityHelper(int minCapacity) {\\n    \\t        if (minCapacity - elementData.length > 0)\\n    \\t            grow(minCapacity);\\n    \\t    }\\n    \\t    \\n    \\t    private void grow(int minCapacity) {\\n    \\t        int oldCapacity = elementData.length;\\n    \\t        int newCapacity = 2*oldCapacity;\\n    \\t        elementData = Arrays.copyOf(elementData, newCapacity);\\n    \\t        minValues = Arrays.copyOf(minValues, newCapacity);\\n    \\t    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    class MinStack {\\n           private static final int DEFAULT_INITIAL_CAPACITY = 16;\\n    \\t   private int index = 0;\\n    \\t   private int elementCount = 0;\\n    \\t   int [] elementData = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   int [] minValues = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   private int  minValue = 0;\\n    \\t   \\n                public void push(int x) {\\n    \\t\\t  ensureCapacityHelper(elementCount + 1);\\n    \\t          elementData[index]=x;\\n    \\t          if(index==0){\\n    \\t          minValue = x;\\n    \\t          }else{\\n    \\t          minValue = Math.min(minValue, x);\\n    \\t          }\\n    \\t          minValues[index] = minValue;\\n    \\t          elementCount++;\\n    \\t          index++;\\n    \\t    }\\n    \\n    \\t    public void pop() {\\n    \\t    \\tif (elementCount == 0)\\n    \\t\\t\\treturn;\\n    \\t        index--;\\n    \\t        elementData[index]=0;\\n    \\t        minValues[index]=0;\\n    \\t        elementCount--;\\n    \\t        \\n    \\t        if(index-1<0){\\n    \\t        minValue = 0;\\n    \\t        }else{\\n    \\t        minValue = minValues[index-1];\\n    \\t        }\\n    \\t    }\\n    \\n    \\n    \\t    public int top() {\\n    \\t\\t  if(index-1<0)\\n    \\t\\t  return elementData[0];\\n    \\t      return elementData[index-1]; \\n    \\t    }\\n    \\n    \\t    public int getMin() {\\n    \\t        return minValue;\\n    \\t    }\\n    \\t    \\n    \\t    private void ensureCapacityHelper(int minCapacity) {\\n    \\t        if (minCapacity - elementData.length > 0)\\n    \\t            grow(minCapacity);\\n    \\t    }\\n    \\t    \\n    \\t    private void grow(int minCapacity) {\\n    \\t        int oldCapacity = elementData.length;\\n    \\t        int newCapacity = 2*oldCapacity;\\n    \\t        elementData = Arrays.copyOf(elementData, newCapacity);\\n    \\t        minValues = Arrays.copyOf(minValues, newCapacity);\\n    \\t    }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49310,
                "title": "why-push-1-top-getmin-will-return-3",
                "content": "    class MinStack:\\n    # @param x, an integer\\n    # @return an integer\\n    \\n    the_stack = []\\n    min_index_stack = []\\n    \\n    def push(self, x):\\n        if(self.the_stack):\\n            the_last_index = self.min_index_stack[len(self.min_index_stack) - 1]\\n            self.the_stack.append(x)\\n            if self.the_stack[the_last_index] > x:\\n                self.min_index_stack.append(len(self.the_stack) - 1)\\n        else:\\n            self.the_stack.append(x)\\n            self.min_index_stack.append(0)\\n\\n    # @return nothing\\n    def pop(self):\\n        if len(self.the_stack) > 0:\\n            if (len(self.the_stack) - 1) == self.min_index_stack[len(self.min_index_stack) - 1]:\\n                self.min_index_stack.pop()\\n            return self.the_stack.pop()\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[len(self.the_stack) - 1]\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[self.min_index_stack[len(self.min_index_stack) - 1]]\\n\\nThe oj end is: Wrong Answer\\nInput:          push(-1), top, getMin\\nOutput:       [-1, -3]\\nExpected:   [-1, -1]\\n\\nI don`t understand why there is \"-3\".",
                "solutionTags": [],
                "code": "    class MinStack:\\n    # @param x, an integer\\n    # @return an integer\\n    \\n    the_stack = []\\n    min_index_stack = []\\n    \\n    def push(self, x):\\n        if(self.the_stack):\\n            the_last_index = self.min_index_stack[len(self.min_index_stack) - 1]\\n            self.the_stack.append(x)\\n            if self.the_stack[the_last_index] > x:\\n                self.min_index_stack.append(len(self.the_stack) - 1)\\n        else:\\n            self.the_stack.append(x)\\n            self.min_index_stack.append(0)\\n\\n    # @return nothing\\n    def pop(self):\\n        if len(self.the_stack) > 0:\\n            if (len(self.the_stack) - 1) == self.min_index_stack[len(self.min_index_stack) - 1]:\\n                self.min_index_stack.pop()\\n            return self.the_stack.pop()\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[len(self.the_stack) - 1]\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[self.min_index_stack[len(self.min_index_stack) - 1]]\\n\\nThe oj end is: Wrong Answer\\nInput:          push(-1), top, getMin\\nOutput:       [-1, -3]\\nExpected:   [-1, -1]\\n\\nI don`t understand why there is \"-3\".",
                "codeTag": "Java"
            },
            {
                "id": 3969801,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class MinStack {\\n    Stack<int> stack = null;\\n    Stack<int> minStack = null;\\n    int minValue = 0;\\n    public MinStack() {\\n        stack = new Stack<int>();\\n        minStack = new Stack<int>();\\n    }\\n    public void Push(int val) {\\n        if(stack.Count == 0)\\n        {\\n            minValue = val;\\n        }\\n        stack.Push(val);\\n        minValue = Math.Min(minValue, val);\\n        minStack.Push(minValue);\\n    }\\n    public void Pop() {\\n        stack.Pop();\\n        minStack.Pop();\\n        if(minStack.Count > 0)\\n        {\\n            minValue = minStack.Peek();\\n        }\\n    }\\n    public int Top() {\\n        return stack.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return minValue;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.Push(val);\\n * obj.Pop();\\n * int param_3 = obj.Top();\\n * int param_4 = obj.GetMin();\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Design"
                ],
                "code": "```\\npublic class MinStack {\\n    Stack<int> stack = null;\\n    Stack<int> minStack = null;\\n    int minValue = 0;\\n    public MinStack() {\\n        stack = new Stack<int>();\\n        minStack = new Stack<int>();\\n    }\\n    public void Push(int val) {\\n        if(stack.Count == 0)\\n        {\\n            minValue = val;\\n        }\\n        stack.Push(val);\\n        minValue = Math.Min(minValue, val);\\n        minStack.Push(minValue);\\n    }\\n    public void Pop() {\\n        stack.Pop();\\n        minStack.Pop();\\n        if(minStack.Count > 0)\\n        {\\n            minValue = minStack.Peek();\\n        }\\n    }\\n    public int Top() {\\n        return stack.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return minValue;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.Push(val);\\n * obj.Pop();\\n * int param_3 = obj.Top();\\n * int param_4 = obj.GetMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784712,
                "title": "most-awesome-java-solution-two-approaches-explained-stacks-arraylist",
                "content": "# Intuition\\nMethod 1:\\nOne normal stack to do all operations Another minStack to keep record of minimum element in the stack yet.\\nMethod 2: \\nUsing two ArrayList.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n        \\n    }\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        \\n        min = Math.min(val, minStack.isEmpty() ?val :minStack.peek());\\n        minStack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        minStack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n\\n    }\\n\\n}\\n\\n//========================SecondMethod===============================\\nclass MinStack {\\n\\n    ArrayList<Integer> list;\\n    ArrayList<Integer> minList;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        list = new ArrayList<>();\\n        minList = new ArrayList<>();\\n        minList.add(min);\\n    }\\n    \\n    public void push(int val) {\\n        if(val <= minList.get(minList.size()-1)){\\n            minList.add(val);\\n        }\\n        list.add(val);\\n    }\\n    \\n    public void pop() {\\n        int removed = list.remove(list.size()-1);\\n        if(minList.get(minList.size()-1)== removed){\\n            minList.remove(minList.size()-1);\\n        }\\n        \\n    }\\n    \\n    public int top() {\\n        return list.get(list.size()-1);\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minList.get(minList.size()-1);\\n\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```\\n![upvoteCat.png](https://assets.leetcode.com/users/images/72472ac7-fbf0-4311-a4ee-ed9fe91c45b9_1689707783.1190436.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n        \\n    }\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        \\n        min = Math.min(val, minStack.isEmpty() ?val :minStack.peek());\\n        minStack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        minStack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n\\n    }\\n\\n}\\n\\n//========================SecondMethod===============================\\nclass MinStack {\\n\\n    ArrayList<Integer> list;\\n    ArrayList<Integer> minList;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        list = new ArrayList<>();\\n        minList = new ArrayList<>();\\n        minList.add(min);\\n    }\\n    \\n    public void push(int val) {\\n        if(val <= minList.get(minList.size()-1)){\\n            minList.add(val);\\n        }\\n        list.add(val);\\n    }\\n    \\n    public void pop() {\\n        int removed = list.remove(list.size()-1);\\n        if(minList.get(minList.size()-1)== removed){\\n            minList.remove(minList.size()-1);\\n        }\\n        \\n    }\\n    \\n    public int top() {\\n        return list.get(list.size()-1);\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minList.get(minList.size()-1);\\n\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685256,
                "title": "code-with-proper-comment-easy-solution",
                "content": "\\n\\n# Code\\n```\\nimport java.util.Stack;\\n\\nclass MinStack {\\n    Stack<Integer> s; // Stack to store the elements\\n    Stack<Integer> min; // Stack to store the minimum elements\\n\\n    /**\\n     * Initialize the MinStack.\\n     */\\n    public MinStack() {\\n        s = new Stack<>();\\n        min = new Stack<>();\\n    }\\n\\n    /**\\n     * Pushes an element onto the stack.\\n     * @param val The value to be pushed.\\n     */\\n    public void push(int val) {\\n        s.push(val); // Push the value onto the main stack\\n\\n        // If the minimum stack is empty or the new value is less than or equal to the current minimum,\\n        // push the new value onto the minimum stack\\n        if (min.isEmpty() || min.peek() >= s.peek()) {\\n            min.push(val);\\n        }\\n    }\\n\\n    /**\\n     * Removes the top element of the stack.\\n     */\\n    public void pop() {\\n        int val = s.pop(); // Pop the top value from the main stack\\n\\n        // If the popped value is the current minimum, remove it from the minimum stack\\n        if (min.peek() == val) {\\n            min.pop();\\n        }\\n    }\\n\\n    /**\\n     * Returns the top element of the stack.\\n     * @return The top element of the stack, or -1 if the stack is empty.\\n     */\\n    public int top() {\\n        if (s.isEmpty()) {\\n            return -1;\\n        }\\n        return s.peek(); // Return the top value from the main stack\\n    }\\n\\n    /**\\n     * Retrieves the minimum element in the stack.\\n     * @return The minimum element in the stack, or -1 if the stack is empty.\\n     */\\n    public int getMin() {\\n        if (min.isEmpty()) {\\n            return -1;\\n        }\\n        return min.peek(); // Return the top value from the minimum stack\\n    }\\n}\\n\\n/**\\n * Example usage of the MinStack class:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Stack;\\n\\nclass MinStack {\\n    Stack<Integer> s; // Stack to store the elements\\n    Stack<Integer> min; // Stack to store the minimum elements\\n\\n    /**\\n     * Initialize the MinStack.\\n     */\\n    public MinStack() {\\n        s = new Stack<>();\\n        min = new Stack<>();\\n    }\\n\\n    /**\\n     * Pushes an element onto the stack.\\n     * @param val The value to be pushed.\\n     */\\n    public void push(int val) {\\n        s.push(val); // Push the value onto the main stack\\n\\n        // If the minimum stack is empty or the new value is less than or equal to the current minimum,\\n        // push the new value onto the minimum stack\\n        if (min.isEmpty() || min.peek() >= s.peek()) {\\n            min.push(val);\\n        }\\n    }\\n\\n    /**\\n     * Removes the top element of the stack.\\n     */\\n    public void pop() {\\n        int val = s.pop(); // Pop the top value from the main stack\\n\\n        // If the popped value is the current minimum, remove it from the minimum stack\\n        if (min.peek() == val) {\\n            min.pop();\\n        }\\n    }\\n\\n    /**\\n     * Returns the top element of the stack.\\n     * @return The top element of the stack, or -1 if the stack is empty.\\n     */\\n    public int top() {\\n        if (s.isEmpty()) {\\n            return -1;\\n        }\\n        return s.peek(); // Return the top value from the main stack\\n    }\\n\\n    /**\\n     * Retrieves the minimum element in the stack.\\n     * @return The minimum element in the stack, or -1 if the stack is empty.\\n     */\\n    public int getMin() {\\n        if (min.isEmpty()) {\\n            return -1;\\n        }\\n        return min.peek(); // Return the top value from the minimum stack\\n    }\\n}\\n\\n/**\\n * Example usage of the MinStack class:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297934,
                "title": "python-one-stack-without-tuples-and-linklist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem we need to solve here is that we need to find a way to **save the min value of every stage/val** so that when we pop the min value of the current val, we don\\'t need to loop and find the previous min value. We can save the min through push a tuple to the stack and linklist. But here we use aother method to achieve it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is **whenever we push a new minimum value, we push the previous one first and then push the new one on the top of the old one.** In this way, when we pop the minimum value, we can pop the next value(previous min value) as well and update the min value.\\n\\n\\n# Code\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minVal = 2**31 - 1\\n\\n    def push(self, val: int) -> None:\\n        if val <= self.minVal:              # remember to add \\'euqals to\\'\\n            self.stack.append(self.minVal)  # push the previous min value\\n            self.minVal = val               # update the min value\\n        self.stack.append(val)              # push the new val\\n\\n    def pop(self) -> None:\\n        if self.stack.pop() == self.minVal: # when we pop the min val, \\n            self.minVal = self.stack.pop()  # we pop the next(previous min value) of it as well and update the min value\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minVal\\n        \\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minVal = 2**31 - 1\\n\\n    def push(self, val: int) -> None:\\n        if val <= self.minVal:              # remember to add \\'euqals to\\'\\n            self.stack.append(self.minVal)  # push the previous min value\\n            self.minVal = val               # update the min value\\n        self.stack.append(val)              # push the new val\\n\\n    def pop(self) -> None:\\n        if self.stack.pop() == self.minVal: # when we pop the min val, \\n            self.minVal = self.stack.pop()  # we pop the next(previous min value) of it as well and update the min value\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minVal\\n        \\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057098,
                "title": "c-two-solutions-o-n-o-1-tc",
                "content": "---\\n### Frist Approach\\n\\n### Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass MinStack {\\npublic:\\n    vector<int> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push_back(val);\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back();\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return *min_element(st.begin(), st.end());\\n    }\\n};\\n```\\n---\\n### Second Approach\\n\\n### Complexity\\n- Time complexity:  $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass MinStack {\\npublic:\\n    vector<pair<int,int>> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n       if(st.size() == 0) st.push_back({val, val});\\n       else st.push_back({val, min(st.back().second, val)});\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back().first;\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return st.back().second;\\n    }\\n};\\n\\n```\\n---\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    vector<int> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push_back(val);\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back();\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return *min_element(st.begin(), st.end());\\n    }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    vector<pair<int,int>> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n       if(st.size() == 0) st.push_back({val, val});\\n       else st.push_back({val, min(st.back().second, val)});\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back().first;\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return st.back().second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914022,
                "title": "java-solution-beat-100-full-explanation-in-depth",
                "content": "# Intuition\\nImagine a list. For each level of this list instead of storing just one value, we store two. Why?\\nSince this is a stack problem, and we are asking to find the min value in 0(1), storing for each level the value provided in the push method, and the min value of the stack at each level, would be great.\\nIf we didn\\'t store two values, we would have to search in a linear time each value in the list and find the minimium. If u still dont get it, read the example in the approach. \\n\\n# Approach\\nMain stack: [1,2,0,7,3],\\nMin stack:  [1,1,0,0,0].\\n\\nDo you see that, at each value of the min stack, we store the current minimium? In the first position since there\\'s just one number, we store just the 1. At the second one, we compare the current number in the main stack, and the least recent minimium. In this way, we don\\'t need to use a linear search since we are storing for the min value for each position. \\nNow you maybe wonder: what if we pop the last element in the main stack?\\nEasy, we pop the last element in the min stack too. Why? \\nBecause i told u that for each level we are storing two value. If we remove the last level in the main stack, we have to remove the last level in the min stack too.\\n\\nFor this, we can use either use two array list like in the example that i provided, or if u think about it, we can use an abstract list.\\nIn this way, we can keep the top value as a variable, the head one, and we dont need to have 2 List.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n0(n)\\n# Code\\n```\\nclass MinStack {\\n    \\n    // at the first, the head is null, cause the stack is empty.\\n    private Node head;\\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        /* if the stack is empty, we can\\'t compare the last min\\n        so we need to check first, is there is a last element. */\\n        int min = this.head == null ?\\n            val :\\n            Math.min(this.head.min, val);\\n        /* this would be equal to: if(this.head == null) ..\\n        else ... */         \\n\\n        // now, the new last element of the stack is the one provided\\n        // in the param, so we reference in the new node, the head\\n        // since it is the last top element of the stack */\\n        head = new Node(val, min, this.head);\\n    }\\n    \\n    public void pop() {\\n        // to remove an element, we just change the head to the prev\\n        this.head = this.head.prev;\\n    }\\n    \\n    public int top() {\\n        return this.head.val;\\n    }\\n    \\n    public int getMin() {\\n        // since we have for each level a node with the min value\\n        // we can just return the last one :)    \\n        return this.head.min;\\n    }\\n\\n    class Node {\\n        int val;\\n        int min;\\n\\n        Node prev;\\n\\n        public Node(int val, int min, Node prev) {\\n            this.val = val;\\n            this.min = min;\\n            this.prev = prev;\\n        } \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "# Intuition\\nImagine a list. For each level of this list instead of storing just one value, we store two. Why?\\nSince this is a stack problem, and we are asking to find the min value in 0(1), storing for each level the value provided in the push method, and the min value of the stack at each level, would be great.\\nIf we didn\\'t store two values, we would have to search in a linear time each value in the list and find the minimium. If u still dont get it, read the example in the approach. \\n\\n# Approach\\nMain stack: [1,2,0,7,3],\\nMin stack:  [1,1,0,0,0].\\n\\nDo you see that, at each value of the min stack, we store the current minimium? In the first position since there\\'s just one number, we store just the 1. At the second one, we compare the current number in the main stack, and the least recent minimium. In this way, we don\\'t need to use a linear search since we are storing for the min value for each position. \\nNow you maybe wonder: what if we pop the last element in the main stack?\\nEasy, we pop the last element in the min stack too. Why? \\nBecause i told u that for each level we are storing two value. If we remove the last level in the main stack, we have to remove the last level in the min stack too.\\n\\nFor this, we can use either use two array list like in the example that i provided, or if u think about it, we can use an abstract list.\\nIn this way, we can keep the top value as a variable, the head one, and we dont need to have 2 List.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n0(n)\\n# Code\\n```\\nclass MinStack {\\n    \\n    // at the first, the head is null, cause the stack is empty.\\n    private Node head;\\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        /* if the stack is empty, we can\\'t compare the last min\\n        so we need to check first, is there is a last element. */\\n        int min = this.head == null ?\\n            val :\\n            Math.min(this.head.min, val);\\n        /* this would be equal to: if(this.head == null) ..\\n        else ... */         \\n\\n        // now, the new last element of the stack is the one provided\\n        // in the param, so we reference in the new node, the head\\n        // since it is the last top element of the stack */\\n        head = new Node(val, min, this.head);\\n    }\\n    \\n    public void pop() {\\n        // to remove an element, we just change the head to the prev\\n        this.head = this.head.prev;\\n    }\\n    \\n    public int top() {\\n        return this.head.val;\\n    }\\n    \\n    public int getMin() {\\n        // since we have for each level a node with the min value\\n        // we can just return the last one :)    \\n        return this.head.min;\\n    }\\n\\n    class Node {\\n        int val;\\n        int min;\\n\\n        Node prev;\\n\\n        public Node(int val, int min, Node prev) {\\n            this.val = val;\\n            this.min = min;\\n            this.prev = prev;\\n        } \\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2812426,
                "title": "python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need $$O(1)$$ for this question, thus regular methods such as sorting, looping through the array cannot be done\\n- We can also deduce that:\\n    - We cannot access middle of array (only the back or front)\\n    - So we need to use some data structures that can access front and back in constant time and add or delete stuff to it\\n- Some data structures that can access the front or back in $$O(1)$$\\n    - Queues (Double ended)\\n    - Linked List\\n- I am going to use queues because its much simpler to use than linked lists in python\\n---\\n- Also, Note that for **stacks**\\n    - We can only **pop from the back**\\n    - and **add from the back**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Using the knowledge we have above,\\n- We can make up some sort of algorithm that may or may not work:\\n    - Let\\'s add the minimum values to the front of the queue and those that aren\\'t are sent to the back\\n    - E.g\\n      ```\\n      Insert values: 1, -2, 3, 5, 6, 2\\n      Queue: 1\\n      Queue: -2, 1\\n      Queue: -2, 1, 3\\n      Queue: -2, 1, 3, 5\\n      Queue: -2, 1, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2\\n      ```\\n- Now, when we pop from the stack:\\n    - We only need to pop from either the back of the queue or the front\\n    - E.g\\n      ```\\n      Stack: 1, -2, 3, 5, 6, 2      =>      1, -2, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2      pop     -2, 1, 3, 5, 6\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5, 6         =>      1, -2, 3, 5\\n      Queue: -2, 1, 3, 5, 6         pop     -2, 1, 3, 5\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5            =>      1, -2, 3\\n      Queue: -2, 1, 3, 5            pop     -2, 1, 3\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3               =>      1, -2\\n      Queue: -2, 1, 3               pop     -2, 1\\n      ------------------------------------------------------\\n      Stack: 1, -2                  =>           1\\n      Queue: -2, 1                  popfront     1\\n      ```\\n- From here we realise that the minimum can only be on the sides of the queue after a few trial and errors\\n- To find the minimum we can just return the minimum of the first or last values of the queue\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.minimums = deque()\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        \\n        if self.minimums and val <= self.minimums[0]:\\n            self.minimums.appendleft(val)\\n            return\\n        self.minimums.append(val)\\n\\n    def pop(self) -> None:\\n        val = self.stack.pop()\\n        if self.minimums[0] == val:\\n            self.minimums.popleft()\\n            return\\n        self.minimums.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return min(self.minimums[0], self.minimums[-1])\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```\\nNote: This solution was what I thought of when I did this question the first time.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n      Insert values: 1, -2, 3, 5, 6, 2\\n      Queue: 1\\n      Queue: -2, 1\\n      Queue: -2, 1, 3\\n      Queue: -2, 1, 3, 5\\n      Queue: -2, 1, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2\\n      ```\n```\\n      Stack: 1, -2, 3, 5, 6, 2      =>      1, -2, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2      pop     -2, 1, 3, 5, 6\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5, 6         =>      1, -2, 3, 5\\n      Queue: -2, 1, 3, 5, 6         pop     -2, 1, 3, 5\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5            =>      1, -2, 3\\n      Queue: -2, 1, 3, 5            pop     -2, 1, 3\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3               =>      1, -2\\n      Queue: -2, 1, 3               pop     -2, 1\\n      ------------------------------------------------------\\n      Stack: 1, -2                  =>           1\\n      Queue: -2, 1                  popfront     1\\n      ```\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.minimums = deque()\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        \\n        if self.minimums and val <= self.minimums[0]:\\n            self.minimums.appendleft(val)\\n            return\\n        self.minimums.append(val)\\n\\n    def pop(self) -> None:\\n        val = self.stack.pop()\\n        if self.minimums[0] == val:\\n            self.minimums.popleft()\\n            return\\n        self.minimums.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return min(self.minimums[0], self.minimums[-1])\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645450,
                "title": "c-o-1-time-complexity",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int, int>>s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push({val,val});\\n        }\\n        else{\\n            s.push({val, min(val, s.top().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        s.pop();    \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int, int>>s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push({val,val});\\n        }\\n        else{\\n            s.push({val, min(val, s.top().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        s.pop();    \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474936,
                "title": "kotlin-single-stack-using-linkedlist",
                "content": "```\\ndata class Node(\\n    val value: Int,\\n    val min: Int,\\n    var next: Node? = null\\n)\\n\\nclass MinStack {\\n    \\n    var top: Node? = null\\n\\n    fun push(`val`: Int) {\\n        val min: Int = top?.min?.let { if (`val` < it) `val` else it } ?: `val`\\n        val node = Node(`val`, min)\\n        node.next = top\\n        top = node    \\n    }\\n\\n    fun pop() {\\n        top = top?.next\\n    }\\n\\n    fun top(): Int {\\n        return top?.value ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n\\n    fun getMin(): Int {\\n        return top?.min ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\ndata class Node(\\n    val value: Int,\\n    val min: Int,\\n    var next: Node? = null\\n)\\n\\nclass MinStack {\\n    \\n    var top: Node? = null\\n\\n    fun push(`val`: Int) {\\n        val min: Int = top?.min?.let { if (`val` < it) `val` else it } ?: `val`\\n        val node = Node(`val`, min)\\n        node.next = top\\n        top = node    \\n    }\\n\\n    fun pop() {\\n        top = top?.next\\n    }\\n\\n    fun top(): Int {\\n        return top?.value ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n\\n    fun getMin(): Int {\\n        return top?.min ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381023,
                "title": "c-constant-space",
                "content": "```\\nclass MinStack {\\npublic:\\n    \\n    // most optimal - using constant space\\n    \\n    // uses a variable to keep track of min\\n    \\n    stack<long long> st;\\n    long long min_ele;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            st.push(val);\\n            min_ele = val;\\n        }\\n        else{\\n            // if val is more than min till now, no change\\n            if(val>min_ele){\\n                st.push(val);\\n            }\\n            // else val will be the new minimum\\n            // to recover prev min we insert 2*val - prev_min instead of val\\n            else{\\n                st.push(2LL*val-min_ele);\\n                min_ele = val;\\n            }\\n        }\\n    }\\n    \\n    // have to recover the previous min\\n    void pop() {\\n        // identifies that current top is the min\\n        if(st.top()<min_ele){\\n            long long prev_min = 2LL*min_ele-st.top();\\n            min_ele = prev_min; \\n        }\\n        st.pop();\\n    }\\n    \\n    // original element in stack = 2*current_min - st.top() \\n    int top() {\\n        if(st.top()<min_ele){\\n            return min_ele;\\n        }\\n        return st.top();\\n    }\\n    \\n    // directly return the min_ele, stored in variable\\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    // most optimal - using constant space\\n    \\n    // uses a variable to keep track of min\\n    \\n    stack<long long> st;\\n    long long min_ele;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            st.push(val);\\n            min_ele = val;\\n        }\\n        else{\\n            // if val is more than min till now, no change\\n            if(val>min_ele){\\n                st.push(val);\\n            }\\n            // else val will be the new minimum\\n            // to recover prev min we insert 2*val - prev_min instead of val\\n            else{\\n                st.push(2LL*val-min_ele);\\n                min_ele = val;\\n            }\\n        }\\n    }\\n    \\n    // have to recover the previous min\\n    void pop() {\\n        // identifies that current top is the min\\n        if(st.top()<min_ele){\\n            long long prev_min = 2LL*min_ele-st.top();\\n            min_ele = prev_min; \\n        }\\n        st.pop();\\n    }\\n    \\n    // original element in stack = 2*current_min - st.top() \\n    int top() {\\n        if(st.top()<min_ele){\\n            return min_ele;\\n        }\\n        return st.top();\\n    }\\n    \\n    // directly return the min_ele, stored in variable\\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164393,
                "title": "c-100-simple-solution",
                "content": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<long> s;\\n    int mi=INT_MAX;\\n    \\n    \\n    MinStack() {\\n        s=stack<long>();\\n        mi=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        \\n        if(s.empty())\\n        {\\n            s.push(val);\\n            mi=val;\\n        }\\n        else\\n        {\\n            if(val>mi)\\n            {\\n                s.push(val);\\n            }\\n            else\\n            {\\n                s.push((long)2*val-(long)mi);\\n                mi=val;\\n            }\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mi)\\n        {\\n            mi=(long)2*mi-(long)s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()<mi)\\n        {\\n            return mi;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<long> s;\\n    int mi=INT_MAX;\\n    \\n    \\n    MinStack() {\\n        s=stack<long>();\\n        mi=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        \\n        if(s.empty())\\n        {\\n            s.push(val);\\n            mi=val;\\n        }\\n        else\\n        {\\n            if(val>mi)\\n            {\\n                s.push(val);\\n            }\\n            else\\n            {\\n                s.push((long)2*val-(long)mi);\\n                mi=val;\\n            }\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mi)\\n        {\\n            mi=(long)2*mi-(long)s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()<mi)\\n        {\\n            return mi;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161035,
                "title": "c-every-operation-constant-time-stack-pair",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n        \\n    }\\n    void push(int val) {\\n        if(st.empty())\\n        st.push({val,val});\\n        else\\n            st.push({val,min(val,st.top().second)});\\n    }   \\n    void pop() {\\n        st.pop();\\n    } \\n    int top() {\\n        return st.top().first;\\n    }\\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n        \\n    }\\n    void push(int val) {\\n        if(st.empty())\\n        st.push({val,val});\\n        else\\n            st.push({val,min(val,st.top().second)});\\n    }   \\n    void pop() {\\n        st.pop();\\n    } \\n    int top() {\\n        return st.top().first;\\n    }\\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159173,
                "title": "js-javascript-easy-solution",
                "content": "```\\n\\nconst MinStack = function() {\\n    this.values = []\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n    this.values.push(val)\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.pop = function() {\\n    return this.values.pop()\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    return this.values[this.values.length - 1]\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    let min = Number.MAX_SAFE_INTEGER\\n    this.values.forEach(value => min = Math.min(min, value))\\n\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst MinStack = function() {\\n    this.values = []\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n    this.values.push(val)\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.pop = function() {\\n    return this.values.pop()\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    return this.values[this.values.length - 1]\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    let min = Number.MAX_SAFE_INTEGER\\n    this.values.forEach(value => min = Math.min(min, value))\\n\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870246,
                "title": "c-2-solutions-2-stack-1-stack-o-1-time-easy-clean-code",
                "content": "**1. Using 2 Stacks**\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s1,s2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int v) {\\n        s1.push(v);\\n        if(s2.empty() || s2.top()>=v)\\n            s2.push(v);\\n    }\\n    \\n    void pop() {\\n        if(s2.top()==s1.top())\\n            s2.pop();\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();\\n    }\\n};\\n```\\n\\n**2. Using single Stack**\\n```\\nclass MinStack {\\npublic:\\n    long mn;\\n    stack<long> s;\\n    \\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n        {\\n            mn=val;\\n            s.push(val);\\n        }\\n        else if(val>mn)\\n            s.push(val);\\n        else\\n        {\\n            s.push((long)2*val-mn);\\n            mn=val;\\n        }  \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mn)\\n            mn=2*mn-s.top();\\n        \\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()>=mn)\\n        return s.top();\\n        \\n        return mn;\\n    }\\n    \\n    int getMin() {\\n        return mn;\\n    }\\n};\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> s1,s2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int v) {\\n        s1.push(v);\\n        if(s2.empty() || s2.top()>=v)\\n            s2.push(v);\\n    }\\n    \\n    void pop() {\\n        if(s2.top()==s1.top())\\n            s2.pop();\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();\\n    }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    long mn;\\n    stack<long> s;\\n    \\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n        {\\n            mn=val;\\n            s.push(val);\\n        }\\n        else if(val>mn)\\n            s.push(val);\\n        else\\n        {\\n            s.push((long)2*val-mn);\\n            mn=val;\\n        }  \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mn)\\n            mn=2*mn-s.top();\\n        \\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()>=mn)\\n        return s.top();\\n        \\n        return mn;\\n    }\\n    \\n    int getMin() {\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761680,
                "title": "most-optimised-one-by-using-encoding-technique",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<long>s;\\n    long currMin;\\n    MinStack() {\\n        currMin=LONG_MAX;\\n    }\\n    \\n    void push(int val) {\\n        int x=val;\\n        if(s.empty())\\n        {\\n            s.push(val);\\n            currMin=val;\\n            return ;\\n        }\\n        if(x<currMin)\\n        {\\n            s.push((long)2*val-currMin);\\n            currMin=val;\\n        }\\n        else\\n        {\\n            s.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.top()<currMin)\\n        {\\n            currMin=(long)2*currMin-s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(s.top()<currMin)\\n            return currMin;\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return currMin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<long>s;\\n    long currMin;\\n    MinStack() {\\n        currMin=LONG_MAX;\\n    }\\n    \\n    void push(int val) {\\n        int x=val;\\n        if(s.empty())\\n        {\\n            s.push(val);\\n            currMin=val;\\n            return ;\\n        }\\n        if(x<currMin)\\n        {\\n            s.push((long)2*val-currMin);\\n            currMin=val;\\n        }\\n        else\\n        {\\n            s.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.top()<currMin)\\n        {\\n            currMin=(long)2*currMin-s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(s.top()<currMin)\\n            return currMin;\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return currMin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676085,
                "title": "java-solution",
                "content": "Implement stack using linked list.\\nMaintain a *min* variable in Node of linked list.\\n\\t\\n\\tclass MinStack {\\n    Node top;\\n\\n\\t\\tpublic MinStack() {\\n\\t\\t\\tthis.top = new Node(0,Integer.MAX_VALUE,null);\\n\\t\\t}\\n\\n\\t\\tpublic void push(int val) {\\n\\t\\t\\tNode n ;\\n\\t\\t\\tif(top.min > val) {\\n\\t\\t\\t\\tn = new Node(val, val, top);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tn = new Node(val, top.min, top);\\n\\t\\t\\t}\\n\\t\\t\\ttop = n;\\n\\t\\t}\\n\\n\\t\\tpublic void pop() {\\n\\t\\t\\ttop = top.prev;\\n\\t\\t}\\n\\n\\t\\tpublic int top() {\\n\\t\\t\\treturn top.val;\\n\\t\\t}\\n\\n\\t\\tpublic int getMin() {\\n\\t\\t\\treturn top.min;\\n\\t\\t}\\n\\t}\\n\\tclass Node {\\n\\t\\tint val;\\n\\t\\tint min;\\n\\t\\tNode prev;\\n    \\n\\t\\tNode(int val, int min, Node prev) {\\n\\t\\t\\tthis.min = min;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.prev = prev;\\n\\t\\t}\\n    \\n\\t}\\n\\n",
                "solutionTags": [],
                "code": "Implement stack using linked list.\\nMaintain a *min* variable in Node of linked list.\\n\\t\\n\\tclass MinStack {\\n    Node top;\\n\\n\\t\\tpublic MinStack() {\\n\\t\\t\\tthis.top = new Node(0,Integer.MAX_VALUE,null);\\n\\t\\t}\\n\\n\\t\\tpublic void push(int val) {\\n\\t\\t\\tNode n ;\\n\\t\\t\\tif(top.min > val) {\\n\\t\\t\\t\\tn = new Node(val, val, top);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tn = new Node(val, top.min, top);\\n\\t\\t\\t}\\n\\t\\t\\ttop = n;\\n\\t\\t}\\n\\n\\t\\tpublic void pop() {\\n\\t\\t\\ttop = top.prev;\\n\\t\\t}\\n\\n\\t\\tpublic int top() {\\n\\t\\t\\treturn top.val;\\n\\t\\t}\\n\\n\\t\\tpublic int getMin() {\\n\\t\\t\\treturn top.min;\\n\\t\\t}\\n\\t}\\n\\tclass Node {\\n\\t\\tint val;\\n\\t\\tint min;\\n\\t\\tNode prev;\\n    \\n\\t\\tNode(int val, int min, Node prev) {\\n\\t\\t\\tthis.min = min;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.prev = prev;\\n\\t\\t}\\n    \\n\\t}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1586639,
                "title": "java-easy-solution-stack-and-priority-queue",
                "content": "**Code**\\n\\n```java\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        pq.add(val);\\n    }\\n    \\n    public void pop() {\\n        pq.remove(stack.pop());\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return pq.peek();\\n    }\\n}\\n```\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        pq.add(val);\\n    }\\n    \\n    public void pop() {\\n        pq.remove(stack.pop());\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553033,
                "title": "c-min-stack",
                "content": "https://leetcode.com/problems/min-stack\\n**With using extra stack**\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> ss;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        s.push(val);\\n        if(ss.size()==0||ss.top()>=val)\\n            ss.push(val);\\n    }\\n    \\n    void pop() {\\n        int x=s.top();\\n        s.pop();\\n        if(x==ss.top())\\n            ss.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(ss.size()==0) return -1;\\n         return ss.top();\\n    }\\n};\\n```\\n**Without using extra stack**\\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int> > s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        int minEle=INT_MAX;\\n        if(s.size()==0)\\n        {\\n            minEle=val;\\n        }\\n        else\\n        {\\n            minEle=min(val,s.top().second);\\n        }\\n        s.push({val,minEle});\\n    }\\n    \\n    void pop() {\\n       s.pop(); \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n ```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> ss;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        s.push(val);\\n        if(ss.size()==0||ss.top()>=val)\\n            ss.push(val);\\n    }\\n    \\n    void pop() {\\n        int x=s.top();\\n        s.pop();\\n        if(x==ss.top())\\n            ss.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(ss.size()==0) return -1;\\n         return ss.top();\\n    }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int> > s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        int minEle=INT_MAX;\\n        if(s.size()==0)\\n        {\\n            minEle=val;\\n        }\\n        else\\n        {\\n            minEle=min(val,s.top().second);\\n        }\\n        s.push({val,minEle});\\n    }\\n    \\n    void pop() {\\n       s.pop(); \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1540191,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/min-stack/) solution\\n```\\ntype StackNode struct {\\n\\tval  int\\n\\tmin  int\\n\\tnext *StackNode\\n}\\n\\nfunc NewStackNode(val, min int, next *StackNode) *StackNode {\\n\\treturn &StackNode{\\n\\t\\tval:  val,\\n\\t\\tmin:  min,\\n\\t\\tnext: next,\\n\\t}\\n}\\n\\ntype MinStack struct {\\n\\thead *StackNode\\n}\\n\\nfunc Constructor() MinStack {\\n\\treturn MinStack{head: nil}\\n}\\n\\nfunc (this *MinStack) Push(val int) {\\n\\tif this.head == nil {\\n\\t\\tthis.head = NewStackNode(val, val, nil)\\n\\t} else {\\n\\t\\tmin := val\\n\\t\\tif this.head.min < min {\\n\\t\\t\\tmin = this.head.min\\n\\t\\t}\\n\\t\\tthis.head = NewStackNode(val, min, this.head)\\n\\t}\\n}\\n\\nfunc (this *MinStack) Pop() {\\n\\tthis.head = this.head.next\\n}\\n\\nfunc (this *MinStack) Top() int {\\n\\treturn this.head.val\\n}\\n\\nfunc (this *MinStack) GetMin() int {\\n\\treturn this.head.min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype StackNode struct {\\n\\tval  int\\n\\tmin  int\\n\\tnext *StackNode\\n}\\n\\nfunc NewStackNode(val, min int, next *StackNode) *StackNode {\\n\\treturn &StackNode{\\n\\t\\tval:  val,\\n\\t\\tmin:  min,\\n\\t\\tnext: next,\\n\\t}\\n}\\n\\ntype MinStack struct {\\n\\thead *StackNode\\n}\\n\\nfunc Constructor() MinStack {\\n\\treturn MinStack{head: nil}\\n}\\n\\nfunc (this *MinStack) Push(val int) {\\n\\tif this.head == nil {\\n\\t\\tthis.head = NewStackNode(val, val, nil)\\n\\t} else {\\n\\t\\tmin := val\\n\\t\\tif this.head.min < min {\\n\\t\\t\\tmin = this.head.min\\n\\t\\t}\\n\\t\\tthis.head = NewStackNode(val, min, this.head)\\n\\t}\\n}\\n\\nfunc (this *MinStack) Pop() {\\n\\tthis.head = this.head.next\\n}\\n\\nfunc (this *MinStack) Top() int {\\n\\treturn this.head.val\\n}\\n\\nfunc (this *MinStack) GetMin() int {\\n\\treturn this.head.min\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539179,
                "title": "beats-95-arraylist-with-clear-explanation",
                "content": "```\\nclass MinStack {\\n    private List<Integer> stack = new ArrayList();    //for pushing into stack\\n    private List<Integer> stackWithMins = new ArrayList(); //to reduce the time complexity of finding min element\\n    \\n    public MinStack() {}\\n    \\n    public void push(int val) {        \\n        if (stackWithMins.isEmpty()) {\\n            stackWithMins.add(val); //pushing if the min-stack is empty\\n        } else if (val <= stackWithMins.get(stackWithMins.size()-1)) { //if the min-stack is empty we compare it with the top element in the min-stack because the top element is less than all the previous elements due to the same condition\\n            stackWithMins.add(val); \\n        }\\n        \\n        stack.add(val); // normal pushing into stack\\n    }\\n    \\n    public void pop() {\\n        int poppedValue = stack.remove(stack.size()-1); // removing the top element from stack\\n        int minValue = stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n        \\n        if (poppedValue == minValue) {\\n            stackWithMins.remove(stackWithMins.size()-1); //if the top element from min-stack is equal to the min element, then we need to pop it\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.get(stack.size()-1); //getting the top element\\n    }\\n    \\n    public int getMin() {\\n        return stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n    }\\n}\\n```\\n\\nThank you \\u2665 Upvoting helps a lot \\uD83D\\uDC51\\nIf you have any doubts, please let me know \\uD83D\\uDC47",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass MinStack {\\n    private List<Integer> stack = new ArrayList();    //for pushing into stack\\n    private List<Integer> stackWithMins = new ArrayList(); //to reduce the time complexity of finding min element\\n    \\n    public MinStack() {}\\n    \\n    public void push(int val) {        \\n        if (stackWithMins.isEmpty()) {\\n            stackWithMins.add(val); //pushing if the min-stack is empty\\n        } else if (val <= stackWithMins.get(stackWithMins.size()-1)) { //if the min-stack is empty we compare it with the top element in the min-stack because the top element is less than all the previous elements due to the same condition\\n            stackWithMins.add(val); \\n        }\\n        \\n        stack.add(val); // normal pushing into stack\\n    }\\n    \\n    public void pop() {\\n        int poppedValue = stack.remove(stack.size()-1); // removing the top element from stack\\n        int minValue = stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n        \\n        if (poppedValue == minValue) {\\n            stackWithMins.remove(stackWithMins.size()-1); //if the top element from min-stack is equal to the min element, then we need to pop it\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.get(stack.size()-1); //getting the top element\\n    }\\n    \\n    public int getMin() {\\n        return stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534170,
                "title": "python3-stack",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append((val,val))  # storing tuple of current value , min of curr and prev value of stack\\n        else:\\n            self.stack.append((val, min(val,self.stack[-1][1]))) # min of prev value & curr\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        if self.stack:\\n            return self.stack[-1][0]   # curr value at 1st index of tuple\\n        else:\\n            return None\\n\\n\\n    def getMin(self) -> int:\\n        if not self.stack:\\n            return None\\n        return self.stack[-1][1]   # min value at 2nd index of tuple\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append((val,val))  # storing tuple of current value , min of curr and prev value of stack\\n        else:\\n            self.stack.append((val, min(val,self.stack[-1][1]))) # min of prev value & curr\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        if self.stack:\\n            return self.stack[-1][0]   # curr value at 1st index of tuple\\n        else:\\n            return None\\n\\n\\n    def getMin(self) -> int:\\n        if not self.stack:\\n            return None\\n        return self.stack[-1][1]   # min value at 2nd index of tuple\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1523228,
                "title": "easy-java-solution",
                "content": "```\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public void push(int val) {\\n        if(val <= min){\\n            stack.push(min);\\n            min = val;\\n        }\\n        stack.push(val);  \\n    }\\n    public void pop() {\\n        if(stack.pop() == min)  min = stack.pop();\\n    }\\n    public int top() {    \\n        return stack.peek();    \\n    }\\n    public int getMin() {   \\n        return min;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public void push(int val) {\\n        if(val <= min){\\n            stack.push(min);\\n            min = val;\\n        }\\n        stack.push(val);  \\n    }\\n    public void pop() {\\n        if(stack.pop() == min)  min = stack.pop();\\n    }\\n    public int top() {    \\n        return stack.peek();    \\n    }\\n    public int getMin() {   \\n        return min;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439818,
                "title": "c-using-single-stack",
                "content": "**Please Upvote if you like!**\\n\\n    class MinStack {\\n    public:\\n    stack<long> st;\\n    long min;\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) \\n    {\\n        if(st.empty())\\n        {\\n            st.push(val);\\n            min=val;\\n        }\\n        else if(val<=min)\\n        {\\n            st.push(2ll*val-min);\\n            min=val;\\n        }\\n        else\\n        {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() \\n    {\\n         if(st.empty()) \\n             return;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            min=2ll*min-t;\\n        }\\n        st.pop();\\n    }\\n    \\n    int top() \\n    {\\n        \\n        if(st.empty())\\n            return -1;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            return min;\\n        }\\n        else \\n            return t;\\n    }\\n    \\n    int getMin() \\n    {\\n        if(st.empty())\\n            return -1;\\n        else\\n        return min;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "**Please Upvote if you like!**\\n\\n    class MinStack {\\n    public:\\n    stack<long> st;\\n    long min;\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) \\n    {\\n        if(st.empty())\\n        {\\n            st.push(val);\\n            min=val;\\n        }\\n        else if(val<=min)\\n        {\\n            st.push(2ll*val-min);\\n            min=val;\\n        }\\n        else\\n        {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() \\n    {\\n         if(st.empty()) \\n             return;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            min=2ll*min-t;\\n        }\\n        st.pop();\\n    }\\n    \\n    int top() \\n    {\\n        \\n        if(st.empty())\\n            return -1;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            return min;\\n        }\\n        else \\n            return t;\\n    }\\n    \\n    int getMin() \\n    {\\n        if(st.empty())\\n            return -1;\\n        else\\n        return min;\\n    }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1282755,
                "title": "java-using-2-stacks-beats-94",
                "content": "**Do vote up if you like it :)**\\n```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    Stack<Integer> minStack;\\n    Stack<Integer> stack;\\n    \\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int val) {\\n        if(minStack.isEmpty() || val <= minStack.peek())  {\\n            minStack.push(val);\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(!minStack.isEmpty() && stack.peek().equals(minStack.peek())) {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```\\n--------------------------------------------------------\\n",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    Stack<Integer> minStack;\\n    Stack<Integer> stack;\\n    \\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int val) {\\n        if(minStack.isEmpty() || val <= minStack.peek())  {\\n            minStack.push(val);\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(!minStack.isEmpty() && stack.peek().equals(minStack.peek())) {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139755,
                "title": "c-clear-code-without-using-stl",
                "content": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    struct Node {\\n        int data;\\n        int min;\\n        Node *next;\\n        Node(int x, int d): data(x), min(d), next(NULL) {}\\n    };\\n    \\n    struct Node* head;\\n    MinStack() { \\n        head=NULL;\\n    }\\n    \\n    void push(int val) {\\n        struct Node *new_node;\\n        if(head==NULL){\\n             new_node = new Node(val,val);\\n        }\\n        else{\\n             new_node = new Node(val,min(val,head->min));\\n             new_node->next=head;\\n        }\\n        head=new_node;\\n    }\\n    \\n    void pop() {\\n        head=head->next;\\n    }\\n    \\n    int top() {\\n        return head->data;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    struct Node {\\n        int data;\\n        int min;\\n        Node *next;\\n        Node(int x, int d): data(x), min(d), next(NULL) {}\\n    };\\n    \\n    struct Node* head;\\n    MinStack() { \\n        head=NULL;\\n    }\\n    \\n    void push(int val) {\\n        struct Node *new_node;\\n        if(head==NULL){\\n             new_node = new Node(val,val);\\n        }\\n        else{\\n             new_node = new Node(val,min(val,head->min));\\n             new_node->next=head;\\n        }\\n        head=new_node;\\n    }\\n    \\n    void pop() {\\n        head=head->next;\\n    }\\n    \\n    int top() {\\n        return head->data;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 996547,
                "title": "c-solution-using-single-container",
                "content": "A min stack is a generic stack that can give us the minimum value in constant time **(O(1) time complexity)** by being on top. The most effective implementation is to use 2 containers.\\n- Generic Container\\n- One with min value on the top\\n\\nThis can be further simplified by combining them into 1 by using a pair with one being a generic entity and other one being the minimum. The solution is implemented using this STL stack as a private member.\\n```\\nstack<int> st;\\n// Pair {generic element, minimum element}\\n```\\n\\n## For Push operation\\nIf the container is empty, then push the incoming element else push the minimum element.\\n```\\nvoid push(int x) {\\n\\tst.push({x, (not st.empty() ? min(x, st.top().second) : x)});\\n}\\n```\\n\\n### Futher explaination\\nBefore including the minimum element, **we must check if the stack is empty or not**. To compare the minimum value, **we must have a two values.** In case of an empty stack, there is **no top** and hence, have **nothing to compare.** As a result, you will encounter `nullptr` exception. To avoid the exception, we are adding the incoming element in the min stack too **if the stack is empty.** Leading to this condition for the second element of the pair.\\n```\\n(not st.empty() ? min(x, st.top().second) : x)\\n```\\n\\n## Pop operation\\nPopping is simple, just pop the element from the stack and done!\\n```\\nvoid pop() \\n{ \\n\\tst.pop(); \\n} \\n```\\n\\n## Top and Min access\\n```top()``` will return the top of the generic stack while ```min()``` will return the minimum value.\\n```\\nvoid top() { \\n\\treturn st.top().first; \\n}\\n\\nvoid getMin() {\\n\\treturn st.top().second;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstack<int> st;\\n// Pair {generic element, minimum element}\\n```\n```\\nvoid push(int x) {\\n\\tst.push({x, (not st.empty() ? min(x, st.top().second) : x)});\\n}\\n```\n```\\n(not st.empty() ? min(x, st.top().second) : x)\\n```\n```\\nvoid pop() \\n{ \\n\\tst.pop(); \\n} \\n```\n```top()```\n```min()```\n```\\nvoid top() { \\n\\treturn st.top().first; \\n}\\n\\nvoid getMin() {\\n\\treturn st.top().second;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 835720,
                "title": "min-stack-using-only-one-stack-in-o-1-extra-space",
                "content": "The key logic in this approach is:\\nwhenever an element say \"b\" which is greater than the minimum element say \"a\" comes it is simply inserted into the stack as it doeas not change the value of minimum element (since it is greater) but when a smaller element say \"c\" comes then we should update the minEle variable to this element (minEle = c) but we will not put this element into the stack instead push 2*c-minEle in the stack.This is done so that during the pop operation when this minimum element gets removed then we can set the minEle variable back to the original element \"a\" by doing this minEle = 2*minEle - s.top() \\n\\nclass MinStack {\\n    \\n    long long minEle;\\n    stack<long long>s;\\n    \\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()) {\\n            s.push(x);\\n            minEle = x;\\n        }\\n        else\\n        {\\n            if(x >= minEle)\\n                s.push(x);\\n            else{\\n                long long y=x;\\n                s.push(2*y-minEle);\\n                minEle = x;\\n            }\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        else\\n        {\\n            if(s.top() >= minEle)\\n                s.pop();\\n            else{\\n                minEle = 2*minEle - s.top();\\n                s.pop();\\n            }\\n                \\n        }\\n    }\\n    \\n    int top() {\\n        long long val = -1;\\n        if(s.empty()) return val;\\n        else\\n        {\\n            if(s.top() >= minEle){\\n                val = s.top();\\n            }\\n            else{\\n                val = minEle;\\n            }    \\n        }\\n        return val;\\n    }\\n    \\n    int getMin() {\\n        if(s.size() == 0) return -1;\\n        return minEle;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "The key logic in this approach is:\\nwhenever an element say \"b\" which is greater than the minimum element say \"a\" comes it is simply inserted into the stack as it doeas not change the value of minimum element (since it is greater) but when a smaller element say \"c\" comes then we should update the minEle variable to this element (minEle = c) but we will not put this element into the stack instead push 2*c-minEle in the stack.This is done so that during the pop operation when this minimum element gets removed then we can set the minEle variable back to the original element \"a\" by doing this minEle = 2*minEle - s.top() \\n\\nclass MinStack {\\n    \\n    long long minEle;\\n    stack<long long>s;\\n    \\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()) {\\n            s.push(x);\\n            minEle = x;\\n        }\\n        else\\n        {\\n            if(x >= minEle)\\n                s.push(x);\\n            else{\\n                long long y=x;\\n                s.push(2*y-minEle);\\n                minEle = x;\\n            }\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        else\\n        {\\n            if(s.top() >= minEle)\\n                s.pop();\\n            else{\\n                minEle = 2*minEle - s.top();\\n                s.pop();\\n            }\\n                \\n        }\\n    }\\n    \\n    int top() {\\n        long long val = -1;\\n        if(s.empty()) return val;\\n        else\\n        {\\n            if(s.top() >= minEle){\\n                val = s.top();\\n            }\\n            else{\\n                val = minEle;\\n            }    \\n        }\\n        return val;\\n    }\\n    \\n    int getMin() {\\n        if(s.size() == 0) return -1;\\n        return minEle;\\n    }\\n};",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569698,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1689860,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1724956,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1897302,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1857413,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1573559,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1843067,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1824562,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1571868,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1567472,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1569698,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1689860,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1724956,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1897302,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1857413,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1573559,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1843067,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1824562,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1571868,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1567472,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1571349,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1937049,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1930311,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1569212,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1568986,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1574276,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1988530,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1977633,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1572087,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1571348,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 2076569,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2075251,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2072330,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2071190,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2062141,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2058300,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2055870,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2055042,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2048080,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2046798,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2020351,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 2001192,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1999327,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1983397,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1956713,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1949447,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1937225,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1931732,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1927958,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1925810,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1925323,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1916547,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1915819,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1906328,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1898115,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1872087,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1867921,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1867870,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1863581,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1859141,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            }
        ]
    }
]