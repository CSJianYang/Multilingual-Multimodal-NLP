[
    {
        "title": "Maximize Number of Subsequences in a String",
        "question_content": "You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\nYou can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\nReturn the maximum number of times pattern can occur as a subsequence of the modified text.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n&nbsp;\nExample 1:\n\nInput: text = \"abdcdbc\", pattern = \"ac\"\nOutput: 4\nExplanation:\nIf we add pattern[0] = 'a' in between text[1] and text[2], we get \"abadcdbc\". Now, the number of times \"ac\" occurs as a subsequence is 4.\nSome other strings which have 4 subsequences \"ac\" after adding a character to text are \"aabdcdbc\" and \"abdacdbc\".\nHowever, strings such as \"abdcadbc\", \"abdccdbc\", and \"abdcdbcc\", although obtainable, have only 3 subsequences \"ac\" and are thus suboptimal.\nIt can be shown that it is not possible to get more than 4 subsequences \"ac\" by adding only one character.\n\nExample 2:\n\nInput: text = \"aabb\", pattern = \"ab\"\nOutput: 6\nExplanation:\nSome of the strings which can be obtained from text and have 6 subsequences \"ab\" are \"aaabb\", \"aaabb\", and \"aabbb\".\n\n&nbsp;\nConstraints:\n\n\t1 <= text.length <= 105\n\tpattern.length == 2\n\ttext and pattern consist only of lowercase English letters.",
        "solutions": [
            {
                "id": 1863900,
                "title": "java-c-python-straight-forward-solution",
                "content": "# **Intuition**\\nIf we add `pattern[0]`, the best option is to add at the begin.\\nIf we add `pattern[1]`, the best option is to add at the end.\\n<br>\\n\\n# **Explanation**\\nFirstly we\\'ll try to find the number of subquence `pattern` in the current string `text`\\nIterate every character `c` from input string `text`,\\n`cnt1` means the count of character `pattern[0]`,\\n`cnt2` means the count of character `pattern[1]`.\\n\\nIf `c == pattern[1]`, \\nit can build up string pattern with every `pattern[0]` before it,\\nso we update `res += cnt1` as well as `cnt2++`\\n\\nIf `c == pattern[0]`, \\nwe simply increment `cnt1++`.\\n\\nThen we consider of adding one more character:\\n\\nIf we add `pattern[0]`,\\nthe best option is to add at the begin,\\n`res += cnt2`\\n\\nIf we add `pattern[1]`,\\nthe best option is to add at the end,\\n`res += cnt1`\\n<br>\\n\\n# **Tip**\\nUse two `if` in my solution,\\nto handle the corner case where `pattern[0] == pattern[1]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long maximumSubsequenceCount(String s, String pattern) {\\n        long res = 0, cnt1 = 0, cnt2 = 0;\\n        for (int i = 0; i < s.length(); ++i) {   \\n            if (s.charAt(i) == pattern.charAt(1)) {   \\n                res += cnt1; \\n                cnt2++;\\n            }\\n            if (s.charAt(i) == pattern.charAt(0)) {   \\n                cnt1++;\\n            }\\n        }\\n        return res + Math.max(cnt1, cnt2);\\n    }\\n```\\n**C++**\\n```cpp\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long res = 0, cnt1 = 0, cnt2 = 0;\\n        for (char& c: text) {   \\n            if (c == pattern[1])\\n                res += cnt1, cnt2++;\\n            if (c == pattern[0])\\n                cnt1++;\\n        }\\n        return res + max(cnt1, cnt2);\\n    }\\n```\\n**Python**\\n```py\\n    def maximumSubsequenceCount(self, text, pattern):\\n        res = cnt1 = cnt2 = 0\\n        for c in text:\\n            if c == pattern[1]:\\n                res += cnt1\\n                cnt2 += 1\\n            if c == pattern[0]:\\n                cnt1 += 1\\n        return res + max(cnt1, cnt2)\\n```\\n<br>\\n\\n**Follow-up**\\nYou can add either character anywhere in text exactly **`K`** times. \\nReturn the result.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long maximumSubsequenceCount(String s, String pattern) {\\n        long res = 0, cnt1 = 0, cnt2 = 0;\\n        for (int i = 0; i < s.length(); ++i) {   \\n            if (s.charAt(i) == pattern.charAt(1)) {   \\n                res += cnt1; \\n                cnt2++;\\n            }\\n            if (s.charAt(i) == pattern.charAt(0)) {   \\n                cnt1++;\\n            }\\n        }\\n        return res + Math.max(cnt1, cnt2);\\n    }\\n```\n```cpp\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long res = 0, cnt1 = 0, cnt2 = 0;\\n        for (char& c: text) {   \\n            if (c == pattern[1])\\n                res += cnt1, cnt2++;\\n            if (c == pattern[0])\\n                cnt1++;\\n        }\\n        return res + max(cnt1, cnt2);\\n    }\\n```\n```py\\n    def maximumSubsequenceCount(self, text, pattern):\\n        res = cnt1 = cnt2 = 0\\n        for c in text:\\n            if c == pattern[1]:\\n                res += cnt1\\n                cnt2 += 1\\n            if c == pattern[0]:\\n                cnt1 += 1\\n        return res + max(cnt1, cnt2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1863892,
                "title": "first-or-last",
                "content": "**Intuition:** the best strategy is to add  `pat[0]` as the first letter, or `pat[1]` as the last.\\n\\nWe go left-to-right, counting `pat[0]` using `cnt0`. Note that `cnt0` starts from `1` - since we added `pat[0]` as the very first character. Every time we find `pat[1]`, we have `cnt0` subsequences\\n\\nThe same logic is applied when we add `pat[1]` as the last character - we just need to go right-to-left.\\n\\n**C++**\\n```cpp\\nlong long maximumSubsequenceCount(string t, string pat) {\\n    long long cnt0 = 1, cnt1 = 1, res0 = 0, res1 = 0;\\n    for (int i = 0, j = t.size() - 1; j >= 0; ++i, --j) {\\n        if (t[i] == pat[1])\\n            res0 += cnt0;\\n        if (t[j] == pat[0])\\n            res1 += cnt1;\\n        cnt0 += t[i] == pat[0];\\n        cnt1 += t[j] == pat[1];\\n    }\\n    return max(res0, res1);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long maximumSubsequenceCount(string t, string pat) {\\n    long long cnt0 = 1, cnt1 = 1, res0 = 0, res1 = 0;\\n    for (int i = 0, j = t.size() - 1; j >= 0; ++i, --j) {\\n        if (t[i] == pat[1])\\n            res0 += cnt0;\\n        if (t[j] == pat[0])\\n            res1 += cnt1;\\n        cnt0 += t[i] == pat[0];\\n        cnt1 += t[j] == pat[1];\\n    }\\n    return max(res0, res1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863909,
                "title": "o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\n    public long maximumSubsequenceCount(String s, String p) {\\n        long ans = 0, max = 0;\\n        int cnt = 1;\\n        //Assume adding 0th character of pattern at starting\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(0)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        ans = 0; cnt = 1;\\n        //Assume adding second character of pattern at end\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(1)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long maximumSubsequenceCount(String s, String p) {\\n        long ans = 0, max = 0;\\n        int cnt = 1;\\n        //Assume adding 0th character of pattern at starting\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(0)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        ans = 0; cnt = 1;\\n        //Assume adding second character of pattern at end\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(1)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864008,
                "title": "c-straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    long long cal(string s , string t){\\n        long long ans = 0;\\n        unordered_map<char , long long> m;\\n        for(auto x : s){\\n            if(x == t[1]){\\n                ans += m[t[0]];\\n            }\\n            m[x]++;\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long op1 = cal(pattern[0] + text , pattern);\\n        long long op2 = cal(text + pattern[1] , pattern);\\n        return max(op1,op2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long cal(string s , string t){\\n        long long ans = 0;\\n        unordered_map<char , long long> m;\\n        for(auto x : s){\\n            if(x == t[1]){\\n                ans += m[t[0]];\\n            }\\n            m[x]++;\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long op1 = cal(pattern[0] + text , pattern);\\n        long long op2 = cal(text + pattern[1] , pattern);\\n        return max(op1,op2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864632,
                "title": "python-o-n-with-clear-explanation",
                "content": "**The things we need to observe at the start:**\\n\\n* Only way to maximise the number of subsequence is to either add `pattern[0]` at the start of the given string or to add `pattern[1]` at end of the given string. \\n* If we can calculate the number of subsequence in the given string, we can easily calculate the final ans. It would be `ans = num_of_subsequence + max(count(pattern[0]), count(pattern[1]))`. If you wonder why we are adding the count of two character, it is indeed what we discussed in the first point. Either adding pattern[0] at the start or pattern[1] at the end. \\n\\n**How to calculate the number_of_subsequence?**\\n\\nWe iterate through every character  in the given string and keep track of `count(pattern[0])` and` count(pattern[1])`, Whenever we encounter` pattern[1]`, we know that the `count(pattern[0])` before that character is` number_of_subsequence` possible, so we add that to the total.\\n\\n**Example:** text = \"aabb\", pattern = \"ab\"\\n\\n**a**abb -> count_a = 1, count_b = 0, total = 0\\na**a**bb -> count_a = 2, count_b = 0, total = 0\\naa**b**b -> count_a = 2, count_b = 1, total = 2\\naab**b** -> count_a = 2, count_b = 2, total = 4\\n\\n**Talking is cheap:**\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        total = count_a = count_b = 0\\n        for c in text:\\n            if c == pattern[1]:\\n                total += count_a\\n                count_b += 1\\n            if c == pattern[0]:\\n                count_a += 1\\n        \\n        return total + max(count_a, count_b)\\n```\\n**Note:** \\n\\tWe must handle` c == pattern[1]` before` c == pattern[0]`, to overcome cases where `pattern[0] == pattern[1]`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        total = count_a = count_b = 0\\n        for c in text:\\n            if c == pattern[1]:\\n                total += count_a\\n                count_b += 1\\n            if c == pattern[0]:\\n                count_a += 1\\n        \\n        return total + max(count_a, count_b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863877,
                "title": "c-easy-add-first-to-first-or-last-to-last",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        long long findAns(string s, string pattern)\\n        {\\n            long long int secondChar = 0;\\n            int n = s.size();\\n            long long int total = 0;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                int flag = 0;\\n                if (s[i] == pattern[1])\\n                {\\n                    flag = 1;\\n                    secondChar++;\\n                }\\n                if (s[i] == pattern[0])\\n                {\\n                    total += secondChar;\\n                }\\n               \\t// for the case like hh\\n                if (flag and pattern[0] == pattern[1])\\n                    total--;\\n            }\\n            return total;\\n        }\\n    long long maximumSubsequenceCount(string text, string pattern)\\n    {\\n       \\t//         add first char to start                         add last char to last\\n        return max(findAns(pattern[0] + text, pattern), findAns(text + pattern[1], pattern));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long findAns(string s, string pattern)\\n        {\\n            long long int secondChar = 0;\\n            int n = s.size();\\n            long long int total = 0;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                int flag = 0;\\n                if (s[i] == pattern[1])\\n                {\\n                    flag = 1;\\n                    secondChar++;\\n                }\\n                if (s[i] == pattern[0])\\n                {\\n                    total += secondChar;\\n                }\\n               \\t// for the case like hh\\n                if (flag and pattern[0] == pattern[1])\\n                    total--;\\n            }\\n            return total;\\n        }\\n    long long maximumSubsequenceCount(string text, string pattern)\\n    {\\n       \\t//         add first char to start                         add last char to last\\n        return max(findAns(pattern[0] + text, pattern), findAns(text + pattern[1], pattern));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864433,
                "title": "o-n-easy-solutions-explained-two-pointers-c",
                "content": "## Maximize Number of Subsequences in a String\\n\\nIf have 2 cases\\n1.  **When pattern[0]==pattern[1]**\\n\\t* we can calculate the number of occurances of pattern[0] in text which we can say `occ`\\n\\t*  our already existing subquence will be `occ*(occ-1)/2`  [sum of n numbers were n=occ-1]\\n\\t* we can add one pattern[0] to existing text to now the answer will be `(occ+1)*occ/2`\\n2. **When pattern[0]!=pattern[1]**\\n\\t* we can take to pointer `first`  which keeps track of occurences of pattern[0] and `second` which keeps track of occurences of pattern[1]\\n\\t* when ever we find `text[i] == pattern[1]` we can add no of new subsquence found i.e. `occ+=first`\\n\\t* for e.g. text=\"abdcadabc\" and pattern=\"ac\"\\n\\t\\t* initialy first=0, second=0, and occ=0\\n\\t\\t* at i=0 first=1 and second=0\\n\\t\\t* at i=3 first=1 and second=1 and so we found 1 subsequence occ=1\\n\\t\\t* at i=4 first=2 and at i=6 first=3\\n\\t\\t* at i=8 first=3 and second=2 so we found 3 new subsequences occ+=first = occ+=3 occ=4\\n\\t* now we are suppoed to add one among pattern[0] and pattern[1] we will **choose the one with least occurance**\\n\\t* for eg first=3 and second=2\\n\\t\\t* if we add pattern[0], occ+=second occ+=2, occ=6\\n\\t\\t* if we add pattern[1], occ+=first, occ+=3, occ=7\\n\\n\\n### C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string p) {\\n        \\n        int n=text.length();\\n        if(p[0]==p[1])\\n        {\\n            long long ans=0;\\n            for(int i=0; i<n; i++)\\n                if(text[i]==p[0])\\n                    ans++;\\n            \\n            return ans*(ans+1)/2;\\n                \\n        }\\n        \\n        int f=0,s=0;\\n        long long ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(text[i]==p[0])\\n                f++;\\n            if(text[i]==p[1])\\n            {\\n                s++;\\n                ans+=f;\\n            }       \\n        }\\n        \\n        return max(ans+f, ans+s);\\n    }\\n};\\n```\\n\\nIf it helped do upvote :)\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string p) {\\n        \\n        int n=text.length();\\n        if(p[0]==p[1])\\n        {\\n            long long ans=0;\\n            for(int i=0; i<n; i++)\\n                if(text[i]==p[0])\\n                    ans++;\\n            \\n            return ans*(ans+1)/2;\\n                \\n        }\\n        \\n        int f=0,s=0;\\n        long long ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(text[i]==p[0])\\n                f++;\\n            if(text[i]==p[1])\\n            {\\n                s++;\\n                ans+=f;\\n            }       \\n        }\\n        \\n        return max(ans+f, ans+s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864950,
                "title": "why-first-or-last-intuition-easy-to-understand-java",
                "content": "**Intuition:**\\n\\nFirst thing we can observe is that our choices are limited-\\n- we can add **only 1 character** to   given string.\\n- we only have **2 characters** from which we can choose.\\n-  subsequence to form is of **length 2.**\\n\\nNow, the only thing that is not limited is that we can place a character before or after any character of given string.\\nbut, if we give it a thought, we can maximize subsequences by placing the character either at the **start of string or end of the string.**\\n\\n**Why placing the character at start or at the end of the string will maximize subsequences?**\\nLet\\'s say `p0` and `p1` are characters at `index 0` and `index 1` respectively in `pattern`.\\n\\n***Observation** - character `p0` should be before character `p1` to form subsequence in string  and vice versa.*\\n\\nTherefore, to maximize subsequence we have two choices-\\n\\n**choice 1:** pick character `p0` and place it before all the occurences of `p1` so that `p0` can pair with every `p1` \\n**choice 2:** pick character `p1` and place it after all the occurences of `p0` so that `p1` can pair with every `p0` \\n\\nWe can satisfy *choice 1* by placing `p0` at the start of the string thus making it before every character of string including `p1`.\\nSimilarly, by placing `p1` at the end of string ensures *choice 2* as it is after every character of string including `p0`.\\n\\nNow, our result would be the `max(choice1, choice2)`.\\n\\n**Code:**\\n\\n```java\\nclass Solution {\\n    public long maximumSubsequenceCount(String s, String p) {\\n        \\n        // choice1: place p0 at the start\\n        long choice1 = 0;\\n        int countOfP0 = 1;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            // if p1 found, it can be paired with all the p0\\'s found till now\\n            if (s.charAt(i) == p.charAt(1)) choice1 += countOfP0;\\n            if (s.charAt(i) == p.charAt(0)) countOfP0++;\\n        }\\n        \\n        // choice2: place p1 at the end\\n        long choice2 = 0;\\n        int countOfP1 = 1;\\n        for (int i = s.length() - 1; i >= 0; i--) \\n        {\\n            // if p0 found, it can be paired with all the p1\\'s found till now \\n            if (s.charAt(i) == p.charAt(0)) choice2 += countOfP1;\\n            if (s.charAt(i) == p.charAt(1)) countOfP1++;\\n        }\\n        \\n        return Math.max(choice1, choice2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public long maximumSubsequenceCount(String s, String p) {\\n        \\n        // choice1: place p0 at the start\\n        long choice1 = 0;\\n        int countOfP0 = 1;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            // if p1 found, it can be paired with all the p0\\'s found till now\\n            if (s.charAt(i) == p.charAt(1)) choice1 += countOfP0;\\n            if (s.charAt(i) == p.charAt(0)) countOfP0++;\\n        }\\n        \\n        // choice2: place p1 at the end\\n        long choice2 = 0;\\n        int countOfP1 = 1;\\n        for (int i = s.length() - 1; i >= 0; i--) \\n        {\\n            // if p0 found, it can be paired with all the p1\\'s found till now \\n            if (s.charAt(i) == p.charAt(0)) choice2 += countOfP1;\\n            if (s.charAt(i) == p.charAt(1)) countOfP1++;\\n        }\\n        \\n        return Math.max(choice1, choice2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863993,
                "title": "c-simple-o-n-with-steps",
                "content": "\\n1.calculate ans in two ways\\n2.first put patter[0] in the beginning of the text and then calculate the answer.\\n3.second put pattern[1] in the end of the text and calculate the total pattern.\\n4.Return the maximum ans between both of them.\\n5.\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        long long ans1=0,ans2=0;\\n\\n        \\n//         loop for calculate the answer if pattern[0] is in the begingging\\n        int m=1;\\n        for(int i=0;i<text.size();i++){\\n             if(pat[1]==text[i]){\\n                long long tp=m*1;\\n                ans1+=tp;\\n            }\\n            if(pat[0]==text[i]){\\n                m++;\\n            }\\n        }\\n//         loof for calculate teh answer if pattern[1] if in the end\\n        int p=1;\\n        for(int i=text.size()-1;i>=0;i--){\\n             if(pat[0]==text[i]){\\n                long long tp=p*1;\\n                ans2+=tp;\\n            }\\n            if(pat[1]==text[i]){\\n                p++;\\n            }\\n        }\\n        return max(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        long long ans1=0,ans2=0;\\n\\n        \\n//         loop for calculate the answer if pattern[0] is in the begingging\\n        int m=1;\\n        for(int i=0;i<text.size();i++){\\n             if(pat[1]==text[i]){\\n                long long tp=m*1;\\n                ans1+=tp;\\n            }\\n            if(pat[0]==text[i]){\\n                m++;\\n            }\\n        }\\n//         loof for calculate teh answer if pattern[1] if in the end\\n        int p=1;\\n        for(int i=text.size()-1;i>=0;i--){\\n             if(pat[0]==text[i]){\\n                long long tp=p*1;\\n                ans2+=tp;\\n            }\\n            if(pat[1]==text[i]){\\n                p++;\\n            }\\n        }\\n        return max(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863963,
                "title": "c-prefix-sum-and-suffix-sum-o-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Prefix Sum and Suffix Sum\\n\\nStep 1: count the number of subsequences in `s` without insertion as `sum`.\\n\\nStep 2: At each index `i`, let `a` be the count of `p[0]` in prefix, and `b` be the count of `p[1]` in the suffix. \\n\\nIf we append `p[0]`, we get `sum + b` subsequences. IF we append `p[1]`, we get `sum + a` subsequences.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string s, string p) {\\n        long a = 0, b = 0, sum = 0;\\n        for (char c : s) b += c == p[1];\\n        long tmp = b;\\n        for (char c : s) {\\n            tmp -= c == p[1]; \\n            if (c == p[0]) sum += tmp;\\n        }\\n        long ans = b;\\n        for (char c : s) {\\n            a += c == p[0];\\n            b -= c == p[1];\\n            ans = max({ ans, b, a });\\n        }\\n        return sum + ans;\\n    }\\n};\\n```\\n\\nIn fact, we can see that, we just need the global maximum of all `a` and `b` values. This leads to solution 2.\\n\\n\\n## Solution 2. Prefix Sum and Suffix Sum\\n\\nIf we add `p[0]`, the best option is to prepend it at the beginning.\\n\\nIf we add `p[1]`, the best option is to append it at the end.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string s, string p) {\\n        long a = 0, b = 0, sum = 0;\\n        for (char c : s) {\\n            if (c == p[1]) sum += a;\\n            a += c == p[0];\\n            b += c == p[1];\\n        }\\n        return sum + max(a, b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string s, string p) {\\n        long a = 0, b = 0, sum = 0;\\n        for (char c : s) b += c == p[1];\\n        long tmp = b;\\n        for (char c : s) {\\n            tmp -= c == p[1]; \\n            if (c == p[0]) sum += tmp;\\n        }\\n        long ans = b;\\n        for (char c : s) {\\n            a += c == p[0];\\n            b -= c == p[1];\\n            ans = max({ ans, b, a });\\n        }\\n        return sum + ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string s, string p) {\\n        long a = 0, b = 0, sum = 0;\\n        for (char c : s) {\\n            if (c == p[1]) sum += a;\\n            a += c == p[0];\\n            b += c == p[1];\\n        }\\n        return sum + max(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881973,
                "title": "o-n-cpp-short-solution-easy-to-understand",
                "content": "The solve function calculates the total no of subsequence in the given text string. We do this by traversing from end of the string and calculating the no of subseqence in each step all while keeping count of the pattern[0] & pattern[1].\\n\\nNow, the no of subsequence will be maximum if pattern[0] is added to the start of the text string or pattern[1] is added to the end of the text string.\\nLastly, we return the maximum of the three answer as our final answer.\\n\\n**NOTE:**  We compare every character with both pattern[0] and pattern[1] so we do not have to  handle the case where both characters of pattern are same\\n```\\nclass Solution {\\npublic:\\n    long long solve(string &t, string &p, long long &p0, long long &p1) {\\n        long long ans = 0;\\n        for (int i = t.length() - 1; i >= 0; i--) {\\n            t[i] == p[0] ? (ans += p1, p0++ ) : 1;\\n            t[i] == p[1] ? p1++ : 1;\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long p0 = 0, p1 = 0 , res = solve(text, pattern, p0, p1), ans1 = res + p1, ans2 = res + p0;\\n        return max(max(res, ans1), ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(string &t, string &p, long long &p0, long long &p1) {\\n        long long ans = 0;\\n        for (int i = t.length() - 1; i >= 0; i--) {\\n            t[i] == p[0] ? (ans += p1, p0++ ) : 1;\\n            t[i] == p[1] ? p1++ : 1;\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long p0 = 0, p1 = 0 , res = solve(text, pattern, p0, p1), ans1 = res + p1, ans2 = res + p0;\\n        return max(max(res, ans1), ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863929,
                "title": "add-pattern-0-to-start-or-add-pattern-1-to-end-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fun(string t,string p)\\n    {\\n        long long prefix[t.size()];\\n        long long count=0,res=0;\\n        for(int i=t.size()-1;i>=0;i--)\\n        {\\n            prefix[i]=count;\\n            if(t[i]==p[1]) count++;\\n        }\\n        \\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==p[0])\\n            {\\n                res+=prefix[i];\\n            }\\n        }\\n        return res;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        return max(fun(pattern[0]+text,pattern),fun(text+pattern[1],pattern));\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fun(string t,string p)\\n    {\\n        long long prefix[t.size()];\\n        long long count=0,res=0;\\n        for(int i=t.size()-1;i>=0;i--)\\n        {\\n            prefix[i]=count;\\n            if(t[i]==p[1]) count++;\\n        }\\n        \\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==p[0])\\n            {\\n                res+=prefix[i];\\n            }\\n        }\\n        return res;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        return max(fun(pattern[0]+text,pattern),fun(text+pattern[1],pattern));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864317,
                "title": "c-easy-solution-add-at-last-or-first",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        vector<long long> count;\\n        long long a=0,b=0;\\n        for(char c: t){\\n            if(c==p[0]){\\n                a++;\\n            }else if(c==p[1]){\\n                count.push_back(a);\\n            }\\n        }\\n    \\n        if(p[0]==p[1]){\\n            long long ans=0;\\n            while(a>0){\\n                ans+=a;\\n                a--;\\n            }\\n            return ans;\\n        }\\n        long long ans1,ans2=0;\\n        for(long long val : count){\\n            ans1+=val;\\n        }\\n\\t        ans1=sum+a;\\n\\n\\tfor(int i=0;i<(int)count.size();i++){\\n            count[i]+=1;\\n            ans2+=count[i];\\n        }       \\n       \\n        return max(ans1,ans2);\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        vector<long long> count;\\n        long long a=0,b=0;\\n        for(char c: t){\\n            if(c==p[0]){\\n                a++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1864065,
                "title": "java-easy",
                "content": "pattern.length == 2, say pattern = ab\\n\\nLet\\'s say we have this string s xxxx, (x can be any character)\\nWe got two chars a, b from pattern that we have to insert in string..\\n\\t1) say, we want to add pattern[0] to string s, we should always add pattern[0] at front of s because it can be first char of all possible pattern subsequence in string s, final string - axxxx.\\n\\t2) similarly, we should add b to end of string, final string - xxxxb.\\n\\t\\nSo we have only two choices, why don;t we go for each of them and check what gives asked result.\\n\\t\\nNow, I have covered this case saperatly : pattern[0] == pattern[1]\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        //when pattern[0] == pattern[1]\\n        if (pattern.charAt(0) == pattern.charAt(1)) {\\n            long freq = 1;\\n\\t\\t\\t//O(N)\\n            for (int i = 0; i < text.length(); i++) {\\n                if (text.charAt(i) == pattern.charAt(0)) {\\n                    freq++;\\n                }\\n            }\\n            //number of subsequences : choose any two characters from freq nC2\\n            return (freq * (freq - 1)) / 2;\\n        }\\n        \\n        //choice 1\\n        String text1 = pattern.charAt(0) + text;\\n        \\n        int freq = 0;\\n        long count1 = 0;\\n\\t\\t//O(N)\\n        for (int i = 0; i < text1.length(); i++) {\\n            if (text1.charAt(i) == pattern.charAt(0)) {\\n                freq++;\\n            } else if (text1.charAt(i) == pattern.charAt(1)) {\\n                count1 += freq;\\n            }\\n        }\\n        \\n        //choice 2\\n        String text2 = text + pattern.charAt(1);\\n        freq = 0;\\n        long count2 = 0;\\n\\t\\t//O(N)\\n        for (int i = text2.length() - 1; i>= 0; i--) {\\n            if (text2.charAt(i) == pattern.charAt(1)) {\\n                freq++;\\n            } else if (text2.charAt(i) == pattern.charAt(0)) {\\n                count2 += freq;\\n            }\\n        }\\n        \\n        return Math.max(count1, count2); \\n    }\\n}\\n```\\n\\nTC - O(N)\\nSC - O(1)\\n\\nFeel free to upvote :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        //when pattern[0] == pattern[1]\\n        if (pattern.charAt(0) == pattern.charAt(1)) {\\n            long freq = 1;\\n\\t\\t\\t//O(N)\\n            for (int i = 0; i < text.length(); i++) {\\n                if (text.charAt(i) == pattern.charAt(0)) {\\n                    freq++;\\n                }\\n            }\\n            //number of subsequences : choose any two characters from freq nC2\\n            return (freq * (freq - 1)) / 2;\\n        }\\n        \\n        //choice 1\\n        String text1 = pattern.charAt(0) + text;\\n        \\n        int freq = 0;\\n        long count1 = 0;\\n\\t\\t//O(N)\\n        for (int i = 0; i < text1.length(); i++) {\\n            if (text1.charAt(i) == pattern.charAt(0)) {\\n                freq++;\\n            } else if (text1.charAt(i) == pattern.charAt(1)) {\\n                count1 += freq;\\n            }\\n        }\\n        \\n        //choice 2\\n        String text2 = text + pattern.charAt(1);\\n        freq = 0;\\n        long count2 = 0;\\n\\t\\t//O(N)\\n        for (int i = text2.length() - 1; i>= 0; i--) {\\n            if (text2.charAt(i) == pattern.charAt(1)) {\\n                freq++;\\n            } else if (text2.charAt(i) == pattern.charAt(0)) {\\n                count2 += freq;\\n            }\\n        }\\n        \\n        return Math.max(count1, count2); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863990,
                "title": "simple-c-soltuion",
                "content": "\\n\\t \\n\\t \\n\\t int n=t.size();\\n        char f=p[0];\\n        char s=p[1];\\n        int ff=0;\\n        int sf=0;\\n        long long a=0;\\n        long long b=0;\\n        for(char it:t){\\n            if(it==f)ff++;\\n             if(it==s)b+=ff;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(t[i]==s){\\n                sf++;\\n            }\\n            else if(t[i]==f){\\n                a+=sf;\\n            }\\n        }\\n        a+=sf;\\n        b+=ff;\\n        if(f==s)return b-a;\\n        return max(a,b);",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\t \\n\\t \\n\\t int n=t.size();\\n        char f=p[0];\\n        char s=p[1];\\n        int ff=0;\\n        int sf=0;\\n        long long a=0;\\n        long long b=0;\\n        for(char it:t){\\n            if(it==f)ff++;\\n             if(it==s)b+=ff;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(t[i]==s){\\n                sf++;\\n            }\\n            else if(t[i]==f){\\n                a+=sf;\\n            }\\n        }\\n        a+=sf;\\n        b+=ff;\\n        if(f==s)return b-a;\\n        return max(a,b);",
                "codeTag": "Unknown"
            },
            {
                "id": 3093874,
                "title": "javascript-o-n-time-easy-to-understand-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are just two options to make the biggest sum: add pattern\\'s first element in the bigining or add second one at the end of the text;\\nIf pattern\\'s elements are equal then use formul for number of combinations\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @param {string} pattern\\n * @return {number}\\n */\\nvar maximumSubsequenceCount = function(text, pattern) {\\n    let fc = 0;\\n    let sc = 0;\\n\\n    let res = 0;\\n\\n    for (let el of text) {\\n        if (el === pattern[0]) fc++;\\n        else if (el === pattern[1]) {\\n            sc++;\\n            res += fc;\\n        }\\n    }\\n\\n    if (pattern[0] === pattern[1]) return fc * (fc + 1) / 2;\\n    \\n    return res + Math.max(fc, sc);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} pattern\\n * @return {number}\\n */\\nvar maximumSubsequenceCount = function(text, pattern) {\\n    let fc = 0;\\n    let sc = 0;\\n\\n    let res = 0;\\n\\n    for (let el of text) {\\n        if (el === pattern[0]) fc++;\\n        else if (el === pattern[1]) {\\n            sc++;\\n            res += fc;\\n        }\\n    }\\n\\n    if (pattern[0] === pattern[1]) return fc * (fc + 1) / 2;\\n    \\n    return res + Math.max(fc, sc);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909880,
                "title": "c-simple-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n    \\n    Idea:\\n    1st question to answer is where is the optimal pos for either of pattern chars.\\n    The ans is either at front or back, this is because, when a subseq is matched it goes from\\n    left to right of chars in pattern. Lets say we are talking for pattern[0], if it is put at\\n    pos \\'i\\' in text, then if there are any instances of pattern[1] before \\'i\\', those will be missed.\\n    So pattern[0] needs to be placed at front so that all the instances of pattern[1] are after it.\\n    Same logic for placement of pattern[1] at back.\\n    \\n    Once that is done, it\\'s easy. Either we can actually make two such strings and then use the DP subsequence\\n    logic to find which new string has more sub seqs. \\n        But since this pattern has only 2 chars, we can do better. We track the no. of instances of pattern[0]\\n    and whenever an instance of pattern[1] is found, we can combine that with the number of pattern[0] instances \\n    found so far in the str. This way we can find the number of subseqs.\\n    Also we track counts of patter[0] and pattern[1] resp. Since we can add 1 instance of either of those, so \\n    we check which instance has the highest count currently and then combine the other char of subseq so that we get more no.\\n    of subsequences.\\n*/\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        // Keeps track of count of patt[0] and patt[1] resp.\\n        long n_patt0 = 0, n_patt1 = 0;\\n        long sub_sequences = 0;\\n        // Find all the subsequences that exist without the addition of \\n        // any chars of pattern\\n        for(int i = 0; i < text.size(); i++) {\\n            // if the second char is found, all the instances of 1st char\\n            // can create a subseq with this char\\n            if(text[i] == pattern[1]) {\\n                sub_sequences += n_patt0;\\n                ++n_patt1;\\n            }\\n            if(text[i] == pattern[0])\\n                ++n_patt0;\\n        }\\n        // Since we can add either patt[0] or patt[1], so whichever\\n        // has the highest existing count in the str can be combined with the\\n        // other needed char of subseq from pattern\\n        return sub_sequences + max(n_patt0, n_patt1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n    \\n    Idea:\\n    1st question to answer is where is the optimal pos for either of pattern chars.\\n    The ans is either at front or back, this is because, when a subseq is matched it goes from\\n    left to right of chars in pattern. Lets say we are talking for pattern[0], if it is put at\\n    pos \\'i\\' in text, then if there are any instances of pattern[1] before \\'i\\', those will be missed.\\n    So pattern[0] needs to be placed at front so that all the instances of pattern[1] are after it.\\n    Same logic for placement of pattern[1] at back.\\n    \\n    Once that is done, it\\'s easy. Either we can actually make two such strings and then use the DP subsequence\\n    logic to find which new string has more sub seqs. \\n        But since this pattern has only 2 chars, we can do better. We track the no. of instances of pattern[0]\\n    and whenever an instance of pattern[1] is found, we can combine that with the number of pattern[0] instances \\n    found so far in the str. This way we can find the number of subseqs.\\n    Also we track counts of patter[0] and pattern[1] resp. Since we can add 1 instance of either of those, so \\n    we check which instance has the highest count currently and then combine the other char of subseq so that we get more no.\\n    of subsequences.\\n*/\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        // Keeps track of count of patt[0] and patt[1] resp.\\n        long n_patt0 = 0, n_patt1 = 0;\\n        long sub_sequences = 0;\\n        // Find all the subsequences that exist without the addition of \\n        // any chars of pattern\\n        for(int i = 0; i < text.size(); i++) {\\n            // if the second char is found, all the instances of 1st char\\n            // can create a subseq with this char\\n            if(text[i] == pattern[1]) {\\n                sub_sequences += n_patt0;\\n                ++n_patt1;\\n            }\\n            if(text[i] == pattern[0])\\n                ++n_patt0;\\n        }\\n        // Since we can add either patt[0] or patt[1], so whichever\\n        // has the highest existing count in the str can be combined with the\\n        // other needed char of subseq from pattern\\n        return sub_sequences + max(n_patt0, n_patt1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867068,
                "title": "c-linear-frequency-counting-fully-explained-100-time-7ms-40-space-16-6mb",
                "content": "This problem is probably scarier than it looks, with a description that IMHO partially conceals is more simple core logic.\\n\\nLet\\'s assume we have a string `text` like `\"acdXcdaXYYabXbYaX\"` and `\"XY\"` as a pattern (I know we will only get lowercase characters, but I put the one matching the pattern as uppercase for ease of reading). This pattern has `4` `\\'X\\'`s and `3` `\\'Y\\'`s.\\n\\nWithout considering adding one extra character, we can quickly see that:\\n* the first `\\'X\\'` is followed by `3` `\\'Y\\'`s, so we add `3` to our result;\\n* same for the second `\\'X\\'`, still followed by `3` `\\'Y\\'`s, so we add `3` to our result;\\n* the third `\\'X\\'` is followed by only `1` `\\'Y\\'`, so we add `1` to our result;\\n* the fourth `\\'X\\'` is followed by `0` `\\'Y\\'`s, so we add `0` to our result.\\n\\nSo, all in all, we would get `7` valid subsequences here, but there is a catch: we can add a single extra character! This character should always be added as the least frequent character of the `pattern` string, since that way we will unlock the higher amount of matches (since the frequency of the other character is bigger).\\n\\nWe might be tempted to thus count the frequencies and then add a character in the beginning or the end of the string (depending on which one was less frequent), but that would be rather expensive and wasteful, particularly the addition on the beginning.\\n\\nOnce we know the frequencies, we can just add to result the value of the bigger one and be done with this bit of the logic.\\n\\nThe last tricky part is to figure out what to do when both characters in `pattern` are the same: in which case we will only take the frequency of one, multiply it by its value increased it by `1` (adding one extra character as we can done) and divide it by `2`, since we need to remember we can use each character only once to match either the first or the second element in a pattern.\\n\\nFor example, if `text` is `\"aaaa\"` and your pattern is `\"aa\"`, we will have `4 * 5 / 2 = 10` possible substrings:\\n* let\\'s add one extra character either at the beginning or the end (or even in the middle - in this case it would not really matter!) and turn `text` into `\"aaaaa\"`;\\n* now we have `4` possible substrings from the first `\\'a\\'`;\\n* then we have `3` possible substrings from the second `\\'a\\'`;\\n* moving on we have `2` possible substrings from the third `\\'a\\'`;\\n* finally we have `1` possible substrings from the fourth and penultimate `\\'a\\'`  - `10` in total \\uD83C\\uDFC6, it works !\\n\\nWith that in mind, let\\'s try to turn our ideas into code, starting with a few support variables:\\n* `len` will store the size of `text`;\\n* `res` will be our accumulator variable, initially set to `0`;\\n* `aCount` and `bCount` are going to be our counter variable for the frequency of the first and second character in `pattern`, both set to `0` initially (and notice I decided to declare them into `long long` from the beginning, to avoid annoying implicit conversions as we go);\\n* `a` and `b` are the values of the first and second character in `pattern`, respectively.\\n\\nWe will then go to compute the frequency of `a` and `b`, looping through each character `c` in `text` and increasing the matching counter variable accordingly.\\n\\nNow, time for the first edge case: if `a == b`, then we will have increased only `aCount` with our logic and, as explained above, we can safely get a valid result without any further ado, just `return`ing `aCount++ * aCount / 2`.\\n\\nAlternatively, we will have to check which frequency is smaller:\\n* if `aCount` is smaller, we can just increase `res` by `bCount` (ie: we virtually added `a` to the beginning of `text`);\\n* otherwise, we increase `bCount` (virtually appending `b` at the end of `text`).\\n\\nNow the trickier bit of the logic - we will loop again through each character `c` in `text` and then we will encounter three possible cases:\\n* `c == a`, so we know this is a valid start of a subsequence and increase `res` by `bCount`;\\n* `c == b`, so we know that from now on we will have one less `b` in front of us, thus we decrease `bCount` by `1`;\\n* all the other cases, we have nothing to do :)\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        // support variables\\n        int len = text.size();\\n        long long res = 0, aCount = 0, bCount = 0;\\n        char a = pattern[0], b = pattern[1];\\n        // getting the frequencies\\n        for (char c: text)  {\\n            if (c == a) aCount++;\\n            else if (c == b) bCount++;\\n        }\\n        // edge case: a == b\\n        if (a == b) return aCount++ * aCount / 2;\\n        // adding our extra character to maximise the occurrences\\n        if (aCount < bCount) res += bCount;\\n        else bCount++;\\n        // computing the occurrences\\n        for (char c: text)  {\\n            // first case: spotting the first element of a sequence\\n            if (c == a) {\\n                res += bCount;\\n            }\\n            // second case: we found an ending sequence\\n            else if (c == b) bCount--;\\n            // all the rest: we do nothing\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        // support variables\\n        int len = text.size();\\n        long long res = 0, aCount = 0, bCount = 0;\\n        char a = pattern[0], b = pattern[1];\\n        // getting the frequencies\\n        for (char c: text)  {\\n            if (c == a) aCount++;\\n            else if (c == b) bCount++;\\n        }\\n        // edge case: a == b\\n        if (a == b) return aCount++ * aCount / 2;\\n        // adding our extra character to maximise the occurrences\\n        if (aCount < bCount) res += bCount;\\n        else bCount++;\\n        // computing the occurrences\\n        for (char c: text)  {\\n            // first case: spotting the first element of a sequence\\n            if (c == a) {\\n                res += bCount;\\n            }\\n            // second case: we found an ending sequence\\n            else if (c == b) bCount--;\\n            // all the rest: we do nothing\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864375,
                "title": "c-easy-tabulation-add-pattern-0-to-start-or-add-pattern-1-to-end",
                "content": "**Approach**\\nSimply Add Pattern[0] to the start or Pattern[1] to the end . \\nNow the solution boils down to simply **count number of times a string occurs as a subsequence in given string**, then return max of both result\\n\\n**Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    long long count(string a, string b)\\n{\\n    int m = a.length();\\n    int n = b.length();\\n \\n   vector<vector<long long>> lookup (m+1,vector<long long>(n+1,0));\\n   \\n   // If only first string is empty and second\\n    // string is not empty, return 0\\n   for (int i = 0; i <= n; ++i)\\n        lookup[0][i] = 0;\\n \\n    // If both first and second string is empty,\\n    // or if second string is empty, return 1\\n    for (int i = 0; i <= m; ++i)\\n        lookup[i][0] = 1;\\n \\n   for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n             // If last characters are same\\n            if (a[i - 1] == b[j - 1])\\n                lookup[i][j] = lookup[i - 1][j - 1] +\\n                               lookup[i - 1][j];\\n                 \\n            else\\n\\t\\t\\t// If last characters are different, ignore\\n            // last char of first string \\n\\t\\t\\t lookup[i][j] = lookup[i - 1][j];\\n        }\\n    }\\n  \\n    return lookup[m][n];\\n}\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n    \\n        \\n        return max(count(pattern[0]+text,pattern),count(text+pattern[1],pattern));\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long count(string a, string b)\\n{\\n    int m = a.length();\\n    int n = b.length();\\n \\n   vector<vector<long long>> lookup (m+1,vector<long long>(n+1,0));\\n   \\n   // If only first string is empty and second\\n    // string is not empty, return 0\\n   for (int i = 0; i <= n; ++i)\\n        lookup[0][i] = 0;\\n \\n    // If both first and second string is empty,\\n    // or if second string is empty, return 1\\n    for (int i = 0; i <= m; ++i)\\n        lookup[i][0] = 1;\\n \\n   for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n             // If last characters are same\\n            if (a[i - 1] == b[j - 1])\\n                lookup[i][j] = lookup[i - 1][j - 1] +\\n                               lookup[i - 1][j];\\n                 \\n            else\\n\\t\\t\\t// If last characters are different, ignore\\n            // last char of first string \\n\\t\\t\\t lookup[i][j] = lookup[i - 1][j];\\n        }\\n    }\\n  \\n    return lookup[m][n];\\n}\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n    \\n        \\n        return max(count(pattern[0]+text,pattern),count(text+pattern[1],pattern));\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864237,
                "title": "modify-at-front-and-back-of-text-c-clean-code",
                "content": "# Code : \\n```\\nclass Solution {\\nprivate:\\n    long long getSubseqencesCount(string a, string b) {\\n        int n = a.size();\\n        \\n        vector<long long> count(n+1, 0LL);\\n        long long subseqCount = 0;\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            count[i] += count[i+1] + (long long)(a[i] == b[1]);\\n        }\\n        \\n        for(int i=0; i<n-1; i++) {\\n            if(a[i] == b[0]) \\n                subseqCount += count[i];\\n        }\\n        \\n        return subseqCount;\\n    }\\n    \\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        if(pattern[0] == pattern[1]) {\\n            long long subseqCount = 0LL;\\n            for(auto& letter : text) if(letter == pattern[0]) subseqCount++;\\n            return subseqCount * (subseqCount - 1) / 2 + subseqCount;\\n        }\\n        \\n        string modified_front = pattern[0] + text;\\n        string modified_back = text + pattern[1];        \\n        \\n        return max({\\n            getSubseqencesCount(modified_front, pattern),  \\n            getSubseqencesCount(modified_back, pattern)\\n        });\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N)`\\n* Space : `O(N)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long getSubseqencesCount(string a, string b) {\\n        int n = a.size();\\n        \\n        vector<long long> count(n+1, 0LL);\\n        long long subseqCount = 0;\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            count[i] += count[i+1] + (long long)(a[i] == b[1]);\\n        }\\n        \\n        for(int i=0; i<n-1; i++) {\\n            if(a[i] == b[0]) \\n                subseqCount += count[i];\\n        }\\n        \\n        return subseqCount;\\n    }\\n    \\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        if(pattern[0] == pattern[1]) {\\n            long long subseqCount = 0LL;\\n            for(auto& letter : text) if(letter == pattern[0]) subseqCount++;\\n            return subseqCount * (subseqCount - 1) / 2 + subseqCount;\\n        }\\n        \\n        string modified_front = pattern[0] + text;\\n        string modified_back = text + pattern[1];        \\n        \\n        return max({\\n            getSubseqencesCount(modified_front, pattern),  \\n            getSubseqencesCount(modified_back, pattern)\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863895,
                "title": "python-solution-o-n-simple-iteration",
                "content": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        c1 = text.count(pattern[0])\\n        c2 = text.count(pattern[1])\\n        c = max(c1,c2)\\n        prev = 0\\n        for i in range(len(text)):\\n            if text[i] == pattern[1]:\\n                c += prev\\n            if text[i] == pattern[0]:\\n                prev += 1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        c1 = text.count(pattern[0])\\n        c2 = text.count(pattern[1])\\n        c = max(c1,c2)\\n        prev = 0\\n        for i in range(len(text)):\\n            if text[i] == pattern[1]:\\n                c += prev\\n            if text[i] == pattern[0]:\\n                prev += 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863884,
                "title": "python3-o-n-time-space-with-observations",
                "content": "\\nObservations:\\n\\t1. Adding a new character will only be maximized at the corners (either pattern[0] before index 0, or either pattern[1] after index len(text))\\n\\t2. Every time you encounter pattern[0], you can generate as many as the number of pattern[1] that occur to the right of that index\\n\\n* a refers to pattern[0], b refers to pattern[1] \\n\\n\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        # keep track of count of b\\'s to the right\\n        \\n        b_count_right = [0] * len(text)\\n        a_count = 0\\n        \\n        for i in range(len(text)-1, -1, -1):\\n            if text[i] == pattern[0]:\\n                a_count += 1\\n            \\n            if i == len(text) - 1:\\n                if pattern[1] == text[i]:\\n                    b_count_right[i] = 1\\n            else:\\n                b_count_right[i] = b_count_right[i+1] + 1 if pattern[1] == text[i] else b_count_right[i+1]\\n        \\n        ans = 0\\n        max_diff = max(b_count_right[0], a_count)\\n        \\n        \\n        for i, ch in enumerate(text):\\n            if ch == pattern[0]:\\n                ans += b_count_right[i]\\n                if pattern[0] == pattern[1]:\\n                    ans -= 1\\n\\n        return ans + max_diff\\n\\n            \\n                    \\n",
                "solutionTags": [],
                "code": "\\nObservations:\\n\\t1. Adding a new character will only be maximized at the corners (either pattern[0] before index 0, or either pattern[1] after index len(text))\\n\\t2. Every time you encounter pattern[0], you can generate as many as the number of pattern[1] that occur to the right of that index\\n\\n* a refers to pattern[0], b refers to pattern[1] \\n\\n\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        # keep track of count of b\\'s to the right\\n        \\n        b_count_right = [0] * len(text)\\n        a_count = 0\\n        \\n        for i in range(len(text)-1, -1, -1):\\n            if text[i] == pattern[0]:\\n                a_count += 1\\n            \\n            if i == len(text) - 1:\\n                if pattern[1] == text[i]:\\n                    b_count_right[i] = 1\\n            else:\\n                b_count_right[i] = b_count_right[i+1] + 1 if pattern[1] == text[i] else b_count_right[i+1]\\n        \\n        ans = 0\\n        max_diff = max(b_count_right[0], a_count)\\n        \\n        \\n        for i, ch in enumerate(text):\\n            if ch == pattern[0]:\\n                ans += b_count_right[i]\\n                if pattern[0] == pattern[1]:\\n                    ans -= 1\\n\\n        return ans + max_diff\\n\\n            \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 4050027,
                "title": "java-easy-100-solution",
                "content": "```java\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long result = 0, first = 0, second = 0;\\n\\n        for(int i = 0; i < text.length(); ++i) {\\n            if(text.charAt(i) == pattern.charAt(1)) {\\n                result += first;\\n                second++;\\n            }\\n            \\n            if(text.charAt(i) == pattern.charAt(0))\\n                first++;\\n        }\\n\\n        return result + Math.max(first, second);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long result = 0, first = 0, second = 0;\\n\\n        for(int i = 0; i < text.length(); ++i) {\\n            if(text.charAt(i) == pattern.charAt(1)) {\\n                result += first;\\n                second++;\\n            }\\n            \\n            if(text.charAt(i) == pattern.charAt(0))\\n                first++;\\n        }\\n\\n        return result + Math.max(first, second);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753528,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long a=0;\\n        long b=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text.charAt(i)==pattern.charAt(0))\\n                b++;\\n            if(text.charAt(i)==pattern.charAt(1))\\n                a++;\\n        }\\n        if(pattern.charAt(0)==pattern.charAt(1))\\n            return ((a+1)*a)/2;\\n        long ans=0;\\n        ans+=Math.max(a,b);\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text.charAt(i)==pattern.charAt(0))\\n                ans+=a;\\n            if(text.charAt(i)==pattern.charAt(1))\\n                a--;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long a=0;\\n        long b=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text.charAt(i)==pattern.charAt(0))\\n                b++;\\n            if(text.charAt(i)==pattern.charAt(1))\\n                a++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2558644,
                "title": "simple-java-solution",
                "content": "```\\npublic long maximumSubsequenceCount(String text, String pattern) {\\n        char first = pattern.charAt(0);\\n        char second = pattern.charAt(1);\\n        \\n        long countFirst = 0, countSecond = 0, result = 0;\\n        \\n        for(int i = 0; i < text.length(); i++) {\\n            char c = text.charAt(i);\\n            \\n            if(c == first) {\\n                countFirst++;\\n            } else if (c == second) {\\n                countSecond++;\\n                result += countFirst;\\n            }\\n        }\\n        \\n        result += Math.max(countFirst, countSecond);\\n        \\n        if(first == second) return ((countFirst + 1) * (countFirst) / 2);\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long maximumSubsequenceCount(String text, String pattern) {\\n        char first = pattern.charAt(0);\\n        char second = pattern.charAt(1);\\n        \\n        long countFirst = 0, countSecond = 0, result = 0;\\n        \\n        for(int i = 0; i < text.length(); i++) {\\n            char c = text.charAt(i);\\n            \\n            if(c == first) {\\n                countFirst++;\\n            } else if (c == second) {\\n                countSecond++;\\n                result += countFirst;\\n            }\\n        }\\n        \\n        result += Math.max(countFirst, countSecond);\\n        \\n        if(first == second) return ((countFirst + 1) * (countFirst) / 2);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2418852,
                "title": "c-o-n-solution-using-simple-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    long long check(string s,string pattern){\\n        int c=0;long long sum=0;\\n        for(auto i:s){\\n            if(i==pattern[0])c++;\\n            if(i==pattern[1])sum+=c;\\n        }\\n        return sum;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string temp;\\n        for(auto i:text){\\n            if(i==pattern[0] || i==pattern[1])temp+=i;\\n        }\\n        if(pattern[0]==pattern[1]){\\n            long long n=temp.size()+1;\\n            return n*(n-1)/2;\\n        }\\n        string t1=pattern[0]+temp;\\n        string t2=temp+pattern[1];\\n        return max(check(t1,pattern),check(t2,pattern));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long check(string s,string pattern){\\n        int c=0;long long sum=0;\\n        for(auto i:s){\\n            if(i==pattern[0])c++;\\n            if(i==pattern[1])sum+=c;\\n        }\\n        return sum;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string temp;\\n        for(auto i:text){\\n            if(i==pattern[0] || i==pattern[1])temp+=i;\\n        }\\n        if(pattern[0]==pattern[1]){\\n            long long n=temp.size()+1;\\n            return n*(n-1)/2;\\n        }\\n        string t1=pattern[0]+temp;\\n        string t2=temp+pattern[1];\\n        return max(check(t1,pattern),check(t2,pattern));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418834,
                "title": "c-simple-logic-dp-approach",
                "content": "Let me know if you have any doubt in the comment section.\\n```\\nclass Solution {\\npublic:\\n    long long f(int ind,int ind1,string s,string t,vector<vector<long long>>&dp){\\n         for(int i=0;i<=s.size();i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<=t.size();i++){\\n            dp[0][i]=0; \\n        }\\n        for(int i=1;i<=s.size();i++){\\n            for(int j=1;j<=t.size();j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; \\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j]; \\n                }\\n            }\\n        }\\n        return (long long) dp[s.size()][t.size()];\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string ans=pattern[0]+text; \\n        vector<vector<long long>>dp(ans.size()+1,vector<long long>(pattern.size()+1,0));\\n        vector<vector<long long>>dp1(ans.size()+1,vector<long long>(pattern.size()+1,0));\\n        //cout<<ans<<endl;\\n        string ans1=text+pattern[1];\\n        return (long long) max(f(0,0,ans,pattern,dp),f(0,0,ans1,pattern,dp1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(int ind,int ind1,string s,string t,vector<vector<long long>>&dp){\\n         for(int i=0;i<=s.size();i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<=t.size();i++){\\n            dp[0][i]=0; \\n        }\\n        for(int i=1;i<=s.size();i++){\\n            for(int j=1;j<=t.size();j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; \\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j]; \\n                }\\n            }\\n        }\\n        return (long long) dp[s.size()][t.size()];\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string ans=pattern[0]+text; \\n        vector<vector<long long>>dp(ans.size()+1,vector<long long>(pattern.size()+1,0));\\n        vector<vector<long long>>dp1(ans.size()+1,vector<long long>(pattern.size()+1,0));\\n        //cout<<ans<<endl;\\n        string ans1=text+pattern[1];\\n        return (long long) max(f(0,0,ans,pattern,dp),f(0,0,ans1,pattern,dp1));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2320999,
                "title": "c-very-intuitive-and-straight-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string s, string pat) {\\n        \\n        long long int cnt1=0;\\n        long long int cnt2=0;\\n        int n=s.length();\\n        string t=pat[0]+s;\\n        unordered_map<int,int>m1;\\n     \\n        \\n        for(int i=0;i<=n;i++){\\n            if(t[i]==pat[1]){m1[i]++;}\\n        }\\n        \\n  \\n        for(int i=0;i<=n;i++){\\n            if(m1.find(i)!=m1.end()){m1.erase(i);}\\n            if(t[i]!=pat[0]){continue;}\\n            cnt1=cnt1+m1.size();\\n\\n            \\n        }\\n        t=s+pat[1];\\n        m1.clear();\\n        for(int i=0;i<=n;i++){\\n            if(t[i]==pat[0]){m1[i]++;}\\n        }\\n        \\n         for(int i=n;i>=0;i--){\\n             if(m1.find(i)!=m1.end()){m1.erase(i);}\\n            if(t[i]!=pat[1]){continue;}\\n            cnt2+=m1.size();\\n\\n        }\\n        \\n        return max(cnt1,cnt2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string s, string pat) {\\n        \\n        long long int cnt1=0;\\n        long long int cnt2=0;\\n        int n=s.length();\\n        string t=pat[0]+s;\\n        unordered_map<int,int>m1;\\n     \\n        \\n        for(int i=0;i<=n;i++){\\n            if(t[i]==pat[1]){m1[i]++;}\\n        }\\n        \\n  \\n        for(int i=0;i<=n;i++){\\n            if(m1.find(i)!=m1.end()){m1.erase(i);}\\n            if(t[i]!=pat[0]){continue;}\\n            cnt1=cnt1+m1.size();\\n\\n            \\n        }\\n        t=s+pat[1];\\n        m1.clear();\\n        for(int i=0;i<=n;i++){\\n            if(t[i]==pat[0]){m1[i]++;}\\n        }\\n        \\n         for(int i=n;i>=0;i--){\\n             if(m1.find(i)!=m1.end()){m1.erase(i);}\\n            if(t[i]!=pat[1]){continue;}\\n            cnt2+=m1.size();\\n\\n        }\\n        \\n        return max(cnt1,cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320266,
                "title": "c-counting-greedy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans = 0;\\n        char c1 = pattern[0];\\n        char c2 = pattern[1];\\n        \\n        // edge case c1 == c2\\n        if(c1 == c2){\\n            int count = 0;\\n            for(auto c:text){\\n                if(c == c1){\\n                    ans+=count;\\n                    count++;\\n                }\\n            }\\n            ans+=count;\\n            return ans;\\n        }\\n        \\n        // keep track of count of c1 and c2\\n        // when encountering c2 , number of subsequence formed with this c2 is count of c1 till now\\n        // by inserting c1 at beginning or c2 at end only we can maximize from here\\n        // max of count of c1 and c2 can be added \\n        int count1 = 0;\\n        int count2 = 0;\\n    \\n        for(auto c:text){\\n            if(c == c1) count1++;\\n            if(c == c2) {\\n                count2++;\\n                ans+=count1;\\n            }\\n        }\\n        ans+=1LL*max(count1,count2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans = 0;\\n        char c1 = pattern[0];\\n        char c2 = pattern[1];\\n        \\n        // edge case c1 == c2\\n        if(c1 == c2){\\n            int count = 0;\\n            for(auto c:text){\\n                if(c == c1){\\n                    ans+=count;\\n                    count++;\\n                }\\n            }\\n            ans+=count;\\n            return ans;\\n        }\\n        \\n        // keep track of count of c1 and c2\\n        // when encountering c2 , number of subsequence formed with this c2 is count of c1 till now\\n        // by inserting c1 at beginning or c2 at end only we can maximize from here\\n        // max of count of c1 and c2 can be added \\n        int count1 = 0;\\n        int count2 = 0;\\n    \\n        for(auto c:text){\\n            if(c == c1) count1++;\\n            if(c == c2) {\\n                count2++;\\n                ans+=count1;\\n            }\\n        }\\n        ans+=1LL*max(count1,count2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058019,
                "title": "java-95-faster-easy-understanding",
                "content": "* **we calculate sum of no of subsequences for each of right character while traversing**\\n* **result will be total subsequenes and maximum of no of occurrences of first character and second character**\\n```\\nclass Solution {\\n    \\tpublic long maximumSubsequenceCount(String text, String pat) {\\n\\t\\tint count1 = 0;\\n\\t\\tint count2 = 0;\\n\\t\\tlong subs = 0;\\n\\n\\t\\tchar c1 = pat.charAt(0);\\n\\t\\tchar c2 = pat.charAt(1);\\n\\n\\t\\tfor (char c : text.toCharArray()) {\\n\\t\\t\\tif (c == c1)\\n\\t\\t\\t\\tcount1++;\\n\\n\\t\\t\\tif (c == c2) {\\n\\t\\t\\t\\tcount2++;\\n\\t\\t\\t\\tsubs += (c1 == c2 ? count1 - 1 : count1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn subs + Math.max(count1, count2);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\tpublic long maximumSubsequenceCount(String text, String pat) {\\n\\t\\tint count1 = 0;\\n\\t\\tint count2 = 0;\\n\\t\\tlong subs = 0;\\n\\n\\t\\tchar c1 = pat.charAt(0);\\n\\t\\tchar c2 = pat.charAt(1);\\n\\n\\t\\tfor (char c : text.toCharArray()) {\\n\\t\\t\\tif (c == c1)\\n\\t\\t\\t\\tcount1++;\\n\\n\\t\\t\\tif (c == c2) {\\n\\t\\t\\t\\tcount2++;\\n\\t\\t\\t\\tsubs += (c1 == c2 ? count1 - 1 : count1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn subs + Math.max(count1, count2);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940508,
                "title": "c-code-beginner-friendly",
                "content": "The best way to add a char from pattern is to add at end or at beginning.\\nIf you are adding pattern[0], then add at beginning\\nIf you are adding pattern[1], then add at end.\\n\\nHere we dont need to exactly add the character.\\np1 is overall pattern[0] count\\np3 is overall pattern[1] count\\np2 is pattern[1] count before next pattern[0] appears.\\n\\nso whenever pattern[0] comes after pattern[1] multiply p1 * p2 and add it to sum.\\nThis is for finding the current sub sequence.\\nNow to maximize it add sum to max count of pattern[0] and pattern[1].\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long p1 = 0,p2 = 0,sum = 0,p3 = 0;\\n        int n = text.length();\\n        bool flag = false;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n            {\\n                if(flag)\\n                {\\n                    sum += p2 * p1;\\n                    flag = false;\\n                }\\n                p1++;\\n                p2 = 0;\\n            }\\n            else if(text[i] == pattern[1])\\n            {\\n                p3++;\\n                p2++;\\n                flag = true;\\n            }\\n        }\\n        \\n        if(flag)\\n            sum += p1*p2;\\n        sum += max(p1,p3);\\n        if(pattern[0] == pattern[1])\\n        {\\n            sum = (p1 *(p1 + 1))/2;\\n            \\n        }\\n        return sum;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long p1 = 0,p2 = 0,sum = 0,p3 = 0;\\n        int n = text.length();\\n        bool flag = false;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n            {\\n                if(flag)\\n                {\\n                    sum += p2 * p1;\\n                    flag = false;\\n                }\\n                p1++;\\n                p2 = 0;\\n            }\\n            else if(text[i] == pattern[1])\\n            {\\n                p3++;\\n                p2++;\\n                flag = true;\\n            }\\n        }\\n        \\n        if(flag)\\n            sum += p1*p2;\\n        sum += max(p1,p3);\\n        if(pattern[0] == pattern[1])\\n        {\\n            sum = (p1 *(p1 + 1))/2;\\n            \\n        }\\n        return sum;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928799,
                "title": "python-forward-and-backward-solution",
                "content": "```python\\nclass Solution(object):\\n    def maximumSubsequenceCount(self, text, pattern):\\n        \"\"\"\\n        :type text: str\\n        :type pattern: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(text)\\n        \\n        forward = 0\\n        f = 1\\n        for t in text:\\n            if t == pattern[1]:\\n                forward += f\\n            if t == pattern[0]:\\n                f += 1\\n        backward = 0\\n        b = 1\\n        for t in text[::-1]:\\n            if t == pattern[0]:\\n                backward += b\\n            if t == pattern[1]:\\n                b += 1\\n                \\n        return max(forward, backward)\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maximumSubsequenceCount(self, text, pattern):\\n        \"\"\"\\n        :type text: str\\n        :type pattern: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(text)\\n        \\n        forward = 0\\n        f = 1\\n        for t in text:\\n            if t == pattern[1]:\\n                forward += f\\n            if t == pattern[0]:\\n                f += 1\\n        backward = 0\\n        b = 1\\n        for t in text[::-1]:\\n            if t == pattern[0]:\\n                backward += b\\n            if t == pattern[1]:\\n                b += 1\\n                \\n        return max(forward, backward)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889773,
                "title": "c-simple-solution",
                "content": "```\\nlong long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        long long fir =0 , sec =0 , ans =0;\\n        \\n        for(auto ch : text){\\n            \\n            if(ch==pattern[0])\\n                fir++;                \\n            \\n            if(ch==pattern[1]){\\n\\t\\t\\t\\n                if(pattern[0]!= pattern[1])\\n                    ans += fir;\\n                \\n                else\\n                    ans += min(fir,sec);\\n            }\\n        }\\n        \\n\\t\\tans += max(sec,fir);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nlong long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        long long fir =0 , sec =0 , ans =0;\\n        \\n        for(auto ch : text){\\n            \\n            if(ch==pattern[0])\\n                fir++;                \\n            \\n            if(ch==pattern[1]){\\n\\t\\t\\t\\n                if(pattern[0]!= pattern[1])\\n                    ans += fir;\\n                \\n                else\\n                    ans += min(fir,sec);\\n            }\\n        }\\n        \\n\\t\\tans += max(sec,fir);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1887637,
                "title": "easy-understanding-o-n-space-o-n-time",
                "content": "1->we will take two vector p1,p2 and store all index of pattern[0] in p1 and all index of pattern[1] in p2\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string p) {\\n      vector<int>p1,p2;\\n        int n=text.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==p[0])\\n                p1.push_back(i);\\n            \\n            if(text[i]==p[1])\\n                p2.push_back(i);\\n        }\\n        if(p[0]==p[1]) //in this case there will be n*(n+1)/2 possibility \\n        {\\n           long long int x=p1.size()+1;\\n            return x*(x-1)/2;\\n            \\n        }\\n        else {\\n            \\n            long long int  ans=0;\\n            if(p1.size()>p2.size())  //ifp1>p2 we will pattern[1] at end\\n                ans=ans+p1.size();\\n            else ans=ans+p2.size();  // we will add pattern[0] at begin\\n            int k=0;\\n            for(int i=0;i<p1.size();i++)\\n            {\\n               \\n                while(k<p2.size()&&p1[i]>=p2[k])\\n                    k++;\\n                ans=ans+p2.size()-k;\\n            }\\n            \\n            return ans;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string p) {\\n      vector<int>p1,p2;\\n        int n=text.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==p[0])\\n                p1.push_back(i);\\n            \\n            if(text[i]==p[1])\\n                p2.push_back(i);\\n        }\\n        if(p[0]==p[1]) //in this case there will be n*(n+1)/2 possibility \\n        {\\n           long long int x=p1.size()+1;\\n            return x*(x-1)/2;\\n            \\n        }\\n        else {\\n            \\n            long long int  ans=0;\\n            if(p1.size()>p2.size())  //ifp1>p2 we will pattern[1] at end\\n                ans=ans+p1.size();\\n            else ans=ans+p2.size();  // we will add pattern[0] at begin\\n            int k=0;\\n            for(int i=0;i<p1.size();i++)\\n            {\\n               \\n                while(k<p2.size()&&p1[i]>=p2[k])\\n                    k++;\\n                ans=ans+p2.size()-k;\\n            }\\n            \\n            return ans;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875573,
                "title": "invalid-test-case",
                "content": "```\\nI got Runtime error in this test case\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ada56d5d-b4d9-43eb-ae8d-4c0565d69950_1648016867.043498.png)\\n\\n```\\nbefore correcting the code\\n```\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) \\n    {\\n        map<char,int>mp;\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(t[i] == p[0] or t[i] == p[1])\\n            {\\n                mp[t[i]]++;\\n            }\\n        }\\n        if(p[0] == p[1])\\n            return (mp[p[0]]*(mp[p[0]]+1))*1ll/2;\\n        // cout<<p[0]<<\" \"<<mp[p[0]]<<\"\\\\n\";\\n        // cout<<p[1]<<\" \"<<mp[p[1]]<<\"\\\\n\";\\n        if(mp[p[0]] > mp[p[1]])\\n        {\\n            t.push_back(p[1]);\\n        }\\n        else\\n        {\\n            t.insert(t.begin(),p[0]);\\n        }\\n        // cout<<t;\\n        \\n        ll count = 0;\\n        ll ans = 0;\\n        for(int i = t.length()-1;i>=0;i--)\\n        {\\n            if(t[i] == p[1])count++;\\n            \\n            if(t[i] == p[0])ans+=count;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nafter correcting the code\\n```\\n\\n```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) \\n    {\\n        map<char,int>mp;\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(t[i] == p[0] or t[i] == p[1])\\n            {\\n                mp[t[i]]++;\\n            }\\n        }\\n        if(p[0] == p[1])\\n            return (mp[p[0]]*1ll*(mp[p[0]]+1))*1ll/2;  //(multiply with 1ll in numerator)\\n        // cout<<p[0]<<\" \"<<mp[p[0]]<<\"\\\\n\";\\n        // cout<<p[1]<<\" \"<<mp[p[1]]<<\"\\\\n\";\\n        if(mp[p[0]] > mp[p[1]])\\n        {\\n            t.push_back(p[1]);\\n        }\\n        else\\n        {\\n            t.insert(t.begin(),p[0]);\\n        }\\n        // cout<<t;\\n        \\n        ll count = 0;\\n        ll ans = 0;\\n        for(int i = t.length()-1;i>=0;i--)\\n        {\\n            if(t[i] == p[1])count++;\\n            \\n            if(t[i] == p[0])ans+=count;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nthe same test case in which i got runtime error , is now invalid test case\\n```\\n![image](https://assets.leetcode.com/users/images/64142fae-17c0-4644-a13d-cdda74263714_1648017255.746621.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6e7c2c7-02f6-48ae-a9e0-d90c0c169e24_1648017225.905154.png)\\n\\n```\\nbut still i got AC with the last code.\\n```\\n![image](https://assets.leetcode.com/users/images/cee5e99c-e764-42e7-beed-17069d356f15_1648017457.004887.png)\\n\\n```\\n-> So why you are checking a test case which is invalid ???\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nI got Runtime error in this test case\\n```\n```\\nbefore correcting the code\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) \\n    {\\n        map<char,int>mp;\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(t[i] == p[0] or t[i] == p[1])\\n            {\\n                mp[t[i]]++;\\n            }\\n        }\\n        if(p[0] == p[1])\\n            return (mp[p[0]]*(mp[p[0]]+1))*1ll/2;\\n        // cout<<p[0]<<\" \"<<mp[p[0]]<<\"\\\\n\";\\n        // cout<<p[1]<<\" \"<<mp[p[1]]<<\"\\\\n\";\\n        if(mp[p[0]] > mp[p[1]])\\n        {\\n            t.push_back(p[1]);\\n        }\\n        else\\n        {\\n            t.insert(t.begin(),p[0]);\\n        }\\n        // cout<<t;\\n        \\n        ll count = 0;\\n        ll ans = 0;\\n        for(int i = t.length()-1;i>=0;i--)\\n        {\\n            if(t[i] == p[1])count++;\\n            \\n            if(t[i] == p[0])ans+=count;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nafter correcting the code\\n```\n```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) \\n    {\\n        map<char,int>mp;\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(t[i] == p[0] or t[i] == p[1])\\n            {\\n                mp[t[i]]++;\\n            }\\n        }\\n        if(p[0] == p[1])\\n            return (mp[p[0]]*1ll*(mp[p[0]]+1))*1ll/2;  //(multiply with 1ll in numerator)\\n        // cout<<p[0]<<\" \"<<mp[p[0]]<<\"\\\\n\";\\n        // cout<<p[1]<<\" \"<<mp[p[1]]<<\"\\\\n\";\\n        if(mp[p[0]] > mp[p[1]])\\n        {\\n            t.push_back(p[1]);\\n        }\\n        else\\n        {\\n            t.insert(t.begin(),p[0]);\\n        }\\n        // cout<<t;\\n        \\n        ll count = 0;\\n        ll ans = 0;\\n        for(int i = t.length()-1;i>=0;i--)\\n        {\\n            if(t[i] == p[1])count++;\\n            \\n            if(t[i] == p[0])ans+=count;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nthe same test case in which i got runtime error , is now invalid test case\\n```\n```\\nbut still i got AC with the last code.\\n```\n```\\n-> So why you are checking a test case which is invalid ???\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1874254,
                "title": "heavily-commented-code-cpp-two-codes-with-the-thought-process-of-space-optimization",
                "content": "Heavily commented code, for the beginners to understand easily.\\nCheck out the second solution for the final optimal solution, This is for beginners, for going through the thought process.\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char fst = pattern[0]; // first character of the pattern\\n        long long f = 0; // frequency of fst\\n        char sec = pattern[1]; // second character of the pattern\\n        long long s = 0; // frequuency of sec\\n        \\n        // Store the number of sec char after the current index in the precal array.\\n        vector<int> precal(text.size());\\n        \\n        // Keep the count of frequency of fst and sec chars in the text string\\n        for(int i = text.size()-1; i>=0; i--) {\\n            precal[i] = s;\\n            if(text[i] == sec) s++;\\n            if(text[i] == fst) f++;\\n        }\\n        \\n        // Compute the cumulative of all occurences of the subsequence\\n        // by adding the frequency of char sec after the index value of the current char fst.\\n        long long total_subseq = 0;\\n        for(int i= 0; i< text.size(); i++) \\n             if(text[i] == fst) \\n                 total_subseq+=precal[i];\\n        \\n        // Now, since we can add pattern[0] or pattern[1] any where in string text, \\n        // we assume to add them at the optimal place ie before first occurence of char sec for char fst and after last occurence of fst for sec. \\n        return total_subseq + max(s,f);\\n    }\\n};\\n\\n```\\n\\nTime complexity : O(n)\\nSpace complexity : O(n)\\nThis was the first solution that i came up with. After giving it another thought i came across some space optimization. Instead of storing the frequencies of the sec char after every index, we can keep utilizing the current value for the current index, making the solution O(1) space.\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char fst = pattern[0]; long long f = 0;\\n        char sec = pattern[1]; long long s = 0;\\n        \\n\\t\\tlong long sum = 0;\\n        for(int i = text.size()-1; i>=0; i--) {\\n            if(text[i] == fst) f++, sum+=s; \\n            if(text[i] == sec) s++;\\n        }\\n        \\n        long long ans =  sum + max(s,f);\\n        return ans;\\n    }\\n};\\n\\n```\\nTime Complexity : O(n)\\nSpace Complexity : O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char fst = pattern[0]; // first character of the pattern\\n        long long f = 0; // frequency of fst\\n        char sec = pattern[1]; // second character of the pattern\\n        long long s = 0; // frequuency of sec\\n        \\n        // Store the number of sec char after the current index in the precal array.\\n        vector<int> precal(text.size());\\n        \\n        // Keep the count of frequency of fst and sec chars in the text string\\n        for(int i = text.size()-1; i>=0; i--) {\\n            precal[i] = s;\\n            if(text[i] == sec) s++;\\n            if(text[i] == fst) f++;\\n        }\\n        \\n        // Compute the cumulative of all occurences of the subsequence\\n        // by adding the frequency of char sec after the index value of the current char fst.\\n        long long total_subseq = 0;\\n        for(int i= 0; i< text.size(); i++) \\n             if(text[i] == fst) \\n                 total_subseq+=precal[i];\\n        \\n        // Now, since we can add pattern[0] or pattern[1] any where in string text, \\n        // we assume to add them at the optimal place ie before first occurence of char sec for char fst and after last occurence of fst for sec. \\n        return total_subseq + max(s,f);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char fst = pattern[0]; long long f = 0;\\n        char sec = pattern[1]; long long s = 0;\\n        \\n\\t\\tlong long sum = 0;\\n        for(int i = text.size()-1; i>=0; i--) {\\n            if(text[i] == fst) f++, sum+=s; \\n            if(text[i] == sec) s++;\\n        }\\n        \\n        long long ans =  sum + max(s,f);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866339,
                "title": "simple-solution-in-java-concise-and-elegant-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long ans = 0;\\n        \\n        int patA = 0;\\n        int patB = 0;\\n        \\n        for(int i=0; i<text.length(); i++){\\n            char c = text.charAt(i);\\n            \\n            if(c == pattern.charAt(0))  patA++;\\n            if(c == pattern.charAt(1))  patB++;\\n        }\\n        \\n        // Find the ans\\n        int countB = 0;\\n        for(int i=0; i<text.length(); i++){\\n            char c = text.charAt(i);\\n            if(c == pattern.charAt(1)) countB++;\\n            if(c == pattern.charAt(0)){\\n                ans += (long)patB - (long)countB;\\n            }\\n        }\\n        \\n        ans += (long)Math.max(patA, patB);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long ans = 0;\\n        \\n        int patA = 0;\\n        int patB = 0;\\n        \\n        for(int i=0; i<text.length(); i++){\\n            char c = text.charAt(i);\\n            \\n            if(c == pattern.charAt(0))  patA++;\\n            if(c == pattern.charAt(1))  patB++;\\n        }\\n        \\n        // Find the ans\\n        int countB = 0;\\n        for(int i=0; i<text.length(); i++){\\n            char c = text.charAt(i);\\n            if(c == pattern.charAt(1)) countB++;\\n            if(c == pattern.charAt(0)){\\n                ans += (long)patB - (long)countB;\\n            }\\n        }\\n        \\n        ans += (long)Math.max(patA, patB);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865422,
                "title": "c-easy-logic",
                "content": "\\n\\t\\tlong long maximumSubsequenceCount(string text, string pattern) {\\n\\t\\t\\t//if first and second element is same.\\n\\t\\t\\t//combination of same letters to form pattern.\\n\\t\\t\\tif(pattern[0] == pattern[1]){\\n\\t\\t\\t\\tlong long n = count(text.begin(), text.end(), pattern[0]); \\n\\t\\t\\t\\treturn (n*(n+1))/2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong long countFirst = 0;       //counts all the pattern[0] found till that point\\n\\t\\t\\tlong long countSecond = 0;      //counts all the pattern[1] element found till that point\\n\\n\\t\\t\\tlong long tempSecond = 0;       //counts all the pattern[1] element after the occurance of first element\\n\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tbool flag = false;\\n\\t\\t\\tfor(int i = 0; i<text.size(); i++){\\n\\n\\t\\t\\t\\tif(text[i] == pattern[0]){\\n\\n\\t\\t\\t\\t\\tif(flag){\\n\\n\\t\\t\\t\\t\\t\\tans += (countFirst*tempSecond);\\n\\t\\t\\t\\t\\t\\ttempSecond = 0;\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcountFirst++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(text[i] == pattern[1]){\\n\\t\\t\\t\\t\\ttempSecond++;\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\tcountSecond++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans += (countFirst*tempSecond);\\n\\n\\t\\t\\treturn ans+max(countFirst,countSecond);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "\\n\\t\\tlong long maximumSubsequenceCount(string text, string pattern) {\\n\\t\\t\\t//if first and second element is same.\\n\\t\\t\\t//combination of same letters to form pattern.\\n\\t\\t\\tif(pattern[0] == pattern[1]){\\n\\t\\t\\t\\tlong long n = count(text.begin(), text.end(), pattern[0]); \\n\\t\\t\\t\\treturn (n*(n+1))/2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong long countFirst = 0;       //counts all the pattern[0] found till that point\\n\\t\\t\\tlong long countSecond = 0;      //counts all the pattern[1] element found till that point\\n\\n\\t\\t\\tlong long tempSecond = 0;       //counts all the pattern[1] element after the occurance of first element\\n\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tbool flag = false;\\n\\t\\t\\tfor(int i = 0; i<text.size(); i++){\\n\\n\\t\\t\\t\\tif(text[i] == pattern[0]){\\n\\n\\t\\t\\t\\t\\tif(flag){\\n\\n\\t\\t\\t\\t\\t\\tans += (countFirst*tempSecond);\\n\\t\\t\\t\\t\\t\\ttempSecond = 0;\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcountFirst++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(text[i] == pattern[1]){\\n\\t\\t\\t\\t\\ttempSecond++;\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\tcountSecond++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans += (countFirst*tempSecond);\\n\\n\\t\\t\\treturn ans+max(countFirst,countSecond);\\n\\t\\t}\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1865405,
                "title": "time-o-n-c-solution-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans1=0;\\n        long long ans2=0;\\n        long long ans3=0;\\n        int count1=0;\\n        int count2=1;\\n        if(pattern[0]==pattern[1])\\n        {  \\n            for(int i=text.length()-1;i>=0;i--)\\n             {\\n            if(text[i]==pattern[0])\\n            {\\n                ans3+=count2;\\n                count2++;\\n            }\\n            \\n             }\\n            return ans3;\\n        }\\n        count1=0;\\n        count2=1;\\n        //We add pattern[1] at last \\n        for(int i=text.length()-1;i>=0;i--)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                ans1+=count2;\\n                \\n            }\\n            else if(text[i]==pattern[1])\\n            {   \\n                count2++;\\n            }\\n        }\\n        count1=0;\\n        count2=0;\\n        //we add pattern[0] at first\\n         for(int i=text.length()-1;i>=0;i--)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                ans2+=count2;\\n                \\n            }\\n            else if(text[i]==pattern[1])\\n            {   \\n                count2++;\\n            }\\n        }\\n        //for first index which we are adding\\n        ans2+=count2;\\n        \\n        return max(ans2,max(ans3,ans1));\\n        \\n    }\\n\\t};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans1=0;\\n        long long ans2=0;\\n        long long ans3=0;\\n        int count1=0;\\n        int count2=1;\\n        if(pattern[0]==pattern[1])\\n        {  \\n            for(int i=text.length()-1;i>=0;i--)\\n             {\\n            if(text[i]==pattern[0])\\n            {\\n                ans3+=count2;\\n                count2++;\\n            }\\n            \\n             }\\n            return ans3;\\n        }\\n        count1=0;\\n        count2=1;\\n        //We add pattern[1] at last \\n        for(int i=text.length()-1;i>=0;i--)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                ans1+=count2;\\n                \\n            }\\n            else if(text[i]==pattern[1])\\n            {   \\n                count2++;\\n            }\\n        }\\n        count1=0;\\n        count2=0;\\n        //we add pattern[0] at first\\n         for(int i=text.length()-1;i>=0;i--)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                ans2+=count2;\\n                \\n            }\\n            else if(text[i]==pattern[1])\\n            {   \\n                count2++;\\n            }\\n        }\\n        //for first index which we are adding\\n        ans2+=count2;\\n        \\n        return max(ans2,max(ans3,ans1));\\n        \\n    }\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865187,
                "title": "java-solution-with-explanation-faster-than-100",
                "content": "There are two scenarios: \\n1) pattern has two same characters:   \\n\\t\\t simply pick any two out of all options. \\n2) pattern has two different characters:   \\n\\t\\twhenever pattern[1] found, can be matched with any pattern[0] beforehand\\n\\nTherefore two parts in my solution\\n\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        int n = text.length();\\n\\n        if (pattern.charAt(1)== pattern.charAt(0) ) {\\n             long count = 0;\\n             for (char c: text.toCharArray()) {\\n                if (c == pattern.charAt(1)) {\\n                    count++; //amount of same character\\n              }\\n            }\\n            return (count + 1) * count / 2;  \\n\\t\\t\\t//Combination formula n!/(2!*(n-2)!) = n*(n-1)/2    here we add one same character to existing count, so n = count +1\\n        }\\n        \\n       long countOne = 0;\\n       long countZero = 0; \\n       long sequence = 0;  \\n       for (char c: text.toCharArray()) {\\n            if (c == pattern.charAt(0)) {\\n                countZero++;\\n            }\\n            if (c == pattern.charAt(1)) {\\n                countOne++;\\n                sequence += countZero; //can pair with every pattern.charAt(0) before it\\n            }\\n        }\\n\\n        return sequence + Math.max(countZero, countOne);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        int n = text.length();\\n\\n        if (pattern.charAt(1)== pattern.charAt(0) ) {\\n             long count = 0;\\n             for (char c: text.toCharArray()) {\\n                if (c == pattern.charAt(1)) {\\n                    count++; //amount of same character\\n              }\\n            }\\n            return (count + 1) * count / 2;  \\n\\t\\t\\t//Combination formula n!/(2!*(n-2)!) = n*(n-1)/2    here we add one same character to existing count, so n = count +1\\n        }\\n        \\n       long countOne = 0;\\n       long countZero = 0; \\n       long sequence = 0;  \\n       for (char c: text.toCharArray()) {\\n            if (c == pattern.charAt(0)) {\\n                countZero++;\\n            }\\n            if (c == pattern.charAt(1)) {\\n                countOne++;\\n                sequence += countZero; //can pair with every pattern.charAt(0) before it\\n            }\\n        }\\n\\n        return sequence + Math.max(countZero, countOne);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865173,
                "title": "c-o-n-solution",
                "content": "As you can see in other solutions the most optimal solution is to add either pattern[0] at 0th place or pattern[1] at nth place.\\nNow, for a given ```string= \"ababb\"```, and ```pattern =\"ab\"```\\nwe iterate over the string and keep the count of both pattern[0] & pattern[1].\\nat any instant suppose the value of pattern[0] is 3 and pattern[1] is 0, and then we encounter the 1st pattern[1], this means that we can make 3 subsequences from it.\\nLike, in the above example, \\nat i=0, count of pattern[0] =1.\\nat i=1, count of pattern[0]=1, and we encounter b(pattern[1]), so we can make 1 subsequence now.\\nmoving forward at i=3, count of pattern[0] is 2 and we encounter another b, so now we can make 2 subsequences from it.\\nsimilarly, for i=4, as count of pattern[0] is 2 we can make 2 more subsequences. so, we add all these possible values.\\nnow, we have to add 1 character, so we add whichever character has come lesser number of times, a in this case.\\nBut, there is a  catch here, if we add one \\'a\\' the total number of new subsequences will increase by count of \\'b\\'. (think why !!)\\n\\nthere is 1 more case to be handled where both the characters of pattern are same.\\nIn that case number of possible solution will be ```sigma(count of character - 1 )```.\\nbut we also have to add 1 more character.\\nSo answer in that case will be sigma(count of characters)\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int n = text.length();\\n        bool flag = false;\\n        \\n        if( pattern[0]== pattern[1]) flag = true;\\n        \\n        int cnt0=0, cnt1=0;\\n        long long ans=0,equalans=0;\\n        if(flag){\\n            for(auto &ch:text)\\n            if(ch==pattern[0]) equalans++;\\n        }\\n        if(flag) return (equalans+1)*equalans/2;\\n            \\n        for(int i=0;i<n;++i){\\n            if(text[i]==pattern[0]) cnt0++;\\n            if(text[i]== pattern[1]){\\n                cnt1++;\\n                ans+=cnt0;\\n            } \\n        }\\n        ans+= (cnt0>cnt1)? cnt0: cnt1;\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```string= \"ababb\"```\n```pattern =\"ab\"```\n```sigma(count of character - 1 )```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864923,
                "title": "python-dynamic-programming-memoization-lcs-variation",
                "content": "```\\n\\ndef find(i,j,text,pattern,dp):\\n    if(j < 0):\\n        return 1;\\n    if(i<0):\\n        return 0;\\n    \\n    if(dp[j][i] != -1):\\n        return dp[j][i]\\n    \\n    \\n    if(text[i] == pattern[j]):\\n        dp[j][i] = find(i-1,j-1,text,pattern,dp) + find(i-1,j,text,pattern,dp)\\n    else:\\n        dp[j][i] = find(i-1,j,text,pattern,dp)\\n    return dp[j][i]\\n\\nclass Solution:\\n    \\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        # Intution :\\n        # count no of pattern[0] in the string and also pattern[1].\\n        # If there are more no of pattern[0] then add pattern[1] to the last.(since this can form a pair) \\n        \\n        \\n        c1 = 0\\n        c2 = 0\\n        for i in text:\\n            if(i == pattern[0]):\\n                c1 += 1\\n            elif(i == pattern[1]):\\n                c2 += 1\\n        \\n        if(c1 >= c2):\\n            text += pattern[1] # If no of a\\'s is greater then add\\n        else:\\n            text = pattern[0] + text\\n        \\n        # Now find the no of subsequences.\\n        \\n        n = len(text)\\n        # print(text)\\n        # print(pattern)\\n        dp = [[-1 for i in range(n)] for j in range(2)]\\n        return find(n-1,1,text,pattern,dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\ndef find(i,j,text,pattern,dp):\\n    if(j < 0):\\n        return 1;\\n    if(i<0):\\n        return 0;\\n    \\n    if(dp[j][i] != -1):\\n        return dp[j][i]\\n    \\n    \\n    if(text[i] == pattern[j]):\\n        dp[j][i] = find(i-1,j-1,text,pattern,dp) + find(i-1,j,text,pattern,dp)\\n    else:\\n        dp[j][i] = find(i-1,j,text,pattern,dp)\\n    return dp[j][i]\\n\\nclass Solution:\\n    \\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        # Intution :\\n        # count no of pattern[0] in the string and also pattern[1].\\n        # If there are more no of pattern[0] then add pattern[1] to the last.(since this can form a pair) \\n        \\n        \\n        c1 = 0\\n        c2 = 0\\n        for i in text:\\n            if(i == pattern[0]):\\n                c1 += 1\\n            elif(i == pattern[1]):\\n                c2 += 1\\n        \\n        if(c1 >= c2):\\n            text += pattern[1] # If no of a\\'s is greater then add\\n        else:\\n            text = pattern[0] + text\\n        \\n        # Now find the no of subsequences.\\n        \\n        n = len(text)\\n        # print(text)\\n        # print(pattern)\\n        dp = [[-1 for i in range(n)] for j in range(2)]\\n        return find(n-1,1,text,pattern,dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864806,
                "title": "c-o-n-biweekly-thought-process-breaking-the-process",
                "content": "Greedly we can agree that\\n**Add pattern[0] at the beginnning.**\\n**OR**\\n**Add pattern[1] at the end.**\\nDuring BiWeekly I came up with this solution.\\n```\\nclass Solution {\\npublic:\\nlong long maximumSubsequenceCount(string text, string pattern) {\\n\\tvector<long long> alpha(2, 0);\\n\\tstring str = \"\";\\n\\tfor (char ch : text) {\\n\\t\\tif (ch == pattern[0] || ch == pattern[1]) {\\n\\t\\t\\tif (ch == pattern[0])\\n\\t\\t\\t\\t++alpha[0];\\n\\t\\t\\tif (ch == pattern[1])\\n\\t\\t\\t\\t++alpha[1];\\n\\t\\t\\tstr += ch;\\n\\t\\t}\\n\\t}\\n\\tif (str.size() == 0)\\n\\t\\treturn 0;\\n\\t//Put pattern[0] front\\n\\tlong long result0 = alpha[1];\\n\\tlong long pattern1count = alpha[1];\\n\\tfor (char ch : str) {\\n\\t\\tif (ch == pattern[1]) {\\n\\t\\t\\t--alpha[1];\\n\\t\\t}\\n\\t\\tif (ch == pattern[0]) {\\n\\t\\t\\tresult0 += alpha[1];\\n\\t\\t}\\n\\t}\\n\\t//Put pattern[1] last\\n\\tlong long result1 = 0;\\n\\talpha[1] = pattern1count + 1; // +1 for adding to end\\n\\tfor (char ch : str) {\\n\\t\\tif (ch == pattern[1]) {\\n\\t\\t\\t--alpha[1];\\n\\t\\t}\\n\\t\\tif (ch == pattern[0]) {\\n\\t\\t\\tresult1 += alpha[1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(result0, result1);\\n}\\n};\\n```\\n\\nHere you can see that I take care of two cases.\\n\\nAfter the contest I optimised my code\\n\\n```\\nclass Solution {\\npublic:\\nlong long maximumSubsequenceCount(string text, string pattern) {\\n\\tvector<long long> alpha(2, 0);\\n\\tstring str = \"\";\\n\\tfor (char ch : text) {\\n\\t\\tif (ch == pattern[0] || ch == pattern[1]) {\\n\\t\\t\\tif (ch == pattern[0])\\n\\t\\t\\t\\t++alpha[0];\\n\\t\\t\\tif (ch == pattern[1])\\n\\t\\t\\t\\t++alpha[1];\\n\\t\\t\\tstr += ch;\\n\\t\\t}\\n\\t}\\n\\tif (str.size() == 0)\\n\\t\\treturn 0;\\n\\tlong long result = 0;\\n\\tlong long pattern1count = alpha[1];\\n\\tfor (char ch : str) {\\n\\t\\tif (ch == pattern[1]) {\\n\\t\\t\\t--pattern1count;\\n\\t\\t}\\n\\t\\tif (ch == pattern[0]) {\\n\\t\\t\\tresult += pattern1count;\\n\\t\\t}\\n\\t}\\n\\treturn max(result + alpha[1], result + alpha[0]);\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long maximumSubsequenceCount(string text, string pattern) {\\n\\tvector<long long> alpha(2, 0);\\n\\tstring str = \"\";\\n\\tfor (char ch : text) {\\n\\t\\tif (ch == pattern[0] || ch == pattern[1]) {\\n\\t\\t\\tif (ch == pattern[0])\\n\\t\\t\\t\\t++alpha[0];\\n\\t\\t\\tif (ch == pattern[1])\\n\\t\\t\\t\\t++alpha[1];\\n\\t\\t\\tstr += ch;\\n\\t\\t}\\n\\t}\\n\\tif (str.size() == 0)\\n\\t\\treturn 0;\\n\\t//Put pattern[0] front\\n\\tlong long result0 = alpha[1];\\n\\tlong long pattern1count = alpha[1];\\n\\tfor (char ch : str) {\\n\\t\\tif (ch == pattern[1]) {\\n\\t\\t\\t--alpha[1];\\n\\t\\t}\\n\\t\\tif (ch == pattern[0]) {\\n\\t\\t\\tresult0 += alpha[1];\\n\\t\\t}\\n\\t}\\n\\t//Put pattern[1] last\\n\\tlong long result1 = 0;\\n\\talpha[1] = pattern1count + 1; // +1 for adding to end\\n\\tfor (char ch : str) {\\n\\t\\tif (ch == pattern[1]) {\\n\\t\\t\\t--alpha[1];\\n\\t\\t}\\n\\t\\tif (ch == pattern[0]) {\\n\\t\\t\\tresult1 += alpha[1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(result0, result1);\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\nlong long maximumSubsequenceCount(string text, string pattern) {\\n\\tvector<long long> alpha(2, 0);\\n\\tstring str = \"\";\\n\\tfor (char ch : text) {\\n\\t\\tif (ch == pattern[0] || ch == pattern[1]) {\\n\\t\\t\\tif (ch == pattern[0])\\n\\t\\t\\t\\t++alpha[0];\\n\\t\\t\\tif (ch == pattern[1])\\n\\t\\t\\t\\t++alpha[1];\\n\\t\\t\\tstr += ch;\\n\\t\\t}\\n\\t}\\n\\tif (str.size() == 0)\\n\\t\\treturn 0;\\n\\tlong long result = 0;\\n\\tlong long pattern1count = alpha[1];\\n\\tfor (char ch : str) {\\n\\t\\tif (ch == pattern[1]) {\\n\\t\\t\\t--pattern1count;\\n\\t\\t}\\n\\t\\tif (ch == pattern[0]) {\\n\\t\\t\\tresult += pattern1count;\\n\\t\\t}\\n\\t}\\n\\treturn max(result + alpha[1], result + alpha[0]);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864693,
                "title": "c-o-n-solution-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans = 0, c1 = 0, c2 = 0;\\n        for (auto c : text) {   \\n            if (c == pattern[1])\\n                ans += c1, c2++;\\n            if (c == pattern[0])\\n                c1++;\\n        }\\n        return ans + max(c1, c2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans = 0, c1 = 0, c2 = 0;\\n        for (auto c : text) {   \\n            if (c == pattern[1])\\n                ans += c1, c2++;\\n            if (c == pattern[0])\\n                c1++;\\n        }\\n        return ans + max(c1, c2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864581,
                "title": "dp-top-down-bottom-up-c-detailed-explanation-begineer-friendly",
                "content": "# Intuition :\\nOptimal Choice is to put pattern[0] at the first index and pattern[1] at the last index and choose max between them.\\nAt every character we have a option : \\n```\\n1. It matches with our pattern character => then we can take it or not : But we have to count total so we add both.\\n2. It doesn\\'t match with our pattern character => then we have no choice : as we can\\'t take it.\\n```\\nApproach : n pointer initially points to end of first string and m pointer initially points to end of pattern, now we move backwards till 0 and meanwhile we will check below conditions...\\n\\nLet\\'s talk about some bases Cases :\\n1. If our first string is empty and second string is empty : then we can say that empty is subsequence can also found in another empty subsequence. Ans will be 1.\\n\\n2. If our pattern string is empty and first string exist : then we can say that after comparing both the string our pattern string reached to end : means we got our answer and we can return 1 as Ans.\\n\\n3. If our first string is empty and second string exist : means we can\\'t find our answer and reached to end of first string or it can also happen if first string is empty given.\\n\\n4. As we are passing sizes of the string, that\\'s why we will check like if(s[n-1] == d[m-1]) : index will be size-1.\\n\\n5. We will check our condition here : which we discussed in intiution part.\\n\\n**Let\\'s Start with Simple Recursion\\nPure Recursion :**\\nTime Limit Exceeded : 140 / 172 test cases passed.\\nTC : O(N^M)\\nSC : O(N^M)\\n**BTW : Here m is always 2 : so we can also say O(N^2)**\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll rec(string &s, int n, string &d, int m){\\n        if(n == 0 && m == 0) return 1;\\n        if(m == 0) return 1;\\n        if(n == 0) return 0;\\n        if(s[n-1] == d[m-1]){\\n            return rec(s, n-1, d, m-1) + rec(s, n-1, d, m);\\n        }\\n        return rec(s, n-1, d, m);\\n    }\\n    ll maximumSubsequenceCount(string s, string d){\\n        string s1 = d[0] + s;\\n        string s2 = s + d[1];\\n        \\n        int n = s1.size();\\n        return max(rec(s1, n, d, 2), rec(s2, n, d, 2));\\n    }\\n};\\n```\\n**Memoization : Works Perfectly Fine on IDE but not working at test case 97 in LeetCode Code editor**\\nTC : O(N*M)\\nSC : O(N*M)\\n**BTW : Here m is always 2 : so we can also say O(N*2) or O(N)**\\n![image](https://assets.leetcode.com/users/images/7509bef3-76b7-45f9-98aa-358d1a9562e7_1647711785.3024213.png)\\n\\n```\\n#define ll long long\\nusing namespace std;\\nclass Solution {\\npublic:\\n    ll memo[100002][3];\\n    ll rec(string &s, int n, string &d, int m){\\n        // Base Cases\\n        if(n == 0 && m == 0) return 1;\\n        if(m == 0) return 1; \\n        if(n == 0) return 0; \\n        if(memo[n][m]!=-1) return memo[n][m];\\n        if(s[n-1] == d[m-1]){\\n            return memo[n][m] = rec(s, n-1, d, m-1) + rec(s, n-1, d, m);\\n        }\\n        return memo[n][m] = rec(s, n-1, d, m);\\n    }\\n    ll maximumSubsequenceCount(string s, string d){\\n        string s1 = d[0] + s;\\n        string s2 = s + d[1];\\n        \\n        int n = s1.size();\\n        memset(memo, -1, sizeof(memo));\\n        return max(rec(s1, n, d, 2), rec(s2, n, d, 2));\\n    }\\n};\\n```\\n\\n**Bottom UP : Tabulation : Simply Convert n into i and m into j.**\\nTC : O(N*M)\\nSC : O(N*M)\\n**BTW : Here m is always 2 : so we can also say O(N*2) or O(N)**\\n```\\n#define ll long long\\nusing namespace std;\\nclass Solution {\\npublic:\\n    ll tabulation(string s, string d)\\n    {\\n        ll n = s.size(), m = d.size();\\n        ll dp[n+1][m+1];\\n        \\n        // Initializing the First Row by 0 : Means if our first string is empty then we always have 0 as answer.\\n        for(int j = 0; j<m+1; j++) dp[0][j] = 0; \\n        \\n        // Initializing the First Column by 1: Means if our pattern is empty then we always have 1 as answer.\\n        for(int i = 0; i<n+1; i++) dp[i][0] = 1;\\n\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j<m+1; j++){\\n                // Checking Condition\\n                if(s[i-1] == d[j-1]){\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n    long long maximumSubsequenceCount(string s, string d){\\n        string s1 = d[0] + s;\\n        string s2 = s + d[1];\\n        return max(tabulation(s1, d), tabulation(s2, d));\\n    }\\n};\\n// here dp[4][2] means what will be the answer if we have length of first string is 4 and pattern is 2\\n```\\nIf anyone knows why Memoization is not working, please let me know : )\\nPlz consider upvoting if u find this post helpful : )",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n1. It matches with our pattern character => then we can take it or not : But we have to count total so we add both.\\n2. It doesn\\'t match with our pattern character => then we have no choice : as we can\\'t take it.\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll rec(string &s, int n, string &d, int m){\\n        if(n == 0 && m == 0) return 1;\\n        if(m == 0) return 1;\\n        if(n == 0) return 0;\\n        if(s[n-1] == d[m-1]){\\n            return rec(s, n-1, d, m-1) + rec(s, n-1, d, m);\\n        }\\n        return rec(s, n-1, d, m);\\n    }\\n    ll maximumSubsequenceCount(string s, string d){\\n        string s1 = d[0] + s;\\n        string s2 = s + d[1];\\n        \\n        int n = s1.size();\\n        return max(rec(s1, n, d, 2), rec(s2, n, d, 2));\\n    }\\n};\\n```\n```\\n#define ll long long\\nusing namespace std;\\nclass Solution {\\npublic:\\n    ll memo[100002][3];\\n    ll rec(string &s, int n, string &d, int m){\\n        // Base Cases\\n        if(n == 0 && m == 0) return 1;\\n        if(m == 0) return 1; \\n        if(n == 0) return 0; \\n        if(memo[n][m]!=-1) return memo[n][m];\\n        if(s[n-1] == d[m-1]){\\n            return memo[n][m] = rec(s, n-1, d, m-1) + rec(s, n-1, d, m);\\n        }\\n        return memo[n][m] = rec(s, n-1, d, m);\\n    }\\n    ll maximumSubsequenceCount(string s, string d){\\n        string s1 = d[0] + s;\\n        string s2 = s + d[1];\\n        \\n        int n = s1.size();\\n        memset(memo, -1, sizeof(memo));\\n        return max(rec(s1, n, d, 2), rec(s2, n, d, 2));\\n    }\\n};\\n```\n```\\n#define ll long long\\nusing namespace std;\\nclass Solution {\\npublic:\\n    ll tabulation(string s, string d)\\n    {\\n        ll n = s.size(), m = d.size();\\n        ll dp[n+1][m+1];\\n        \\n        // Initializing the First Row by 0 : Means if our first string is empty then we always have 0 as answer.\\n        for(int j = 0; j<m+1; j++) dp[0][j] = 0; \\n        \\n        // Initializing the First Column by 1: Means if our pattern is empty then we always have 1 as answer.\\n        for(int i = 0; i<n+1; i++) dp[i][0] = 1;\\n\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j<m+1; j++){\\n                // Checking Condition\\n                if(s[i-1] == d[j-1]){\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n    long long maximumSubsequenceCount(string s, string d){\\n        string s1 = d[0] + s;\\n        string s2 = s + d[1];\\n        return max(tabulation(s1, d), tabulation(s2, d));\\n    }\\n};\\n// here dp[4][2] means what will be the answer if we have length of first string is 4 and pattern is 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864397,
                "title": "python-o-n-solution-optimized-approach-with-explanation",
                "content": "Approach: \\nThe approach is to find the count of letters of pattern . \\nStep one : Using a loop find the total number of combinations of first and second letters along with their position,\\nDon\\'t forget to reduct the count of second letter and reduce it first in case first and second letters are same.\\n\\nStep Two: Add first letter in the very first position or very last position is the best way to increase the number of combinations, so add the opposite letter count and compare.\\n\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        a = text.count(pattern[0])\\n        b = text.count(pattern[1])\\n        c = 0 \\n        for i in text:\\n            if i==pattern[1]:\\n                b-=1\\n            if i==pattern[0]:\\n                c+=b \\n            \\n        return max(c+a,c+text.count(pattern[1]))\\n        \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        a = text.count(pattern[0])\\n        b = text.count(pattern[1])\\n        c = 0 \\n        for i in text:\\n            if i==pattern[1]:\\n                b-=1\\n            if i==pattern[0]:\\n                c+=b \\n            \\n        return max(c+a,c+text.count(pattern[1]))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864254,
                "title": "python-solution-for-beginners-o-n",
                "content": "If the letters in `pattern` are equal, we count the occurence of that letter in `text`\\nWe can add the extra letter anywhere in `text` and the answer will be the sum of integers from 1 to that letter count.\\n\\nOtherwise, we will keep 3 counts: one of the first letter, one of the second letter and one of the occurence of the `pattern` in `text`. We will increase those counts as we traverse `text`. \\nIf the count of the first letter is greater, we have to add the second letter at the end of `text` to maximize our final count.\\nOtherwise, we have to add the first letter at the beginning of `text`.\\n\\n```\\ndef maximumSubsequenceCount(self, text, pattern):\\n        \"\"\"\\n        :type text: str\\n        :type pattern: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        if pattern[0]==pattern[1]:\\n            count = text.count(pattern[0])\\n            return count*(count+1)/2\\n        \\n        count1 = 0\\n        count2 = 0\\n        count = 0\\n        \\n        for letter in text:\\n            if letter == pattern[0]:\\n                count1+=1\\n            elif letter == pattern[1]:\\n                count2+=1\\n                count+=count1\\n        \\n        return count + max(count1, count2)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maximumSubsequenceCount(self, text, pattern):\\n        \"\"\"\\n        :type text: str\\n        :type pattern: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        if pattern[0]==pattern[1]:\\n            count = text.count(pattern[0])\\n            return count*(count+1)/2\\n        \\n        count1 = 0\\n        count2 = 0\\n        count = 0\\n        \\n        for letter in text:\\n            if letter == pattern[0]:\\n                count1+=1\\n            elif letter == pattern[1]:\\n                count2+=1\\n                count+=count1\\n        \\n        return count + max(count1, count2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1864205,
                "title": "c-solution-similar-to-distinct-subsequences-115",
                "content": "```\\nclass Solution {\\npublic:\\n    long long find(string &s,string &t)\\n    {\\n        int m = t.length(), n = s.length();\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1, 0ll));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int j = 1; j <= n; j++)\\n            for (int i = 1; i <= m; i++)\\n                dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0ll);\\n        return dp[m][n];\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) \\n    {\\n        string s1=pattern[0]+text;\\n        string s2=text+pattern[1];\\n        return max({find(s1,pattern),find(s2,pattern)});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(string &s,string &t)\\n    {\\n        int m = t.length(), n = s.length();\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1, 0ll));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int j = 1; j <= n; j++)\\n            for (int i = 1; i <= m; i++)\\n                dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0ll);\\n        return dp[m][n];\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) \\n    {\\n        string s1=pattern[0]+text;\\n        string s2=text+pattern[1];\\n        return max({find(s1,pattern),find(s2,pattern)});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864122,
                "title": "c-easy",
                "content": "create two strings with  given string (s)\\ns1 = pattern[0] + s\\ns2 = s+ patten[1]\\nthen return  the maximum answer  of them\\n```\\nclass Solution {\\npublic:\\n    long long solve(string s,string p){\\n        char a = p[0],b = p[1];\\n        long long  ans = 0;\\n        long long  cnt = 0;\\n        for(long long i=0;i<s.size();i++){\\n            if(s[i] == a)cnt++;\\n            else if(s[i] == b){\\n                ans += cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n       long long ans = 0;\\n        if(pattern[0] == pattern[1]){\\n            long long cnt = 0;\\n            for(auto c:text){\\n                if(c == pattern[0])cnt++;\\n            }\\n            cnt++;\\n            return (cnt*(cnt-1))/2;\\n        }\\n        ans = max(ans,solve(pattern[0] + text,pattern));\\n        ans = max(ans,solve(text + pattern[1],pattern)); \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(string s,string p){\\n        char a = p[0],b = p[1];\\n        long long  ans = 0;\\n        long long  cnt = 0;\\n        for(long long i=0;i<s.size();i++){\\n            if(s[i] == a)cnt++;\\n            else if(s[i] == b){\\n                ans += cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n       long long ans = 0;\\n        if(pattern[0] == pattern[1]){\\n            long long cnt = 0;\\n            for(auto c:text){\\n                if(c == pattern[0])cnt++;\\n            }\\n            cnt++;\\n            return (cnt*(cnt-1))/2;\\n        }\\n        ans = max(ans,solve(pattern[0] + text,pattern));\\n        ans = max(ans,solve(text + pattern[1],pattern)); \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864118,
                "title": "very-easy-solution-c",
                "content": "Either you\\'ll add the pattern[0] at first, or pattern[1] at last.\\nThe character which is lesser in number would be added.\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char a = pattern[0];\\n        char b = pattern[1];\\n        long long val1 = 0;\\n        long long val2 = 0;\\n        for(auto &it : text){\\n            if(it == a){\\n                val1++;\\n            }\\n            if(it == b)\\n                val2++;\\n        }\\n    \\n        if(val1<val2){\\n            text.insert(text.begin(),a);\\n            val1++;\\n        }\\n        else{\\n            text.push_back(b);\\n            val2++;\\n        }\\n        long long ans = 0;\\n        if(a == b){\\n            ans = (val2 *(val2-1))/2;\\n            return ans;\\n        }\\n        \\n        for(int i = 0;i<text.size();i++){\\n            if(!val1 || !val2)\\n                break;\\n            if(text[i] == a){\\n                ans+= val2;\\n                val1--;\\n            }\\n            if(text[i] == b)\\n                val2--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char a = pattern[0];\\n        char b = pattern[1];\\n        long long val1 = 0;\\n        long long val2 = 0;\\n        for(auto &it : text){\\n            if(it == a){\\n                val1++;\\n            }\\n            if(it == b)\\n                val2++;\\n        }\\n    \\n        if(val1<val2){\\n            text.insert(text.begin(),a);\\n            val1++;\\n        }\\n        else{\\n            text.push_back(b);\\n            val2++;\\n        }\\n        long long ans = 0;\\n        if(a == b){\\n            ans = (val2 *(val2-1))/2;\\n            return ans;\\n        }\\n        \\n        for(int i = 0;i<text.size();i++){\\n            if(!val1 || !val2)\\n                break;\\n            if(text[i] == a){\\n                ans+= val2;\\n                val1--;\\n            }\\n            if(text[i] == b)\\n                val2--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864107,
                "title": "python-3-solution-d-p-bottom-up",
                "content": "> Not the most efficient one\\n```py\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        def bottom_up(str1, str2):\\n            m, n = len(str1), len(str2)\\n            dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n            for i in range(m + 1):\\n                dp[i][0] = 1\\n\\n            for i in range(1, m + 1):\\n                for j in range(1, n + 1):\\n                    dp[i][j] = (dp[i-1][j-1] if (str1[i-1] == str2[j-1]) else 0) + dp[i - 1][j]\\n\\n            return dp[-1][-1]\\n        \\n        first, second = pattern[0], pattern[1]\\n        if first not in text and second not in text:\\n            return 0\\n        \\n        text1 = first + text\\n        res1 = bottom_up(text1, pattern)\\n        \\n        text2 = text + second\\n        res2 = bottom_up(text2, pattern)\\n        \\n        return max(res1, res2)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```py\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        def bottom_up(str1, str2):\\n            m, n = len(str1), len(str2)\\n            dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n            for i in range(m + 1):\\n                dp[i][0] = 1\\n\\n            for i in range(1, m + 1):\\n                for j in range(1, n + 1):\\n                    dp[i][j] = (dp[i-1][j-1] if (str1[i-1] == str2[j-1]) else 0) + dp[i - 1][j]\\n\\n            return dp[-1][-1]\\n        \\n        first, second = pattern[0], pattern[1]\\n        if first not in text and second not in text:\\n            return 0\\n        \\n        text1 = first + text\\n        res1 = bottom_up(text1, pattern)\\n        \\n        text2 = text + second\\n        res2 = bottom_up(text2, pattern)\\n        \\n        return max(res1, res2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864089,
                "title": "c-solution-using-stack",
                "content": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        \\n        stack<char> st;\\n        for(int i=0 ; i<text.length() ; i++){\\n            if(text[i] == pat[0] || text[i] == pat[1]) st.push(text[i]);\\n        }\\n        \\n        long long count1=0;\\n        long long count2 =0;\\n        long long res =0;\\n        while(!st.empty()){\\n            if(st.top()==pat[1]) count2++ , st.pop();\\n            else if(st.top()==pat[0]){\\n                res+=count2;\\n                count1++;\\n                st.pop();\\n            }\\n        }\\n        \\n     \\n        if(pat[0]==pat[1]) return count2*(count2+1)/2;\\n        res+=max(count1,count2);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        \\n        stack<char> st;\\n        for(int i=0 ; i<text.length() ; i++){\\n            if(text[i] == pat[0] || text[i] == pat[1]) st.push(text[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1864088,
                "title": "c-easy-prefix-suffix-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        map<int, int> pref;\\n        map<int, int> suff;\\n        int firstcnt = 0, secondcnt = 0, safefront = 0, safeback = 0;\\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            if(t[i] == p[1])\\n            {\\n                pref[i] = firstcnt;\\n            }\\n            if(t[i] == p[0])\\n            {\\n                firstcnt++;\\n            }\\n        }\\n        \\n        for(int i = t.length()-1; i >= 0; i--)\\n        {\\n            if(t[i] == p[0])\\n            {\\n                suff[i] = secondcnt;\\n            }\\n            if(t[i] == p[1])\\n            {\\n                secondcnt++;\\n            }\\n        }\\n        \\n        long long currsum = 0, sum = 0;\\n        for(auto m : pref)\\n        {\\n            sum += m.second+1;\\n        }\\n        currsum = max(currsum, sum);\\n        sum = 0;\\n        for(auto m : suff)\\n        {\\n            sum += m.second+1;\\n        }\\n        currsum = max(currsum, sum);\\n        return currsum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        map<int, int> pref;\\n        map<int, int> suff;\\n        int firstcnt = 0, secondcnt = 0, safefront = 0, safeback = 0;\\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            if(t[i] == p[1])\\n            {\\n                pref[i] = firstcnt;\\n            }\\n            if(t[i] == p[0])\\n            {\\n                firstcnt++;\\n            }\\n        }\\n        \\n        for(int i = t.length()-1; i >= 0; i--)\\n        {\\n            if(t[i] == p[0])\\n            {\\n                suff[i] = secondcnt;\\n            }\\n            if(t[i] == p[1])\\n            {\\n                secondcnt++;\\n            }\\n        }\\n        \\n        long long currsum = 0, sum = 0;\\n        for(auto m : pref)\\n        {\\n            sum += m.second+1;\\n        }\\n        currsum = max(currsum, sum);\\n        sum = 0;\\n        for(auto m : suff)\\n        {\\n            sum += m.second+1;\\n        }\\n        currsum = max(currsum, sum);\\n        return currsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864081,
                "title": "c-simple-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long cal(string s, string t){\\n    long long ans = 0;\\n    unordered_map<char, long long> m;\\n    for(auto x : s){\\n        if(x == t[1]){\\n        ans += m[t[0]];\\n        }\\n        m[x]++;\\n    }\\n    return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long op1 = cal(pattern[0] + text, pattern);\\n        long long op2 = cal(text + pattern[1], pattern);\\n    return max(op1,op2);    \\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long cal(string s, string t){\\n    long long ans = 0;\\n    unordered_map<char, long long> m;\\n    for(auto x : s){\\n        if(x == t[1]){\\n        ans += m[t[0]];\\n        }\\n        m[x]++;\\n    }\\n    return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long op1 = cal(pattern[0] + text, pattern);\\n        long long op2 = cal(text + pattern[1], pattern);\\n    return max(op1,op2);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864080,
                "title": "java-o-n-o-1-space-easy-to-understand-beats-100",
                "content": "Let\\'s take an example, text = \"abdcdbc\", pattern = \"ac\"\\n     We can see that the pairs possible in text are with index (0,3) and (0,6)\\n     If we look carefully, the **pairs start with the index of first character** of pattern string and **end with second character**\\n     Now, if we have an option to add either the first character (a) or second character (c), **We would want to add the first character at the beginning of text or the second character at the end of text**\\n     because in that way we can form the maximum pairs.\\t \\n     So our answer in this case becomes count existing pairs + max(firstCharacterCount, secondCharacterCount)\\n     because in this example, we will add \\'a\\' at the beginning of text to have pairs with other 2 c\\'s, i.e. max(1,2)\\t \\n     Now we will iterate through each position of text and store count of each character of pattern string\\n     as soon as we encounter the second character, there is a possibility of having added new pairs, so we add them which are equal to firstCharacterCount\\n     **Note:**  If both the characters of pattern are equal, then we will have the count at the end in firstCharacterCount.\\n      Since both the characters are same, so the number of subsequences rather becomes selecting any 2 characters out of the count(n) i.e. (n+1)C2\\n```\\n  public long maximumSubsequenceCount(String text, String pattern) {\\n        int firstCharacterCount = 0, secondCharacterCount = 0;\\n        char firstCharacter = pattern.charAt(0), secondCharacter = pattern.charAt(1);\\n        long ans = 0;\\n        for (int i = 0; i < text.length(); i++) {\\n            if (text.charAt(i) == firstCharacter) {\\n                firstCharacterCount++;\\n            } else if (text.charAt(i) == secondCharacter) {\\n                secondCharacterCount++;\\n                if (firstCharacterCount != 0 && secondCharacterCount != 0)\\n                    ans += firstCharacterCount;\\n            }\\n        }\\n        // (n+1)C2 = (n+1)*n/2\\n        if (firstCharacter == secondCharacter) {\\n            long len = firstCharacterCount;\\n            return (len + 1) * len / 2;\\n        }\\n        return ans + Math.max(firstCharacterCount, secondCharacterCount);\\n    }",
                "solutionTags": [],
                "code": "Let\\'s take an example, text = \"abdcdbc\", pattern = \"ac\"\\n     We can see that the pairs possible in text are with index (0,3) and (0,6)\\n     If we look carefully, the **pairs start with the index of first character** of pattern string and **end with second character**\\n     Now, if we have an option to add either the first character (a) or second character (c), **We would want to add the first character at the beginning of text or the second character at the end of text**\\n     because in that way we can form the maximum pairs.\\t \\n     So our answer in this case becomes count existing pairs + max(firstCharacterCount, secondCharacterCount)\\n     because in this example, we will add \\'a\\' at the beginning of text to have pairs with other 2 c\\'s, i.e. max(1,2)\\t \\n     Now we will iterate through each position of text and store count of each character of pattern string\\n     as soon as we encounter the second character, there is a possibility of having added new pairs, so we add them which are equal to firstCharacterCount\\n     **Note:**  If both the characters of pattern are equal, then we will have the count at the end in firstCharacterCount.\\n      Since both the characters are same, so the number of subsequences rather becomes selecting any 2 characters out of the count(n) i.e. (n+1)C2\\n```\\n  public long maximumSubsequenceCount(String text, String pattern) {\\n        int firstCharacterCount = 0, secondCharacterCount = 0;\\n        char firstCharacter = pattern.charAt(0), secondCharacter = pattern.charAt(1);\\n        long ans = 0;\\n        for (int i = 0; i < text.length(); i++) {\\n            if (text.charAt(i) == firstCharacter) {\\n                firstCharacterCount++;\\n            } else if (text.charAt(i) == secondCharacter) {\\n                secondCharacterCount++;\\n                if (firstCharacterCount != 0 && secondCharacterCount != 0)\\n                    ans += firstCharacterCount;\\n            }\\n        }\\n        // (n+1)C2 = (n+1)*n/2\\n        if (firstCharacter == secondCharacter) {\\n            long len = firstCharacterCount;\\n            return (len + 1) * len / 2;\\n        }\\n        return ans + Math.max(firstCharacterCount, secondCharacterCount);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1864072,
                "title": "c-straight-forward-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    long long solve(string a,string b){\\n        long long ans=0,cnt=0;\\n        char ed=b[1],st=b[0];\\n        int n=a.length();\\n\\t\\t//get count of subsequences\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]==ed)cnt++;\\n            else if(a[i]==st)ans+=cnt;\\n        }\\n\\t\\t//when both characters in pattern are same\\n        if(ed==st)ans+=(((cnt-1)*(cnt))/2);\\n        return ans;\\n    }\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string res1=pattern[0]+text; // adding first charcter to starting\\n        string res2=text+pattern[1]; // adding second character to last\\n        return max(solve(res1,pattern),solve(res2,pattern)); //return maximum of both\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long solve(string a,string b){\\n        long long ans=0,cnt=0;\\n        char ed=b[1],st=b[0];\\n        int n=a.length();\\n\\t\\t//get count of subsequences\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]==ed)cnt++;\\n            else if(a[i]==st)ans+=cnt;\\n        }\\n\\t\\t//when both characters in pattern are same\\n        if(ed==st)ans+=(((cnt-1)*(cnt))/2);\\n        return ans;\\n    }\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string res1=pattern[0]+text; // adding first charcter to starting\\n        string res2=text+pattern[1]; // adding second character to last\\n        return max(solve(res1,pattern),solve(res2,pattern)); //return maximum of both\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863978,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        int n = text.length();\\n        int a = 0;  //  count of pattern[0]\\n        int b = 0;  //  count of pattern[1]\\n        char[] arr = text.toCharArray();\\n        for (char c : arr) {\\n            if (c == pattern.charAt(0)) {\\n                a++;\\n            }\\n            if (c == pattern.charAt(1)) {\\n                b++;\\n            }\\n        }\\n        \\n        char f = pattern.charAt(0);\\n        char s = pattern.charAt(1);\\n        \\n        //  count of pattern[1] on right\\n        int b_onright = b;\\n        \\n        long answer = 0;\\n        for (char c : arr) {\\n            if (c == s) {\\n                b_onright--;\\n            }\\n            if (c == f) {\\n                //  this \\'f\\' character will pair with all the \\'s\\' on the right\\n                answer += b_onright;\\n            }\\n        }\\n        \\n        /*\\n        \\n            we GREEDLY want to attach \\'f\\' on left to increase the chances of matching with \\'s\\' on right hand side\\n                or\\n            attach \\'s\\' on right to increase the chances of matching with \\'f\\' on left hand side\\n        \\n        */\\n        \\n        //  until now we have not appended either \\'f\\' on the left or \\'s\\' on the right \\n        //  now we check if we want to append \\'f\\' on the left or \\'s\\' on the right\\n        //  we can greedly pick the character with more frequency to attach at the end of string\\n        //  i.e. \\'f\\' on the left  or \\n        //       \\'s\\' on the right\\n        answer += b > a ? b : a;\\n        return answer;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        int n = text.length();\\n        int a = 0;  //  count of pattern[0]\\n        int b = 0;  //  count of pattern[1]\\n        char[] arr = text.toCharArray();\\n        for (char c : arr) {\\n            if (c == pattern.charAt(0)) {\\n                a++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1863957,
                "title": "feature-request-unhide-hidden-test-cases-after-60-minutes",
                "content": "18113 might be the record for most submissions ever. \\n\\n### DISCLAIMER: \\nI love Leetcode and largely credit it for landing a job at a FAANG. I\\'ve attended 167 contests.\\n\\n# Summary\\nHeres a Leetcode question for you product owners out there: Create a better idea for how to implement hidden test cases. Hidden test cases are singularly the most frustrating thing on this platform. \\n\\n# SOLUTION:\\n```\\nAfter 60 minutes, unhide test cases. \\n// Cheaters who brute force all of the test cases of a problem after 60 minutes can still be found but it doesn\\'t invalidate the results of the contest.\\n```\\n\\n### MOTIVATION:\\n- I am one of the poor bastards that came up with the solution to this problem in 60 seconds and spent 60 minutes trying to debug a hidden test case.\\n- I understand that hidden test cases were added as a security feature. I get it. I understand that you are literally trying to prevent some of the most technically literate people in the world from cheating. I get it. But compromising user experience is not something that should be done lightly. I would bet you have had engineers at leetcode tell you for months/years that \"we don\\'t have the resources to tackle cheaters so we have to hide test cases\". I get it. Just please keep exploring additional options, because this is borderline a bad|horrible user experience in my biased opinion.\\n\\nI submitted this as a feature suggestion/request to Leetcode, maybe someone will read it.",
                "solutionTags": [],
                "code": "```\\nAfter 60 minutes, unhide test cases. \\n// Cheaters who brute force all of the test cases of a problem after 60 minutes can still be found but it doesn\\'t invalidate the results of the contest.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863954,
                "title": "python-3-simple-o-n-code",
                "content": "```python\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        def f(s: str, x: str, y: str) -> int:\\n            res, cnt = 0, 1\\n            for i, c in enumerate(s):\\n                if c == x:\\n                    cnt += 1\\n                elif c == y:\\n                    res += cnt\\n            return res\\n        \\n        x, y = list(pattern)\\n        if x == y:\\n            ct = text.count(x)\\n            return ct * (ct + 1) // 2\\n        return max(f(text, x, y), f(text[:: -1], y, x))\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        def f(s: str, x: str, y: str) -> int:\\n            res, cnt = 0, 1\\n            for i, c in enumerate(s):\\n                if c == x:\\n                    cnt += 1\\n                elif c == y:\\n                    res += cnt\\n            return res\\n        \\n        x, y = list(pattern)\\n        if x == y:\\n            ct = text.count(x)\\n            return ct * (ct + 1) // 2\\n        return max(f(text, x, y), f(text[:: -1], y, x))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1863906,
                "title": "c-solution-with-explanation",
                "content": "* It is to be understood that the optimal answer can only be found by either appending ```pattern[0]``` to the front (Case 1) or ```pattern[1]``` to the end (Case 2) of ```text```\\n* If ```pattern[0]==pattern[1]```, the final result would be ```sum from 1 to x``` where ```x``` is total number of occurences of ```pattern[0]``` \\n* Count all subsequences which make up to ```pattern``` in the present ```text```\\n* At last, add number of new subsequences after \"appending\" ```pattern[0]``` or ```pattern[1]```\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long n=text.size(), ans1=0, ans2=0, o=0, t=0;\\n        if(pattern[0]==pattern[1]){\\n            for(char i:text)    if(i==pattern[0])   ans1++;\\n            return (ans1*(ans1+1))/2;\\n        }\\n        for(int i=n-1; i>=0; i--)\\n            if(text[i]==pattern[1]) t++;\\n            else if(text[i]==pattern[0])    ans1+=t;\\n        \\n        for(char i:text)\\n            if(i==pattern[0])       o++;\\n            else if(i==pattern[1])  ans2+=o;\\n        \\n        return max(ans1+t,ans2+o);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```pattern[0]```\n```pattern[1]```\n```text```\n```pattern[0]==pattern[1]```\n```sum from 1 to x```\n```x```\n```pattern[0]```\n```pattern```\n```text```\n```pattern[0]```\n```pattern[1]```\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long n=text.size(), ans1=0, ans2=0, o=0, t=0;\\n        if(pattern[0]==pattern[1]){\\n            for(char i:text)    if(i==pattern[0])   ans1++;\\n            return (ans1*(ans1+1))/2;\\n        }\\n        for(int i=n-1; i>=0; i--)\\n            if(text[i]==pattern[1]) t++;\\n            else if(text[i]==pattern[0])    ans1+=t;\\n        \\n        for(char i:text)\\n            if(i==pattern[0])       o++;\\n            else if(i==pattern[1])  ans2+=o;\\n        \\n        return max(ans1+t,ans2+o);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863898,
                "title": "c-easy-to-understand-o-n",
                "content": "\\n       \\n      int n=t.size();\\n        char f=p[0];\\n        char s=p[1];\\n        int ff=0;\\n        int sf=0;\\n        long long a=0;\\n        long long b=0;\\n        for(char it:t){\\n            if(it==f)ff++;\\n             if(it==s)b+=ff;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(t[i]==s){\\n                sf++;\\n            }\\n            else if(t[i]==f){\\n                a+=sf;\\n            }\\n        }\\n        a+=sf;\\n        b+=ff;\\n        if(f==s)return b-a;\\n        return max(a,b);",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n       \\n      int n=t.size();\\n        char f=p[0];\\n        char s=p[1];\\n        int ff=0;\\n        int sf=0;\\n        long long a=0;\\n        long long b=0;\\n        for(char it:t){\\n            if(it==f)ff++;\\n             if(it==s)b+=ff;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(t[i]==s){\\n                sf++;\\n            }\\n            else if(t[i]==f){\\n                a+=sf;\\n            }\\n        }\\n        a+=sf;\\n        b+=ff;\\n        if(f==s)return b-a;\\n        return max(a,b);",
                "codeTag": "Unknown"
            },
            {
                "id": 4084645,
                "title": "easy-to-understand-solution-in-java-using-prefix-sum",
                "content": "# Intuition\\nWe have a pattern of only 2 characters. \\nwe know that if we want to add either 0 index or 1 index character to increase the number of occurence of the pattern in the string.\\n\\nwe need to add the index 1 character at the last and index 0 character at the beginning.\\n\\n# Approach\\ncommented in the code\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n\\n        int n = text.length();\\n        //res and count are for counting pairs pf pattern in the string if pattern[0] is added to the string in the starting\\n\\n        // res1 and count1 are for counting pairs pf pattern in the string if pattern[1] is added to the string in the last\\n\\n// count variable is for counting the occurence of the pattern[1] character\\n// res is for storing the pairs\\n\\n        long count = 0,\\n             res = 0,   \\n             res1 = 0,\\n             count1 = 1;\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            char c = text.charAt(i);\\n            if(c==pattern.charAt(1))\\n            {\\n                count1++;\\n                count++;\\n            }\\n            else if(c==pattern.charAt(0))\\n            {\\n                res = res+count;\\n                res1 = res1 + count1;\\n            }\\n        }\\n\\n//if pattern contains the same character then \\n// 1 1 1 1 1 no of possible pairs of (1,1) is given by\\n// 4 3 2 1     \\n// for n = 5  sum = 4 * (4+1)/2 [sum of 1,2,3,4]\\n\\n        if(pattern.charAt(1)==pattern.charAt(0))\\n        {\\n            return count *(count+1)/2;\\n        }\\n\\n        // lets assume we have added the pattern[0] to the starting\\n        res = res+count;\\n      \\n        return Math.max(res,res1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n\\n        int n = text.length();\\n        //res and count are for counting pairs pf pattern in the string if pattern[0] is added to the string in the starting\\n\\n        // res1 and count1 are for counting pairs pf pattern in the string if pattern[1] is added to the string in the last\\n\\n// count variable is for counting the occurence of the pattern[1] character\\n// res is for storing the pairs\\n\\n        long count = 0,\\n             res = 0,   \\n             res1 = 0,\\n             count1 = 1;\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            char c = text.charAt(i);\\n            if(c==pattern.charAt(1))\\n            {\\n                count1++;\\n                count++;\\n            }\\n            else if(c==pattern.charAt(0))\\n            {\\n                res = res+count;\\n                res1 = res1 + count1;\\n            }\\n        }\\n\\n//if pattern contains the same character then \\n// 1 1 1 1 1 no of possible pairs of (1,1) is given by\\n// 4 3 2 1     \\n// for n = 5  sum = 4 * (4+1)/2 [sum of 1,2,3,4]\\n\\n        if(pattern.charAt(1)==pattern.charAt(0))\\n        {\\n            return count *(count+1)/2;\\n        }\\n\\n        // lets assume we have added the pattern[0] to the starting\\n        res = res+count;\\n      \\n        return Math.max(res,res1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031822,
                "title": "ez-python-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, string: str, p: str) -> int:\\n\\n\\n\\n        # TC: O(N)\\n\\n        # greedy best to put\\n        # p[0] first OR\\n        # p[1] last\\n\\n        def count_subseq(s):\\n\\n            N = len(s)\\n\\n            amt_before = 0\\n            ans = 0\\n\\n            # case when pattern are like: aa\\n            if p[0] == p[1]:\\n                amt_before-=1\\n            \\n\\n            # pref sum\\n            for i in range(N):\\n                if s[i] == p[0]:\\n                    amt_before+=1\\n\\n                # here we complete the subseq : we ask how many of p[0] are before me that could make a sub seq with me\\n                if s[i] == p[1]:\\n                    ans+= amt_before\\n\\n            return ans\\n                \\n        # count how many substring are in s with p[0] at front OR with p[1] at end\\n\\n        s1 = p[0] + string\\n        s2 = string + p[1]\\n        return max(count_subseq(s1),count_subseq(s2))\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, string: str, p: str) -> int:\\n\\n\\n\\n        # TC: O(N)\\n\\n        # greedy best to put\\n        # p[0] first OR\\n        # p[1] last\\n\\n        def count_subseq(s):\\n\\n            N = len(s)\\n\\n            amt_before = 0\\n            ans = 0\\n\\n            # case when pattern are like: aa\\n            if p[0] == p[1]:\\n                amt_before-=1\\n            \\n\\n            # pref sum\\n            for i in range(N):\\n                if s[i] == p[0]:\\n                    amt_before+=1\\n\\n                # here we complete the subseq : we ask how many of p[0] are before me that could make a sub seq with me\\n                if s[i] == p[1]:\\n                    ans+= amt_before\\n\\n            return ans\\n                \\n        # count how many substring are in s with p[0] at front OR with p[1] at end\\n\\n        s1 = p[0] + string\\n        s2 = string + p[1]\\n        return max(count_subseq(s1),count_subseq(s2))\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028480,
                "title": "easy-cpp-map",
                "content": "# Intuition\\nThe goal is to maximize the number of times the given pattern can occur as a subsequence in the modified text. To do this, we can count the occurrences of each character in the original text and use this information to calculate the maximum number of subsequences of the pattern. The idea is to determine how many times we can insert `pattern[0]` and `pattern[1]` into the text to create new subsequences of the pattern.\\n\\n# Approach\\n1. Initialize an unordered map `mp` to store the frequency of each character in the original text.\\n2. Initialize variables `maxi` and `mini` to keep track of the maximum and minimum occurrences of `pattern[0]` and `pattern[1]` in the text.\\n3. Initialize a variable `ans` to keep track of the count of subsequences of the pattern.\\n4. Iterate through the characters in the original text:\\n   - If the current character is equal to `pattern[1]`, decrement its count in the map `mp`.\\n   - If the count of `pattern[1]` becomes zero, remove it from the map.\\n   - If the current character is equal to `pattern[0]`, add the count of `pattern[1]` (if it exists in the map) to the `ans` variable. This is because adding `pattern[0]` at this position creates new subsequences with `pattern[1]`.\\n5. After iterating through the text, check whether `maxi` (maximum count of `pattern[0]`) is less than `mini` (minimum count of `pattern[1]`). If it is, return `mini + ans`, as it indicates that inserting `pattern[0]` is more beneficial. Otherwise, return `maxi + ans`.\\n\\n# Complexity\\n- Time complexity: The algorithm iterates through the text once, which takes O(n) time, where n is the length of the text.\\n- Space complexity: The space complexity is O(1) as the space used for the map and variables is constant.\\n\\n# Code\\nHere\\'s the provided C++ code implementing the approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        unordered_map<char, long long> mp;\\n        long long ans = 0;\\n        \\n        // Count the occurrences of each character in the original text\\n        for (auto i : t) {\\n            mp[i]++;\\n        }\\n        \\n        long long maxi = mp[p[0]]; // Maximum count of pattern[0]\\n        long long mini = mp[p[1]]; // Minimum count of pattern[1]\\n        \\n        for (auto i : t) {\\n            if (i == p[1]) {\\n                mp[p[1]]--;\\n            }\\n            if (mp[p[1]] == 0) {\\n                mp.erase(p[1]);\\n            }\\n            if (i == p[0]) {\\n                ans += mp[p[1]];\\n            }\\n        }\\n        \\n        // Determine whether to use pattern[0] or pattern[1] to maximize subsequences\\n        if (maxi < mini) {\\n            return mini + ans;\\n        } else {\\n            return maxi + ans;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        unordered_map<char, long long> mp;\\n        long long ans = 0;\\n        \\n        // Count the occurrences of each character in the original text\\n        for (auto i : t) {\\n            mp[i]++;\\n        }\\n        \\n        long long maxi = mp[p[0]]; // Maximum count of pattern[0]\\n        long long mini = mp[p[1]]; // Minimum count of pattern[1]\\n        \\n        for (auto i : t) {\\n            if (i == p[1]) {\\n                mp[p[1]]--;\\n            }\\n            if (mp[p[1]] == 0) {\\n                mp.erase(p[1]);\\n            }\\n            if (i == p[0]) {\\n                ans += mp[p[1]];\\n            }\\n        }\\n        \\n        // Determine whether to use pattern[0] or pattern[1] to maximize subsequences\\n        if (maxi < mini) {\\n            return mini + ans;\\n        } else {\\n            return maxi + ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005173,
                "title": "simple-c-solution-using-first-and-last-position",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n       long long temp=1;\\n       long long sum=0;\\n       for(int i=0;i<text.size();i++){\\n           if(text[i]==pattern[1]){\\n               temp++;\\n           }\\n       }\\n       if(pattern[0]==pattern[1]){\\n           temp--;\\n           return ((temp)*(temp+1)*1L)/2;\\n       }\\n       long long cnt2=temp;\\n       long long x=0;\\n       for(int i=0;i<text.size();i++){\\n           if(text[i]==pattern[0]){\\nsum=sum+(temp);\\nx++;\\n           }\\n           else if(text[i]==pattern[1]){\\ntemp--;\\n           }\\n       }\\nlong long sum2=0;\\ncnt2--;\\nsum2=sum2+(cnt2-x)+sum;\\n       return max(sum,sum2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n       long long temp=1;\\n       long long sum=0;\\n       for(int i=0;i<text.size();i++){\\n           if(text[i]==pattern[1]){\\n               temp++;\\n           }\\n       }\\n       if(pattern[0]==pattern[1]){\\n           temp--;\\n           return ((temp)*(temp+1)*1L)/2;\\n       }\\n       long long cnt2=temp;\\n       long long x=0;\\n       for(int i=0;i<text.size();i++){\\n           if(text[i]==pattern[0]){\\nsum=sum+(temp);\\nx++;\\n           }\\n           else if(text[i]==pattern[1]){\\ntemp--;\\n           }\\n       }\\nlong long sum2=0;\\ncnt2--;\\nsum2=sum2+(cnt2-x)+sum;\\n       return max(sum,sum2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953654,
                "title": "c-with-2-lists",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        vector<int> list_a;\\n        deque<int> list_b;\\n\\n        const char pa = pattern.front();\\n        const char pb = pattern.back();\\n\\n        for (int i = 0; i < (int)text.size(); i ++) {\\n            const char c = text[i];\\n            if (c == pa) {\\n                list_a.push_back(i);\\n            } \\n            else if (c == pb) {\\n                list_b.push_back(i);\\n            }\\n        }\\n\\n        long long cnt = std::max(list_a.size(), list_b.size());\\n\\n        if (pa == pb) {\\n            for (int i = 1; i < (int)list_a.size(); i ++) {\\n                cnt += i;\\n            }\\n        }\\n        else {\\n            for (int i : list_a) {\\n                while (list_b.size() > 0 && list_b.front() <= i) {\\n                    list_b.pop_front();\\n                }\\n                cnt += (int) list_b.size();\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        vector<int> list_a;\\n        deque<int> list_b;\\n\\n        const char pa = pattern.front();\\n        const char pb = pattern.back();\\n\\n        for (int i = 0; i < (int)text.size(); i ++) {\\n            const char c = text[i];\\n            if (c == pa) {\\n                list_a.push_back(i);\\n            } \\n            else if (c == pb) {\\n                list_b.push_back(i);\\n            }\\n        }\\n\\n        long long cnt = std::max(list_a.size(), list_b.size());\\n\\n        if (pa == pb) {\\n            for (int i = 1; i < (int)list_a.size(); i ++) {\\n                cnt += i;\\n            }\\n        }\\n        else {\\n            for (int i : list_a) {\\n                while (list_b.size() > 0 && list_b.front() <= i) {\\n                    list_b.pop_front();\\n                }\\n                cnt += (int) list_b.size();\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951789,
                "title": "java-7ms-beats-97-and-clean-code",
                "content": "# Approach\\n1. The only way to make the best choice is to put pattern[0] at the beginning of text OR pattern[1] at the end of text.\\n    - If pattern[0] is put at the beginning of the text, then it will form NEW substrings with ALL the pattern[1] chars present in the string.\\n    - If pattern[1] is put at the end of text, then ALL pattern[0] chars from text will form extra subtrings with the next char added at the end.\\n2. Start traversing the string from the end and count the pattern0 / pattern1 chars.\\n3. If you counter an pattern0 char, then that will make substrings with all pattern1Count chars encountered so far (so total += pattern1Count)\\n4. If current char is pattern1, then increase pattern1Count by 1.\\n5. Pay attention to the edge case when pattern is made out of two identical chars (eg:aa).\\n    - In this case, step #3 needs to be adjusted. EG: pattern1Count = pattern0Count - 1;\\n    - EG: text = abaca , pattern  = \"aa\"\\n    - i = 4: pattern0Count = 1, pattern1Count = pattern0Count -1 = 0;\\n        total += 0;\\n    - i = 2: pattern0Count = 2, pattern1Count = pattern0Count - 1 = 1;\\n        total += 1;\\n    - i = 0: pattern0Count = 3, pattern1Count  = pattern0Count - 1 = 2;\\n        total += 2.\\n6. So far, we have counted how many substrings exist, but we need to add pattern0/pattern1 char\\n7. If both pattern0Count/pattern1Count are 0, then we cannot make any pattern\\n8. If they are both > 0, then we need to add the char that will give the best extra number of substrings: max(pattern0Count, pattern1Count).\\n    - EG: xaaab, pattern = \"ab\". We have 3 by default and 3 a, 1 b\\n    - If we add b at the end (=> xaaabb), we get 3 extra substrings\\n    - If we add a at the beginning(axaaab), we get 1 extra substring.   \\n    - Thus, the bext answer is max(pattern0Count, pattern1Count)\\n9. If one of them is 0, then we can only make max(pattern0Count, pattern1Count)\\n    - EG: \\'abcdee\\' pattern = pe\\n    - 0 p and 2e. If we make one p, then that p can make 2 patterns with e.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long maxSubsequence = 0;\\n        char ch, firstPatternChar = pattern.charAt(0), secondPatternChar = pattern.charAt(1);\\n        int firstPatternCharCount = 0, secondPatternCharCount = 0;\\n        boolean samePatternChars = firstPatternChar == secondPatternChar;\\n        for (int i = text.length() - 1; i >=0; i--) {\\n            ch = text.charAt(i);\\n            if (ch == firstPatternChar) {\\n                firstPatternCharCount++;\\n                if (samePatternChars) {\\n                    secondPatternCharCount = firstPatternCharCount - 1;\\n                }\\n                maxSubsequence += secondPatternCharCount;\\n            } else if (ch == secondPatternChar) {\\n                secondPatternCharCount++;\\n            }\\n        }\\n        if (firstPatternCharCount > 0 && secondPatternCharCount > 0) {\\n            maxSubsequence += Math.max(firstPatternCharCount, secondPatternCharCount);\\n        } else if (firstPatternCharCount == 0 && secondPatternCharCount == 0){\\n            maxSubsequence = 0;\\n        } else {\\n            maxSubsequence = Math.max(firstPatternCharCount, secondPatternCharCount);\\n        }\\n        return maxSubsequence;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long maxSubsequence = 0;\\n        char ch, firstPatternChar = pattern.charAt(0), secondPatternChar = pattern.charAt(1);\\n        int firstPatternCharCount = 0, secondPatternCharCount = 0;\\n        boolean samePatternChars = firstPatternChar == secondPatternChar;\\n        for (int i = text.length() - 1; i >=0; i--) {\\n            ch = text.charAt(i);\\n            if (ch == firstPatternChar) {\\n                firstPatternCharCount++;\\n                if (samePatternChars) {\\n                    secondPatternCharCount = firstPatternCharCount - 1;\\n                }\\n                maxSubsequence += secondPatternCharCount;\\n            } else if (ch == secondPatternChar) {\\n                secondPatternCharCount++;\\n            }\\n        }\\n        if (firstPatternCharCount > 0 && secondPatternCharCount > 0) {\\n            maxSubsequence += Math.max(firstPatternCharCount, secondPatternCharCount);\\n        } else if (firstPatternCharCount == 0 && secondPatternCharCount == 0){\\n            maxSubsequence = 0;\\n        } else {\\n            maxSubsequence = Math.max(firstPatternCharCount, secondPatternCharCount);\\n        }\\n        return maxSubsequence;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892974,
                "title": "golang-greedy-solution",
                "content": "# Code\\n```\\nfunc maximumSubsequenceCount(text string, pattern string) int64 {\\n  var a, b int\\n  // We keep track of a (pattern[0]) and b (pattern[1]) and join\\n  // a and b\\n  for i := 0; i < len(text); i++ {\\n    if text[i] == pattern[1] {\\n      b++\\n    }\\n  }\\n  max := b\\n  var res int64\\n  for i := 0; i < len(text); i++ {\\n    if text[i] == pattern[1] {\\n      b--\\n    }\\n    if text[i] == pattern[0] {\\n      a++\\n      res += int64(b)\\n    }\\n    if a > max {\\n      max = a\\n    }\\n  }\\n  // It is always optimal to either add the first character in the front or the\\n  // last character in the end. We do that based on the maximum occurrence of either a or b\\n  return res + int64(max)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc maximumSubsequenceCount(text string, pattern string) int64 {\\n  var a, b int\\n  // We keep track of a (pattern[0]) and b (pattern[1]) and join\\n  // a and b\\n  for i := 0; i < len(text); i++ {\\n    if text[i] == pattern[1] {\\n      b++\\n    }\\n  }\\n  max := b\\n  var res int64\\n  for i := 0; i < len(text); i++ {\\n    if text[i] == pattern[1] {\\n      b--\\n    }\\n    if text[i] == pattern[0] {\\n      a++\\n      res += int64(b)\\n    }\\n    if a > max {\\n      max = a\\n    }\\n  }\\n  // It is always optimal to either add the first character in the front or the\\n  // last character in the end. We do that based on the maximum occurrence of either a or b\\n  return res + int64(max)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855219,
                "title": "c-clean-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string r) {\\n        map<char,int> p;\\n        // Adding r[0] at the front of the string.\\n        p[r[0]]++;\\n        long long int a=0,s=0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==r[1])\\n            s+=p[r[0]];\\n            if(t[i]==r[0])\\n            p[r[0]]++;\\n        }\\n        a=max(a,s);\\n        s=0;\\n        p.clear();\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==r[1])\\n            s+=p[r[0]];\\n            if(t[i]==r[0])\\n            p[r[0]]++;\\n        }\\n        // Adding r[1] at the end of the string.\\n        s+=p[r[0]];\\n        a=max(a,s);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string r) {\\n        map<char,int> p;\\n        // Adding r[0] at the front of the string.\\n        p[r[0]]++;\\n        long long int a=0,s=0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==r[1])\\n            s+=p[r[0]];\\n            if(t[i]==r[0])\\n            p[r[0]]++;\\n        }\\n        a=max(a,s);\\n        s=0;\\n        p.clear();\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==r[1])\\n            s+=p[r[0]];\\n            if(t[i]==r[0])\\n            p[r[0]]++;\\n        }\\n        // Adding r[1] at the end of the string.\\n        s+=p[r[0]];\\n        a=max(a,s);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809438,
                "title": "java-using-for-loop-and-counters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        int adding = 0;\\n        long count = 0;\\n        long result = 0;\\n        while(adding < 2){\\n        String modified = \"\";\\n        //first character in pattern can be added at the beginning of the string\\n        if(adding==0) modified = String.valueOf(pattern.charAt(adding)) + text;\\n        //or second character in pattern can be added at the end of the string\\n        else modified = text + String.valueOf(pattern.charAt(adding)) ;\\n        \\n        long c1 = 0;\\n        long c2 = 0;\\n        \\n        for(int i = 0; i<modified.length();i++){\\n            char c = modified.charAt(i);\\n            if(c == pattern.charAt(1)){\\n                c2 = c2 + c1;\\n                result = Math.max(result,c2);\\n            } \\n            if(c == pattern.charAt(0)){\\n                c1++;\\n            }\\n        }\\n        adding++;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        int adding = 0;\\n        long count = 0;\\n        long result = 0;\\n        while(adding < 2){\\n        String modified = \"\";\\n        //first character in pattern can be added at the beginning of the string\\n        if(adding==0) modified = String.valueOf(pattern.charAt(adding)) + text;\\n        //or second character in pattern can be added at the end of the string\\n        else modified = text + String.valueOf(pattern.charAt(adding)) ;\\n        \\n        long c1 = 0;\\n        long c2 = 0;\\n        \\n        for(int i = 0; i<modified.length();i++){\\n            char c = modified.charAt(i);\\n            if(c == pattern.charAt(1)){\\n                c2 = c2 + c1;\\n                result = Math.max(result,c2);\\n            } \\n            if(c == pattern.charAt(0)){\\n                c1++;\\n            }\\n        }\\n        adding++;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773453,
                "title": "cpp-dp-solution-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,int j,string &s,string &t, vector<vector<long long>> &dp){\\n        if(j==0) return 1;\\n        if(i<0) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long long tk=0;\\n        if(s[i]==t[j-1]) tk = solve(i-1,j-1,s,t,dp);\\n        long long nottk = solve(i-1,j,s,t,dp);\\n        \\n        return dp[i][j] = tk+nottk;\\n    }\\n    long long maximumSubsequenceCount(string s, string t) {\\n        int n = s.size()+1;\\n        int ct0=0,ct1=0;\\n        vector<vector<long long>> dp(n+1,vector<long long>(3,-1));\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]==t[0]) ct0++;\\n            else if(s[i]==t[1]) ct1++;\\n        }\\n        \\n        long long ans=0;\\n        if(ct1<=ct0){\\n            s.push_back(t[1]);\\n            ans = max(ans,solve(n-1,2,s,t,dp));\\n        }\\n        else{\\n            string ch;\\n            ch += t[0];\\n            s.insert(0,ch);\\n            ans = max(ans,solve(n-1,2,s,t,dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,int j,string &s,string &t, vector<vector<long long>> &dp){\\n        if(j==0) return 1;\\n        if(i<0) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long long tk=0;\\n        if(s[i]==t[j-1]) tk = solve(i-1,j-1,s,t,dp);\\n        long long nottk = solve(i-1,j,s,t,dp);\\n        \\n        return dp[i][j] = tk+nottk;\\n    }\\n    long long maximumSubsequenceCount(string s, string t) {\\n        int n = s.size()+1;\\n        int ct0=0,ct1=0;\\n        vector<vector<long long>> dp(n+1,vector<long long>(3,-1));\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]==t[0]) ct0++;\\n            else if(s[i]==t[1]) ct1++;\\n        }\\n        \\n        long long ans=0;\\n        if(ct1<=ct0){\\n            s.push_back(t[1]);\\n            ans = max(ans,solve(n-1,2,s,t,dp));\\n        }\\n        else{\\n            string ch;\\n            ch += t[0];\\n            s.insert(0,ch);\\n            ans = max(ans,solve(n-1,2,s,t,dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751733,
                "title": "python-one-line",
                "content": "One line lmao\\n# Code\\n```\\nclass Solution:\\n     maximumSubsequenceCount = lambda self, text, pattern, thing=[0, 0]: ([thing := [thing[0] + 1 if i == pattern[0] else thing[0], thing[1]+thing[0] if i == pattern[1] else thing[1]] for i in text][-1][1] + max(text.count(pattern[1]), text.count(pattern[0]))) if pattern[0] != pattern[1] else (int) ((k := text.count(pattern[0])) * (1 + k) / 2)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n     maximumSubsequenceCount = lambda self, text, pattern, thing=[0, 0]: ([thing := [thing[0] + 1 if i == pattern[0] else thing[0], thing[1]+thing[0] if i == pattern[1] else thing[1]] for i in text][-1][1] + max(text.count(pattern[1]), text.count(pattern[0]))) if pattern[0] != pattern[1] else (int) ((k := text.count(pattern[0])) * (1 + k) / 2)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695192,
                "title": "c-o-n-solution-beats-99-3-pure-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long int l=text.length(),ct=0,ct_1=0,ct_2=0;\\n        long long int i=0,temp=0;\\n        long long int n=text.length();\\n        if(pattern[0]==pattern[1]){\\n            for(int j=0;j<n;j++){\\n                if(text[j]==pattern[0]) ct_1++;\\n            }\\n            ct+=(ct_1*(ct_1-1))/2;\\n            ct+=ct_1;\\n            return ct;\\n        }\\n        while(i<n){\\n            if(text[i]==pattern[0]){\\n                temp+=1; ct_1++;\\n            }\\n            else if(text[i]==pattern[1]){\\n                ct+=temp; ct_2++;\\n            }\\n            i++;\\n        }\\n        if(ct_1>ct_2){\\n            ct+=ct_1;\\n        }\\n        else ct+=ct_2;\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long int l=text.length(),ct=0,ct_1=0,ct_2=0;\\n        long long int i=0,temp=0;\\n        long long int n=text.length();\\n        if(pattern[0]==pattern[1]){\\n            for(int j=0;j<n;j++){\\n                if(text[j]==pattern[0]) ct_1++;\\n            }\\n            ct+=(ct_1*(ct_1-1))/2;\\n            ct+=ct_1;\\n            return ct;\\n        }\\n        while(i<n){\\n            if(text[i]==pattern[0]){\\n                temp+=1; ct_1++;\\n            }\\n            else if(text[i]==pattern[1]){\\n                ct+=temp; ct_2++;\\n            }\\n            i++;\\n        }\\n        if(ct_1>ct_2){\\n            ct+=ct_1;\\n        }\\n        else ct+=ct_2;\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689583,
                "title": "c-solution-beats-98-46-in-runtime",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is easy to see that whether inserting pattern[0] or pattern[1] will maximize the result depends on the number of pattern[0] or pattern[1] in the text.\\nSo the remaining task is to count how many times that pattern appears in that text. For each pattern[1] in the text, the number of times that pattern appears is equal to the number of times that pattern[0] occurs before. Thus we only need to traverse the text once for each character.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char ch1 = pattern[0];\\n        char ch2 = pattern[1];\\n        //the case in which ch1 ==ch2\\n        if (ch1 == ch2){\\n            long long count=0;\\n            for (char ch : text)\\n                if(ch==ch1) count++;\\n            return (count+1)*count/2;\\n        }\\n        //the case in which ch1!=ch2\\n        long long count1=0, count2=0,sub=0;\\n        for(char ch : text){\\n            if (ch == ch1) count1++;\\n            if (ch == ch2){\\n                count2++;\\n                sub+=count1;\\n            }\\n        }\\n        return sub + max(count1,count2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char ch1 = pattern[0];\\n        char ch2 = pattern[1];\\n        //the case in which ch1 ==ch2\\n        if (ch1 == ch2){\\n            long long count=0;\\n            for (char ch : text)\\n                if(ch==ch1) count++;\\n            return (count+1)*count/2;\\n        }\\n        //the case in which ch1!=ch2\\n        long long count1=0, count2=0,sub=0;\\n        for(char ch : text){\\n            if (ch == ch1) count1++;\\n            if (ch == ch2){\\n                count2++;\\n                sub+=count1;\\n            }\\n        }\\n        return sub + max(count1,count2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643132,
                "title": "explained-exploring-an-optimized-approach",
                "content": "**Solution:**\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        if pattern[0] == pattern[1]:\\n            c = text.count(pattern[0])\\n            return sum(range(c + 1))\\n        count = 0\\n        c0 = 0\\n        c1 = 0\\n        for ch in text:\\n            if ch == pattern[0]:\\n                c0 += 1\\n            elif ch == pattern[1]:\\n                c1 += 1\\n                count += c0\\n        return count + max(c1, c0)\\n```\\n\\n**Introduction:**\\nIn this article, we will delve into an optimized solution to find the maximum number of times a given pattern can occur as a subsequence in modified text. We will explore the logic, main idea, and time and space complexity of the solution.\\n\\n**Problem Statement:**\\nGiven a text string and a pattern string, both consisting of only lowercase English letters, we need to determine the maximum number of times the pattern can occur as a subsequence in the modified text. The modification involves adding one of the characters from the pattern anywhere in the text exactly once.\\n\\n**Solution Approach:**\\nWe will utilize a concise and efficient approach to solve the problem at hand. The main idea is to count the occurrences of the two characters in the pattern within the text and calculate the maximum number of subsequences based on these counts.\\n\\n**Detailed Explanation:**\\n1. Handle the special case:\\n   - Check if both characters in the pattern are the same.\\n   - If they are the same, count the number of occurrences of that character in the text using the `count()` function. Let\\'s call this count `c`.\\n   - Return the sum of the first `c` positive integers using the `sum(range(c + 1))` formula. This represents the maximum number of subsequences formed by repeating the character multiple times.\\n\\n2. Handle the general case:\\n   - Initialize the variables `count`, `c0`, and `c1` to keep track of counts for the two characters in the pattern.\\n   - Iterate through each character `ch` in the text:\\n     - If `ch` matches the first character in the pattern, increment the count `c0` for that character.\\n     - If `ch` matches the second character in the pattern:\\n       - Increment the count `c1` for that character.\\n       - Add the current value of `c0` to the `count` variable. This accounts for the subsequences formed by combining the second character with all the occurrences of the first character before it.\\n\\n3. Return the maximum count:\\n   - After the loop, return the sum of `count` and the maximum value between `c1` and `c0`. This accounts for any remaining occurrences of either character at the end of the text.\\n\\nTime Complexity Analysis:\\nThe time complexity of this solution is O(n), where n is the length of the input text. Here\\'s the breakdown:\\n- The initial check for the special case takes constant time.\\n- The loop iterates through each character in the text, resulting in O(n) time complexity.\\n- The `count()` function used to count occurrences has a time complexity of O(n), but it is only called once in the special case.\\n- The subsequent operations in the loop, such as comparisons and incrementing counts, are constant-time operations.\\n\\n**Space Complexity Analysis:**\\nThe space complexity of this solution is O(1) since it does not require any extra space that grows with the input size. It only uses a few additional variables to store counts and perform calculations.\\n\\n**Conclusion**:\\nIn this article, we explored an optimized solution to find the maximum number of times a given pattern can occur as a subsequence in modified text. We discussed the logic and main idea behind the solution, which involves counting occurrences of the pattern\\'s characters and calculating the maximum number of subsequences based on these counts. The solution has a time complexity of O(n) and a space complexity of O(1), making it an efficient approach for this problem.\\n\\nNote: The provided solution in this article has been tested and verified to produce the correct results for the given problem and constraints.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        if pattern[0] == pattern[1]:\\n            c = text.count(pattern[0])\\n            return sum(range(c + 1))\\n        count = 0\\n        c0 = 0\\n        c1 = 0\\n        for ch in text:\\n            if ch == pattern[0]:\\n                c0 += 1\\n            elif ch == pattern[1]:\\n                c1 += 1\\n                count += c0\\n        return count + max(c1, c0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633095,
                "title": "java-easy-solution-greedy",
                "content": "\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        List<int[]> list = new ArrayList();\\n        int pat0[] = new int[text.length()];\\n        int count0=0, count1=0;\\n        for(int i=0; i<text.length(); i++){\\n            if(text.charAt(i)==pattern.charAt(0)){\\n                count0+=1;\\n            }\\n            pat0[i] = count0;\\n        }\\n        if(pattern.charAt(0)==pattern.charAt(1)){\\n            long n=count0;\\n            return n*(n+1)/2;\\n        }\\n        for(int i=text.length()-1; i>=0; i--){\\n            if(text.charAt(i)==pattern.charAt(1)){\\n                count1++;\\n                list.add(new int[]{pat0[i],count1});\\n            }\\n        }\\n        long ans1 = 0;\\n        for(int []arr:list){\\n            ans1+=((long)arr[0]+1);\\n        }\\n        long ans2 = 0;\\n        for(int []arr:list){\\n            ans2+=(long)arr[0];\\n        }\\n        ans2+=count0;\\n        return ans1>ans2?ans1:ans2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\n//RITIK PATEL\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        List<int[]> list = new ArrayList();\\n        int pat0[] = new int[text.length()];\\n        int count0=0, count1=0;\\n        for(int i=0; i<text.length(); i++){\\n            if(text.charAt(i)==pattern.charAt(0)){\\n                count0+=1;\\n            }\\n            pat0[i] = count0;\\n        }\\n        if(pattern.charAt(0)==pattern.charAt(1)){\\n            long n=count0;\\n            return n*(n+1)/2;\\n        }\\n        for(int i=text.length()-1; i>=0; i--){\\n            if(text.charAt(i)==pattern.charAt(1)){\\n                count1++;\\n                list.add(new int[]{pat0[i],count1});\\n            }\\n        }\\n        long ans1 = 0;\\n        for(int []arr:list){\\n            ans1+=((long)arr[0]+1);\\n        }\\n        long ans2 = 0;\\n        for(int []arr:list){\\n            ans2+=(long)arr[0];\\n        }\\n        ans2+=count0;\\n        return ans1>ans2?ans1:ans2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622618,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans = 0;\\n        long long mx = 0;\\n        int p1 = 1,p2 = 0;\\n        for(int i=0; i<text.length(); i++){\\n            if(text[i]==pattern[1]){\\n                mx += p1;\\n            }\\n            if(text[i]==pattern[0]){\\n                p1++;\\n            }\\n        }\\n        ans = max(mx,ans);\\n        mx = 0;\\n        p1 = 0;\\n        p2 = 1;\\n        for(int i=text.length()-1; i>=0; i--){\\n            if(text[i]==pattern[0]){\\n                mx += p2;\\n            }\\n            if(text[i]==pattern[1]){\\n                p2++;\\n            }\\n        }\\n        ans = max(mx,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans = 0;\\n        long long mx = 0;\\n        int p1 = 1,p2 = 0;\\n        for(int i=0; i<text.length(); i++){\\n            if(text[i]==pattern[1]){\\n                mx += p1;\\n            }\\n            if(text[i]==pattern[0]){\\n                p1++;\\n            }\\n        }\\n        ans = max(mx,ans);\\n        mx = 0;\\n        p1 = 0;\\n        p2 = 1;\\n        for(int i=text.length()-1; i>=0; i--){\\n            if(text[i]==pattern[0]){\\n                mx += p2;\\n            }\\n            if(text[i]==pattern[1]){\\n                p2++;\\n            }\\n        }\\n        ans = max(mx,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552059,
                "title": "easy-cpp",
                "content": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern)\\n    {\\n        char f=pattern[0],s=pattern[1];\\n        long long l=0,r=0,ans=0;\\n        \\n        for(int i=0;text[i];i++)\\n            if(text[i]==s)\\n                r++;\\n        int tmp=r;\\n        for(int i=0;text[i];i++)\\n        {\\n            if(text[i]==s)\\n                tmp--;\\n            if(text[i]==f)\\n            {\\n                l++;\\n                ans+=tmp;\\n            }\\n        }\\n        if(l>=r)\\n            ans+=l;\\n        else\\n            ans+=r;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern)\\n    {\\n        char f=pattern[0],s=pattern[1];\\n        long long l=0,r=0,ans=0;\\n        \\n        for(int i=0;text[i];i++)\\n            if(text[i]==s)\\n                r++;\\n        int tmp=r;\\n        for(int i=0;text[i];i++)\\n        {\\n            if(text[i]==s)\\n                tmp--;\\n            if(text[i]==f)\\n            {\\n                l++;\\n                ans+=tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3544237,
                "title": "python3-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        \\n        def helper(c):\\n            return sum(ch==c for ch in text)\\n        \\n        count=0\\n        c1,c2=pattern[0],pattern[1]\\n        \\n        prefix=[]\\n        for i,ch in enumerate(text):\\n            if ch==c2:\\n                count+=1\\n            prefix.append(count)\\n            \\n            \\n        res=0\\n        for i,ch in enumerate(text):\\n            if ch==c1:\\n                res+=prefix[-1]-prefix[i]\\n        \\n        return res+max(helper(c1),helper(c2))\\n    \\n    \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        \\n        def helper(c):\\n            return sum(ch==c for ch in text)\\n        \\n        count=0\\n        c1,c2=pattern[0],pattern[1]\\n        \\n        prefix=[]\\n        for i,ch in enumerate(text):\\n            if ch==c2:\\n                count+=1\\n            prefix.append(count)\\n            \\n            \\n        res=0\\n        for i,ch in enumerate(text):\\n            if ch==c1:\\n                res+=prefix[-1]-prefix[i]\\n        \\n        return res+max(helper(c1),helper(c2))\\n    \\n    \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497724,
                "title": "easy-simple-c-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char c1 = pattern[0],c2 = pattern[1];\\n        long long ans = 0,cnt1=0,cnt2=0;\\n        for(int i=0;i<text.size();i++){\\n            if(text[i]==c2){\\n                ans+=cnt1;\\n                cnt2++;\\n            }\\n            if(text[i]==c1) cnt1++;\\n        }\\n        return ans+max(cnt1,cnt2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        char c1 = pattern[0],c2 = pattern[1];\\n        long long ans = 0,cnt1=0,cnt2=0;\\n        for(int i=0;i<text.size();i++){\\n            if(text[i]==c2){\\n                ans+=cnt1;\\n                cnt2++;\\n            }\\n            if(text[i]==c1) cnt1++;\\n        }\\n        return ans+max(cnt1,cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445573,
                "title": "java-2-pass-straightword",
                "content": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long res1 = helper(pattern.charAt(0)+text, pattern);\\n        long res2 = helper(new StringBuilder(text+pattern.charAt(1)).reverse().toString(), new StringBuilder(pattern).reverse().toString());\\n        return res1>res2?res1:res2;\\n    }\\n    \\n    public long helper(String text, String pattern){\\n        long res= 0;\\n        int c1 = 0;\\n        for(int i=text.length()-1;i>=0;i--){\\n            char c = text.charAt(i);\\n            if(c==pattern.charAt(1)){\\n                c1++;\\n            }\\n            else if(c==pattern.charAt(0)){\\n                res += c1;\\n            }\\n        }\\n        if(pattern.charAt(0)==pattern.charAt(1)){\\n            while(--c1>0){\\n                res+=c1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long res1 = helper(pattern.charAt(0)+text, pattern);\\n        long res2 = helper(new StringBuilder(text+pattern.charAt(1)).reverse().toString(), new StringBuilder(pattern).reverse().toString());\\n        return res1>res2?res1:res2;\\n    }\\n    \\n    public long helper(String text, String pattern){\\n        long res= 0;\\n        int c1 = 0;\\n        for(int i=text.length()-1;i>=0;i--){\\n            char c = text.charAt(i);\\n            if(c==pattern.charAt(1)){\\n                c1++;\\n            }\\n            else if(c==pattern.charAt(0)){\\n                res += c1;\\n            }\\n        }\\n        if(pattern.charAt(0)==pattern.charAt(1)){\\n            while(--c1>0){\\n                res+=c1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436382,
                "title": "c-clean-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long res = 0;\\n        pair<int,int> p;\\n        for (char c : text) {\\n            if (c == pattern[0]) ++ p.first;\\n            if (c == pattern[1]) {\\n                ++ p.second;\\n                res += p.first - (pattern[0] == pattern[1]);\\n            }\\n        }\\n        return res + max(p.first, p.second);\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long res = 0;\\n        pair<int,int> p;\\n        for (char c : text) {\\n            if (c == pattern[0]) ++ p.first;\\n            if (c == pattern[1]) {\\n                ++ p.second;\\n                res += p.first - (pattern[0] == pattern[1]);\\n            }\\n        }\\n        return res + max(p.first, p.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432463,
                "title": "short",
                "content": "**time: `O(N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/b7dea999-b05d-40c2-8679-cd5b03008afc_1681849188.6519413.png)\\n\\n```\\nlong long maximumSubsequenceCount(string t, string p)\\n{       \\n\\tlong long out{}, X{1}, Y{1};\\n\\tfor(const auto & t : t)\\n\\t{\\n\\t\\t out += X*(t==p[1]);\\n\\t\\t X   +=    t==p[0]; \\n\\t\\t Y   +=    t==p[1];\\n\\t}\\n\\treturn max(out, out+X-Y);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long maximumSubsequenceCount(string t, string p)\\n{       \\n\\tlong long out{}, X{1}, Y{1};\\n\\tfor(const auto & t : t)\\n\\t{\\n\\t\\t out += X*(t==p[1]);\\n\\t\\t X   +=    t==p[0]; \\n\\t\\t Y   +=    t==p[1];\\n\\t}\\n\\treturn max(out, out+X-Y);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3390442,
                "title": "o-n-2-loops-intuition-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} text\\n * @param {string} pattern\\n * @return {number}\\n */\\nvar maximumSubsequenceCount = function(text, pattern) {\\n    const count = [0,0];\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) count[0]++;\\n        if (text[i] === pattern[1]) count[1]++;\\n    }\\n\\n    if (count[0] > count[1]) {\\n        text = text + pattern[1];\\n        count[1]++;\\n    } else {\\n        text = pattern[0] + text;\\n        count[0]++;\\n    }\\n\\n    let total = 0;\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) total += count[1];\\n        if (text[i] === pattern[1]) count[1]--;\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @param {string} pattern\\n * @return {number}\\n */\\nvar maximumSubsequenceCount = function(text, pattern) {\\n    const count = [0,0];\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) count[0]++;\\n        if (text[i] === pattern[1]) count[1]++;\\n    }\\n\\n    if (count[0] > count[1]) {\\n        text = text + pattern[1];\\n        count[1]++;\\n    } else {\\n        text = pattern[0] + text;\\n        count[0]++;\\n    }\\n\\n    let total = 0;\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) total += count[1];\\n        if (text[i] === pattern[1]) count[1]--;\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364140,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maximumSubsequenceCount(text: String, pattern: String): Long = {\\n        val resL = text.foldLeft(1L,0L){(acc, cur) => {\\n            val resL = if(cur == pattern.last) acc._2 + acc._1 else acc._2\\n            (acc._1 + (if(cur == pattern.head) 1 else 0), resL)\\n        }}\\n        val resR = text.reverse.foldLeft(1L, 0L) { (acc, cur) => {\\n            val resL = if (cur == pattern.head) acc._2 + acc._1 else acc._2\\n            (acc._1 + (if (cur == pattern.last) 1 else 0), resL)\\n        }}\\n        resL._2 max resR._2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maximumSubsequenceCount(text: String, pattern: String): Long = {\\n        val resL = text.foldLeft(1L,0L){(acc, cur) => {\\n            val resL = if(cur == pattern.last) acc._2 + acc._1 else acc._2\\n            (acc._1 + (if(cur == pattern.head) 1 else 0), resL)\\n        }}\\n        val resR = text.reverse.foldLeft(1L, 0L) { (acc, cur) => {\\n            val resL = if (cur == pattern.head) acc._2 + acc._1 else acc._2\\n            (acc._1 + (if (cur == pattern.last) 1 else 0), resL)\\n        }}\\n        resL._2 max resR._2\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3336238,
                "title": "easy-c-solution-must-see",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int a=0;\\n        long long ans1=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                a++;\\n            }\\n            else if(text[i]==pattern[1])\\n            {\\n                ans1=ans1+(a+1);\\n            }\\n        }\\n        long long ans2=0;\\n        a=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                a++;\\n            }\\n            else if(text[i]==pattern[1])\\n            {\\n                ans2=ans2+a;\\n            }\\n        }\\n        ans2=ans2+a;\\n        if(pattern[0]==pattern[1])\\n        {\\n            return max((ans1*(ans1+1))/2,(ans2*(ans2+1))/2);\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int a=0;\\n        long long ans1=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                a++;\\n            }\\n            else if(text[i]==pattern[1])\\n            {\\n                ans1=ans1+(a+1);\\n            }\\n        }\\n        long long ans2=0;\\n        a=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                a++;\\n            }\\n            else if(text[i]==pattern[1])\\n            {\\n                ans2=ans2+a;\\n            }\\n        }\\n        ans2=ans2+a;\\n        if(pattern[0]==pattern[1])\\n        {\\n            return max((ans1*(ans1+1))/2,(ans2*(ans2+1))/2);\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311743,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int count0 = 0, count1 = 0;\\n        long long ans = 0;\\n        for(char ch: text) { \\n            if(ch == pattern[0]) {\\n                count0++;\\n            } else if(ch == pattern[1]) {\\n                count1++;\\n                ans += count0;\\n            }\\n        }\\n        if(pattern[0] == pattern[1]) return count0 * 1L * (count0 + 1) / 2;\\n        return ans + max(count1, count0);\\n    }\\n};\\n\\n\\n// Golang\\nfunc maximumSubsequenceCount(text string, pattern string) int64 {\\n    var count0, count1 int = 0, 0\\n    var ans int64 = 0\\n    for _, ch := range text { \\n        if byte(ch) == pattern[0] {\\n            count0++\\n        } else if byte(ch) == pattern[1] {\\n            count1++\\n            ans += int64(count0)\\n        }\\n    }\\n    if pattern[0] == pattern[1] {return int64(count0) * int64(count0 + 1) / 2}\\n    if count0 > count1 {\\n        ans += int64(count0)\\n    } else {\\n        ans += int64(count1)\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int count0 = 0, count1 = 0;\\n        long long ans = 0;\\n        for(char ch: text) { \\n            if(ch == pattern[0]) {\\n                count0++;\\n            } else if(ch == pattern[1]) {\\n                count1++;\\n                ans += count0;\\n            }\\n        }\\n        if(pattern[0] == pattern[1]) return count0 * 1L * (count0 + 1) / 2;\\n        return ans + max(count1, count0);\\n    }\\n};\\n\\n\\n// Golang\\nfunc maximumSubsequenceCount(text string, pattern string) int64 {\\n    var count0, count1 int = 0, 0\\n    var ans int64 = 0\\n    for _, ch := range text { \\n        if byte(ch) == pattern[0] {\\n            count0++\\n        } else if byte(ch) == pattern[1] {\\n            count1++\\n            ans += int64(count0)\\n        }\\n    }\\n    if pattern[0] == pattern[1] {return int64(count0) * int64(count0 + 1) / 2}\\n    if count0 > count1 {\\n        ans += int64(count0)\\n    } else {\\n        ans += int64(count1)\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309689,
                "title": "veryyy-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(string t,string p){\\n        unordered_map<char,int>m;\\n        long long ans=0;\\n\\n        for(int i=0;i<t.size();i++){\\n            if(t[i]==p[1])ans+=m[p[0]];\\n            if(t[i]==p[0])m[p[0]]++;\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string t, string p) {\\n        long long ans=max(f(p[0]+t,p),f(t+p[1],p));\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(string t,string p){\\n        unordered_map<char,int>m;\\n        long long ans=0;\\n\\n        for(int i=0;i<t.size();i++){\\n            if(t[i]==p[1])ans+=m[p[0]];\\n            if(t[i]==p[0])m[p[0]]++;\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string t, string p) {\\n        long long ans=max(f(p[0]+t,p),f(t+p[1],p));\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270298,
                "title": "c-fast-easy",
                "content": "class Solution {\\npublic:\\n\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans1=0, ans2=0;\\n        string s1 = pattern[0] + text;\\n        string s2= text + pattern[1];\\n        long long count=0;\\n        // when we insert pattern[0] at the first of the text\\n        for(int i=0;i<s1.size();i++){\\n            if(s1[i]==pattern[0]){\\n                count++;\\n            }\\n            else if(s1[i]==pattern[1]){\\n                ans1 +=count;\\n            }\\n        }\\n         // when we insert pattern[0] at the end of the text\\n        count=0;\\n        for(int i=s2.size()-1;i>=0;i--){\\n            if(s2[i]==pattern[1]){\\n                count++;\\n            }\\n            else if(s2[i]==pattern[0]){\\n                ans2 += count;\\n            }\\n        }\\n        \\n        if(pattern[0]==pattern[1]){\\n            ans2 = (count * (count-1)/2);\\n        }\\n        return max(ans1,ans2);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans1=0, ans2=0;\\n        string s1 = pattern[0] + text;\\n        string s2= text + pattern[1];\\n        long long count=0;\\n        // when we insert pattern[0] at the first of the text\\n        for(int i=0;i<s1.size();i++){\\n            if(s1[i]==pattern[0]){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3253980,
                "title": "greedy-prefix-sum-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can maximize the count of the given subsequence by either adding pat[0] at the very beginning or pat[1] at the very end.\\n\\nWhy? \\nText: \"b z b\"\\nPat: \"a b\"\\n\\nOnly when you add pat[0] = \\'a\\' to the very beginning on the text, you can pair with all the available b\\'s on the right side maximizing the number of subsequence. It doesnot make sense to place \\'a\\' after the first \\'b\\'. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhenever you encounter pat[1] on index i, add number of pat[0]\\'s seen before index i. \\n\\nAt the very end, account for the greedy approach by adding either number of pat[0] seen or the number pat[1] seen to the solution. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        int n = text.size();\\n        int numLeft = 0; \\n        int numRight = 0; \\n\\n        long long sol = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(text[i] == pat[1]) {\\n                numRight++;\\n                sol+= numLeft;    \\n            }\\n            if(text[i] == pat[0]) numLeft++;\\n        }\\n\\n        // account for greedy approach\\n        return max(sol + numLeft, sol + numRight);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        int n = text.size();\\n        int numLeft = 0; \\n        int numRight = 0; \\n\\n        long long sol = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(text[i] == pat[1]) {\\n                numRight++;\\n                sol+= numLeft;    \\n            }\\n            if(text[i] == pat[0]) numLeft++;\\n        }\\n\\n        // account for greedy approach\\n        return max(sol + numLeft, sol + numRight);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216082,
                "title": "java-o-n-time",
                "content": "- Logic:\\n    - make a subsequence of current string for example:\\n    - **aba**cd**b**gbw**ba**h**ab**h -> subsequence will be: **ababbbaab** with pattern \"ab\"\\n    - Now for such string we can calculate directly pairs with mathematices.\\n    - iterate over this subsequence, Keep track of a\\'s and b\\'s count while iterating and permute the possible pairs\\n    - for example a\\'s and b\\'s count is [4,5] for ababbbaab\\n    - for first iteration (first a), **a**babbbaab there are 5 b\\'s ahead of it, so add 5 in ans.\\n    - now remove a\\'s count from count [4,5]->[3,5]\\n    - now go further for second character, a**b**abbbaab\\n    - just decrease count of b so as for next a, there will be less number of b\\'s that can make subsequence. count [3,5]->[3,4]\\n    - do recursively till any of count becomes 0.\\n    - as a part of adding one of the character from text to the main string, think it as mathematically.\\n    - for ababbbaab we can add the a or b, but substring count will be maximized (add a in left corner or b in right corner). that is ans+= Max(count of a, count of b). I have added this at the start only.\\n    - Special case: if both of pattern are same chars then this is a combination question which will give nc2 (n*(n-1)/2) subsequence pairs.\\n\\n</br>\\n\\n- Time complexity: **O(N)**\\n\\n- Space complexity: **O(1)** (can be optimized to O(1) instead of using toCharArray in code with simple forEach loop)\\n- \\n# Code\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] count=new int[2];\\n        \\n        // make a subsequence of current string\\n        for(char ch: text.toCharArray()){\\n            if(pattern.charAt(0)==ch){\\n                count[0]++;\\n                sb.append(ch);\\n            }\\n            else if(pattern.charAt(1)==ch){\\n                count[1]++;\\n                sb.append(ch);\\n            }\\n                \\n        }\\n\\n        String str=sb.toString();\\n        long ans=0;\\n\\n        // special case\\n        if(pattern.charAt(0)==pattern.charAt(1)){\\n            long n=str.length()+1;\\n            ans=n*(n-1)/2;\\n            return ans;\\n        }\\n        // for ababbbaab we can add the a or b, but substring count will be maximized (add a in left corner or b in right corner). that is ans+= Max(count of a, count of b)\\n        ans+=count[0]>count[1]?count[0]:count[1];\\n\\n        for(char c: str.toCharArray()){\\n            // do recursively till any of count becomes 0.\\n            if(count[0]==0 || count[1]==0) break;\\n            if(c==pattern.charAt(0)){\\n                ans+=count[1];\\n                count[0]--;\\n            }\\n            else{\\n                count[1]--;\\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```\\n\\n\\n\\n\\n# More Precise Solution of same version :\\n\\n```\\nclass Solution{\\n    public long maximumSubsequenceCount(String s, String pattern) {\\n        long res = 0, cnt1 = 0, cnt2 = 0;\\n        for (int i = 0; i < s.length(); ++i) {   \\n            if (s.charAt(i) == pattern.charAt(1)) {   \\n                res += cnt1; \\n                cnt2++;\\n            }\\n            if (s.charAt(i) == pattern.charAt(0)) {   \\n                cnt1++;\\n            }\\n        }\\n        return res + Math.max(cnt1, cnt2);\\n    }\\n}\\n```\\n\\nCan be found: https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/solutions/1863900/java-c-python-straight-forward-solution/",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] count=new int[2];\\n        \\n        // make a subsequence of current string\\n        for(char ch: text.toCharArray()){\\n            if(pattern.charAt(0)==ch){\\n                count[0]++;\\n                sb.append(ch);\\n            }\\n            else if(pattern.charAt(1)==ch){\\n                count[1]++;\\n                sb.append(ch);\\n            }\\n                \\n        }\\n\\n        String str=sb.toString();\\n        long ans=0;\\n\\n        // special case\\n        if(pattern.charAt(0)==pattern.charAt(1)){\\n            long n=str.length()+1;\\n            ans=n*(n-1)/2;\\n            return ans;\\n        }\\n        // for ababbbaab we can add the a or b, but substring count will be maximized (add a in left corner or b in right corner). that is ans+= Max(count of a, count of b)\\n        ans+=count[0]>count[1]?count[0]:count[1];\\n\\n        for(char c: str.toCharArray()){\\n            // do recursively till any of count becomes 0.\\n            if(count[0]==0 || count[1]==0) break;\\n            if(c==pattern.charAt(0)){\\n                ans+=count[1];\\n                count[0]--;\\n            }\\n            else{\\n                count[1]--;\\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```\n```\\nclass Solution{\\n    public long maximumSubsequenceCount(String s, String pattern) {\\n        long res = 0, cnt1 = 0, cnt2 = 0;\\n        for (int i = 0; i < s.length(); ++i) {   \\n            if (s.charAt(i) == pattern.charAt(1)) {   \\n                res += cnt1; \\n                cnt2++;\\n            }\\n            if (s.charAt(i) == pattern.charAt(0)) {   \\n                cnt1++;\\n            }\\n        }\\n        return res + Math.max(cnt1, cnt2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155777,
                "title": "using-dp-not-soo-good-but-a-possibility",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(string &s,string &t){\\n        int n=size(s)+1,m=size(t)+1;\\n        vector<vector<long long>> dp(n,vector<long long> (m,1));\\n        dp[0][1]=0;\\n        dp[0][2]=0;\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                long long m=0,nm=dp[i-1][j];\\n                if(s[i-1]==t[j-1])\\n                m=dp[i-1][j-1];\\n                dp[i][j]=m+nm;\\n            }\\n        }\\n        return dp[n-1][m-1];\\n\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string s1=pattern[0]+text, s2=text+pattern[1];\\n        int n=text.length()+2;\\n        cout<<s1;\\n        return max(f(s1,pattern),f(s2,pattern));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(string &s,string &t){\\n        int n=size(s)+1,m=size(t)+1;\\n        vector<vector<long long>> dp(n,vector<long long> (m,1));\\n        dp[0][1]=0;\\n        dp[0][2]=0;\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                long long m=0,nm=dp[i-1][j];\\n                if(s[i-1]==t[j-1])\\n                m=dp[i-1][j-1];\\n                dp[i][j]=m+nm;\\n            }\\n        }\\n        return dp[n-1][m-1];\\n\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string s1=pattern[0]+text, s2=text+pattern[1];\\n        int n=text.length()+2;\\n        cout<<s1;\\n        return max(f(s1,pattern),f(s2,pattern));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3120573,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int countF = 0, countS = 0;\\n        for (auto& c : text){\\n            countF += c == pattern[0];\\n            countS += c == pattern[1];\\n        }\\n        long long ans = max(countF, countS);\\n        for (auto& c : text){\\n            countF -= c == pattern[0];\\n            countS -= c == pattern[1];\\n            if (c == pattern[0]) ans += countS;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int countF = 0, countS = 0;\\n        for (auto& c : text){\\n            countF += c == pattern[0];\\n            countS += c == pattern[1];\\n        }\\n        long long ans = max(countF, countS);\\n        for (auto& c : text){\\n            countF -= c == pattern[0];\\n            countS -= c == pattern[1];\\n            if (c == pattern[0]) ans += countS;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985390,
                "title": "python-o-n-explanation",
                "content": "Technique is best shown with an example:\\n\\ntext = aabb\\npattern = ab\\n\\ncnt1 is the count of pattern[0] (\\'a\\') we encounter in text \\ncnt2 is the count of pattern[1] (\\'b\\') we encounter in text\\nttl tracks each pattern[1] (\\'b) we encounter, and when we encounter a \\'b\\', we want to add the number of \\'a\\' we have encountered so far. This basically tracks the number of subsequences we have without adding a letter from pattern. Upon returning the final result, we will return this number along with the max count of either pattern[0] or pattern[1] as the count will add this count to the total number of subsequences.\\n\\n**a**abb - cnt1 = 1, cnt2 = 0, ttl = 0  \\na**a**bb - cnt1 = 2, cnt2 = 0, ttl = 0\\naa**b**b - cnt1 = 2, cnt2 = 1, ttl = 2\\naab**b** - cnt1 = 2, cnt2 = 2, ttl = 4\\n\\nWe have 4 subsequences without adding a letter from pattern. We don\\'t have to think about specifically where in the text we want to add pattern[0] or pattern[1] - they take full effect (add the most amount of subsequences) by either adding pattern[0] at the beginning of the text or pattern[1] at the end of the text. Therefore, as the count for both a and b is 2, we add 2 to the ttl, to give us 6. \\n\\nIf the text was aaabb, we can see that by adding b at the end we will garner 3 more subsequences (3 is the count of \\'a\\', in this case we would\\'ve returned ttl + max(3,2)).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n\\n        cnt1 = cnt2 = 0\\n        ttl = 0\\n\\n        for ch in text:\\n            if ch == pattern[1]:\\n                cnt2 += 1\\n                ttl += cnt1\\n            if ch == pattern[0]:\\n                cnt1 += 1\\n        return ttl + max(cnt1,cnt2)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n\\n        cnt1 = cnt2 = 0\\n        ttl = 0\\n\\n        for ch in text:\\n            if ch == pattern[1]:\\n                cnt2 += 1\\n                ttl += cnt1\\n            if ch == pattern[0]:\\n                cnt1 += 1\\n        return ttl + max(cnt1,cnt2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975354,
                "title": "very-easy-solution-simple-observation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string p) {\\n        long long int ans = 0;\\n        int p1c = 0, p2c = 0;\\n        for(char c: text){\\n            if(p[0] == c) p1c++;\\n            if(p[1] == c) p2c++;\\n        }\\n        if(p[0] == p[1]){\\n            ans = p1c;\\n            // we have to return n!\\n            return (ans*(ans+1))/2;\\n        }\\n        if(p1c == 0 && p2c == 0) return 0;\\n        if(p1c == 0) return p2c;\\n        if(p2c == 0) return p1c;\\n        int t = p2c;\\n        for(char c: text){\\n            if(p[0] == c) ans += t;\\n            if(p[1] == c) t--;\\n        }\\n        if(p1c >= p2c) return ans + p1c;\\n        return ans+p2c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string p) {\\n        long long int ans = 0;\\n        int p1c = 0, p2c = 0;\\n        for(char c: text){\\n            if(p[0] == c) p1c++;\\n            if(p[1] == c) p2c++;\\n        }\\n        if(p[0] == p[1]){\\n            ans = p1c;\\n            // we have to return n!\\n            return (ans*(ans+1))/2;\\n        }\\n        if(p1c == 0 && p2c == 0) return 0;\\n        if(p1c == 0) return p2c;\\n        if(p2c == 0) return p1c;\\n        int t = p2c;\\n        for(char c: text){\\n            if(p[0] == c) ans += t;\\n            if(p[1] == c) t--;\\n        }\\n        if(p1c >= p2c) return ans + p1c;\\n        return ans+p2c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942598,
                "title": "c-clean-solution-single-pass-o-n-time",
                "content": "# Approach\\n- count1 counts the number of occurences of pattern[1] when pattern[0] is added in the beginnning. Hence, we add count1 to sum1 in the end.\\n- count2 counts the number of occurences of pattern[1] when pattern[1] is added in the end. Hence, it starts from 1.\\n- sum1 and sum2 measure the sum in two cases.\\n- We use two ifs instead of if and else if in order to cover the case when pattern[0] == pattern[1].\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long sum1 = 0;\\n        long long sum2 = 0;\\n        \\n        int len = text.size();\\n        int count1 = 0;\\n        int count2 = 1;\\n        \\n        for(int i = len-1; i >= 0; i--){\\n            if (text[i] == pattern[0]){\\n                sum1 += count1;\\n                sum2 += count2;\\n            }\\n            if(text[i] == pattern[1]){\\n                count1++;\\n                count2++;\\n            }\\n        }\\n        sum1 += count1;\\n\\n        return max(sum1, sum2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long sum1 = 0;\\n        long long sum2 = 0;\\n        \\n        int len = text.size();\\n        int count1 = 0;\\n        int count2 = 1;\\n        \\n        for(int i = len-1; i >= 0; i--){\\n            if (text[i] == pattern[0]){\\n                sum1 += count1;\\n                sum2 += count2;\\n            }\\n            if(text[i] == pattern[1]){\\n                count1++;\\n                count2++;\\n            }\\n        }\\n        sum1 += count1;\\n\\n        return max(sum1, sum2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926677,
                "title": "c-scan-and-choose-the-char-with-max-occurrence",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        // count of pat[0] and pat[1], respectively\\n        int64_t cnt0 = 0, cnt1 = 0;\\n        int64_t occ = 0; // occurrences of the subseq\\n        const char p0 = pattern[0], p1 = pattern[1];\\n        for (char c : text) {\\n            if (c == p1) {\\n                occ += cnt0;\\n                ++cnt1;\\n            }\\n            if (c == p0) {\\n                ++cnt0;\\n            }\\n        }\\n        return occ + max(cnt0, cnt1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        // count of pat[0] and pat[1], respectively\\n        int64_t cnt0 = 0, cnt1 = 0;\\n        int64_t occ = 0; // occurrences of the subseq\\n        const char p0 = pattern[0], p1 = pattern[1];\\n        for (char c : text) {\\n            if (c == p1) {\\n                occ += cnt0;\\n                ++cnt1;\\n            }\\n            if (c == p0) {\\n                ++cnt0;\\n            }\\n        }\\n        return occ + max(cnt0, cnt1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924418,
                "title": "c-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdding the least occurring character of the pattern would give us the maximum answer as it would increase the answer by the count of most occurring character in the string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long int n = text.size();\\n\\n        long long int first = 0;\\n        long long int second = 0;\\n\\n        long long int ans = 0;\\n\\n        for(int i=0;i<n;++i){\\n            if(text[i] == pattern[1]) {\\n                second++;\\n                ans += first;\\n            }\\n            if(text[i] == pattern[0]) first++;\\n        }\\n\\n        ans += max(first, second);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long int n = text.size();\\n\\n        long long int first = 0;\\n        long long int second = 0;\\n\\n        long long int ans = 0;\\n\\n        for(int i=0;i<n;++i){\\n            if(text[i] == pattern[1]) {\\n                second++;\\n                ans += first;\\n            }\\n            if(text[i] == pattern[0]) first++;\\n        }\\n\\n        ans += max(first, second);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914703,
                "title": "c-easy-understanding-o-n-time-complexity-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Idea is very simple here , we can get the maximum number of subsequence only in two cases.\\n2. First case is we add the first-character of the pattern in the beginning of the string .\\n3. Second case is we add the last-character of the pattern in the end of string.\\n4. The main challange is to find the number of subsequences in O(n) time complexity , as in the constraint it is given n can go upto 10^5.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Consider two cases\\n2. First case we add pattern[0] in the begining of the text string \\n3. Second case we add pattern[1] in the end of the text string\\n4. Now we traverse the string from back , we keep the count of the pattern[1] in text string , if we encounter pattern[0] in the text string , add the count of pattern[1] string to the total result.\\n\\nFor eg: Text=\"abcab\"\\n        Pattern=\"ab\"\\n\\nCASE-1: Text=aabcab\\n\\n        text[5]==\\'b\\' , tempCount=1  , totalCount=0\\n        text[4]==\\'a\\' , tempCount=1 , totalCount=1\\n        text[2]==\\'b\\' , tempCount=2 , totalCount=1;\\n        text[1]==\\'a\\' , tempCount=2  , totalCount=3\\n        text[0]==\\'a\\'  , tempCount=2  , totalCount=5\\nResult=5\\n\\nSimilarily we can do for case-2\\n\\nCASE-2: Text=abcabb\\n\\n         text[5]==\\'b\\' , tempCount=1 , totalCount=0\\n         text[4]==\\'b\\' , tempCount=2 , totalCount=0\\n         text[3]==\\'a\\' , tempCount=2  , totalCount=2\\n         text[1]==\\'b\\' , tempCount=3 , totalCount=2\\n         text[0]==\\'a\\' , tempCount=3 , totalCount=5\\nResult=5\\n\\nwe Return max(CASE-1,CASE-2)\\n\\nNOTE: One of the edge cases of this question is when pattern[0]==pattern[1]\\n\\n5. We handle this seperately\\n6. Count total number of pattern[0] in the text string\\n7. Add the count to total count and decrement count \\n\\nEG: text=\"abczz\"\\n    pattern=\"zz\"\\n\\nWe know the answer will be \"abczzz\"\\n\\n    text[5]==\\'z\\'  , countOfZ=1, totalCount=0\\n    text[4]==\\'z\\'  , countOfZ=2 , totalCount=1\\n    text[3]==\\'z\\'  , counntOfZ=3, totalCount=3\\n\\nResult=3\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Time complexity: O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxOccurance(string text,string pattern)\\n    {\\n        char firstChar=pattern[0];\\n        char secondChar=pattern[1];\\n        int n=text.length();\\n\\n        long long totalCount=0;\\n        long long tempCount=0;\\n\\n        if(firstChar!=secondChar){\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(text[i]==secondChar)tempCount+=1;\\n\\n            else if(text[i]==firstChar)totalCount+=tempCount;\\n        }\\n        }\\n       \\n\\n      \\n        \\n\\n        \\n        return totalCount;\\n    }\\n\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n\\n        if(pattern[0]==pattern[1])\\n        {\\n            int count=0;\\n            for(int i=0;i<text.length();i++)\\n            {\\n                if(text[i]==pattern[0])count++;\\n            }\\n            long long  res=0;\\n            while(count!=0)\\n            {\\n                res+=count;\\n\\n                count--;\\n            }\\n\\n            return res;\\n        }\\n        \\n        long long res=0;\\n         int n=text.length();\\n         long long maxRes=INT_MIN;\\n\\n         char a=pattern[0];\\n         string a1;\\n         a1+=a;\\n\\n\\n         char b=pattern[1];\\n         string b1;\\n         b1+=b;\\n\\n        // cout<<a1<<\" \"<<b1;\\n        \\n        string temp=text;\\n        temp.insert(0,a1);\\n        maxRes=max(maxRes,maxOccurance(temp,pattern));\\n\\n        temp=text;\\n        temp.insert(n,b1);\\n       // cout<<temp;\\n        maxRes=max(maxRes,maxOccurance(temp,pattern));\\n\\n\\n        return maxRes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxOccurance(string text,string pattern)\\n    {\\n        char firstChar=pattern[0];\\n        char secondChar=pattern[1];\\n        int n=text.length();\\n\\n        long long totalCount=0;\\n        long long tempCount=0;\\n\\n        if(firstChar!=secondChar){\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(text[i]==secondChar)tempCount+=1;\\n\\n            else if(text[i]==firstChar)totalCount+=tempCount;\\n        }\\n        }\\n       \\n\\n      \\n        \\n\\n        \\n        return totalCount;\\n    }\\n\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n\\n        if(pattern[0]==pattern[1])\\n        {\\n            int count=0;\\n            for(int i=0;i<text.length();i++)\\n            {\\n                if(text[i]==pattern[0])count++;\\n            }\\n            long long  res=0;\\n            while(count!=0)\\n            {\\n                res+=count;\\n\\n                count--;\\n            }\\n\\n            return res;\\n        }\\n        \\n        long long res=0;\\n         int n=text.length();\\n         long long maxRes=INT_MIN;\\n\\n         char a=pattern[0];\\n         string a1;\\n         a1+=a;\\n\\n\\n         char b=pattern[1];\\n         string b1;\\n         b1+=b;\\n\\n        // cout<<a1<<\" \"<<b1;\\n        \\n        string temp=text;\\n        temp.insert(0,a1);\\n        maxRes=max(maxRes,maxOccurance(temp,pattern));\\n\\n        temp=text;\\n        temp.insert(n,b1);\\n       // cout<<temp;\\n        maxRes=max(maxRes,maxOccurance(temp,pattern));\\n\\n\\n        return maxRes;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2913754,
                "title": "c-tc-o-n-simple-solution-easy-to-understand",
                "content": "\\tlong long maximumSubsequenceCount(string text, string pattern) {\\n        long long count = 1 , c1 = 0 ,c2 = 0, ans = 0;\\n        \\n        //adding pattern[0] at starting \\n        for(int i = 0;  i < text.length(); i++){\\n            if(text[i] == pattern[1]){\\n                c1 += count;\\n            }\\n            if(text[i] == pattern[0])count++;\\n        }\\n        \\n        count = 1;\\n        \\n        // adding pattern[1] at ending...\\n        for(int i = text.length()-1;  i >= 0; i--){\\n            if(text[i] == pattern[0]){\\n                c2 += count;\\n            }\\n            if(text[i] == pattern[1])count++;\\n        }\\n        \\n        return max(c1,c2);\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "\\tlong long maximumSubsequenceCount(string text, string pattern) {\\n        long long count = 1 , c1 = 0 ,c2 = 0, ans = 0;\\n        \\n        //adding pattern[0] at starting \\n        for(int i = 0;  i < text.length(); i++){\\n            if(text[i] == pattern[1]){\\n                c1 += count;\\n            }\\n            if(text[i] == pattern[0])count++;\\n        }\\n        \\n        count = 1;\\n        \\n        // adding pattern[1] at ending...\\n        for(int i = text.length()-1;  i >= 0; i--){\\n            if(text[i] == pattern[0]){\\n                c2 += count;\\n            }\\n            if(text[i] == pattern[1])count++;\\n        }\\n        \\n        return max(c1,c2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2913644,
                "title": "very-easy-solution-o-n-faster-than-97",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string s;\\n        for(auto x : text){\\n            if(x==pattern[0] || x==pattern[1])s+=x;\\n        }\\n        if(pattern[0]==pattern[1]){\\n            long long n=s.length();\\n            return (n*(n+1))/2;\\n        }\\n        int i=s.length()-1,cnt=0;\\n        long long ans=0;\\n        while(i>=0){\\n            int ind=i;\\n            while(i>=0 && s[i]==pattern[1])i--;\\n            cnt+=ind-i;\\n            while(i>=0 && s[i]==pattern[0]){\\n                ans+=cnt;\\n                i--;\\n            }\\n        }\\n        if(cnt<s.length()-cnt)ans+=(s.length()-cnt);\\n        else ans+=cnt;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string s;\\n        for(auto x : text){\\n            if(x==pattern[0] || x==pattern[1])s+=x;\\n        }\\n        if(pattern[0]==pattern[1]){\\n            long long n=s.length();\\n            return (n*(n+1))/2;\\n        }\\n        int i=s.length()-1,cnt=0;\\n        long long ans=0;\\n        while(i>=0){\\n            int ind=i;\\n            while(i>=0 && s[i]==pattern[1])i--;\\n            cnt+=ind-i;\\n            while(i>=0 && s[i]==pattern[0]){\\n                ans+=cnt;\\n                i--;\\n            }\\n        }\\n        if(cnt<s.length()-cnt)ans+=(s.length()-cnt);\\n        else ans+=cnt;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913598,
                "title": "c-very-easy-solution",
                "content": "```\\n long long maximumSubsequenceCount(string text, string pattern) {\\n      \\n    long long ans1 = 0 , ans2 = 0 ;\\n        \\n    int n = text.size();\\n        \\n        int prefix[n] ;\\n        int suffix[n] ;\\n        \\n        long long int count1 = 0 ,  count2 = 0 ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            if( text[i] == pattern[0] )\\n            {\\n                count1++ ;\\n            }\\n            \\n            if( text[i] == pattern[1] )\\n            {\\n                prefix[i] = count1 ;\\n            }\\n        }\\n        \\n        for( int i = n-1 ; i >= 0 ; i-- )\\n        {\\n            if( text[i] == pattern[1] )\\n            {\\n                count2++ ;\\n            }\\n            \\n            if( text[i] == pattern[0] )\\n            {\\n                suffix[i] = count2 ;\\n            }\\n        }\\n        \\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            if( text[i] == pattern[1] )\\n            {\\n                ans1 += prefix[i] ;\\n            }\\n            \\n            if( text[i] == pattern[0] )\\n            {\\n                ans2 += suffix[i] ;\\n            }\\n        }\\n        \\n        if( pattern[0] == pattern[1] )\\n        {\\n            return count1*(count1+1)/2 ;\\n        }\\n        \\n        \\n        return max( ans1 + count1 , ans2 + count2 ) ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n long long maximumSubsequenceCount(string text, string pattern) {\\n      \\n    long long ans1 = 0 , ans2 = 0 ;\\n        \\n    int n = text.size();\\n        \\n        int prefix[n] ;\\n        int suffix[n] ;\\n        \\n        long long int count1 = 0 ,  count2 = 0 ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            if( text[i] == pattern[0] )\\n            {\\n                count1++ ;\\n            }\\n            \\n            if( text[i] == pattern[1] )\\n            {\\n                prefix[i] = count1 ;\\n            }\\n        }\\n        \\n        for( int i = n-1 ; i >= 0 ; i-- )\\n        {\\n            if( text[i] == pattern[1] )\\n            {\\n                count2++ ;\\n            }\\n            \\n            if( text[i] == pattern[0] )\\n            {\\n                suffix[i] = count2 ;\\n            }\\n        }\\n        \\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            if( text[i] == pattern[1] )\\n            {\\n                ans1 += prefix[i] ;\\n            }\\n            \\n            if( text[i] == pattern[0] )\\n            {\\n                ans2 += suffix[i] ;\\n            }\\n        }\\n        \\n        if( pattern[0] == pattern[1] )\\n        {\\n            return count1*(count1+1)/2 ;\\n        }\\n        \\n        \\n        return max( ans1 + count1 , ans2 + count2 ) ;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2913397,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tlong long maximumSubsequenceCount(string t, string p) {\\n\\t\\tlong long ans = 0, ctFirstchar = 0, ctSecondChar = 0;\\n\\n\\t\\tfor (auto &e : t) {\\n\\t\\t\\tif (e == p[1]) {\\n\\t\\t\\t\\tans += ctFirstchar;\\n\\t\\t\\t\\tctSecondChar++;\\n\\t\\t\\t}\\n\\t\\t\\tif (e == p[0]) ctFirstchar++;\\n\\t\\t}\\n\\t\\treturn ans + max(ctFirstchar, ctSecondChar);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long maximumSubsequenceCount(string t, string p) {\\n\\t\\tlong long ans = 0, ctFirstchar = 0, ctSecondChar = 0;\\n\\n\\t\\tfor (auto &e : t) {\\n\\t\\t\\tif (e == p[1]) {\\n\\t\\t\\t\\tans += ctFirstchar;\\n\\t\\t\\t\\tctSecondChar++;\\n\\t\\t\\t}\\n\\t\\t\\tif (e == p[0]) ctFirstchar++;\\n\\t\\t}\\n\\t\\treturn ans + max(ctFirstchar, ctSecondChar);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893628,
                "title": "java-greedy",
                "content": "# Intuition\\nFor maximum profit, the best option is to put pattern[0] at the beginning and pattern[1] at the end. \\n\\n# Approach\\nConstruct two strings of the same and traverse them keeping the count of how many times the corresponding character has occured. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n\\n        //O(1) approach\\n\\n        char pat0 = pattern.charAt(0);\\n        char pat1 = pattern.charAt(1);\\n\\n        String text0 = pat0 + text;\\n        String text1 = text + pat1;\\n\\n        int cnt0 = 0, cnt1 = 0;\\n        long res0 = 0, res1 = 0;\\n\\n        int n = text0.length(); //text1.length();\\n\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            char ch = text0.charAt(i);\\n            if(ch == pat1)  res0 += cnt0;\\n            if(ch == pat0) ++cnt0;\\n\\n            int j = n - i - 1;\\n            ch = text1.charAt(j);\\n            if(ch == pat0) res1 += cnt1;\\n            if(ch == pat1) cnt1++;\\n        }\\n\\n        return Math.max(res0, res1);\\n \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n\\n        //O(1) approach\\n\\n        char pat0 = pattern.charAt(0);\\n        char pat1 = pattern.charAt(1);\\n\\n        String text0 = pat0 + text;\\n        String text1 = text + pat1;\\n\\n        int cnt0 = 0, cnt1 = 0;\\n        long res0 = 0, res1 = 0;\\n\\n        int n = text0.length(); //text1.length();\\n\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            char ch = text0.charAt(i);\\n            if(ch == pat1)  res0 += cnt0;\\n            if(ch == pat0) ++cnt0;\\n\\n            int j = n - i - 1;\\n            ch = text1.charAt(j);\\n            if(ch == pat0) res1 += cnt1;\\n            if(ch == pat1) cnt1++;\\n        }\\n\\n        return Math.max(res0, res1);\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830565,
                "title": "c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long fun(string t,string p)\\n    {\\n        long long prefix[t.size()];\\n        long long count=0,res=0;\\n        for(int i=t.size()-1;i>=0;i--)\\n        {\\n            prefix[i]=count;\\n            if(t[i]==p[1]) count++;\\n        }\\n        \\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==p[0])\\n            {\\n                res+=prefix[i];\\n            }\\n        }\\n        return res;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        return max(fun(pattern[0]+text,pattern),fun(text+pattern[1],pattern));\\n    }\\n    /*long long count(string s,string p){\\n        long long ans=0,c=0;\\n         if(p[0]==p[1])\\n        {\\n            long long ans=0;\\n            for(int i=0; i<s.size(); i++)\\n                if(s[i]==p[0])\\n                    ans++;\\n            return ans*(ans-1)/2;\\n        }\\n        for(auto x:s){\\n            if(x==p[0]){\\n                c++;\\n            }\\n            else if(x==p[1]){\\n                ans+=c;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int f=count(pattern[0]+text,pattern);\\n        int l=count(text+pattern[1],pattern);\\n        return max(f,l);\\n    }*/\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long fun(string t,string p)\\n    {\\n        long long prefix[t.size()];\\n        long long count=0,res=0;\\n        for(int i=t.size()-1;i>=0;i--)\\n        {\\n            prefix[i]=count;\\n            if(t[i]==p[1]) count++;\\n        }\\n        \\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]==p[0])\\n            {\\n                res+=prefix[i];\\n            }\\n        }\\n        return res;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        return max(fun(pattern[0]+text,pattern),fun(text+pattern[1],pattern));\\n    }\\n    /*long long count(string s,string p){\\n        long long ans=0,c=0;\\n         if(p[0]==p[1])\\n        {\\n            long long ans=0;\\n            for(int i=0; i<s.size(); i++)\\n                if(s[i]==p[0])\\n                    ans++;\\n            return ans*(ans-1)/2;\\n        }\\n        for(auto x:s){\\n            if(x==p[0]){\\n                c++;\\n            }\\n            else if(x==p[1]){\\n                ans+=c;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int f=count(pattern[0]+text,pattern);\\n        int l=count(text+pattern[1],pattern);\\n        return max(f,l);\\n    }*/\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828588,
                "title": "easy-to-understand-c-sol",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        string a=\"\",b=\"\";\\n        \\n        a+=p[0];b+=t;a+=t;b+=p[1];\\n        if(p[0]==p[1]){\\n            ll c=count(t.begin(),t.end(),p[0]);\\n            return c*(c+1)/2;\\n        }\\n        ll cnt1=0,cnt2=0,cnt=0;\\n        for(ll i=0;i<a.size();i++){\\n            if(a[i]==p[0])cnt++;\\n            if(a[i]==p[1])cnt1+=cnt;\\n        }\\n        cnt=0;\\n        for(ll i=0;i<b.size();i++){\\n            if(b[i]==p[0])cnt++;\\n            if(b[i]==p[1])cnt2+=cnt;\\n        }\\n        return max(cnt1,cnt2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        string a=\"\",b=\"\";\\n        \\n        a+=p[0];b+=t;a+=t;b+=p[1];\\n        if(p[0]==p[1]){\\n            ll c=count(t.begin(),t.end(),p[0]);\\n            return c*(c+1)/2;\\n        }\\n        ll cnt1=0,cnt2=0,cnt=0;\\n        for(ll i=0;i<a.size();i++){\\n            if(a[i]==p[0])cnt++;\\n            if(a[i]==p[1])cnt1+=cnt;\\n        }\\n        cnt=0;\\n        for(ll i=0;i<b.size();i++){\\n            if(b[i]==p[0])cnt++;\\n            if(b[i]==p[1])cnt2+=cnt;\\n        }\\n        return max(cnt1,cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794426,
                "title": "c-easy-understanding-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        int n = text.size();\\n        vector<int> first,second;\\n        long long ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((text[i] == pattern[0]))\\n            {\\n              first.push_back(i);\\n            }else if(text[i] == pattern[1])\\n            {\\n                second.push_back(i);\\n            }\\n        }\\n        \\n        if(pattern[0] == pattern[1]){\\n            long long n = first.size()+1;\\n            ans = n*(n-1)/2;\\n            return ans;\\n        }\\n        \\n        for(int i=0;i<first.size();i++)\\n        {\\n            int l=0;\\n            int h = second.size()-1;\\n            while(l<=h)\\n            {\\n                int mid = (l+(h-l)/2);\\n                if(second[mid]>first[i])\\n                {\\n                    h = mid-1;\\n                }else{\\n                    l = mid+1;\\n                }\\n            }\\n            \\n            ans += second.size()-l;\\n            cout<<l<<endl;\\n        }\\n        // cout<<ans<<endl;\\n        if(first.size()>second.size())\\n        {\\n            ans += first.size();\\n        }else{\\n            ans += second.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        int n = text.size();\\n        vector<int> first,second;\\n        long long ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((text[i] == pattern[0]))\\n            {\\n              first.push_back(i);\\n            }else if(text[i] == pattern[1])\\n            {\\n                second.push_back(i);\\n            }\\n        }\\n        \\n        if(pattern[0] == pattern[1]){\\n            long long n = first.size()+1;\\n            ans = n*(n-1)/2;\\n            return ans;\\n        }\\n        \\n        for(int i=0;i<first.size();i++)\\n        {\\n            int l=0;\\n            int h = second.size()-1;\\n            while(l<=h)\\n            {\\n                int mid = (l+(h-l)/2);\\n                if(second[mid]>first[i])\\n                {\\n                    h = mid-1;\\n                }else{\\n                    l = mid+1;\\n                }\\n            }\\n            \\n            ans += second.size()-l;\\n            cout<<l<<endl;\\n        }\\n        // cout<<ans<<endl;\\n        if(first.size()>second.size())\\n        {\\n            ans += first.size();\\n        }else{\\n            ans += second.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2754147,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        n = len(text)\\n        adder = 0\\n        res = 0\\n        n_1 = 0\\n        n_2 = 0\\n        for i in range(n-1,-1,-1):\\n            if text[i] == pattern[0]:\\n                res += adder\\n                n_1 += 1\\n            if text[i] == pattern[1]:\\n                adder += 1\\n                n_2 += 1\\n           \\n        \\n        return res + max(n_1,n_2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        n = len(text)\\n        adder = 0\\n        res = 0\\n        n_1 = 0\\n        n_2 = 0\\n        for i in range(n-1,-1,-1):\\n            if text[i] == pattern[0]:\\n                res += adder\\n                n_1 += 1\\n            if text[i] == pattern[1]:\\n                adder += 1\\n                n_2 += 1\\n           \\n        \\n        return res + max(n_1,n_2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720942,
                "title": "c-add-to-first-add-to-last-equal-pattern",
                "content": "consider three cases:\\n// case 0: first char equal to second char\\n// case 1: add first char in the left\\n\\tonce hit second, add all cur first pattern count to result\\n// case 2: add second char in the right\\n\\tafter counting first and second pattern, add all frist patter count again\\n\\t\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans1 = 0, ans2 = 0, count;\\n        int i, n = text.size();\\n        \\n        // case 0: first char equal to second char\\n        if(pattern[0] == pattern[1])\\n        {\\n            count = 0;\\n            for(i = 0; i < n; i++)\\n            {\\n                if(text[i] == pattern[0])\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            return (count+1) * count / 2;\\n        }\\n        \\n        // case 1: add first char in the left\\n        count = 1;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n            {\\n                count++;\\n            }\\n            if(text[i] == pattern[1])\\n            {\\n                ans1 += count;\\n            }\\n        }\\n\\n        // case 2: add second char in the right\\n        count = 0;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n            {\\n                count++;\\n            }\\n            if(text[i] == pattern[1])\\n            {\\n                ans2 += count;\\n            }\\n        }\\n        ans2 += count;\\n        \\n        return (ans1 > ans2) ? ans1 : ans2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long ans1 = 0, ans2 = 0, count;\\n        int i, n = text.size();\\n        \\n        // case 0: first char equal to second char\\n        if(pattern[0] == pattern[1])\\n        {\\n            count = 0;\\n            for(i = 0; i < n; i++)\\n            {\\n                if(text[i] == pattern[0])\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            return (count+1) * count / 2;\\n        }\\n        \\n        // case 1: add first char in the left\\n        count = 1;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n            {\\n                count++;\\n            }\\n            if(text[i] == pattern[1])\\n            {\\n                ans1 += count;\\n            }\\n        }\\n\\n        // case 2: add second char in the right\\n        count = 0;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n            {\\n                count++;\\n            }\\n            if(text[i] == pattern[1])\\n            {\\n                ans2 += count;\\n            }\\n        }\\n        ans2 += count;\\n        \\n        return (ans1 > ans2) ? ans1 : ans2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684699,
                "title": "java-easy-solution-maximize-number-of-subsequences-in-a-string-without-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n         int countFirst = 0;\\n         int countSecond = 0;\\n         long ans = 0;\\n        for(int i=0;i<text.length();i++){\\n          if(text.charAt(i)==pattern.charAt(1))\\n            {\\n              ans += countFirst;\\n              countSecond++;\\n            }\\n            if(text.charAt(i)==pattern.charAt(0)){\\n              countFirst++;\\n            }\\n        }\\n        ans += Math.max(countFirst,countSecond);\\n        return ans;\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n         int countFirst = 0;\\n         int countSecond = 0;\\n         long ans = 0;\\n        for(int i=0;i<text.length();i++){\\n          if(text.charAt(i)==pattern.charAt(1))\\n            {\\n              ans += countFirst;\\n              countSecond++;\\n            }\\n            if(text.charAt(i)==pattern.charAt(0)){\\n              countFirst++;\\n            }\\n        }\\n        ans += Math.max(countFirst,countSecond);\\n        return ans;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629071,
                "title": "python-simple-counters",
                "content": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        cb=0\\n        ps=[]\\n        for i in range(len(text)):\\n            if text[i]==pattern[0] or text[i]==pattern[1]:\\n                ps.append(text[i])\\n                if text[i]==pattern[1]:\\n                    cb+=1\\n        ss=\"\".join(ps)\\n        if pattern[0]==pattern[1]:\\n            return ((len(ss)*(len(ss)+1))//2)\\n        def cnt(s,cb):\\n            ans=0\\n            for x in s:\\n                if x==pattern[0]:ans+=cb\\n                else:cb-=1\\n            return ans\\n        if len(ps)==0:return 0\\n        return max(cnt(pattern[0]+ss,cb),cnt(ss+pattern[1],cb+1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        cb=0\\n        ps=[]\\n        for i in range(len(text)):\\n            if text[i]==pattern[0] or text[i]==pattern[1]:\\n                ps.append(text[i])\\n                if text[i]==pattern[1]:\\n                    cb+=1\\n        ss=\"\".join(ps)\\n        if pattern[0]==pattern[1]:\\n            return ((len(ss)*(len(ss)+1))//2)\\n        def cnt(s,cb):\\n            ans=0\\n            for x in s:\\n                if x==pattern[0]:ans+=cb\\n                else:cb-=1\\n            return ans\\n        if len(ps)==0:return 0\\n        return max(cnt(pattern[0]+ss,cb),cnt(ss+pattern[1],cb+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624642,
                "title": "add-first-add-last-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int ct=1;\\n        long long sum1=0,sum2=0;\\n        for(int i=text.size()-1;i>=0;i--)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                sum1+=ct;\\n                sum2+=ct-1;\\n            }\\n            if(text[i]==pattern[1])\\n            {\\n                ct++;\\n            }\\n        }\\n        sum2+=ct-1;\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int ct=1;\\n        long long sum1=0,sum2=0;\\n        for(int i=text.size()-1;i>=0;i--)\\n        {\\n            if(text[i]==pattern[0])\\n            {\\n                sum1+=ct;\\n                sum2+=ct-1;\\n            }\\n            if(text[i]==pattern[1])\\n            {\\n                ct++;\\n            }\\n        }\\n        sum2+=ct-1;\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605415,
                "title": "java-o-n-with-explanation-first-last-insertion",
                "content": "We can either add pattern[0] or pattern[1] to the string.\\nWe need to find max no of SUBSEQUENCE of pattern as a string So if we either :\\n* add pattern[0] to the start, it will contribute maximum to our count of subsequence\\n*  add pattern[1] to the end, it will contribute maximum our count of subsequence.\\n\\n\\n So we run 2 condition in a single loop 1 from left to right with i & other from right to left with j\\n let pattern =\"ac\":\\n* then counting the occurence of \\'c\\' when I move from left to right would give me subsequences till that point ( This counts the case that I have added \"a\" to start of string )\\n*  & counting the occurence of \\'a\\' when I move from right to left would give me subsequence till that point ( This counts the case that I have added \"c\" to the end of the string )\\n\\n\\n In the end return max of both counts.\\n\\n```\\n\\nclass Solution {\\n        public long maximumSubsequenceCount(String text, String pattern) {\\n            long a=1,b=1,res1 = 0,res2 = 0,n = text.length();\\n            for(int i=0, j = (int)(n-1);i<n;i++,--j){\\n                if(pattern.charAt(1) == text.charAt(i)){\\n                    res1 += a;\\n                }\\n                if(text.charAt(i) == pattern.charAt(0)) a++;\\n                if(pattern.charAt(0) == text.charAt(j))\\n                    res2 += b;\\n                if(text.charAt(j) == pattern.charAt(1)) b++;\\n            }\\n\\n            return Math.max(res1, res2);\\n        }\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n        public long maximumSubsequenceCount(String text, String pattern) {\\n            long a=1,b=1,res1 = 0,res2 = 0,n = text.length();\\n            for(int i=0, j = (int)(n-1);i<n;i++,--j){\\n                if(pattern.charAt(1) == text.charAt(i)){\\n                    res1 += a;\\n                }\\n                if(text.charAt(i) == pattern.charAt(0)) a++;\\n                if(pattern.charAt(0) == text.charAt(j))\\n                    res2 += b;\\n                if(text.charAt(j) == pattern.charAt(1)) b++;\\n            }\\n\\n            return Math.max(res1, res2);\\n        }\\n    }\\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2598673,
                "title": "concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        long long cnt1 = 0, cnt2 = 0, fr1 = 0, fr2 = 0, a = 0;\\n        string t1 = p[0] + t, t2 = t + p[1];\\n        \\n        for(char c : t1) {\\n            if(c == p[0]) fr1++, a++;\\n            if(c == p[1]) cnt1 += fr1;\\n        }\\n        for(char c : t2) {\\n            if(c == p[0]) fr2++;\\n            if(c == p[1]) cnt2 += fr2;\\n        }\\n        \\n        return p[0] == p[1] ? (a * (a - 1)) / 2 : max(cnt1, cnt2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p) {\\n        long long cnt1 = 0, cnt2 = 0, fr1 = 0, fr2 = 0, a = 0;\\n        string t1 = p[0] + t, t2 = t + p[1];\\n        \\n        for(char c : t1) {\\n            if(c == p[0]) fr1++, a++;\\n            if(c == p[1]) cnt1 += fr1;\\n        }\\n        for(char c : t2) {\\n            if(c == p[0]) fr2++;\\n            if(c == p[1]) cnt2 += fr2;\\n        }\\n        \\n        return p[0] == p[1] ? (a * (a - 1)) / 2 : max(cnt1, cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545447,
                "title": "c-add-to-first-or-last",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long maximumSubsequenceCount(string text, string pattern) {\\n\\t\\t\\tfunction<long long(string,string)> recur=[&](string text,string pattern){\\n\\t\\t\\t\\tint p2=count(text.begin(),text.end(),pattern[1]);\\n\\t\\t\\t\\tlong long res=0;\\n\\t\\t\\t\\tfor(int i=0;i<text.length();i++) {\\n\\t\\t\\t\\t\\tif(text[i]==pattern[1]) p2--;\\n\\t\\t\\t\\t\\tif(text[i]==pattern[0]) {\\n\\t\\t\\t\\t\\t\\tres+=p2;  \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t};\\n\\t\\t\\treturn max(recur(pattern[0]+text,pattern),\\n\\t\\t\\t\\t\\t  recur(text+pattern[1],pattern));\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long maximumSubsequenceCount(string text, string pattern) {\\n\\t\\t\\tfunction<long long(string,string)> recur=[&](string text,string pattern){\\n\\t\\t\\t\\tint p2=count(text.begin(),text.end(),pattern[1]);\\n\\t\\t\\t\\tlong long res=0;\\n\\t\\t\\t\\tfor(int i=0;i<text.length();i++) {\\n\\t\\t\\t\\t\\tif(text[i]==pattern[1]) p2--;\\n\\t\\t\\t\\t\\tif(text[i]==pattern[0]) {\\n\\t\\t\\t\\t\\t\\tres+=p2;  \\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2540851,
                "title": "cpp-best-approach",
                "content": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int p1 = 0, p2 = 0, n = text.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n                p1++;\\n            else if(text[i] == pattern[1])\\n                p2++;\\n        }\\n        if(p1 == 0 && p2 == 0)\\n            return 0;\\n        if(pattern[0] == pattern[1])\\n            return (long long)p1*(p1+1)/2;\\n        long long ans = max(p1,p2), val = p2;\\n        for(char &ch : text)\\n        {\\n            if(ch == pattern[0])\\n                val += p2;\\n            else if(ch == pattern[1])\\n                p2--;\\n        }\\n        ans = max(val, ans);\\n        val = p1;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(text[i] == pattern[1])\\n                val += p1;\\n            else if(text[i] == pattern[0])\\n                p1--;\\n        }\\n        ans = max(val, ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int p1 = 0, p2 = 0, n = text.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n                p1++;\\n            else if(text[i] == pattern[1])\\n                p2++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2518612,
                "title": "c-simple-c-code-90-time-88-space-o-n",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int p1 = 0, p2 = 0, n = text.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n                p1++;\\n            else if(text[i] == pattern[1])\\n                p2++;\\n        }\\n        if(p1 == 0 && p2 == 0)\\n            return 0;\\n        if(pattern[0] == pattern[1])\\n            return (long long)p1*(p1+1)/2;\\n        long long ans = max(p1,p2), val = p2;\\n        for(char &ch : text)\\n        {\\n            if(ch == pattern[0])\\n                val += p2;\\n            else if(ch == pattern[1])\\n                p2--;\\n        }\\n        ans = max(val, ans);\\n        val = p1;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(text[i] == pattern[1])\\n                val += p1;\\n            else if(text[i] == pattern[0])\\n                p1--;\\n        }\\n        ans = max(val, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int p1 = 0, p2 = 0, n = text.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(text[i] == pattern[0])\\n                p1++;\\n            else if(text[i] == pattern[1])\\n                p2++;\\n        }\\n        if(p1 == 0 && p2 == 0)\\n            return 0;\\n        if(pattern[0] == pattern[1])\\n            return (long long)p1*(p1+1)/2;\\n        long long ans = max(p1,p2), val = p2;\\n        for(char &ch : text)\\n        {\\n            if(ch == pattern[0])\\n                val += p2;\\n            else if(ch == pattern[1])\\n                p2--;\\n        }\\n        ans = max(val, ans);\\n        val = p1;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(text[i] == pattern[1])\\n                val += p1;\\n            else if(text[i] == pattern[0])\\n                p1--;\\n        }\\n        ans = max(val, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501496,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, string: str, pattern: str) -> int:\\n\\n        text = pattern[0]+string\\n        text1 = string + pattern[1]\\n        cnt,cnt1 = 0,0\\n        ans,ans1 = 0,0\\n        \\n        for i in range(len(text)):\\n            if text[i] == pattern[0]:\\n                cnt+=1\\n            elif text[i] == pattern[1]:\\n                ans+= cnt\\n        if pattern[0] == pattern[1]:\\n            ans = ((cnt)*(cnt-1))//2\\n        # appending at the last \\n        for i in range(len(text1)):\\n            if text1[i] == pattern[0]:\\n                cnt1+=1\\n            elif text1[i] == pattern[1]:\\n                ans1+= cnt1\\n        if pattern[0] == pattern[1]:\\n            ans1 = ((cnt1)*(cnt1-1))//2\\n        return max(ans1,ans)\\n    \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, string: str, pattern: str) -> int:\\n\\n        text = pattern[0]+string\\n        text1 = string + pattern[1]\\n        cnt,cnt1 = 0,0\\n        ans,ans1 = 0,0\\n        \\n        for i in range(len(text)):\\n            if text[i] == pattern[0]:\\n                cnt+=1\\n            elif text[i] == pattern[1]:\\n                ans+= cnt\\n        if pattern[0] == pattern[1]:\\n            ans = ((cnt)*(cnt-1))//2\\n        # appending at the last \\n        for i in range(len(text1)):\\n            if text1[i] == pattern[0]:\\n                cnt1+=1\\n            elif text1[i] == pattern[1]:\\n                ans1+= cnt1\\n        if pattern[0] == pattern[1]:\\n            ans1 = ((cnt1)*(cnt1-1))//2\\n        return max(ans1,ans)\\n    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439758,
                "title": "c-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        string s = \"\";\\n\\t\\tfor (const char &c: text) {\\n\\t\\t\\tif (pat[0] == c) s += c;\\n\\t\\t\\telse if (pat[1] == c) s += c;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (pat[0] == pat[1]) {\\n            s = pat[0] + s;\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\treturn 1LL * n * (n - 1) / 2;\\n\\t\\t}\\n\\t\\tstring s1 = pat[0] + s;\\n\\t\\tlong long ans = 0;\\n\\t\\tint c0 = 0;\\n\\t\\tfor (const char &c: s1) {\\n\\t\\t\\tif (c == pat[0]) c0++;\\n\\t\\t\\telse ans += c0;\\n\\t\\t}\\n\\t\\tc0 = 0;\\n\\t\\tlong long cur = 0;\\n\\t\\tstring s2 = s + pat[1];\\n\\t\\tfor (const char &c: s2) {\\n\\t\\t\\tif (c == pat[0]) c0++;\\n\\t\\t\\telse cur += c0;\\n\\t\\t}\\n\\t\\treturn max(ans, cur);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n        string s = \"\";\\n\\t\\tfor (const char &c: text) {\\n\\t\\t\\tif (pat[0] == c) s += c;\\n\\t\\t\\telse if (pat[1] == c) s += c;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (pat[0] == pat[1]) {\\n            s = pat[0] + s;\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\treturn 1LL * n * (n - 1) / 2;\\n\\t\\t}\\n\\t\\tstring s1 = pat[0] + s;\\n\\t\\tlong long ans = 0;\\n\\t\\tint c0 = 0;\\n\\t\\tfor (const char &c: s1) {\\n\\t\\t\\tif (c == pat[0]) c0++;\\n\\t\\t\\telse ans += c0;\\n\\t\\t}\\n\\t\\tc0 = 0;\\n\\t\\tlong long cur = 0;\\n\\t\\tstring s2 = s + pat[1];\\n\\t\\tfor (const char &c: s2) {\\n\\t\\t\\tif (c == pat[0]) c0++;\\n\\t\\t\\telse cur += c0;\\n\\t\\t}\\n\\t\\treturn max(ans, cur);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401632,
                "title": "simple-approach-with-intuition",
                "content": "very basic approach , you just have to take care of one edge case which is when both the character of the pattern are same then you just have to sum of n natural number nothing else......\\n//code\\n\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n       int count1=0;\\n        int count2=0;\\n        int n=text.length();\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(text[i]==pat[0]){\\n                count1++;\\n            }\\n            else if(text[i]==pat[1]){\\n                count2++;\\n                ans+=count1;\\n            }\\n        }\\n        if(pat[0]==pat[1]){\\n            count1++;\\n            ans=((long long)(count1)*(count1-1))/2;\\n        }\\n        else{\\n            int val=max(count1,count2);\\n            ans+=val;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pat) {\\n       int count1=0;\\n        int count2=0;\\n        int n=text.length();\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(text[i]==pat[0]){\\n                count1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2382838,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n\\n    func maximumSubsequenceCount(_ text: String, _ pattern: String) -> Int {\\n        let txtArray = Array(text)\\n        let patternArray = Array(pattern)\\n        \\n        let p1Str = String(patternArray[0])\\n        let p2Str = String(patternArray[1])\\n            \\n        var count1 = 0, count2 = 0, result = 0 \\n    \\n        for character in txtArray{\\n\\t\\t\\n            let curCharStr = String(character)\\n\\t\\t\\t\\n            if curCharStr == p2Str { \\n                result += count1\\n                count2 += 1\\n            }  \\n\\t\\t\\t\\n            if curCharStr == p1Str {\\n                count1 += 1\\n            }          \\n\\t\\t\\t\\n        }\\n        return result + max(count1,count2)\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func maximumSubsequenceCount(_ text: String, _ pattern: String) -> Int {\\n        let txtArray = Array(text)\\n        let patternArray = Array(pattern)\\n        \\n        let p1Str = String(patternArray[0])\\n        let p2Str = String(patternArray[1])\\n            \\n        var count1 = 0, count2 = 0, result = 0 \\n    \\n        for character in txtArray{\\n\\t\\t\\n            let curCharStr = String(character)\\n\\t\\t\\t\\n            if curCharStr == p2Str { \\n                result += count1\\n                count2 += 1\\n            }  \\n\\t\\t\\t\\n            if curCharStr == p1Str {\\n                count1 += 1\\n            }          \\n\\t\\t\\t\\n        }\\n        return result + max(count1,count2)\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374051,
                "title": "easy-java-solution-greedy",
                "content": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n        long  a= subsequenceCount(pattern.charAt(0)+text,pattern);\\n        long b = subsequenceCount(text+pattern.charAt(1),pattern);\\n        \\n        return a>b?a:b;\\n        \\n    }\\n    private long subsequenceCount(String text ,String pattern ){\\n        long ans =0L;\\n        long count =0L;\\n        long previous =0L;\\n        for(int i =text.length()-1;i>=0;i--){\\n            if(text.charAt(i)==pattern.charAt(1)){\\n                count ++;\\n                \\n             if(pattern.charAt(0)==pattern.charAt(1) && count >1 && count !=previous) { \\n                ans +=count-1;\\n                 previous =count;\\n            }\\n            }\\n            else if (text.charAt(i)==pattern.charAt(0))\\n                ans +=count ;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n        long  a= subsequenceCount(pattern.charAt(0)+text,pattern);\\n        long b = subsequenceCount(text+pattern.charAt(1),pattern);\\n        \\n        return a>b?a:b;\\n        \\n    }\\n    private long subsequenceCount(String text ,String pattern ){\\n        long ans =0L;\\n        long count =0L;\\n        long previous =0L;\\n        for(int i =text.length()-1;i>=0;i--){\\n            if(text.charAt(i)==pattern.charAt(1)){\\n                count ++;\\n                \\n             if(pattern.charAt(0)==pattern.charAt(1) && count >1 && count !=previous) { \\n                ans +=count-1;\\n                 previous =count;\\n            }\\n            }\\n            else if (text.charAt(i)==pattern.charAt(0))\\n                ans +=count ;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354927,
                "title": "python-simple-greedy-based-notes",
                "content": "```\\n\"\"\"\\nthere can only be two optimal strategies, either we add the first character of\\nthe pattern towards the start of the given sequence\\nor we add the last character of pattern towards the end of given sequence\\nwe return the case in which we are getting the maximum subsequences\\n\"\"\"\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        # identify the maximum subsequence that can be created \\n        # by given text\\n        first_char_count, second_char_count = 0, 0\\n        res = list()\\n        for i in range(len(text)-1, -1, -1):\\n            if text[i] == pattern[1]:\\n                second_char_count+=1\\n            elif text[i] == pattern[0]:\\n                res.append(second_char_count)\\n        if pattern[0] == pattern[1]:\\n            return int(second_char_count * (second_char_count+1) / 2)\\n        if not len(res):\\n            return second_char_count\\n        num_seq = sum(res)\\n        return max(num_seq + len(res), num_seq + second_char_count)\\n```",
                "solutionTags": [
                    "Python",
                    "Counting"
                ],
                "code": "```\\n\"\"\"\\nthere can only be two optimal strategies, either we add the first character of\\nthe pattern towards the start of the given sequence\\nor we add the last character of pattern towards the end of given sequence\\nwe return the case in which we are getting the maximum subsequences\\n\"\"\"\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        # identify the maximum subsequence that can be created \\n        # by given text\\n        first_char_count, second_char_count = 0, 0\\n        res = list()\\n        for i in range(len(text)-1, -1, -1):\\n            if text[i] == pattern[1]:\\n                second_char_count+=1\\n            elif text[i] == pattern[0]:\\n                res.append(second_char_count)\\n        if pattern[0] == pattern[1]:\\n            return int(second_char_count * (second_char_count+1) / 2)\\n        if not len(res):\\n            return second_char_count\\n        num_seq = sum(res)\\n        return max(num_seq + len(res), num_seq + second_char_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340744,
                "title": "c",
                "content": "```\\nlong long maxSubseCn(char* text, char* pattern){\\n    int i;\\n    int len = strlen(text);\\n    int* dp = (int*)calloc(len , sizeof(int));\\n    if(text[len-1] == pattern[1])\\n        dp[len-1] = 1;\\n    else\\n        dp[len-1] = 0;\\n    \\n    for(i = len-2; i >= 0; i--){\\n        if(text[i] == pattern[1])\\n            dp[i] = dp[i+1] + 1;\\n        else\\n            dp[i] = dp[i+1];\\n    }\\n    long long cn = 0;\\n    for(i = 0; i < len-1; i++){\\n        if(text[i] == pattern[0]){\\n            cn = cn + dp[i+1];\\n        }\\n    }\\n    free(dp);\\n    return cn;\\n}\\n\\nlong long maximumSubsequenceCount(char * text, char * pattern){\\n    long long item1;\\n    long long item2;\\n    int i;\\n    int len = strlen(text);\\n    char* s1 = malloc((len+1+1) * sizeof(char));  //add to head of text\\n    char* s2 = malloc((len+1+1) * sizeof(char));  //add to tail of text\\n    s1[len+1] = \\'\\\\0\\';\\n    s2[len+1] = \\'\\\\0\\';\\n    for(i = 0; i < len; i++){\\n        s1[i+1] = text[i];\\n        s2[i] = text[i];\\n    }\\n    s1[0] = pattern[0];\\n    s2[len] = pattern[1];\\n    \\n    item1 = maxSubseCn(s1, pattern);\\n    item2 = maxSubseCn(s2, pattern);\\n    free(s1);\\n    free(s2);\\n    return fmax(item1, item2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long maxSubseCn(char* text, char* pattern){\\n    int i;\\n    int len = strlen(text);\\n    int* dp = (int*)calloc(len , sizeof(int));\\n    if(text[len-1] == pattern[1])\\n        dp[len-1] = 1;\\n    else\\n        dp[len-1] = 0;\\n    \\n    for(i = len-2; i >= 0; i--){\\n        if(text[i] == pattern[1])\\n            dp[i] = dp[i+1] + 1;\\n        else\\n            dp[i] = dp[i+1];\\n    }\\n    long long cn = 0;\\n    for(i = 0; i < len-1; i++){\\n        if(text[i] == pattern[0]){\\n            cn = cn + dp[i+1];\\n        }\\n    }\\n    free(dp);\\n    return cn;\\n}\\n\\nlong long maximumSubsequenceCount(char * text, char * pattern){\\n    long long item1;\\n    long long item2;\\n    int i;\\n    int len = strlen(text);\\n    char* s1 = malloc((len+1+1) * sizeof(char));  //add to head of text\\n    char* s2 = malloc((len+1+1) * sizeof(char));  //add to tail of text\\n    s1[len+1] = \\'\\\\0\\';\\n    s2[len+1] = \\'\\\\0\\';\\n    for(i = 0; i < len; i++){\\n        s1[i+1] = text[i];\\n        s2[i] = text[i];\\n    }\\n    s1[0] = pattern[0];\\n    s2[len] = pattern[1];\\n    \\n    item1 = maxSubseCn(s1, pattern);\\n    item2 = maxSubseCn(s2, pattern);\\n    free(s1);\\n    free(s2);\\n    return fmax(item1, item2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326580,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-greedy",
                "content": "It is simple logic - you either insert the first pattern character at the beginning or you add the last pattern character to the end.\\n```C#\\npublic class Solution {\\n    public long MaximumSubsequenceCount(string text, string pattern) {\\n        return Math.Max(GetSubsequencesCount(1, false), GetSubsequencesCount(0, true));\\n        \\n        long GetSubsequencesCount(int initial, bool addAtEnd) {\\n            int patternStartCount = initial;\\n            long ans = 0L;\\n            for (int i = 0; i < text.Length; i++) {\\n                // pattern[0] may be equal to pattern[1]\\n                if (text[i] == pattern[1]) ans += patternStartCount;\\n                if (text[i] == pattern[0]) patternStartCount++;\\n            }\\n            \\n            if (addAtEnd) ans += patternStartCount;\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```C#\\npublic class Solution {\\n    public long MaximumSubsequenceCount(string text, string pattern) {\\n        return Math.Max(GetSubsequencesCount(1, false), GetSubsequencesCount(0, true));\\n        \\n        long GetSubsequencesCount(int initial, bool addAtEnd) {\\n            int patternStartCount = initial;\\n            long ans = 0L;\\n            for (int i = 0; i < text.Length; i++) {\\n                // pattern[0] may be equal to pattern[1]\\n                if (text[i] == pattern[1]) ans += patternStartCount;\\n                if (text[i] == pattern[0]) patternStartCount++;\\n            }\\n            \\n            if (addAtEnd) ans += patternStartCount;\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310586,
                "title": "brute-force-clean-to-see-and-elegant-code-python3-52-faster",
                "content": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        # Logic:\\n        # I am sure if I filter letters of pattern, I can accomplish my task.\\n        # I am sure if I append the first letter of the pattern in the filtered string,\\n        # at the beginning and the second letter of the pattern at the end, I can get the maximum\\n        # number subsequences which is the pattern.\\n        # I need to count the occurrance of pattern[0] and pattern[1]\\n        #After I filtered, The only letters in string are pattern[0] and pattern[1]\\n        #let_ONE=0 #The maximum number of subsequence up to the current index\\n        #let_TWO=0 # The second letter counter==pattern[1]\\n        \\n        filtered=[]\\n        for let in text:\\n            if let  in pattern:\\n                filtered.append(let)\\n        return  max(self.maxFinder(False,filtered,pattern),\\n                    self.maxFinder(True,filtered,pattern))\\n        \\n        \\n    def maxFinder(self,atTheBeginning,string,pattern):\\n        \\n        let_ONE=0 \\n        let_TWO=0\\n        if not atTheBeginning:\\n            let_TWO=1\\n        for index in range(len(string)-1,-1,-1):\\n            if string[index]==pattern[0]:\\n                let_ONE+=let_TWO\\n            if string[index]==pattern[1]:\\n                let_TWO+=1\\n        if atTheBeginning:\\n            let_ONE+=let_TWO\\n        return let_ONE\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        # Logic:\\n        # I am sure if I filter letters of pattern, I can accomplish my task.\\n        # I am sure if I append the first letter of the pattern in the filtered string,\\n        # at the beginning and the second letter of the pattern at the end, I can get the maximum\\n        # number subsequences which is the pattern.\\n        # I need to count the occurrance of pattern[0] and pattern[1]\\n        #After I filtered, The only letters in string are pattern[0] and pattern[1]\\n        #let_ONE=0 #The maximum number of subsequence up to the current index\\n        #let_TWO=0 # The second letter counter==pattern[1]\\n        \\n        filtered=[]\\n        for let in text:\\n            if let  in pattern:\\n                filtered.append(let)\\n        return  max(self.maxFinder(False,filtered,pattern),\\n                    self.maxFinder(True,filtered,pattern))\\n        \\n        \\n    def maxFinder(self,atTheBeginning,string,pattern):\\n        \\n        let_ONE=0 \\n        let_TWO=0\\n        if not atTheBeginning:\\n            let_TWO=1\\n        for index in range(len(string)-1,-1,-1):\\n            if string[index]==pattern[0]:\\n                let_ONE+=let_TWO\\n            if string[index]==pattern[1]:\\n                let_TWO+=1\\n        if atTheBeginning:\\n            let_ONE+=let_TWO\\n        return let_ONE\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307694,
                "title": "faster-than-95-dp-python",
                "content": "![image](https://assets.leetcode.com/users/images/0b4e80ff-e418-4ec4-9e61-709e291429e9_1658303476.1544755.png)\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, s: str, p: str) -> int:\\n        q=max(s.count(p[0]),s.count(p[1]))\\n        if p[0]==p[1]:\\n            return q*(q+1)//2\\n        k=0\\n        for i in s:\\n            if i==p[0]:\\n                k+=1\\n            elif i==p[1]:\\n                q+=k\\n        return q",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/0b4e80ff-e418-4ec4-9e61-709e291429e9_1658303476.1544755.png)\\n```\\nclass Solution:\\n    def maximumSubsequenceCount(self, s: str, p: str) -> int:\\n        q=max(s.count(p[0]),s.count(p[1]))\\n        if p[0]==p[1]:\\n            return q*(q+1)//2\\n        k=0\\n        for i in s:\\n            if i==p[0]:\\n                k+=1\\n            elif i==p[1]:\\n                q+=k\\n        return q",
                "codeTag": "Java"
            },
            {
                "id": 2298403,
                "title": "c-counting-frequency",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        if(pattern[0]==pattern[1]){\\n            long long count=0;\\n            for(long long i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]){\\n                    count++;\\n                }\\n            }\\n            long long res=(count*(count+1))/2;\\n            return res;\\n        }\\n        else{\\n            map<char, long long> mp;\\n            vector<long long> n;\\n            long long count=0;\\n            for(long long i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]){\\n                    mp[text[i]]++;\\n                    count++;\\n                }\\n                else if(text[i]==pattern[1]){\\n                    mp[text[i]]++;\\n                    n.push_back(count);\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n\\n            long long res=0;\\n            for(int i=0; i<n.size(); i++){\\n                res+=n[i];\\n            }\\n\\n            if(mp[pattern[0]]>mp[pattern[1]]){\\n                res+=mp[pattern[0]];\\n            }\\n            else{\\n                res+=mp[pattern[1]];\\n            }\\n            return res;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        if(pattern[0]==pattern[1]){\\n            long long count=0;\\n            for(long long i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]){\\n                    count++;\\n                }\\n            }\\n            long long res=(count*(count+1))/2;\\n            return res;\\n        }\\n        else{\\n            map<char, long long> mp;\\n            vector<long long> n;\\n            long long count=0;\\n            for(long long i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]){\\n                    mp[text[i]]++;\\n                    count++;\\n                }\\n                else if(text[i]==pattern[1]){\\n                    mp[text[i]]++;\\n                    n.push_back(count);\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n\\n            long long res=0;\\n            for(int i=0; i<n.size(); i++){\\n                res+=n[i];\\n            }\\n\\n            if(mp[pattern[0]]>mp[pattern[1]]){\\n                res+=mp[pattern[0]];\\n            }\\n            else{\\n                res+=mp[pattern[1]];\\n            }\\n            return res;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297275,
                "title": "python-simple-hashmap-maths",
                "content": "\\n    def maximumSubsequenceCount(self, text, pattern):\\n        count, dict1, dict2 = 0, Counter(text), Counter(text)\\n        \\n        if pattern[0] == pattern[1]:\\n            return dict2[pattern[0]]*(dict2[pattern[0]] + 1)//2\\n        \\n        for i in text:\\n            if i == pattern[0]:\\n                count += dict1[pattern[1]]\\n                dict1[pattern[0]] -= 1\\n                if dict1[pattern[0]] == 0:\\n                    del dict1[pattern[0]]\\n            elif i == pattern[1]:\\n                dict1[pattern[1]] -= 1\\n                if dict1[pattern[1]] == 0:\\n                    del dict1[pattern[1]]\\n            else:\\n                continue\\n                \\n            \\n        return max(count + dict2[pattern[1]], count + dict2[pattern[0]])",
                "solutionTags": [],
                "code": "\\n    def maximumSubsequenceCount(self, text, pattern):\\n        count, dict1, dict2 = 0, Counter(text), Counter(text)\\n        \\n        if pattern[0] == pattern[1]:\\n            return dict2[pattern[0]]*(dict2[pattern[0]] + 1)//2\\n        \\n        for i in text:\\n            if i == pattern[0]:\\n                count += dict1[pattern[1]]\\n                dict1[pattern[0]] -= 1\\n                if dict1[pattern[0]] == 0:\\n                    del dict1[pattern[0]]\\n            elif i == pattern[1]:\\n                dict1[pattern[1]] -= 1\\n                if dict1[pattern[1]] == 0:\\n                    del dict1[pattern[1]]\\n            else:\\n                continue\\n                \\n            \\n        return max(count + dict2[pattern[1]], count + dict2[pattern[0]])",
                "codeTag": "Python3"
            },
            {
                "id": 2250871,
                "title": "intuitive-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int len = text.size();\\n        long long ls = 0;\\n        long long rs = 0;\\n        long long res = 0;\\n        \\n        for (auto c : text) {\\n            if (c == pattern[0]) {\\n                ++ls;\\n            } else if (c == pattern[1]) {\\n                res += ls;\\n                ++rs;\\n            }\\n        }\\n        \\n        if (pattern[0] == pattern[1])\\n            return (ls + 1) * (ls) / 2;\\n        \\n        return max(ls, rs) + res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        int len = text.size();\\n        long long ls = 0;\\n        long long rs = 0;\\n        long long res = 0;\\n        \\n        for (auto c : text) {\\n            if (c == pattern[0]) {\\n                ++ls;\\n            } else if (c == pattern[1]) {\\n                res += ls;\\n                ++rs;\\n            }\\n        }\\n        \\n        if (pattern[0] == pattern[1])\\n            return (ls + 1) * (ls) / 2;\\n        \\n        return max(ls, rs) + res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249677,
                "title": "maximum-number-of-subsequences-in-a-string",
                "content": "please comment if any doubt\\n```\\nclass Solution(object):\\n    def maximumSubsequenceCount(self, text, pattern):\\n        \"\"\"\\n        :type text: str\\n        :type pattern: str\\n        :rtype: int\\n        \"\"\"\\n        dc_1 = {}\\n        n = len(text)\\n        x = 0\\n        for i in range(n-1,-1,-1):\\n            if text[i] == pattern[1]:\\n                x += 1\\n            dc_1[i] = x\\n        num = 0\\n        for i in range(n):\\n            if text[i] == pattern[0]:\\n                if pattern[0] == pattern[1]:\\n                    dc_1[i] -= 1\\n                num += dc_1[i]\\n        orignal = num\\n        dc_2 = {}\\n        x = 0\\n        for i in range(n):\\n            if text[i] == pattern[0]:\\n                x += 1\\n            dc_2[i] = x\\n        lon_1 = 0\\n        for i in range(n-1,-1,-1):\\n            n_1 = dc_1[i]\\n            if n_1 > lon_1:\\n                lon_1 = n_1\\n        lon_2 = 0\\n        for i in range(n):\\n            n_2 = dc_2[i]\\n            if n_2 > lon_2:\\n                lon_2 = n_2\\n        lon = max(lon_1,lon_2)\\n        return orignal + lon\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumSubsequenceCount(self, text, pattern):\\n        \"\"\"\\n        :type text: str\\n        :type pattern: str\\n        :rtype: int\\n        \"\"\"\\n        dc_1 = {}\\n        n = len(text)\\n        x = 0\\n        for i in range(n-1,-1,-1):\\n            if text[i] == pattern[1]:\\n                x += 1\\n            dc_1[i] = x\\n        num = 0\\n        for i in range(n):\\n            if text[i] == pattern[0]:\\n                if pattern[0] == pattern[1]:\\n                    dc_1[i] -= 1\\n                num += dc_1[i]\\n        orignal = num\\n        dc_2 = {}\\n        x = 0\\n        for i in range(n):\\n            if text[i] == pattern[0]:\\n                x += 1\\n            dc_2[i] = x\\n        lon_1 = 0\\n        for i in range(n-1,-1,-1):\\n            n_1 = dc_1[i]\\n            if n_1 > lon_1:\\n                lon_1 = n_1\\n        lon_2 = 0\\n        for i in range(n):\\n            n_2 = dc_2[i]\\n            if n_2 > lon_2:\\n                lon_2 = n_2\\n        lon = max(lon_1,lon_2)\\n        return orignal + lon\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245703,
                "title": "c-no-dp-only-simple-o-n-approach",
                "content": "class Solution {\\npublic:\\n\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        long long int cnt1=0; //this is a count of pattern[0] in the text string ;\\n        long long int cnt2=0; //this is a count of pattern[1] in the text string;\\n        \\n        for(auto i : text)\\n        {\\n            if(i==pattern[0])cnt1++;\\n            if(i==pattern[1])cnt2++;\\n        }\\n        long long  int ans=max(cnt1,cnt2);\\n        //here at least our ans will be max of cnt1 and cnt2 because \\n        //in first example \"a c c\" we can add pattern[0] or pattern[1] at the end or at the front \\n        // so our ans will be greater than or equal to max(cnt1,cnt2);\\n        long long int cnt=cnt2;\\n        \\n        for(auto i : text)\\n        {   \\n            if(i==pattern[1])cnt--;\\n            if(i==pattern[0])ans+=cnt;\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        \\n        long long int cnt1=0; //this is a count of pattern[0] in the text string ;\\n        long long int cnt2=0; //this is a count of pattern[1] in the text string;\\n        \\n        for(auto i : text)\\n        {\\n            if(i==pattern[0])cnt1++;\\n            if(i==pattern[1])cnt2++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2201662,
                "title": "java-solution-0-ms",
                "content": "```\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        char x = pattern.charAt(0);\\n        char y = pattern.charAt(1);\\n        int xC = 0;\\n        int yC = 0;\\n        long count = 0;\\n        for(char c: text.toCharArray()) {\\n            if(c == y) {\\n                yC++;\\n                count+=xC;\\n            }\\n            if(c == x) xC++;\\n        }\\n        count+=Math.max(xC, yC);\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        char x = pattern.charAt(0);\\n        char y = pattern.charAt(1);\\n        int xC = 0;\\n        int yC = 0;\\n        long count = 0;\\n        for(char c: text.toCharArray()) {\\n            if(c == y) {\\n                yC++;\\n                count+=xC;\\n            }\\n            if(c == x) xC++;\\n        }\\n        count+=Math.max(xC, yC);\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2191961,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, s: str, p: str) -> int:\\n        a=b=ans=0\\n        for i in range(len(s)-1,-1,-1):\\n            i=s[i]\\n            if i==p[0]:\\n                ans+=b   \\n                a+=1\\n            if i==p[1]:\\n                b+=1\\n        return ans+max(a,b)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, s: str, p: str) -> int:\\n        a=b=ans=0\\n        for i in range(len(s)-1,-1,-1):\\n            i=s[i]\\n            if i==p[0]:\\n                ans+=b   \\n                a+=1\\n            if i==p[1]:\\n                b+=1\\n        return ans+max(a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177291,
                "title": "very-simple-cpp-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fun(string s1,string s2){\\n        int m=s1.size(),n=s2.size();\\n        long long int f=0,s=0,count=0;\\n        for(int i=0;i<m;i++){\\n            if(s1[i]==s2[0])\\n            {\\n                f++;\\n            }else if(s1[i]==s2[1]){\\n                count=count + f;\\n            }\\n        }\\n       \\n        if(s2[1]==s2[0])\\n        {\\n             f=f-1;\\n            return ((f*(f+1))/2);\\n        }\\n            \\n        return count;\\n        \\n    }\\n    \\n    long long maximumSubsequenceCount(string t, string p) {\\n       \\n        return max(fun(p[0]+t,p),fun(t+p[1],p));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fun(string s1,string s2){\\n        int m=s1.size(),n=s2.size();\\n        long long int f=0,s=0,count=0;\\n        for(int i=0;i<m;i++){\\n            if(s1[i]==s2[0])\\n            {\\n                f++;\\n            }else if(s1[i]==s2[1]){\\n                count=count + f;\\n            }\\n        }\\n       \\n        if(s2[1]==s2[0])\\n        {\\n             f=f-1;\\n            return ((f*(f+1))/2);\\n        }\\n            \\n        return count;\\n        \\n    }\\n    \\n    long long maximumSubsequenceCount(string t, string p) {\\n       \\n        return max(fun(p[0]+t,p),fun(t+p[1],p));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166752,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p)\\n    {\\n        long long f=INT_MIN,ans=0; int lt=t.length();  string s=t;//preserved string\\n        \\n        //special cases when both are same\\n        if(p[0]==p[1])\\n        {\\n            long long int c=0,ans=0;\\n            s=p[0]+s;\\n            \\n            for(long long int i=1;i<s.length();i++) { if(s[i]==p[1]) {c++; ans=ans+c;} }\\n            return ans;\\n        }\\n        \\n        //ek baar aage daalke dekha\\n        s=p[0]+s;                         long long int c=0; //to store count of p[0]\\n        \\n        for(long long int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==p[0]) c++;   else if(s[i]==p[1]) ans=ans+c;\\n        }\\n    \\n        f=max(f,ans); ans=0;\\n        \\n        //ek baar piche daalke dekha\\n        s=t; c=0;\\n        s=s+p[1];\\n\\n        for(long long int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==p[0]) c++;\\n            else if(s[i]==p[1]) ans=ans+c;\\n        }\\n  \\n        f=max(f,ans);\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string t, string p)\\n    {\\n        long long f=INT_MIN,ans=0; int lt=t.length();  string s=t;//preserved string\\n        \\n        //special cases when both are same\\n        if(p[0]==p[1])\\n        {\\n            long long int c=0,ans=0;\\n            s=p[0]+s;\\n            \\n            for(long long int i=1;i<s.length();i++) { if(s[i]==p[1]) {c++; ans=ans+c;} }\\n            return ans;\\n        }\\n        \\n        //ek baar aage daalke dekha\\n        s=p[0]+s;                         long long int c=0; //to store count of p[0]\\n        \\n        for(long long int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==p[0]) c++;   else if(s[i]==p[1]) ans=ans+c;\\n        }\\n    \\n        f=max(f,ans); ans=0;\\n        \\n        //ek baar piche daalke dekha\\n        s=t; c=0;\\n        s=s+p[1];\\n\\n        for(long long int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==p[0]) c++;\\n            else if(s[i]==p[1]) ans=ans+c;\\n        }\\n  \\n        f=max(f,ans);\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151020,
                "title": "explained-java-solution",
                "content": "As the patten is only of size 2, to get max subsequence we either add pattern[0] at the begining or pattern[1] at the last, this will be decided with the character which has lower count in the pattern.\\n\\nFor Example:- text = \"aabceaceedaaaffefa\"\\n\\t    \\tand pattern= \"af\"\\nhere there are 7 a\\'s and 3 f\\'s so adding 1 f at the end gives 7 more subsequence.\\nNow the problem becomes of calculating no. of substrings which can be done by when ever i encounter pattern[1], I see how many pattern[0] i have encountered and add that to max variable.If doestn\\'t work if both the characters in pattern are same so we iterate differntly for it.\\nCode :- \\n\\'\\'\\'\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n        long p1=0,p2=0,max=0;\\n        char[] pat = pattern.toCharArray();\\n        \\n        if(pat[0]==pat[1]){\\n            p1=1;\\n            for(char ch : text.toCharArray()){\\n                if(ch==pat[0]){\\n                    max+=p1;\\n                    p1++;\\n                }\\n            }\\n            return max;\\n        }\\n        for(char ch : text.toCharArray()){\\n            if(ch==pat[0]) p1++;\\n            else if(ch==pat[1]){\\n                max+=p1;\\n                p2++;\\n            }\\n        }\\n        return max+Math.max(p1,p2);\\n    }\\n}\\n\\'\\'\\'\\npls upvote it, if it helped",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n        long p1=0,p2=0,max=0;\\n        char[] pat = pattern.toCharArray();\\n        \\n        if(pat[0]==pat[1]){\\n            p1=1;\\n            for(char ch : text.toCharArray()){\\n                if(ch==pat[0]){\\n                    max+=p1;\\n                    p1++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2150987,
                "title": "java-accepted-solution",
                "content": "class Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n        long p1=0,p2=0,max=0;\\n        char[] pat = pattern.toCharArray();\\n        \\n        if(pat[0]==pat[1]){\\n            p1=1;\\n            for(char ch : text.toCharArray()){\\n                if(ch==pat[0]){\\n                    max+=p1;\\n                    p1++;\\n                }\\n            }\\n            return max;\\n        }\\n        for(char ch : text.toCharArray()){\\n            if(ch==pat[0]) p1++;\\n            else if(ch==pat[1]){\\n                max+=p1;\\n                p2++;\\n            }\\n        }\\n        return max+Math.max(p1,p2);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n        long p1=0,p2=0,max=0;\\n        char[] pat = pattern.toCharArray();\\n        \\n        if(pat[0]==pat[1]){\\n            p1=1;\\n            for(char ch : text.toCharArray()){\\n                if(ch==pat[0]){\\n                    max+=p1;\\n                    p1++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2149768,
                "title": "maximize-number-of-subsequence-in-a-string",
                "content": "Just take 2 possibilty one that you append 0th char at starting of string or 1th character at end of the string so that you can obtain maximum subsequence \\nlike string is aabcc and two size string is [a,c]\\nif you add a at starting string will be aaabcc then subsequences are same as ac ->4 \\nif you add c at last then string would be aabccc then subsequence ac->6 then 6 is the ans .\\n```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n             long ans=0,ans1=0;\\n    String f=pattern.charAt(0)+text;\\n    String s=text+pattern.charAt(1);\\n    long cnt1=0;\\n    for(int i=0;i<f.length();i++)\\n    {\\n        if(f.charAt(i)== pattern.charAt(0))cnt1 ++;\\n        else if(f.charAt(i)==pattern.charAt(1))ans+=(cnt1);\\n    }\\n    if(pattern.charAt(0)==pattern.charAt(1))\\n    {\\n        ans=((cnt1)*(cnt1-1))/2;\\n    }\\n    cnt1=0;\\n    for(int i=s.length()-1;i>=0;i--)\\n    {\\n        if(s.charAt(i)== pattern.charAt(1))cnt1 ++;\\n        else if(s.charAt(i)== pattern.charAt(0))ans1+=(cnt1);\\n    }\\n    if(pattern.charAt(0)==pattern.charAt(1))\\n    {\\n        ans1=((cnt1)*(cnt1-1))/2;\\n    }\\n    return Math.max(ans,ans1);\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        \\n             long ans=0,ans1=0;\\n    String f=pattern.charAt(0)+text;\\n    String s=text+pattern.charAt(1);\\n    long cnt1=0;\\n    for(int i=0;i<f.length();i++)\\n    {\\n        if(f.charAt(i)== pattern.charAt(0))cnt1 ++;\\n        else if(f.charAt(i)==pattern.charAt(1))ans+=(cnt1);\\n    }\\n    if(pattern.charAt(0)==pattern.charAt(1))\\n    {\\n        ans=((cnt1)*(cnt1-1))/2;\\n    }\\n    cnt1=0;\\n    for(int i=s.length()-1;i>=0;i--)\\n    {\\n        if(s.charAt(i)== pattern.charAt(1))cnt1 ++;\\n        else if(s.charAt(i)== pattern.charAt(0))ans1+=(cnt1);\\n    }\\n    if(pattern.charAt(0)==pattern.charAt(1))\\n    {\\n        ans1=((cnt1)*(cnt1-1))/2;\\n    }\\n    return Math.max(ans,ans1);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148748,
                "title": "c-short-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long totalFirst = 0;\\n        long long totalSecond = 0;\\n        long long total = 0;\\n        for(int i = 0;i < text.length();i++) {\\n            if(text[i] == pattern[1]) {\\n                total += totalFirst;\\n                totalSecond++;\\n            }\\n            if(text[i] == pattern[0])\\n                totalFirst++;\\n        }\\n        return max(totalSecond,totalFirst) + total;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long totalFirst = 0;\\n        long long totalSecond = 0;\\n        long long total = 0;\\n        for(int i = 0;i < text.length();i++) {\\n            if(text[i] == pattern[1]) {\\n                total += totalFirst;\\n                totalSecond++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2124693,
                "title": "python-o-n",
                "content": "````\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        firstCharCount, secondCharCount = 0,0\\n        \\n        # get both the char counts\\n        for char in text:\\n            if char == pattern[0]: firstCharCount += 1\\n            elif char == pattern[1]: secondCharCount += 1\\n        \\n        result = 0\\n        \\n        # if characters are matching, then it will be sum of all posible combination,\\n        # ie, consecutive number sum.\\n        if pattern[0] == pattern[1]:\\n            return firstCharCount*(firstCharCount+1)//2\\n        \\n        # if we dont have both return 0, because we can insert only one.\\n        if not firstCharCount and not secondCharCount: return 0\\n\\n        # one of the character doesnt exists, after inserting we can get max the other char count\\n        if not firstCharCount: return secondCharCount \\n        elif not secondCharCount: return firstCharCount\\n        \\n        # The max we get after inserting will be max of either count\\n        result = max(firstCharCount, secondCharCount)\\n        \\n        # to determine how many we can get with current string.\\n        for char in text:\\n            if char == pattern[0]:\\n                result += secondCharCount\\n            elif char == pattern[1]:\\n                secondCharCount -= 1\\n        \\n        return result\\n        \\n````",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\nclass Solution:\\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        \\n        firstCharCount, secondCharCount = 0,0\\n        \\n        # get both the char counts\\n        for char in text:\\n            if char == pattern[0]: firstCharCount += 1\\n            elif char == pattern[1]: secondCharCount += 1\\n        \\n        result = 0\\n        \\n        # if characters are matching, then it will be sum of all posible combination,\\n        # ie, consecutive number sum.\\n        if pattern[0] == pattern[1]:\\n            return firstCharCount*(firstCharCount+1)//2\\n        \\n        # if we dont have both return 0, because we can insert only one.\\n        if not firstCharCount and not secondCharCount: return 0\\n\\n        # one of the character doesnt exists, after inserting we can get max the other char count\\n        if not firstCharCount: return secondCharCount \\n        elif not secondCharCount: return firstCharCount\\n        \\n        # The max we get after inserting will be max of either count\\n        result = max(firstCharCount, secondCharCount)\\n        \\n        # to determine how many we can get with current string.\\n        for char in text:\\n            if char == pattern[0]:\\n                result += secondCharCount\\n            elif char == pattern[1]:\\n                secondCharCount -= 1\\n        \\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116572,
                "title": "c-single-pass-o-n-solution",
                "content": "```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\n\\nclass Solution {\\npublic:\\n    ll maximumSubsequenceCount(string text, string pattern) {\\n        ll ans = 0, cnt1 = 0, cnt2 = 0;\\n        for(char c:text) {\\n            cnt1 += c == pattern[1];\\n            cnt2 += c == pattern[0];\\n        }\\n        ans = 0;\\n        ll cnt = cnt1;\\n        f(i,0,text.length()) {\\n            if(text[i] == pattern[1]) cnt--;\\n            if(text[i] == pattern[0]) ans += cnt;\\n        }\\n        return ans+max(cnt1,cnt2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\n\\nclass Solution {\\npublic:\\n    ll maximumSubsequenceCount(string text, string pattern) {\\n        ll ans = 0, cnt1 = 0, cnt2 = 0;\\n        for(char c:text) {\\n            cnt1 += c == pattern[1];\\n            cnt2 += c == pattern[0];\\n        }\\n        ans = 0;\\n        ll cnt = cnt1;\\n        f(i,0,text.length()) {\\n            if(text[i] == pattern[1]) cnt--;\\n            if(text[i] == pattern[0]) ans += cnt;\\n        }\\n        return ans+max(cnt1,cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115412,
                "title": "javascript-solution-prefix-sum",
                "content": "```\\nvar maximumSubsequenceCount = function(text, pattern) {\\n    const n = text.length;\\n    \\n    let postFixSecondCharCount = 0;\\n   \\n    for (let i = n - 1; i >= 0; --i) {\\n        const char = text[i];\\n        \\n        if (char === pattern.charAt(1)) ++postFixSecondCharCount;\\n    }\\n    \\n    let addFirstCharSeqCount = 0;\\n    let addSecondCharSeqCount = 0;\\n    \\n    let prefixFirstCharCount = 0; \\n    \\n    for (let i = 0; i < n; ++i) {\\n        const currChar = text[i];\\n        \\n        if (currChar === pattern.charAt(0)) {\\n            addSecondCharSeqCount += postFixSecondCharCount + 1;\\n            prefixFirstCharCount++;\\n        }\\n        else if (currChar === pattern.charAt(1)) {\\n            addFirstCharSeqCount += prefixFirstCharCount + 1;\\n            postFixSecondCharCount -= 1;\\n        }\\n    }\\n\\t\\n\\tif (pattern.charAt(0) === pattern.charAt(1)) {\\n        return (prefixFirstCharCount + 1) * (prefixFirstCharCount) / 2;\\n    }\\n    \\n    return Math.max(addFirstCharSeqCount, addSecondCharSeqCount);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumSubsequenceCount = function(text, pattern) {\\n    const n = text.length;\\n    \\n    let postFixSecondCharCount = 0;\\n   \\n    for (let i = n - 1; i >= 0; --i) {\\n        const char = text[i];\\n        \\n        if (char === pattern.charAt(1)) ++postFixSecondCharCount;\\n    }\\n    \\n    let addFirstCharSeqCount = 0;\\n    let addSecondCharSeqCount = 0;\\n    \\n    let prefixFirstCharCount = 0; \\n    \\n    for (let i = 0; i < n; ++i) {\\n        const currChar = text[i];\\n        \\n        if (currChar === pattern.charAt(0)) {\\n            addSecondCharSeqCount += postFixSecondCharCount + 1;\\n            prefixFirstCharCount++;\\n        }\\n        else if (currChar === pattern.charAt(1)) {\\n            addFirstCharSeqCount += prefixFirstCharCount + 1;\\n            postFixSecondCharCount -= 1;\\n        }\\n    }\\n\\t\\n\\tif (pattern.charAt(0) === pattern.charAt(1)) {\\n        return (prefixFirstCharCount + 1) * (prefixFirstCharCount) / 2;\\n    }\\n    \\n    return Math.max(addFirstCharSeqCount, addSecondCharSeqCount);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112873,
                "title": "c-prefix-sum",
                "content": "**Careful for the case text=\"cccc\" and pattern=\"cc\" and rest good to go!**\\n```\\nclass Solution {\\npublic:\\n    long long func(string s, string p){\\n        int n=s.size();\\n        char first=p[0];\\n        char second=p[1];\\n        long long prefix[n];\\n        long long cnt=0,res=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==second){\\n                cnt++;\\n            }\\n            prefix[i]=cnt;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==first and first!=second){\\n                res+=prefix[i];\\n            }else if(s[i]==first and first==second){\\n                res+=prefix[i]-1;\\n            }\\n            \\n        }\\n        \\n        //cout<<res<<endl;\\n        return res+=prefix[0];\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string text2=text;\\n        string pat=pattern;\\n        swap(pat[0],pat[1]);\\n        reverse(text.begin(),text.end());\\n        return max(func(text2,pattern),func(text,pat));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long func(string s, string p){\\n        int n=s.size();\\n        char first=p[0];\\n        char second=p[1];\\n        long long prefix[n];\\n        long long cnt=0,res=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==second){\\n                cnt++;\\n            }\\n            prefix[i]=cnt;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==first and first!=second){\\n                res+=prefix[i];\\n            }else if(s[i]==first and first==second){\\n                res+=prefix[i]-1;\\n            }\\n            \\n        }\\n        \\n        //cout<<res<<endl;\\n        return res+=prefix[0];\\n    }\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        string text2=text;\\n        string pat=pattern;\\n        swap(pat[0],pat[1]);\\n        reverse(text.begin(),text.end());\\n        return max(func(text2,pattern),func(text,pat));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2106316,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, t: str, pa: str) -> int:\\n        \\n        def finds(s,p):\\n            m=len(s)\\n            n=len(p)\\n            \\n            dp=[[0 for j in range(n+1)] for i in range(m+1)]\\n            dp[m][n]=1\\n            \\n            for i in range(m-1,-1,-1):\\n                for j in range(n,-1,-1):\\n                    if j==n:\\n                        dp[i][j]=1\\n                    elif s[i]==p[j]:\\n                        dp[i][j]=dp[i+1][j]+dp[i+1][j+1]\\n                    else:\\n                        dp[i][j]=dp[i+1][j]\\n            return dp[0][0]\\n        \\n        mx=0\\n        mx=max(mx,finds(pa[0]+t,pa))\\n        mx=max(mx,finds(t+pa[1],pa))\\n        return mx\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubsequenceCount(self, t: str, pa: str) -> int:\\n        \\n        def finds(s,p):\\n            m=len(s)\\n            n=len(p)\\n            \\n            dp=[[0 for j in range(n+1)] for i in range(m+1)]\\n            dp[m][n]=1\\n            \\n            for i in range(m-1,-1,-1):\\n                for j in range(n,-1,-1):\\n                    if j==n:\\n                        dp[i][j]=1\\n                    elif s[i]==p[j]:\\n                        dp[i][j]=dp[i+1][j]+dp[i+1][j+1]\\n                    else:\\n                        dp[i][j]=dp[i+1][j]\\n            return dp[0][0]\\n        \\n        mx=0\\n        mx=max(mx,finds(pa[0]+t,pa))\\n        mx=max(mx,finds(t+pa[1],pa))\\n        return mx\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099588,
                "title": "c-o-n-time-o-1-space-prefix-sum",
                "content": "O(n) time, O(1) space; Prefix Sum, Array \\n```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long sub=0;\\n        if(pattern[0]!=pattern[1]){\\n            int a=0, b=0;// # of patterns[0] and patterns[1]\\n            for( int i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]){\\n                    a++;\\n                }else if(text[i]==pattern[1]){\\n                    b++;\\n                    sub+=a;\\n                }\\n            }\\n            return sub+(a<b?b:a);          \\n        }else{\\n            int a=0;\\n            for( int i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]) a++;\\n            }\\n            return (long)a*(a+1)/2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n        long long sub=0;\\n        if(pattern[0]!=pattern[1]){\\n            int a=0, b=0;// # of patterns[0] and patterns[1]\\n            for( int i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]){\\n                    a++;\\n                }else if(text[i]==pattern[1]){\\n                    b++;\\n                    sub+=a;\\n                }\\n            }\\n            return sub+(a<b?b:a);          \\n        }else{\\n            int a=0;\\n            for( int i=0; i<text.size(); i++){\\n                if(text[i]==pattern[0]) a++;\\n            }\\n            return (long)a*(a+1)/2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085925,
                "title": "java-brute-force",
                "content": "From right to left, check how many second character accumulated once first character is met, and put the accumulated value in the list. End of loop, compare the count of first character and count of second character, choose the larger one and add to the list. The result will be the sum of the list.\\n```java\\n\\t  public long maximumSubsequenceCount(String text, String pattern) {\\n        char first = pattern.charAt(0);\\n        char next = pattern.charAt(1);\\n        int count = 0;\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = text.length() - 1; i >= 0; i--) {\\n            char c = text.charAt(i);\\n            if (c == first) {\\n                list.add(count);\\n            }\\n            if (c == next) { // not using else if here b/c first and next could be the same char\\n                count++;\\n            }\\n        }\\n        int additional = list.size() > count ? list.size() : count;\\n        list.add(additional);\\n        return list.stream().mapToLong(i -> i).sum();\\n\\t}\\n\\n```\\n\\n**Optimize**:\\n```java\\n\\t public long maximumSubsequenceCount(String text, String pattern) {\\n\\t\\tchar first = pattern.charAt(0);\\n        char next = pattern.charAt(1);\\n        int sum = 0, curr = 0;\\n        int count = 0;\\n        for (int i = text.length() - 1; i >= 0; i--) {\\n            char c = text.charAt(i);\\n            if (c == first) {\\n                sum += curr;\\n                count++;\\n            }\\n            if (c == next) {\\n                curr++;\\n            }\\n        }\\n        sum += curr > count ? curr : count;\\n        return sum;\\n\\t}\\n```\\n\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n\\t  public long maximumSubsequenceCount(String text, String pattern) {\\n        char first = pattern.charAt(0);\\n        char next = pattern.charAt(1);\\n        int count = 0;\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = text.length() - 1; i >= 0; i--) {\\n            char c = text.charAt(i);\\n            if (c == first) {\\n                list.add(count);\\n            }\\n            if (c == next) { // not using else if here b/c first and next could be the same char\\n                count++;\\n            }\\n        }\\n        int additional = list.size() > count ? list.size() : count;\\n        list.add(additional);\\n        return list.stream().mapToLong(i -> i).sum();\\n\\t}\\n\\n```\n```java\\n\\t public long maximumSubsequenceCount(String text, String pattern) {\\n\\t\\tchar first = pattern.charAt(0);\\n        char next = pattern.charAt(1);\\n        int sum = 0, curr = 0;\\n        int count = 0;\\n        for (int i = text.length() - 1; i >= 0; i--) {\\n            char c = text.charAt(i);\\n            if (c == first) {\\n                sum += curr;\\n                count++;\\n            }\\n            if (c == next) {\\n                curr++;\\n            }\\n        }\\n        sum += curr > count ? curr : count;\\n        return sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2048670,
                "title": "o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n      long long  ans=0;\\n        long long  first=0;\\n        long long  second=0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==pattern[0]) first++;\\n            else if(text[i]==pattern[1]) second++;\\n        }\\n        \\n        if(first> second) {\\n            text += pattern[1];\\n            second++;\\n        }\\n        else {\\n            text = pattern[0] + text;\\n            first++;\\n        }\\n        if(pattern[0]==pattern[1])\\n        {\\n           \\n          long long   x=first+second;\\n         if(x>0)   ans=((x-1)*x)/2;\\n            return ans ;\\n        }\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==pattern[1]) second--;\\n            if(text[i]==pattern[0] && second>0) ans +=second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubsequenceCount(string text, string pattern) {\\n      long long  ans=0;\\n        long long  first=0;\\n        long long  second=0;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==pattern[0]) first++;\\n            else if(text[i]==pattern[1]) second++;\\n        }\\n        \\n        if(first> second) {\\n            text += pattern[1];\\n            second++;\\n        }\\n        else {\\n            text = pattern[0] + text;\\n            first++;\\n        }\\n        if(pattern[0]==pattern[1])\\n        {\\n           \\n          long long   x=first+second;\\n         if(x>0)   ans=((x-1)*x)/2;\\n            return ans ;\\n        }\\n        for(int i=0;i<text.size();i++)\\n        {\\n            if(text[i]==pattern[1]) second--;\\n            if(text[i]==pattern[0] && second>0) ans +=second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036281,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n  pub fn maximum_subsequence_count(text: String, pattern: String) -> i64 {\\n    let n = text.len();\\n    let s = text.chars().into_iter().collect::<Vec<char>>();\\n    let p = pattern.chars().into_iter().collect::<Vec<char>>();\\n    let (p1, p2) = (p[0], p[1]);\\n\\n    if p1 == p2 {\\n      let mut count = 0;\\n      for c in s {\\n        if c == p1 {\\n          count += 1;\\n        }\\n      }\\n      return count * (count + 1) / 2\\n    }\\n\\n    let mut result = 0;\\n    let mut count = 0;\\n    for &c in &s {\\n      if c == p1 {\\n        count += 1;\\n      } else if c == p2 {\\n        result += count;\\n      }\\n    }\\n\\n    let mut memo1 = 0;\\n    let mut memo2 = 0;\\n    for i in 0..n {\\n      if s[i] == p1 {\\n        memo1 += 1;\\n      }\\n    }\\n    for i in (0..n).rev() {\\n      if s[i] == p2 {\\n        memo2 += 1;\\n      }\\n    }\\n    \\n    std::cmp::max(memo1+result, memo2+result)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn maximum_subsequence_count(text: String, pattern: String) -> i64 {\\n    let n = text.len();\\n    let s = text.chars().into_iter().collect::<Vec<char>>();\\n    let p = pattern.chars().into_iter().collect::<Vec<char>>();\\n    let (p1, p2) = (p[0], p[1]);\\n\\n    if p1 == p2 {\\n      let mut count = 0;\\n      for c in s {\\n        if c == p1 {\\n          count += 1;\\n        }\\n      }\\n      return count * (count + 1) / 2\\n    }\\n\\n    let mut result = 0;\\n    let mut count = 0;\\n    for &c in &s {\\n      if c == p1 {\\n        count += 1;\\n      } else if c == p2 {\\n        result += count;\\n      }\\n    }\\n\\n    let mut memo1 = 0;\\n    let mut memo2 = 0;\\n    for i in 0..n {\\n      if s[i] == p1 {\\n        memo1 += 1;\\n      }\\n    }\\n    for i in (0..n).rev() {\\n      if s[i] == p2 {\\n        memo2 += 1;\\n      }\\n    }\\n    \\n    std::cmp::max(memo1+result, memo2+result)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028636,
                "title": "python-java-dp-solution-time-on-space-o1",
                "content": "Runtime: 24 ms, faster than 64.65% of Java online submissions for Maximize Number of Subsequences in a String.\\nMemory Usage: 42.6 MB, less than 96.51% of Java online submissions for Maximize Number of Subsequences in a String.\\n```\\nclass Solution {\\n  public long helper(String t, int start, int end, int step, char p0, char p1){\\n    long ans = 0, letter = 1;\\n    \\n    for(int i = start; i != end; i += step)  \\n      if     (t.charAt(i) == p0) letter++;\\n      else if(t.charAt(i) == p1) ans += letter;\\n  \\n    return ans;\\n  }\\n  \\n  public long maximumSubsequenceCount(String text, String pattern) {\\n    if( pattern.charAt(0) == pattern.charAt(1)){\\n      long letter = 1;\\n      for(int i = 0; i != text.length();) \\n        if ( text.charAt(i++) == pattern.charAt(0)) letter++;\\n      \\n      return letter*(letter-1)/2;\\n    }\\n    \\n   return Math.max(helper(text, 0,    text.length(),  1, pattern.charAt(0), pattern.charAt(1)),\\n                   helper(text, text.length()-1, -1, -1, pattern.charAt(1), pattern.charAt(0)));      \\n  }\\n}\\n```\\nRuntime: 911 ms, faster than 15.58% of Python3 online submissions for Maximize Number of Subsequences in a String.\\nMemory Usage: 14.9 MB, less than 99.17% of Python3 online submissions for Maximize Number of Subsequences in a String.\\n```\\nclass Solution:\\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n    if pattern[0] == pattern[1]:\\n      letter = 1\\n      for i in range (len(text)) : \\n        if text[i] == pattern[0] : letter += 1\\n      return letter*(letter-1)//2\\n    else :\\n      letter = 1\\n      ans1 = 0\\n      for i in range (len(text)) : \\n        if   text[i] == pattern[0] : letter += 1\\n        elif text[i] == pattern[1] : ans1 += letter\\n          \\n      letter = 1\\n      ans2 = 0\\n      for i in range (len(text)-1, -1, -1) : \\n        if   text[i] == pattern[1] : letter += 1\\n        elif text[i] == pattern[0] : ans2 += letter\\n      \\n      return max(ans1, ans2)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n  public long helper(String t, int start, int end, int step, char p0, char p1){\\n    long ans = 0, letter = 1;\\n    \\n    for(int i = start; i != end; i += step)  \\n      if     (t.charAt(i) == p0) letter++;\\n      else if(t.charAt(i) == p1) ans += letter;\\n  \\n    return ans;\\n  }\\n  \\n  public long maximumSubsequenceCount(String text, String pattern) {\\n    if( pattern.charAt(0) == pattern.charAt(1)){\\n      long letter = 1;\\n      for(int i = 0; i != text.length();) \\n        if ( text.charAt(i++) == pattern.charAt(0)) letter++;\\n      \\n      return letter*(letter-1)/2;\\n    }\\n    \\n   return Math.max(helper(text, 0,    text.length(),  1, pattern.charAt(0), pattern.charAt(1)),\\n                   helper(text, text.length()-1, -1, -1, pattern.charAt(1), pattern.charAt(0)));      \\n  }\\n}\\n```\n```\\nclass Solution:\\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n    if pattern[0] == pattern[1]:\\n      letter = 1\\n      for i in range (len(text)) : \\n        if text[i] == pattern[0] : letter += 1\\n      return letter*(letter-1)//2\\n    else :\\n      letter = 1\\n      ans1 = 0\\n      for i in range (len(text)) : \\n        if   text[i] == pattern[0] : letter += 1\\n        elif text[i] == pattern[1] : ans1 += letter\\n          \\n      letter = 1\\n      ans2 = 0\\n      for i in range (len(text)-1, -1, -1) : \\n        if   text[i] == pattern[1] : letter += 1\\n        elif text[i] == pattern[0] : ans2 += letter\\n      \\n      return max(ans1, ans2)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1938861,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "Was thinking for a DP solution lol"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tips:\\n- In order to get the max number of EXTRA substrings, you need to add pattern[0] at the start of text OR pattern[1] at the end of text.\\n- Traverse the string and count the pattern[0] / pattern[1] chars. \\n- If traversing from the beginning, each time you encounter a pattern[1] char, that will form pattern[0] count subtrings. (g: aaacdd\", pattern = \"ac\". when i = 3, that c will give you 3 substrings, as pattern0Count = 3.\\n- At the end, pay attention to edge cases: both counts can be 0 or just one count is 0. (which needs to be made 1).\\n- Also, pay attention to edge case when pattern is made out of two identical letters \"aa\". In this case, pattern1Count = pattern0Count -1."
                    },
                    {
                        "username": "oops_moment",
                        "content": "CLEARLY READ THE QUESTION : pattern is of just length 2 .\\nYou need maximum subsequences: either at front insertion or at end :)\\nGo code"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Fun fact- you don\\'t need dp for this problem"
                    }
                ]
            },
            {
                "id": 2027573,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "Was thinking for a DP solution lol"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tips:\\n- In order to get the max number of EXTRA substrings, you need to add pattern[0] at the start of text OR pattern[1] at the end of text.\\n- Traverse the string and count the pattern[0] / pattern[1] chars. \\n- If traversing from the beginning, each time you encounter a pattern[1] char, that will form pattern[0] count subtrings. (g: aaacdd\", pattern = \"ac\". when i = 3, that c will give you 3 substrings, as pattern0Count = 3.\\n- At the end, pay attention to edge cases: both counts can be 0 or just one count is 0. (which needs to be made 1).\\n- Also, pay attention to edge case when pattern is made out of two identical letters \"aa\". In this case, pattern1Count = pattern0Count -1."
                    },
                    {
                        "username": "oops_moment",
                        "content": "CLEARLY READ THE QUESTION : pattern is of just length 2 .\\nYou need maximum subsequences: either at front insertion or at end :)\\nGo code"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Fun fact- you don\\'t need dp for this problem"
                    }
                ]
            },
            {
                "id": 1967280,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "Was thinking for a DP solution lol"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tips:\\n- In order to get the max number of EXTRA substrings, you need to add pattern[0] at the start of text OR pattern[1] at the end of text.\\n- Traverse the string and count the pattern[0] / pattern[1] chars. \\n- If traversing from the beginning, each time you encounter a pattern[1] char, that will form pattern[0] count subtrings. (g: aaacdd\", pattern = \"ac\". when i = 3, that c will give you 3 substrings, as pattern0Count = 3.\\n- At the end, pay attention to edge cases: both counts can be 0 or just one count is 0. (which needs to be made 1).\\n- Also, pay attention to edge case when pattern is made out of two identical letters \"aa\". In this case, pattern1Count = pattern0Count -1."
                    },
                    {
                        "username": "oops_moment",
                        "content": "CLEARLY READ THE QUESTION : pattern is of just length 2 .\\nYou need maximum subsequences: either at front insertion or at end :)\\nGo code"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Fun fact- you don\\'t need dp for this problem"
                    }
                ]
            },
            {
                "id": 1948688,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "Was thinking for a DP solution lol"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tips:\\n- In order to get the max number of EXTRA substrings, you need to add pattern[0] at the start of text OR pattern[1] at the end of text.\\n- Traverse the string and count the pattern[0] / pattern[1] chars. \\n- If traversing from the beginning, each time you encounter a pattern[1] char, that will form pattern[0] count subtrings. (g: aaacdd\", pattern = \"ac\". when i = 3, that c will give you 3 substrings, as pattern0Count = 3.\\n- At the end, pay attention to edge cases: both counts can be 0 or just one count is 0. (which needs to be made 1).\\n- Also, pay attention to edge case when pattern is made out of two identical letters \"aa\". In this case, pattern1Count = pattern0Count -1."
                    },
                    {
                        "username": "oops_moment",
                        "content": "CLEARLY READ THE QUESTION : pattern is of just length 2 .\\nYou need maximum subsequences: either at front insertion or at end :)\\nGo code"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Fun fact- you don\\'t need dp for this problem"
                    }
                ]
            }
        ]
    }
]